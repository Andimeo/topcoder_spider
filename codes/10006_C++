<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt; <br>#include &lt;list&gt; <br>#include &lt;map&gt; <br>#include &lt;set&gt; <br>#include &lt;deque&gt; <br>#include &lt;vector&gt; <br>#include &lt;list&gt; <br>#include &lt;map&gt; <br>#include &lt;set&gt; <br>#include &lt;deque&gt; <br>#include &lt;queue&gt; <br>#include &lt;stack&gt; <br>#include &lt;bitset&gt; <br>#include &lt;algorithm&gt; <br>#include &lt;functional&gt; <br>#include &lt;numeric&gt; <br>#include &lt;utility&gt; <br>#include &lt;sstream&gt; <br>#include &lt;iostream&gt; <br>#include &lt;iomanip&gt; <br>#include &lt;cstdio&gt; <br>#include &lt;cmath&gt; <br>#include &lt;cstdlib&gt; <br>#include &lt;cctype&gt; <br>#include &lt;string&gt; <br>#include &lt;cstring&gt; <br>#include &lt;ctime&gt; <br><br>using namespace std;<br><br>#define _int64 long long<br><br>_int64 d[60][11000];<br><br>class BaronsAndCoins<br>{<br>public:<br>int getMaximum(vector &lt;int&gt; x, vector &lt;int&gt; y)<br>{<br>    _int64 i,j,k,n,tmp,tmp1,best;<br>    vector&lt;pair&lt;_int64,_int64&gt; &gt; a;<br>    n=x.size();<br>    for (i=0;i&lt;n;i++)<br>    {<br>        a.push_back(make_pair(x[i],y[i]));<br>    }<br>    sort(a.begin(),a.end());<br>    memset(d,-1,sizeof(d));<br>    for (i=0;i&lt;n;i++)<br>    {<br>        tmp=(a[i].second+1)*a[i].second/2;<br>        if (a[i].first&lt;tmp)<br>            continue;<br>        if (a[i].first==tmp)<br>            tmp1=a[i].second;<br>        else<br>        {<br>            tmp1=a[i].second;<br>            tmp1+=(a[i].first-tmp-1)/a[i].second+1;<br><br>        }<br>        d[i][tmp1]=1;<br>    }<br>    best=0;<br>    for (i=0;i&lt;n;i++)<br>        for (j=0;j&lt;=10000;j++)<br>            if (d[i][j]&gt;=0)<br>            {<br>                if (d[i][j]&gt;best) best=d[i][j];<br>                for (k=i+1;k&lt;n;k++)<br>                    if ((a[k].first&gt;a[i].first)&amp;&amp;(a[k].second&gt;a[i].second))<br>                    {<br>                        tmp=(a[k].second-a[i].second+1)*(a[k].second-a[i].second)/2+j*(a[k].second-a[i].second);<br>                        if (a[k].first-a[i].first&lt;tmp) continue;<br>                        if (a[k].first-a[i].first==tmp) tmp1=a[k].second-a[i].second+j;<br>                        else<br>                        {<br>                            tmp1=a[k].second-a[i].second+j;<br>                            tmp1+=(a[k].first-a[i].first-tmp-1)/(a[k].second-a[i].second)+1;<br>                        }<br>                        if (d[i][j]+1&gt;d[k][tmp1])<br>                            d[k][tmp1]=d[i][j]+1;<br>                    }<br>            }<br>    return best;<br>}<br>};<br></td>