<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class BarbarianInvasion {<br>    static List&lt;Vertex&gt; allV = new List&lt;Vertex&gt;();<br><br>    class Vertex<br>    {<br>        public bool visited = false;<br>        public List&lt;Edge&gt; outgoing = new List&lt;Edge&gt;();<br><br>        public Vertex()<br>        {<br>            allV.Add(this);<br>        }<br>    }<br><br>    class Edge<br>    {<br>        public Vertex src;<br>        public Vertex dst;<br>        public Edge rev = null;<br>        public int cap;<br>        public int flow = 0;<br><br>        public Edge(Vertex src, Vertex dst, int cap)<br>        {<br>            this.src = src;<br>            this.dst = dst;<br>            this.cap = cap;<br>            src.outgoing.Add(this);<br>            new Edge(this);<br>        }<br><br>        public Edge(Edge toRev)<br>        {<br>            src = toRev.dst;<br>            dst = toRev.src;<br>            cap = 0;<br>            rev = toRev;<br>            toRev.rev = this;<br>            src.outgoing.Add(this);<br>        }<br>    }<br><br>    const int BIG = 5000001;<br>    const int VERY_BIG = 20000000;<br><br>    public int minimalDetachment(string[] countryMap, int[] detachmentSize) {<br>        int height = countryMap.Length;<br>        int width = countryMap[0].Length;<br>        Vertex[,,] grid = new Vertex[height, width, 2];<br>        Vertex src = null;<br>        for (int row = 0; row &lt; height; ++row)<br>            for (int col = 0; col &lt; width; ++col)<br>            {<br>                if (countryMap[row][col] != '-') {<br>                    grid[row, col, 0] = new Vertex();<br>                    grid[row, col, 1] = new Vertex();<br>                    int w = 0;<br>                    if (countryMap[row][col] != '*')<br>                    {<br>                        w = detachmentSize[countryMap[row][col] - 'A'];<br>                    }<br>                    new Edge(grid[row, col, 0], grid[row, col, 1], BIG + w);<br>                }<br>                if (countryMap[row][col] == '*')<br>                {<br>                    src = grid[row, col, 1];<br>                }<br>            }<br>        Vertex outside = new Vertex();<br>        for (int row = 0; row &lt; height; ++row)<br>            for (int col = 0; col &lt; width; ++col)<br>            {<br>                Vertex a = grid[row, col, 1];<br>                if (a == null)<br>                    continue;<br>                for (int dr = -1; dr &lt;= 1; ++dr)<br>                    for (int dc = -1; dc &lt;= 1; ++dc)<br>                        if (dr == 0 ^ dc == 0)<br>                        {<br>                            int nr = row + dr;<br>                            int nc = col + dc;<br>                            Vertex b;<br>                            if (nr &gt;= 0 &amp;&amp; nr &lt; height &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; width)<br>                            {<br>                                if (countryMap[nr][nc] == '-')<br>                                    continue;<br>                                b = grid[nr, nc, 0];<br>                            }<br>                            else<br>                            {<br>                                b = outside;<br>                            }<br>                            new Edge(a, b, VERY_BIG);<br>                        }<br>            }<br>        return flow(src, outside) % BIG;<br>    }<br><br>    private int flow(Vertex src, Vertex dst)<br>    {<br>        int res = 0;<br>        while (true)<br>        {<br>            foreach (Vertex v in allV)<br>                v.visited = false;<br>            int delta = dfs(src, dst, VERY_BIG);<br>            if (delta == 0)<br>                break;<br>            res += delta;<br>        }<br>        return res;<br>    }<br><br>    private int dfs(Vertex src, Vertex dst, int am)<br>    {<br>        if (src.visited)<br>            return 0;<br>        if (src == dst)<br>            return am;<br>        src.visited = true;<br>        foreach (Edge e in src.outgoing)<br>        {<br>            int nam = Math.Min(am, e.cap - e.flow);<br>            if (nam &gt; 0)<br>            {<br>                nam = dfs(e.dst, dst, nam);<br>                if (nam &gt; 0)<br>                {<br>                    e.flow += nam;<br>                    e.rev.flow -= nam;<br>                    return nam;<br>                }<br>            }<br>        }<br>        return 0;<br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>