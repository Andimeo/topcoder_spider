<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;string&gt;<br>#include &lt;numeric&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>using namespace std;<br> <br>#define VV vector<br>#define PB push_back<br>#define ll long long<br>#define ld long double<br>#define REP(i,n) FOR(i,0,(n)-1)<br>#define FOR(i,a,b) for(VAR(i,a);i&lt;=(b);++i)<br>#define FORD(i,a,b) for(VAR(i,a);i&gt;=(b);--i)<br>#define FORE(a,b) for(VAR(a,(b).begin());a!=(b).end();++a)<br>#define VAR(a,b) __typeof(b) a=(b)<br>#define SS(a) ((int)(a).size())<br>#define ALL(x) (x).begin(),(x).end()<br>#define CLR(x,a) memset(x,a,sizeof(x))<br>#define VI VV&lt;int&gt;<br>#define VS VV&lt;string&gt;<br>int COND = 1;<br>#define DB(x) { if (COND &gt; 0) { COND--; REP (xxx, 1) cerr &lt;&lt; __LINE__ &lt;&lt; " " &lt;&lt; #x &lt;&lt; " " &lt;&lt; x &lt;&lt; endl; cerr.flush(); } }<br> <br> <br>#define int ll<br>#define PII pair&lt;int, int&gt;<br>#define X first<br>#define Y second<br> <br>namespace MF {<br>    const int NSZ = 30011;<br>    const int MSZ = 30011;<br>    const int inf = 0x3f3f3f3f3f3f3f3fLL;<br>    int FL[MSZ];<br>    int MID = 0;<br>    vector&lt;PII&gt; ED[NSZ];<br>    int dist[NSZ];<br>    int N;<br>    int STA, END;<br>    int QQ[NSZ]; int SS, EE;<br>    vector&lt;PII&gt;::iterator KR[NSZ];<br> <br>    void clear(int N_) { N = N_; MID = 0; REP (i, N) ED[i].clear(); }<br> <br>    void add_edge(int i, int j, int c1, int c2) {<br>        ED[i].PB(PII(j, MID));<br>        FL[MID] = c1;<br>        ++MID;<br>        ED[j].PB(PII(i, MID));<br>        FL[MID] = c2;<br>        ++MID;<br>    }<br> <br>    bool bfs() {<br>        REP (i, N) dist[i] = inf;<br>        SS = EE = 0;<br>        dist[STA] = 0; QQ[EE++] = STA;<br>        while (SS &lt; EE) {<br>            int top = QQ[SS++];<br>            FORE (it, ED[top]) if (FL[it-&gt;Y] &gt; 0 &amp;&amp; dist[it-&gt;X] == inf) {<br>                dist[it-&gt;X] = dist[top] + 1;<br>                QQ[EE++] = it-&gt;X;<br>            }<br>        }<br>        return dist[END] != inf;<br>    }<br> <br>    int dfs(int i, int fl) {<br>        if (fl == 0) return 0;<br>        if (i == END) return fl;<br>        int ret = 0;<br>        for (vector&lt;PII&gt;::iterator &amp;it = KR[i]; it != ED[i].end(); ++it)<br>            if (dist[it-&gt;X] == dist[i] + 1 &amp;&amp; FL[it-&gt;Y] &gt; 0) {<br>                int tadd = dfs(it-&gt;X, min(FL[it-&gt;Y], fl));<br>                ret += tadd;<br>                fl -= tadd;<br>                FL[it-&gt;Y] -= tadd;<br>                FL[it-&gt;Y^1] += tadd;<br>                if (fl == 0) break;<br>            }<br>        return ret;<br>    }<br> <br>    int flow(int STA_, int END_) {<br>        int ret = 0;<br>        STA = STA_; END = END_;<br>        while (bfs()) {<br>            DB(ret);<br>            REP (i, N) KR[i] = ED[i].begin();<br>            ret += dfs(STA, inf);<br>        }<br>        return ret;<br>    }<br>};<br> <br>int dx[4] = { -1, 0, 1, 0};<br>int dy[4] = {0,-1,0,1};<br> <br>class BarbarianInvasion {<br>      public:<br>#undef int<br>      int minimalDetachment(VS CO, VI DE) { DB(0);<br>#define int ll<br>        MF::clear(5011);<br>        int N = CO.size(); int M = CO[0].size();<br>        int SS = 2 * N * M;<br>        int EE = 2 * N * M + 1;<br>        REP (i, N) REP (j, M) {<br>          int id1 = 2 * (i * M + j);<br>          int id2 = 2 * (i * M + j) + 1;<br>          if (isalpha(CO[i][j])) {<br>            int index = CO[i][j] - 'A';<br>            int cost = (int)1e9 + DE[index];<br>            MF::add_edge(id1, id2, cost, 0);<br>          }<br>          if (i == 0 || i == N - 1 || j == 0 || j == M - 1)<br>            MF::add_edge(SS, id1, (ll)1e16, 0);<br>          if (CO[i][j] == '*')<br>            MF::add_edge(id1, EE, (ll)1e16, 0);<br>          REP (d, 4) {<br>            int nx = i + dx[d];<br>            int ny = j + dy[d];<br>            if (nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; M) {<br>              MF::add_edge(id2, 2 * (nx * M + ny), (ll)1e16, 0);<br>            }<br>          }<br>        }<br>        ll ret = MF::flow(SS, EE);<br>        return ret % (ll)1e9;<br>      }<br> <br>      <br> <br>};<br>#undef int<br> <br> <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>