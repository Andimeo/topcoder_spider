<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br>import java.text.*;<br>import java.math.*;<br>import java.awt.geom.*;<br> <br>public class FeudaliasWar<br>{<br>public double getMinimumTime(int[] baseX, int[] baseY, int[] siloX, int[] siloY, int takeOffTime_, int rechargeTime, int missileSpeed)<br>  {<br>    double takeOffTime = takeOffTime_ * 1.0 / 60;<br>    int n = siloX.length;<br>    m = baseX.length;<br>    double[][] distance = new double[n][m];<br>    double dmax = 0;<br>    for (int i=0; i&lt;n; i++)<br>      for (int j=0; j&lt;m; j++)<br>      {<br>        distance[i][j] = Math.sqrt((baseX[j]-siloX[i])*1.0*(baseX[j]-siloX[i]) + <br>            (baseY[j]-siloY[i])*1.0*(baseY[j]-siloY[i]))/missileSpeed;<br>        dmax = Math.max(dmax, distance[i][j]);<br>      }<br>    double left = takeOffTime, right =m*(dmax+rechargeTime+takeOffTime);<br>    used = new boolean[m];<br>    pair = new int[n*m];<br>    while (right-left&gt;1e-9)<br>    {<br>      double time = (left+right)/2;<br>      //double time = 91.50;<br>      graph = new boolean[m][n*m];<br>      k = 0;<br>      for (int i=0; i&lt;n; i++)<br>      {<br>        int count = (int)Math.floor(time / (takeOffTime+rechargeTime)) + 1;<br>        count = Math.min(count, m);<br>        for (int j=0; j&lt;count; j++)<br>        {<br>          double t = time - (j+1) * takeOffTime - j * rechargeTime;<br>          if (t&lt;0.0) continue;<br>          for (int target = 0; target&lt;m; target++)<br>            if (distance[i][target]&lt;=t)<br>              graph[target][k] = true;<br>          k++;<br>        }<br>      }<br>      Arrays.fill(pair, -1);<br>      for (int x=0; x&lt;m; x++)<br>      {<br>        Arrays.fill(used, false);<br>        khun(x);<br>      }<br>      int count = 0;<br>      for (int i=0; i&lt;k; i++)<br>        if (pair[i]!=-1)<br>          count++;<br>      if (count==m)<br>        right = time;<br>      else left = time;<br>    }<br>    return (left+right)/2;<br>  }<br>  <br>  boolean[] used;<br>  boolean[][] graph;<br>  int[] pair;<br>  int m, k;<br>  <br>  boolean khun(int x)<br>  {<br>    if (used[x]) return false;<br>    used[x] = true;<br>    for (int y = 0; y&lt;k; y++)<br>    {<br>      if (!graph[x][y]) continue;<br>      if (pair[y]==-1 || khun(pair[y]))<br>      {<br>        pair[y] = x;<br>        return true;<br>      }<br>    }<br>    return false;<br>  }<br>  <br>  <br>}<br>//Powered by [KawigiEdit] 2.0!<br></td>