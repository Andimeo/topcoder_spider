<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br> <br>#include &lt;cstdio&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;queue&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br> <br>using namespace std;<br> <br>#define REP(a,n) for(int a=0; a&lt;(n); ++a)<br>#define FOR(a,b,c) for(int a=(b); a&lt;=(c); ++a)<br>#define FORD(a,b,c) for(int a=(b); a&gt;=(c); --a)<br>#define INIT(a, b) __typeof(b) a = (b)<br>#define FOREACH(a, b) for(INIT(a, (b).begin()); a!=(b).end(); ++a)<br> <br>#define PB push_back<br> <br>typedef long long LL;<br>typedef pair&lt;int, int&gt; pii;<br>typedef vector&lt;string&gt; vs;<br>typedef vector&lt;int&gt; vi;<br> <br>#define INF 1000000000<br> <br>template&lt;class T&gt;<br>inline int size(const T&amp;t){return t.size();}<br> <br>//////////////////////////////////////////<br> <br>#define MOD (INF+3)<br> <br>vi edges[200];<br>vi cyc[200];<br>int tab[200], tab0[200], tab1[200];<br>int N;<br>int ile[200][200];<br> <br>void zaznacz(vi &amp;v, int *t, int val)<br>{<br>    FOREACH(it, v)<br>      FOREACH(e, cyc[*it])<br>        t[*e] = val;<br>}<br> <br>vi child(vi &amp;v, int *t) <br>{<br>    vi res;<br>    FOREACH(it, v)<br>      FOREACH(e, cyc[*it])<br>        FOREACH(n, edges[*e])<br>          if (!t[*n])<br>            res.PB(*n);<br>    return res;<br>}<br> <br>int probuj(vi &amp;c0, vi &amp;c1)<br>{<br>int mn = 1;<br>    REP(poz, size(c0))<br>    {<br>      vi ch0, ch1;<br>      FOREACH(n, edges[c0[poz]])<br>        if (!tab0[*n])<br>          ch0.PB(*n);<br>      FOREACH(n, edges[c1[poz]])<br>        if (!tab1[*n])<br>          ch1.PB(*n);<br>      if (size(ch0)!=size(ch1))<br>        return 0;<br>      while (size(ch0))<br>      {<br>        int prz = -1, c = 0;<br>        REP(a, size(ch1))<br>          if (ile[ch0[0]][ch1[a]])<br>          {<br>            prz = ch1[a];<br>            ch1[a] = ch1.back();<br>            ch1.resize(ch1.size()-1);<br>            --a;<br>            ++c;<br>          }<br>        int mnw = ile[ch0[0]][prz];<br>        REP(a, size(ch0))<br>          if (ile[ch0[a]][prz])<br>          {<br>            ch0[a] = ch0.back();<br>            ch0.resize(ch0.size()-1);<br>            --a;<br>          }<br>        if (c==0)<br>          return 0;<br>        if (size(ch0)!=size(ch1))<br>          return 0;<br>        FOR(x, 1, c)<br>        {<br>          mn = (mn*(LL)x)%MOD;<br>          mn = (mn*(LL)mnw)%MOD;<br>        }<br>      }<br>    }<br>    return mn;<br>}<br> <br>void call(vi &amp;v0, vi &amp;v1)<br>{<br>    if (!size(v0))<br>      return;<br>    zaznacz(v0, tab0, 1);<br>    zaznacz(v1, tab1, 1);<br> <br>    vi nv0 = child(v0, tab0), nv1 = child(v1, tab1);<br>    call(nv0, nv1);<br>    <br>    FOREACH(it0, v0)<br>      FOREACH(it1, v1)<br>      {<br>        int x = *it0, y = *it1;<br>        ile[x][y] = 0;<br>        if (size(cyc[x])!=size(cyc[y]))<br>          continue;<br>        ile[x][y] = probuj(cyc[x], cyc[y]);<br>        if (size(cyc[x])==1)<br>          continue;<br>        vi odw;<br>        odw.PB(x);<br>        FORD(a, size(cyc[x])-1, 1)<br>          odw.PB(cyc[x][a]);<br>        ile[x][y] = (ile[x][y]+probuj(odw, cyc[y]))%MOD;<br>      }<br>    <br> <br>    zaznacz(v0, tab0, 0);<br>    zaznacz(v1, tab1, 0);<br> <br>}<br> <br> <br>void szuk(int x0, int x, int pr, bool start = false) {<br>    if (x==x0 &amp;&amp; !start)<br>        throw 0;<br>    if (tab[x])<br>      return;<br>    tab[x] = 1;<br>    cyc[x0].PB(x);<br>    FOREACH(it, edges[x])<br>      if (*it!=pr)<br>        szuk(x0, *it, x);<br>    cyc[x0].pop_back();<br>}<br> <br>    class CactusAutomorphisms<br>        { <br>        public: <br>        int count(int N_, vector &lt;string&gt; edges_) <br>            { <br>              N = N_;<br>              REP(a, N)<br>                edges[a].clear();<br>              string str;<br>              FOREACH(it, edges_)<br>                str += *it;<br>              int x, y; char ch;<br>              istringstream is(str);<br>              while (is&gt;&gt;x) {<br>                is &gt;&gt; y &gt;&gt; ch;<br>                --x, --y;<br>                edges[x].PB(y);<br>                edges[y].PB(x);<br>              }<br>              // szuk cykli<br>              REP(x0, N)<br>              {<br>                REP(a, N)<br>                  tab[a] = 0;<br>                cyc[x0].clear();<br>                try {<br>                  szuk(x0, x0, -1, true);<br>                  cyc[x0].PB(x0);<br>                } catch(...) {}<br>              }<br>              // work<br>              int res = 0;<br>              REP(x0, N)<br>              {<br>                  REP(a, N)<br>                      tab0[a] = tab1[a] = 0;<br>                  vi v0, v1;<br>                  v0.PB(0);<br>                  v1.PB(x0);<br>                  call(v0, v1);<br>                  res = (res+ile[0][x0])%MOD;<br>                  printf("aaa\n");<br>              }<br>              return res;<br>            } <br>        <br> <br>        }; <br> <br> <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>