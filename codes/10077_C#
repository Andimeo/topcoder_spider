<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br><br>public class DSU<br>{<br>    private int[] pred, rank;<br><br>    public DSU(int n)<br>    {<br>        pred = new int[n];<br>        for (int i = 0; i &lt; n; i++)<br>            pred[i] = i;<br>        rank = new int[n];<br>    }<br><br>    public void MakeSet(int x)<br>    {<br>        pred[x] = x;<br>        rank[x] = 0;<br>    }<br><br>    public int FindSet(int x)<br>    {<br>        if (x == pred[x]) return x;<br>        return (pred[x] = FindSet(pred[x]));<br>    }<br><br>    public void Unite(int a, int b)<br>    {<br>        int x = FindSet(a);<br>        int y = FindSet(b);<br>        if (x == y) return;<br>        if (rank[x] &lt;= rank[y])<br>        {<br>            pred[x] = y;<br>            if (rank[x] == rank[y]) ++rank[y];<br>        }<br>        else<br>        {<br>            pred[y] = x;<br>        }<br>    }<br>}<br><br>public class CactusCount<br>{<br>    public int countCacti(int n, string[] edges)<br>    {<br>        bool[,] a = new bool[n,n];<br>        string tmp = "";<br>        for(int i = 0; i &lt; edges.Length; i++)<br>        {<br>            string[] sp = (tmp+edges[i]).Split(',');<br>            int l = sp.Length - 1;<br>            if (i == edges.Length - 1) l = sp.Length;<br>            for(int j = 0; j &lt; l; j++)<br>            {<br>                string[] sp2 = sp[j].Split(' ');<br>                a[Convert.ToInt32(sp2[0]) - 1, Convert.ToInt32(sp2[1]) - 1] = true;<br>                a[Convert.ToInt32(sp2[1]) - 1, Convert.ToInt32(sp2[0]) - 1] = true;<br>            }<br>            tmp = sp[sp.Length - 1];<br>        }<br><br>        int[] b = new int[n];<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            if(b[i]==-1)continue;<br>            int[] f = new int[n];<br>            bool first = true;<br>            Queue qu = new Queue();<br>            qu.Enqueue(i);<br>            f[i] = i + 1;<br>            int ci = 0;<br>            while(qu.Count!=0)<br>            {<br>                int next = (int)qu.Dequeue();<br>                for(int j = 0; j &lt; n; j++)<br>                    if (j!=i &amp;&amp; a[next, j])<br>                    {<br>                        if (f[j] == 0)<br>                        {<br>                            if (first) f[j] = j + 1;<br>                            else f[j] = f[next];<br>                            qu.Enqueue(j);<br>                        }else if(f[j]!=f[next])<br>                        {<br>                            ci++;<br>                            int y = f[j];<br>                            for (int k = 0; k &lt; n; k++)<br>                                if (y == f[k]) f[k] = f[next];<br>                        }<br>                    }<br>                first = false;<br>            }<br>            if(ci&gt;1)<br>                for (int k = 0; k &lt; n; k++)<br>                    if (f[k]!=0)b[k] = -1;<br>        }<br><br>        int ret = 0;<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            if (b[i] == -1) continue;<br>            b[i] = -1;<br>            ret++;<br>            Queue qu = new Queue();<br>            qu.Enqueue(i);<br>            while (qu.Count != 0)<br>            {<br>                int next = (int)qu.Dequeue();<br>                for (int j = 0; j &lt; n; j++)<br>                    if (a[next, j] &amp;&amp; b[j] != -1)<br>                    {<br>                        qu.Enqueue(j);<br>                        b[j] = -1;<br>                    }<br>            }<br>        }<br><br>        return ret;<br>    }<br>}<br></td>