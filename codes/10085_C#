<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class NimForK {<br>  public int[] winners(int n, int k, string[] moves_) {<br>        int[][] moves = Array.ConvertAll&lt;string, int[]&gt;(moves_, delegate(string s) {<br>            if (s == "")<br>                return new int[0];<br>            else<br>                return Array.ConvertAll&lt;string, int&gt;(s.Split(' '), int.Parse);<br>        });<br>        bool[,,] canBy = new bool[k, n + 1, n + 1];<br>        bool[,] canStop = new bool[k, n + 1];<br>        for (int i = 1; i &lt;= n; ++i)<br>            canBy[0, i, i] = true;<br>        for (int by = 1; by &lt; k; ++by)<br>            for (int i = 1; i &lt;= n; ++i) {<br>                for (int j = 1; j &lt;= n; ++j)<br>                    if (canBy[by - 1, i, j]) {<br>                        foreach (int u in moves[j - 1])<br>                            canBy[by, i, j - u] = true;<br>                        if (moves[j - 1].Length == 0)<br>                            canStop[by, i] = true;<br>                    }<br>                if (canStop[by - 1, i])<br>                    canStop[by, i] = true;<br>                if (canBy[by, i, 0])<br>                    canStop[by, i] = true;<br>            }<br>        bool[,] possibleWinners = new bool[n + 1, k];<br>        bool[] onlyFirst = new bool[n + 1];<br>        for (int i = 1; i &lt;= n; ++i)<br>        {<br>            onlyFirst[i] = false;<br>            foreach (int u in moves[i - 1])<br>            {<br>                int j = i - u;<br>                if (j == 0)<br>                    onlyFirst[i] = true;<br>                else<br>                {<br>                    if (canStop[k - 1, j])<br>                        continue;<br>                    onlyFirst[i] = true;<br>                    for (int l = 1; l &lt;= n; ++l)<br>                        if (canBy[k - 1, j, l])<br>                            if (!onlyFirst[l])<br>                            {<br>                                onlyFirst[i] = false;<br>                                break;<br>                            }<br>                }<br>                if (onlyFirst[i])<br>                    break;<br>            }<br>            if (onlyFirst[i])<br>            {<br>                possibleWinners[i, 0] = true;<br>            }<br>            else<br>            {<br>                foreach (int u in moves[i - 1])<br>                {<br>                    int j = i - u;<br>                    if (possibleWinners[j, k - 1])<br>                    {<br>                        for (int l = 0; l &lt; k; ++l)<br>                            if (possibleWinners[j, l])<br>                                possibleWinners[i, (l + 1) % k] = true;<br>                    }<br>                }<br>                if (!possibleWinners[i, 0])<br>                {<br>                    foreach (int u in moves[i - 1])<br>                    {<br>                        int j = i - u;<br>                        for (int l = 0; l &lt; k; ++l)<br>                            if (possibleWinners[j, l])<br>                                possibleWinners[i, (l + 1) % k] = true;<br>                    }<br>                }<br>            }<br>        }<br>        List&lt;int&gt; res = new List&lt;int&gt;();<br>        for (int i = 0; i &lt; k; ++i)<br>            if (possibleWinners[n, i])<br>                res.Add(i + 1);<br>        return res.ToArray();<br>  }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>