<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;algorithm&gt;<br>#include&lt;sstream&gt;<br>#include&lt;string&gt;<br>#include&lt;vector&gt;<br>#include&lt;cmath&gt;<br>using namespace std;<br><br>#define FOR(i,a,b) for(int i = (a); i &lt; (b); ++i)<br>#define REP(i,n) FOR(i,0,n)<br>#define FORE(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();++it)<br>#define pb push_back<br>#define all(x) (x).begin(),(x).end()<br>#define CLEAR(x,with) memset(x,with,sizeof(x))<br>#define sz size()<br>typedef long long ll;<br><br>int n, k;<br>vector&lt;vector&lt;int&gt; &gt; m;<br>double cache[51][21][21];<br><br>struct NimForK <br>{<br>  double getAverage(const vector&lt;int&gt;&amp; take, int here, int remaining, int whoWins)<br>  {<br>    double ret = 0;<br>    REP(i,take.sz)<br>      ret += go((here+1)%k, remaining-take[i], whoWins);<br>    return ret / take.sz;<br>  }<br>  double go(int here, int remaining, int whoWins)<br>  {<br>    if(remaining == 0) return (whoWins == (here+k-1)%k) ? 1.0 : 0.0;<br>    double&amp; ret = cache[remaining][here][whoWins];<br>    if(ret &gt;= 0.0) return ret;<br>    ret = 0.0;<br>    vector&lt;int&gt; winningMove, possibleMove, elseMove;<br>    REP(i,m[remaining].sz)<br>    {<br>      int take = m[remaining][i];<br>      if(take &lt;= remaining)<br>      {<br>        double p = go((here+1)%k, remaining-take, here);<br>        if(p == 1.0)<br>          winningMove.pb(take);<br>        else if(p &gt; 0.0)<br>          possibleMove.pb(take);<br>        else <br>          elseMove.pb(take);<br>      }<br>    }<br>    if(winningMove.sz &gt; 0)<br>      ret = getAverage(winningMove, here, remaining, whoWins);<br>    else if(possibleMove.sz &gt; 0)<br>      ret = getAverage(possibleMove, here, remaining, whoWins);<br>    else if(elseMove.sz &gt; 0)<br>      ret = getAverage(elseMove, here, remaining, whoWins);<br>    else<br>      ret = 0; // nobody wins<br>    return ret;<br>  }<br>  vector &lt;int&gt; winners(int n, int k, vector &lt;string&gt; moves) <br>  {<br>    REP(i,51) REP(j,21) REP(k,21) cache[i][j][k] = -1;<br>    ::n = n; ::k = k;<br>    m.resize(moves.sz+1);<br>    REP(i,moves.sz)<br>    {<br>      istringstream inp(moves[i]);<br>      int x;<br>      while(inp &gt;&gt; x) m[i+1].pb(x);<br>    }<br><br>    vector&lt;int&gt; ret;<br>    REP(i,k)<br>      if(go(0, n, i) &gt; 0.0)<br>        ret.pb(i+1);<br>    return ret;<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>