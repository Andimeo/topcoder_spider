<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br>import java.text.*;<br>import java.math.*;<br> <br> <br>public class NimForK<br>{<br>  static class Fraction {<br>    BigInteger a, b;<br>    <br>    Fraction(BigInteger a, BigInteger b) {<br>      BigInteger g = a.gcd(b);<br>      this.a = a.divide(g);<br>      this.b = b.divide(g);<br>    }<br>    <br>    Fraction multiply(Fraction v) {<br>      return new Fraction(a.multiply(v.a), b.multiply(v.b));<br>    }<br>    <br>    Fraction divide(Fraction v) {<br>      return new Fraction(a.multiply(v.b), b.multiply(v.a));<br>    }<br>    <br>    Fraction add(Fraction v) {<br>      return new Fraction(a.multiply(v.b).add(b.multiply(v.a)), b.multiply(v.b));<br>    }<br>    <br>    Fraction subtract(Fraction v) {<br>      return new Fraction(a.multiply(v.b).subtract(b.multiply(v.a)), b.multiply(v.b));<br>    }<br>    <br>    boolean isOne() {<br>      return a.compareTo(BigInteger.ONE) == 0 &amp;&amp; b.compareTo(BigInteger.ONE) == 0;<br>    }<br>    <br>    boolean nonZero() {<br>      return a.signum() != 0;<br>    }<br>    <br>    public String toString() {<br>      return a + "/" + b;<br>    }<br>  }<br>  <br>  public int[] winners(int n, int k, String[] moves)<br>  {<br>    int[][] a = new int[n][];<br>    for (int i = 0; i &lt; n; ++i) {<br>      if (moves[i].length() == 0) {<br>        a[i] = new int[0];<br>        continue;<br>      }<br>      String[] s = moves[i].split(" ");<br>      a[i] = new int[s.length];<br>      for (int j = 0; j &lt; a[i].length; ++j) {<br>        a[i][j] = Integer.parseInt(s[j]);<br>      }<br>    }<br>    Fraction[][] p = new Fraction[n + 1][k];<br>    for (Fraction[] ar : p) {<br>      Arrays.fill(ar, new Fraction(BigInteger.ZERO, BigInteger.ONE));<br>    }<br>    p[0][k - 1] = new Fraction(BigInteger.ONE, BigInteger.ONE);<br>    for (int i = 1; i &lt;= n; ++i) {<br>      ArrayList&lt;Integer&gt; movesOne = new ArrayList&lt;Integer&gt;();<br>      ArrayList&lt;Integer&gt; movesNonZero = new ArrayList&lt;Integer&gt;();<br>      ArrayList&lt;Integer&gt; movesAny = new ArrayList&lt;Integer&gt;();<br>      for (int j : a[i - 1]) {<br>        if (p[i - j][k - 1].isOne()) {<br>          movesOne.add(j);<br>        }<br>        if (p[i - j][k - 1].nonZero()) {<br>          movesNonZero.add(j);<br>        }<br>        movesAny.add(j);<br>      }<br>      ArrayList&lt;Integer&gt; ms = null;<br>      if (!movesOne.isEmpty()) {<br>        ms = movesOne;<br>      } else if (!movesNonZero.isEmpty()) {<br>        ms = movesNonZero;<br>      } else {<br>        ms = movesAny;<br>      }<br>      if (!ms.isEmpty()) {<br>        for (int j : ms) {<br>          for (int t = 0; t &lt; k; ++t) {<br>            p[i][t] = p[i][t].add(p[i - j][(t + k - 1) % k].divide(new Fraction(BigInteger.valueOf(ms.size()), BigInteger.ONE)));<br>          }<br>        }<br>      }<br>    }<br>    //System.out.println(Arrays.deepToString(p));<br>    int winnersCount = 0;<br>    for (int i = 0; i &lt; k; ++i) {<br>      if (p[n][i].nonZero()) {<br>        winnersCount++;<br>      }<br>    }<br>    int[] winners = new int[winnersCount];<br>    winnersCount = 0;<br>    for (int i = 0; i &lt; k; ++i) {<br>      if (p[n][i].nonZero()) {<br>        winners[winnersCount++] = i + 1;<br>      }<br>    }<br>    return winners;<br>  }<br>  <br> <br>}<br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>