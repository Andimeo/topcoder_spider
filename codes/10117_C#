<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class PiecesMover {<br>    List&lt;int&gt; x;<br>    List&lt;int&gt; y;<br>    List&lt;int&gt; cx;<br>    List&lt;int&gt; cy;<br>    bool[,] f;<br>    bool[] used;<br><br>  public int getMinimumMoves(string[] board) {<br>        x = new List&lt;int&gt;();<br>        y = new List&lt;int&gt;();<br>        for (int i = 0; i &lt; board.Length; ++i)<br>            for (int j = 0; j &lt; board[i].Length; ++j)<br>            {<br>                if (board[i][j] == '*')<br>                {<br>                    x.Add(i);<br>                    y.Add(j);<br>                }<br>            }<br>        cx = new List&lt;int&gt;();<br>        cy = new List&lt;int&gt;();<br>        f = new bool[5, 5];<br>        used = new bool[x.Count];<br>        return doit();<br>  }<br><br>    private int doit()<br>    {<br>        if (cx.Count == x.Count)<br>            return eval(0);<br>        else<br>        {<br>            int res = int.MaxValue;<br>            for (int i = 0; i &lt; cx.Count; ++i)<br>            {<br>                for (int dx = -1; dx &lt;= 1; ++dx)<br>                    for (int dy = -1; dy &lt;= 1; ++dy)<br>                        if (dx == 0 ^ dy == 0)<br>                        {<br>                            int nx = cx[i] + dx;<br>                            int ny = cy[i] + dy;<br>                            if (nx &gt;= 0 &amp;&amp; nx &lt; 5 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; 5 &amp;&amp; !f[nx, ny])<br>                            {<br>                                f[nx, ny] = true;<br>                                cx.Add(nx);<br>                                cy.Add(ny);<br>                                res = Math.Min(res, doit());<br>                                cx.RemoveAt(cx.Count - 1);<br>                                cy.RemoveAt(cy.Count - 1);<br>                                f[nx, ny] = false;<br>                            }<br>                        }<br>            }<br>            if (cx.Count == 0)<br>            {<br>                for (int nx = 0; nx &lt; 5; ++nx)<br>                    for (int ny = 0; ny &lt; 5; ++ny)<br>                    {<br>                        f[nx, ny] = true;<br>                        cx.Add(nx);<br>                        cy.Add(ny);<br>                        res = Math.Min(res, doit());<br>                        cx.RemoveAt(cx.Count - 1);<br>                        cy.RemoveAt(cy.Count - 1);<br>                        f[nx, ny] = false;<br>                    }<br>            }<br>            return res;<br>        }<br>    }<br><br>    private int eval(int at)<br>    {<br>        if (at == x.Count)<br>            return 0;<br>        int res = int.MaxValue;<br>        for (int i = 0; i &lt; x.Count; ++i)<br>            if (!used[i])<br>            {<br>                used[i] = true;<br>                res = Math.Min(res, Math.Abs(cx[i] - x[at]) + Math.Abs(cy[i] - y[at]) + eval(at + 1));<br>                used[i] = false;<br>            }<br>        return res;<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>