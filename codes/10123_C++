<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;list&gt;<br>#include &lt;complex&gt;<br>#include &lt;queue&gt;<br> <br>using namespace std;<br> <br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef long long ll;<br>typedef complex&lt;double&gt; pnt;<br>typedef pair&lt;int, int&gt; pii;<br> <br>#define RA(x) (x).begin(), (x).end()<br>#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)<br>#define SZ(x) ((int) (x).size())<br> <br> <br>class CavePassage<br>{<br>public:<br>    int minimalTime(vector &lt;int&gt; travelersWeights, vector &lt;int&gt; travelersTimes, vector &lt;string&gt; trustTable, int bridgeStrength);<br>};<br> <br>bool trusted(const vector&lt;string&gt; &amp;table, int bits)<br>{<br>    int N = table.size();<br>    if (__builtin_popcount(bits) == 1) return true;<br>    for (int i = 0; i &lt; N; i++)<br>        if (bits &amp; (1 &lt;&lt; i))<br>        {<br>            bool good = false;<br>            for (int j = 0; j &lt; N; j++)<br>                if (i != j &amp;&amp; table[i][j] == 'Y' &amp;&amp; (bits &amp; (1 &lt;&lt; j)))<br>                    good = true;<br>            if (!good)<br>                return false;<br>        }<br>    return true;<br>}<br> <br>struct qitem<br>{<br>    int state;<br>    int prio;<br>    bool operator &lt;(const qitem &amp;b) const<br>    {<br>        return prio &gt; b.prio;<br>    }<br> <br>    qitem() {}<br>    qitem(int s, int p) : state(s), prio(p) {}<br>};<br> <br>int CavePassage::minimalTime(vector &lt;int&gt; weight, vector &lt;int&gt; times, vector &lt;string&gt; trustTable, int strength)<br>{<br>    int N = weight.size();<br>    int speed[1 &lt;&lt; N];<br>    for (int b = 1; b &lt; (1 &lt;&lt; N); b++)<br>    {<br>        if (!trusted(trustTable, b))<br>        {<br>            speed[b] = -1;<br>            continue;<br>        }<br>        speed[b] = 0;<br>        int tweight = 0;<br>        for (int i = 0; i &lt; N; i++)<br>            if (b &amp; (1 &lt;&lt; i))<br>            {<br>                tweight += weight[i];<br>                speed[b] = max(speed[b], times[i]);<br>            }<br>        if (tweight &gt; strength)<br>            speed[b] = -1;<br>    }<br> <br>    int M = 1 &lt;&lt; N;<br> <br>    priority_queue&lt;qitem&gt; q;<br>    q.push(qitem(0, 0));<br>    int prio[2 &lt;&lt; N];<br>    fill(prio, prio + (2 &lt;&lt; N), INT_MAX);<br>    prio[0] = 0;<br> <br>    while (!q.empty())<br>    {<br>        int s = q.top().state;<br>        int p = q.top().prio;<br>        q.pop();<br>        if (prio[s] != p) continue;<br> <br>        int moveable = (s &amp; M) ? s &amp; (M - 1) : ~s &amp; (M - 1);<br>        for (int m = moveable; m != 0; m = (m - 1) &amp; moveable)<br>            if (speed[m] != -1)<br>            {<br>                int s2 = s ^ m ^ M;<br>                int p2 = p + speed[m];<br>                if (p2 &lt; prio[s2])<br>                {<br>                    prio[s2] = p2;<br>                    q.push(qitem(s2, p2));<br>                }<br>            }<br>    }<br> <br>    int trg = (2 &lt;&lt; N) - 1;<br>    if (prio[trg] == INT_MAX) return -1;<br>    else return prio[trg];<br>}<br> <br> <br>// Powered by FileEdit<br></td>