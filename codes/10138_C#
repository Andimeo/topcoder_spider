<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class TwinTowns {<br>    const int INF = int.MaxValue;<br><br>  public int[] optimalTwinTowns(int[] x, int[] y, int maxPartners, int minDistance) {<br>        int n = x.Length;<br>        int[] best = new int[1 &lt;&lt; (2 * n)];<br>        int[] bestLen = new int[1 &lt;&lt; (2 * n)];<br>        for (int i = 0; i &lt; best.Length; ++i)<br>            best[i] = -INF;<br>        int start = 0;<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            start = (start &lt;&lt; 2) + maxPartners;<br>        }<br>        best[start] = 0;<br>        bestLen[start] = 0;<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            for (int k = i + 1; k &lt; n; ++k)<br>                if (Math.Abs(x[i] - x[k]) + Math.Abs(y[i] - y[k]) &gt;= minDistance) {<br>                    for (int j = 0; j &lt; 1 &lt;&lt; (2 * (n - i)); ++j)<br>                        if (best[j] &gt; -INF)<br>                        {<br>                            int avail = j &amp; 3;<br>                            int avail2 = (j &gt;&gt; (2 * (k - i))) &amp; 3;<br>                            if (avail &gt; 0 &amp;&amp; avail2 &gt; 0) {<br>                                int nxt = j - 1 - (1 &lt;&lt; (2 * (k - i)));<br>                                int nxtam = best[j] + 1;<br>                                int nxtdst = bestLen[j] + Math.Abs(x[i] - x[k]) + Math.Abs(y[i] - y[k]);<br>                                if (nxtam &gt; best[nxt] || nxtam == best[nxt] &amp;&amp; nxtdst &lt; bestLen[nxt])<br>                                {<br>                                    best[nxt] = nxtam;<br>                                    bestLen[nxt] = nxtdst;<br>                                }<br>                            }<br>                        }<br>                }<br>            int[] next = new int[1 &lt;&lt; (2 * (n - i - 1))];<br>            int[] nextLen = new int[next.Length];<br>            for (int j = 0; j &lt; next.Length; ++j)<br>                next[j] = -INF;<br>            for (int j = 0; j &lt; 1 &lt;&lt; (2 * (n - i)); ++j)<br>            {<br>                if (best[j] &gt; -INF &amp;&amp; best[j] &gt; next[j &gt;&gt; 2] || best[j] == next[j &gt;&gt; 2] &amp;&amp; bestLen[j] &lt; nextLen[j &gt;&gt; 2])<br>                {<br>                    next[j &gt;&gt; 2] = best[j];<br>                    nextLen[j &gt;&gt; 2] = bestLen[j];<br>                }<br>            }<br>            best = next;<br>            bestLen = nextLen;<br>        }<br>        return new int[]{best[0], bestLen[0]};<br>  }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>