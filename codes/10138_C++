<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;ctime&gt;<br>using namespace std;<br><br>typedef vector&lt;int&gt; vi;<br><br>#define For(i,a,b) for (int i(a),_b(b); i &lt;= _b; ++i)<br>#define Ford(i,a,b) for (int i(a),_b(b); i &gt;= _b; --i)<br>#define Rep(i,n) for (int i(0),_n(n); i &lt; _n; ++i)<br>#define Repd(i,n) for (int i((n)-1); i &gt;= 0; --i)<br>#define MP(x, y) make_pair((x), (y))<br><br>template&lt;typename T&gt; inline int Size(const T&amp; c) { return (int)c.size(); }<br><br>typedef pair&lt;int,int&gt; pii;<br><br>int n;<br>bool a[10][10];<br>int d[10][10];<br>map&lt;int,pii&gt; memo;<br>int b[10];<br><br>pii rec(int i) {<br>  if (i == n) return MP(0, 0);<br>  int state = 0;<br>  For(j, i, n-1)<br>    state = state*4+b[j];<br>  state = state*n+i;<br>  if (memo.count(state)) return memo[state];<br>  pii res = rec(i+1);<br>  if (b[i] &gt;= 1) {<br>    For(j, i+1, n-1) {<br>      if (a[i][j] &amp;&amp; b[j] &gt;= 1) {<br>        --b[i]; --b[j];<br>        pii cur = rec(i+1);<br>        cur.first += 1;<br>        cur.second += d[i][j];<br>        if (cur.first &gt; res.first || cur.first == res.first &amp;&amp; cur.second &lt; res.second) res = cur;<br>        ++b[i]; ++b[j];<br>      }<br>    }<br>    if (b[i] &gt;= 2) {<br>      For(j1, i+1, n-1) if (a[i][j1] &amp;&amp; b[j1] &gt;= 1) {<br>        --b[i]; --b[j1];<br>        For(j2, j1+1, n-1) if (a[i][j2] &amp;&amp; b[j2] &gt;= 1) {<br>          --b[i]; --b[j2];<br>          pii cur = rec(i+1);<br>          cur.first += 2;<br>          cur.second += d[i][j1]+d[i][j2];<br>          if (cur.first &gt; res.first || cur.first == res.first &amp;&amp; cur.second &lt; res.second) res = cur;<br>          ++b[i]; ++b[j2];<br>        }<br>        ++b[i]; ++b[j1];<br>      }<br>      if (b[i] == 3) {<br>        For(j1, i+1, n-1) if (a[i][j1] &amp;&amp; b[j1] &gt;= 1) {<br>          --b[i]; --b[j1];<br>          For(j2, j1+1, n-1) if (a[i][j2] &amp;&amp; b[j2] &gt;= 1) {<br>            --b[i]; --b[j2];<br>            For(j3, j2+1, n-1) if (a[i][j3] &amp;&amp; b[j3] &gt;= 1) {<br>              --b[i]; --b[j3];<br>              pii cur = rec(i+1);<br>              cur.first += 3;<br>              cur.second += d[i][j1]+d[i][j2]+d[i][j3];<br>              if (cur.first &gt; res.first || cur.first == res.first &amp;&amp; cur.second &lt; res.second) res = cur;<br>              ++b[i]; ++b[j3];<br>            }<br>            ++b[i]; ++b[j2];<br>          }<br>          ++b[i]; ++b[j1];<br>        }<br>      }<br>    }    <br>  }<br>  return memo[state] = res;<br>}<br><br>struct TwinTowns {<br>  vi optimalTwinTowns(vi x, vi y, int maxP, int minD) {<br>    n = Size(x);<br>    Rep(i, n) Rep(j, n)<br>      a[i][j] = (d[i][j] = abs(x[i]-x[j])+abs(y[i]-y[j])) &gt;= minD;<br>    Rep(i, n)<br>      b[i] = maxP;<br>    pii res = rec(0);<br>    vi v;<br>    v.push_back(res.first);<br>    v.push_back(res.second);<br>    return v;<br>  }<br>};<br></td>