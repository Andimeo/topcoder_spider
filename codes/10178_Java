<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class BuildersCountry {<br>    static class Edge {<br>        int start;<br>        int end;<br> <br>        Edge(int start, int end) {<br>            this.start = start;<br>            this.end = end;<br>        }<br>    }<br> <br>    public long minCost(int[] before, int[] after, int[] houseCost, String[] g, int roadCost) {<br>        int n = before.length;<br>        long res = 0;<br>        for (int i = 0; i &lt; n; ++i) {<br>            long cur = houseCost[i];<br>            cur *= (before[i] + after[i] - 1);<br>            cur *= (after[i] - before[i]);<br>            cur /= 2;<br>            res += cur; <br>        }<br>        final long[][] afterBuild = new long[n][n];<br>        final long[][] build = new long[n][n];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>                if (i != j) {<br>                    int b1 = before[i];<br>                    int a1 = after[i];<br>                    int b2 = before[j];<br>                    int a2 = after[j];<br>                    long c1 = houseCost[i];<br>                    long c2 = houseCost[j];<br>                    if (houseCost[i] &lt; houseCost[j]) {<br>                        int t = b1;<br>                        b1 = b2;<br>                        b2 = t;<br>                        t = a1;<br>                        a1 = a2;<br>                        a2 = t;<br>                        long tt = c1;<br>                        c1 = c2;<br>                        c2 = tt;<br>                    }<br>                    long cur = c1 * b2 * (long) (a1 - b1) + c2 * a1 * (long) (a2 - b2);<br>                    afterBuild[i][j] = cur;<br>                    cur = roadCost;<br>                    cur *= (b1 + b2); <br>                    build[i][j] = cur;<br>                }<br>        int[] comp = new int[n];<br>        for (int i = 0; i &lt; n; ++i)<br>            comp[i] = i;<br>        List&lt;Edge&gt; edges = new ArrayList&lt;Edge&gt;();<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = i + 1; j &lt; n; ++j)<br>                if (g[i].charAt(j) == 'Y') {<br>                    res += afterBuild[i][j];<br>                    if (comp[i] != comp[j]) {<br>                        int a = comp[i];<br>                        int b = comp[j];<br>                        for (int k = 0; k &lt; n; ++k)<br>                            if (comp[k] == a)<br>                                comp[k] = b;<br>                    }<br>                } else {<br>                    edges.add(new Edge(i, j));<br>                }<br>        Collections.sort(edges, new Comparator&lt;Edge&gt;() {<br>            public int compare(Edge o1, Edge o2) {<br>                long z1 = build[o1.start][o1.end] + afterBuild[o1.start][o1.end];<br>                long z2 = build[o2.start][o2.end] + afterBuild[o2.start][o2.end];<br>                if (z1 &lt; z2)<br>                    return -1;<br>                else if (z1 &gt; z2)<br>                    return 1;<br>                else<br>                    return 0;<br>            }<br>        });<br>        for (Edge e : edges) {<br>            if (comp[e.start] != comp[e.end]) {<br>                int a = comp[e.start];<br>                int b = comp[e.end];<br>                for (int k = 0; k &lt; n; ++k)<br>                    if (comp[k] == a)<br>                        comp[k] = b;<br>                res += build[e.start][e.end] + afterBuild[e.start][e.end];<br>            }<br>        }<br>        return res;<br>  }<br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>