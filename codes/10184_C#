<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class TheLongPalindrome {<br>    const long MOD = 1234567891;<br><br>    public int count(int _n, int _k) {<br>        long n = _n;<br>        long k = _k;<br>        long[,] m = new long[27, 27];<br>        for (int i = 1; i &lt; 27; ++i) {<br>            m[i, i] = i;<br>            m[i, i - 1] = (27 - i);<br>        }<br>        long h1 = (_n + 1) / 2 + 1;<br>        long h2 = _n / 2 + 1;<br>        long[,] mres = madd(mpsum(m, h1), mpsum(m, h2));<br>        long res = 0;<br>        for (int i = 1; i &lt;= k; ++i)<br>        {<br>            res = (res + mres[i, 0]) % MOD;<br>        }<br>        return (int)res;<br>    }<br><br>    private long[,] mpsum(long[,] a, long k)<br>    {<br>        if (k == 0) {<br>            return new long[27, 27];<br>        }<br>        if (k % 2 == 0)<br>        {<br>            return mmul(mpsum(a, k / 2), madd(munit(), mpow(a, k / 2)));<br>        }<br>        else<br>        {<br>            return madd(munit(), mmul(mpsum(a, k - 1), a));<br>        }<br>    }<br><br>    private long[,] mpow(long[,] a, long k)<br>    {<br>        if (k == 0)<br>            return munit();<br>        else if (k % 2 == 0)<br>        {<br>            return mpow(mmul(a, a), k / 2);<br>        }<br>        else<br>        {<br>            return mmul(a, mpow(a, k - 1));<br>        }<br>    }<br><br>    private long[,] mmul(long[,] a, long[,] b)<br>    {<br>        long[,] c = new long[27, 27];<br>        for (int i = 0; i &lt; 27; ++i)<br>            for (int j = 0; j &lt; 27; ++j)<br>            {<br>                long z = 0;<br>                for (int k = 0; k &lt; 27; ++k)<br>                {<br>                    z = (z + (a[i, k] * b[k, j])) % MOD;<br>                }<br>                c[i, j] = z;<br>            }<br>        return c;<br><br>    }<br><br>    private long[,] madd(long[,] a, long[,] b)<br>    {<br>        long[,] c = new long[27, 27];<br>        for (int i = 0; i &lt; 27; ++i)<br>            for (int j = 0; j &lt; 27; ++j)<br>            {<br>                c[i, j] = (a[i, j] + b[i, j]) % MOD;<br>            }<br>        return c;<br>    }<br><br>    private long[,] munit()<br>    {<br>        long[,] res = new long[27, 27];<br>        for (int i = 0; i &lt; 27; ++i)<br>            res[i, i] = 1;<br>        return res;<br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>