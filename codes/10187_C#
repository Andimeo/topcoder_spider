<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br> <br>public class PrimePairs<br>{<br>    public int[] matches(int[] numbers)<br>    {<br>        bool[] isprime = new bool[3000];<br>        for (int i = 0; i &lt; isprime.Length; i++)<br>            isprime[i] = true;<br>        isprime[0] = false;<br>        isprime[1] = false;<br>        for (int i = 2; i &lt; isprime.Length; i++)<br>            if (isprime[i])<br>                for (int j = i * i; j &lt; isprime.Length; j += i)<br>                    isprime[j] = false;<br>        LinkedList&lt;int&gt; ret = new LinkedList&lt;int&gt;();<br> <br>        for (int i = 1; i &lt; numbers.Length; i++)<br>        {<br>            if (!isprime[numbers[0] + numbers[i]])<br>                continue;<br>            MaxFlow flow = new MaxFlow(numbers.Length + 2);<br>            int source = numbers.Length;<br>            int sink = source + 1;<br>            for (int j = 1; j &lt; numbers.Length; j++)<br>            {<br>                if (j == i) continue;<br>                if (numbers[j] % 2 == 0)<br>                { // even<br>                    flow.Add(source, j, 1);<br> <br>                    for (int k = 1; k &lt; numbers.Length; k++)<br>                    {<br>                        if (k == j) continue;<br>                        if (k == i) continue;<br>                        if (isprime[numbers[j] + numbers[k]])<br>                            flow.Add(j, k, 1);<br>                    }<br>                }<br>                else<br>                {<br>                    flow.Add(j, sink, 1);<br>                }<br>            }<br>            int totalflow = flow.NetworkFlow(source, sink);<br>            if (totalflow == (numbers.Length / 2) - 1)<br>            {<br>                ret.AddLast(numbers[i]);<br>            }<br>        }<br> <br>        int[] realret = new int[ret.Count];<br>        int ind = 0;<br>        foreach (int i in ret)<br>            realret[ind++] = i;<br>        Array.Sort(realret);<br>        return realret;<br>    }<br> <br>    public class MaxFlow<br>    {<br>        public int Nodes;<br>        public int[,] Capacity;<br>        LinkedList&lt;int&gt;[] Neighbours;<br>        bool[,] NeighbourAdded;<br> <br>        public MaxFlow(int Nodes)<br>        {<br>            this.Nodes = Nodes;<br>            Neighbours = new LinkedList&lt;int&gt;[Nodes];<br>            for (int i = 0; i &lt; Nodes; i++)<br>                Neighbours[i] = new LinkedList&lt;int&gt;();<br>            Capacity = new int[Nodes, Nodes];<br>            NeighbourAdded = new bool[Nodes, Nodes];<br>        }<br> <br>        public void Add(int From, int To, int Cap)<br>        {<br>            Capacity[From, To] += Cap;<br>            if (!NeighbourAdded[From, To])<br>            {<br>                NeighbourAdded[From, To] = true;<br>                NeighbourAdded[To, From] = true;<br>                Neighbours[From].AddLast(To);<br>                Neighbours[To].AddLast(From);<br>            }<br>        }<br> <br>        public int NetworkFlow(int From, int To)<br>        {<br>            int[,] flow = new int[Nodes, Nodes];<br>            int[] parent = new int[Nodes];<br>            int[] cap = new int[Nodes];<br> <br>            int total = 0;<br>            while (true)<br>            {<br>                for (int i = 0; i &lt; Nodes; i++)<br>                    parent[i] = -1;<br>                parent[From] = -2;<br>                cap[From] = int.MaxValue;<br>                Queue&lt;int&gt; Q = new Queue&lt;int&gt;();<br>                Q.Enqueue(From);<br>                while (Q.Count &gt; 0 &amp;&amp; parent[To] == -1)<br>                {<br>                    int act = Q.Dequeue();<br>                    foreach (int next in Neighbours[act])<br>                    {<br>                        if (parent[next] == -1 &amp;&amp; Capacity[act, next] &gt; flow[act, next])<br>                        {<br>                            parent[next] = act;<br>                            cap[next] = Math.Min(cap[act], Capacity[act, next] - flow[act, next]);<br>                            Q.Enqueue(next);<br>                        }<br>                    }<br>                }<br> <br>                if (parent[To] == -1)<br>                    return total;<br> <br>                total += cap[To];<br>                int j = To;<br>                while (j != From)<br>                {<br>                    flow[parent[j], j] += cap[To];<br>                    flow[j, parent[j]] -= cap[To];<br>                    j = parent[j];<br>                }<br>            }<br>        }<br>    }<br> <br> <br>}<br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>