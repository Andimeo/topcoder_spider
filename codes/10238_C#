<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class AvoidFour {<br>    const long MOD = 1000000007;<br><br>    long gcd(long a, long b)<br>    {<br>        while (b &gt; 0)<br>        {<br>            long t = a % b;<br>            a = b;<br>            b = t;<br>        }<br>        return a;<br>    }<br><br>  public int count(long n) {<br>        long[,] m = new long[4, 4];<br>        m[0, 0] = 9;<br>        for (long i = 1; i &lt; 4; ++i)<br>        {<br>            m[i, i - 1] = 1;<br>            m[0, i] = 9;<br>        }<br>        long[] start = new long[4];<br>        start[0] = 8;<br>        start[1] = 1;<br>        long[,] rm;<br>        long[,] dummy;<br>        sumpow(m, n, out rm, out dummy);<br>        if (n &gt;= 44)<br>        {<br>            List&lt;long&gt; fours = new List&lt;long&gt;();<br>            fours.Add(44);<br>            while (fours[fours.Count - 1] * 10 + 4 &lt;= n)<br>            {<br>                fours.Add(fours[fours.Count - 1] * 10 + 4);<br>            }<br>            for (int set = 1; set &lt; (1 &lt;&lt; fours.Count); ++set)<br>            {<br>                long lcm = 1;<br>                int am = 0;<br>                for (int i = 0; i &lt; fours.Count; ++i)<br>                {<br>                    if ((set &amp; (1 &lt;&lt; i)) != 0)<br>                    {<br>                        ++am;<br>                        long z = gcd(lcm, fours[i]);<br>                        long by = fours[i] / z;<br>                        if (n / by &lt; lcm)<br>                        {<br>                            lcm = n + 1;<br>                            break;<br>                        }<br>                        else<br>                        {<br>                            lcm *= by;<br>                        }<br>                    }<br>                }<br>                if (lcm &gt; n)<br>                    continue;<br>                long[,] nrm;<br>                long[,] tmp = pow(m, lcm - 1);<br>                sumpow(mul(m, tmp), n / lcm, out nrm, out dummy);<br>                nrm = mul(tmp, nrm);<br>                if (am % 2 == 0)<br>                    rm = add(rm, nrm);<br>                else<br>                    rm = sub(rm, nrm);<br>            }<br>        }<br>        return (int)total(mul(rm, start));<br>  }<br><br>    void sumpow(long[,] m, long k, out long[,] sum, out long[,] max)<br>    {<br>        if (k == 0)<br>        {<br>            sum = new long[4, 4];<br>            max = unit();<br>        }<br>        else if (k % 2 == 0)<br>        {<br>            long[,] psum;<br>            long[,] pmax;<br>            sumpow(m, k / 2, out psum, out pmax);<br>            max = mul(pmax, pmax);<br>            sum = mul(psum, add(unit(), pmax));<br>        }<br>        else<br>        {<br>            long[,] psum;<br>            long[,] pmax;<br>            sumpow(m, k - 1, out psum, out pmax);<br>            max = mul(m, pmax);<br>            sum = add(unit(), mul(m, psum));<br>        }<br>    }<br><br>    private long[,] add(long[,] a, long[,] b)<br>    {<br>        long[,] c = new long[4, 4];<br>        for (int i = 0; i &lt; 4; ++i)<br>            for (int j = 0; j &lt; 4; ++j)<br>                c[i, j] = (c[i, j] + a[i, j] + b[i, j]) % MOD;<br>        return c;<br>    }<br><br>    private long[,] sub(long[,] a, long[,] b)<br>    {<br>        long[,] c = new long[4, 4];<br>        for (int i = 0; i &lt; 4; ++i)<br>            for (int j = 0; j &lt; 4; ++j)<br>                c[i, j] = (c[i, j] + a[i, j] - b[i, j] + MOD) % MOD;<br>        return c;<br>    }<br><br>    long[,] pow(long[,] m, long k)<br>    {<br>        if (k == 0)<br>            return unit();<br>        else if (k % 2 == 0)<br>            return pow(mul(m, m), k / 2);<br>        else<br>            return mul(m, pow(m, k - 1));<br>    }<br><br>    private long[,] mul(long[,] a, long[,] b)<br>    {<br>        long[,] c = new long[4, 4];<br>        for (int i = 0; i &lt; 4; ++i)<br>            for (int j = 0; j &lt; 4; ++j)<br>                for (int k = 0; k &lt; 4; ++k)<br>                    c[i, j] = (c[i, j] + a[i, k] * b[k, j]) % MOD;<br>        return c;<br>    }<br><br>    private long total(long[] x)<br>    {<br>        long sum = 0;<br>        foreach (long a in x)<br>            sum = (sum + a) % MOD;<br>        return sum;<br>    }<br><br>    private long[] mul(long[,] a, long[] b)<br>    {<br>        long[] c = new long[4];<br>        for (int i = 0; i &lt; 4; ++i)<br>            for (int k = 0; k &lt; 4; ++k)<br>                c[i] = (c[i] + a[i, k] * b[k]) % MOD;<br>        return c;<br>    }<br><br>    private long[,] unit()<br>    {<br>        long[,] res = new long[4, 4];<br>        for (long i = 0; i &lt; 4; ++i)<br>            res[i, i] = 1;<br>        return res;<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>