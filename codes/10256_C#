<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class YetAnotherStonesGame {<br>    int NUM_STATES = 8 * 8 * 8 * 8 * 8 * 8;<br>    int EMPTY = 6;<br>    int EARLIER = 7;<br>    string markedSquares;<br>    int[] allowedMoves;<br>    bool[,] visited;<br>    bool[,] res;<br>    public int fewestStones(int[] allowedMoves, string markedSquares) {<br>        markedSquares += "XXXXXX";<br>        this.allowedMoves = allowedMoves;<br>        this.markedSquares = markedSquares;<br>        visited = new bool[markedSquares.Length, NUM_STATES];<br>        res = new bool[markedSquares.Length, NUM_STATES];<br>        int ret = int.MaxValue;<br>        for (int initialState = 0; initialState &lt; NUM_STATES; ++initialState)<br>        {<br>            int cnt = 0;<br>            int t = initialState;<br>            int[] state = new int[6];<br>            bool[] was = new bool[6];<br>            bool ok = true;<br>            for (int i = 0; i &lt; 6; ++i)<br>            {<br>                state[i] = t &amp; 7;<br>                if (state[i] &lt; EMPTY)<br>                {<br>                    if (was[state[i]])<br>                    {<br>                        ok = false;<br>                    }<br>                    else<br>                    {<br>                        was[state[i]] = true;<br>                    }<br>                    ++cnt;<br>                }<br>                if ((markedSquares[i] == 'X') ^ (state[i] == 7))<br>                    ok = false;<br>                t &gt;&gt;= 3;<br>            }<br>            for (int i = 0; i &lt; 6; ++i)<br>                if ((state[i] &lt; EMPTY) ^ was[i])<br>                {<br>                    ok = false;<br>                }<br>            if (!ok)<br>                continue;<br>            if (dfs(0, initialState))<br>                ret = Math.Min(ret, getNumCycles(state));<br>        }<br>        if (ret == int.MaxValue)<br>            return -1;<br>        else<br>            return ret;<br>  }<br><br>    private int getNumCycles(int[] state)<br>    {<br>        int res = 0;<br>        bool[] visited = new bool[6];<br>        for (int i = 0; i &lt; 6; ++i)<br>            if (state[i] &lt; EMPTY &amp;&amp; !visited[i])<br>            {<br>                int j = i;<br>                do<br>                {<br>                    visited[j] = true;<br>                    j = state[j];<br>                } while (j != i);<br>                ++res;<br>            }<br>        return res;<br>    }<br><br>    private bool dfs(int at, int encodedState)<br>    {<br>        if (at &gt;= markedSquares.Length - 6)<br>        {<br>            return true;<br>        }<br>        if (visited[at, encodedState])<br>            return res[at, encodedState];<br>        visited[at, encodedState] = true;<br>        int first = encodedState &amp; 7;<br>        int state = encodedState + ((markedSquares[at + 6] == 'X' ? EARLIER : EMPTY) &lt;&lt; (3 * 6));<br>        if (first == EMPTY)<br>        {<br>            // do nothing<br>        }<br>        else if (first == EARLIER)<br>        {<br>            if (dfs(at + 1, state &gt;&gt; 3))<br>            {<br>                res[at, encodedState] = true;<br>            }<br>        }<br>        else<br>        {<br>            foreach (int move in allowedMoves)<br>            {<br>                int dest = ((state &gt;&gt; (3 * move)) &amp; 7);<br>                if (dest == EMPTY)<br>                {<br>                    if (dfs(at + 1, (state ^ ((EMPTY ^ first) &lt;&lt; (3 * move))) &gt;&gt; 3))<br>                    {<br>                        res[at, encodedState] = true;<br>                        break;<br>                    }<br>                }<br>                else if (dest == EARLIER)<br>                {<br>                    if (at + move == markedSquares.Length - 6 + first)<br>                    {<br>                        if (dfs(at + 1, state &gt;&gt; 3))<br>                        {<br>                            res[at, encodedState] = true;<br>                            break;<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        return res[at, encodedState];<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>