<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Text;<br><br>public class IncreasingLists {<br>  public string makeIncreasingList(string mask) {<br>        mask += ",";<br>        if (!canComplete(mask))<br>            return "impossible";<br>        string res = mask;<br>        for (int i = 0; i &lt; res.Length; ++i)<br>        {<br>            if (res[i] == '?')<br>            {<br>                foreach (char ch in ",0123456789") {<br>                    string cur = res.Substring(0, i) + ch + res.Substring(i + 1);<br>                    if (canComplete(cur))<br>                    {<br>                        res = cur;<br>                        break;<br>                    }<br>                }<br>            }<br>        }<br>        return res.Substring(0, res.Length - 1);<br>  }<br><br>    private bool canComplete(string mask)<br>    {<br>        string[] minEnd = new string[mask.Length + 1];<br>        minEnd[0] = "";<br>        for (int i = 0; i &lt; mask.Length; ++i)<br>        {<br>            if ((mask[i] == '?' || mask[i] == ',') &amp;&amp; i &gt; 0)<br>            {<br>                string best = null;<br>                for (int j = i - 1; j &gt;= 0; --j)<br>                {<br>                    if (mask[j] == ',')<br>                        break;<br>                    if (minEnd[j] == null)<br>                        continue;<br>                    string cur = getMinimal(mask.Substring(j, i - j), minEnd[j]);<br>                    if (cur != null)<br>                    {<br>                        if (best == null || cur.Length &lt; best.Length || cur.Length == best.Length &amp;&amp; cur.CompareTo(best) &lt; 0)<br>                            best = cur;<br>                    }<br>                }<br>                minEnd[i + 1] = best;<br>            }<br>        }<br>        return minEnd[mask.Length] != null;<br>    }<br><br>    private string getMinimal(string p, string q)<br>    {<br>        if (p.Length == 0 || p[0] == '0')<br>            return null;<br>        if (p.Length &lt; q.Length)<br>            return null;<br>        bool already = p.Length &gt; q.Length;<br>        bool[] canBeBigger = null;<br>        if (!already)<br>        {<br>            canBeBigger = new bool[p.Length + 1];<br>            bool can = false;<br>            for (int i = p.Length - 1; i &gt;= 0; --i)<br>            {<br>                if (p[i] == '?')<br>                {<br>                    if (q[i] != '9')<br>                    {<br>                        can = true;<br>                    }<br>                }<br>                else<br>                {<br>                    if (p[i] &gt; q[i])<br>                        can = true;<br>                    else if (p[i] &lt; q[i])<br>                        can = false;<br>                }<br>                canBeBigger[i] = can;<br>            }<br>            if (!canBeBigger[0])<br>                return null;<br>        }<br>        StringBuilder b = new StringBuilder();<br>        for (int i = 0; i &lt; p.Length; ++i)<br>        {<br>            if (p[i] == '?')<br>            {<br>                if (already)<br>                {<br>                    if (i == 0)<br>                        b.Append('1');<br>                    else<br>                        b.Append('0');<br>                }<br>                else<br>                {<br>                    if (canBeBigger[i + 1])<br>                    {<br>                        b.Append(q[i]);<br>                    }<br>                    else<br>                    {<br>                        already = true;<br>                        b.Append((char)(q[i] + 1));<br>                    }<br>                }<br>            }<br>            else<br>            {<br>                b.Append(p[i]);<br>                if (!already) {<br>                    if (p[i] &gt; q[i])<br>                        already = true;<br>                    if (p[i] &lt; q[i])<br>                        // Should never happen<br>                        return null;<br>                }<br>            }<br>        }<br>        return b.ToString();<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>