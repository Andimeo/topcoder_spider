<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.ArrayList;<br>import java.util.List;<br><br>public class MazeWanderingEasy {<br>  public static void main(final String[] args) {<br>    String[] maze = { "...", "XMX", "..*" };<br>    System.out.println(new MazeWanderingEasy().decisions(maze));<br>  }<br><br>  public int decisions(final String[] maze) {<br>    Point p = getStartingPoint(maze);<br>    return DFS(maze, p, p);<br>  }<br><br>  private final static int NOT_FOUND = -1;<br><br>  private static int DFS(final String[] maze, final Point p, final Point prev) {<br>    if (isEnd(maze, p))<br>      return 0;<br>    List&lt;Point&gt; points = getPossibilities(maze, p, prev);<br>    if (points.size() == 1)<br>      return DFS(maze, points.get(0), p);<br>    for (Point newp : points) {<br>      int choices = DFS(maze, newp, p);<br>      if (choices != NOT_FOUND)<br>        return choices + 1;<br>    }<br>    return NOT_FOUND;<br>  }<br><br>  private static boolean isEnd(final String[] maze, final Point p) {<br>    return maze[p.x].charAt(p.y) == '*';<br>  }<br><br>  private static boolean isEmpty(final String[] maze, final Point p) {<br>    return maze[p.x].charAt(p.y) != 'X';<br>  }<br><br>  private static List&lt;Point&gt; getPossibilities(final String[] maze,<br>      final Point p, final Point prev) {<br>    List&lt;Point&gt; l = new ArrayList&lt;Point&gt;();<br>    Point tmp;<br>    tmp = p.getN();<br>    if (tmp.isValid(maze) &amp;&amp; isEmpty(maze, tmp) &amp;&amp; !prev.equals(tmp))<br>      l.add(tmp);<br>    tmp = p.getS();<br>    if (tmp.isValid(maze) &amp;&amp; isEmpty(maze, tmp) &amp;&amp; !prev.equals(tmp))<br>      l.add(tmp);<br>    tmp = p.getE();<br>    if (tmp.isValid(maze) &amp;&amp; isEmpty(maze, tmp) &amp;&amp; !prev.equals(tmp))<br>      l.add(tmp);<br>    tmp = p.getW();<br>    if (tmp.isValid(maze) &amp;&amp; isEmpty(maze, tmp) &amp;&amp; !prev.equals(tmp))<br>      l.add(tmp);<br>    return l;<br>  }<br><br>  private static Point getStartingPoint(final String[] maze) {<br>    for (int i = 0; i &lt; maze.length; i++)<br>      for (int j = 0; j &lt; maze[i].length(); j++)<br>        if (maze[i].charAt(j) == 'M')<br>          return new Point(i, j);<br>    return null;<br>  }<br><br>  private static class Point {<br>    public int x, y;<br><br>    public Point(final int x, final int y) {<br>      this.x = x;<br>      this.y = y;<br>    }<br><br>    public boolean equals(final Point other) {<br>      return this.x == other.x &amp;&amp; this.y == other.y;<br>    }<br><br>    public boolean isValid(final String[] maze) {<br>      return this.x &gt;= 0 &amp;&amp; this.y &gt;= 0 &amp;&amp; this.x &lt; maze.length<br>          &amp;&amp; this.y &lt; maze[this.x].length();<br>    }<br><br>    public Point getN() {<br>      return new Point(x, y - 1);<br>    }<br><br>    public Point getS() {<br>      return new Point(x, y + 1);<br>    }<br><br>    public Point getW() {<br>      return new Point(x - 1, y);<br>    }<br><br>    public Point getE() {<br>      return new Point(x + 1, y);<br>    }<br>  }<br>}<br></td>