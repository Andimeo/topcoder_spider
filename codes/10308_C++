<td class="problemText" colspan="8" valign="middle" align="left">
            //  SRM 485 (C)<br><br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;utility&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;complex&gt;<br><br>using namespace std;<br><br>typedef unsigned uint;<br>typedef long long Int;<br>typedef vector&lt;int&gt; vint;<br>typedef vector&lt;string&gt; vstr;<br>typedef pair&lt;int,int&gt; pint;<br>#define mp make_pair<br><br>template&lt;class T&gt; void pv(T a, T b) { for (T i = a; i != b; ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; endl; }<br><br>const double EPS = 1e-10;<br>const double INF = 1e+10;<br>const double PI = acos(-1.0);<br>int sig(double r) { return (r &lt; -EPS) ? -1 : (r &gt; EPS) ? 1 : 0; }<br><br>struct Pt {<br>  double x, y;<br>  Pt() {}<br>  Pt(double x, double y) : x(x), y(y) {}<br>  Pt operator+(const Pt &amp;a) { return Pt(x + a.x, y + a.y); }<br>  Pt operator-(const Pt &amp;a) { return Pt(x - a.x, y - a.y); }<br>  Pt operator*(const Pt &amp;a) { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }<br>  Pt operator/(const Pt &amp;a) { return Pt(dot(a) / a.norm(), -det(a) / a.norm()); }<br>  Pt operator-() { return Pt(-x, -y); }<br>  Pt operator*(const double &amp;k) { return Pt(x * k, y * k); }<br>  Pt operator/(const double &amp;k) { return Pt(x / k, y / k); }<br>  double abs() const { return sqrt(x * x + y * y); }<br>  double norm() const { return x * x + y * y; }<br>  double arg() const { return atan2(y, x); }<br>  double dot(Pt a) const { return x * a.x + y * a.y; }<br>  double det(Pt a) const { return x * a.y - y * a.x; }<br>};<br>namespace std {<br>  bool operator&lt;(const Pt &amp;a, const Pt &amp;b) { return (a.x != b.x) ? (a.x &lt; b.x) : (a.y &lt; b.y); }<br>  bool operator==(const Pt &amp;a, const Pt &amp;b) { return (sig(a.x - b.x) == 0) &amp;&amp; (sig(a.y - b.y) == 0); }<br>  ostream &amp;operator&lt;&lt;(ostream &amp;os, const Pt &amp;a) { os &lt;&lt; "(" &lt;&lt; a.x &lt;&lt; ", " &lt;&lt; a.y &lt;&lt; ")"; return os; }<br>}<br>double tri(Pt a, Pt b, Pt c) { return (b - a).det(c - a); }<br><br>int iLL(Pt a, Pt b, Pt c, Pt d) {<br>  if (sig((b - a).det(d - c))) return 1;  //  intersect<br>  if (sig((b - a).det(c - a))) return 0;  //  parallel<br>  return -1;  //  correspond<br>}<br>Pt pLL(Pt a, Pt b, Pt c, Pt d) {<br>  b = b - a; d = d - c;<br>  return a + b * (c - a).det(d) / b.det(d);<br>}<br><br><br>int M, N;<br>Pt P[60], Q[60];<br><br>//  suinitou<br>int len;<br>Pt A[3010], B[3010];<br><br>int K;<br>pair&lt;double,Pt&gt; ps[3010];<br><br>struct Deposit {<br>  <br>  double solve(Pt o, Pt a, Pt b) {<br>    int i;<br>    double s = +INF, t = -INF;<br>    for (i = 0; i &lt; N; ++i) {<br>      if (iLL(o, Q[i], a, b)) {<br>        Pt p = pLL(o, Q[i], a, b);<br>        if (sig((p - a).dot(p - b)) &lt;= 0) {<br>          double u = (p - a).abs();<br>          if (s &gt; u) s = u;<br>          if (t &lt; u) t = u;<br>        }<br>      }<br>    }<br>    for (i = 0; i &lt; N; ++i) {<br>      if (iLL(o, a, Q[i], Q[i + 1])) {<br>        Pt p = pLL(o, a, Q[i], Q[i + 1]);<br>        if (sig((p - Q[i]).dot(p - Q[i + 1])) &lt;= 0) {<br>          double u = 0.0;<br>          if (s &gt; u) s = u;<br>          if (t &lt; u) t = u;<br>        }<br>      }<br>      if (iLL(o, b, Q[i], Q[i + 1])) {<br>        Pt p = pLL(o, b, Q[i], Q[i + 1]);<br>        if (sig((p - Q[i]).dot(p - Q[i + 1])) &lt;= 0) {<br>          double u = (b - a).abs();<br>          if (s &gt; u) s = u;<br>          if (t &lt; u) t = u;<br>        }<br>      }<br>    }<br>    double ret = max(t - s, 0.0);<br>//cout&lt;&lt;o&lt;&lt;" "&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;" : "&lt;&lt;ret&lt;&lt;endl;<br>    return ret;<br>  }<br>  <br>  double successProbability(vector &lt;int&gt; siteX, vector &lt;int&gt; siteY, vector &lt;int&gt; depositX, vector &lt;int&gt; depositY) {<br>    int i, j, k;<br>    int e, f, g;<br>    double sumAll = 0.0;<br>    double sumOK = 0.0;<br>    <br>    M = siteX.size();<br>    for (i = 0; i &lt; M; ++i) P[i] = Pt(siteX[i], siteY[i]);<br>    P[M] = P[0];<br>    N = depositX.size();<br>    for (i = 0; i &lt; N; ++i) Q[i] = Pt(depositX[i], depositY[i]);<br>    Q[N] = Q[0];<br>    <br>    for (e = 0; e &lt; M; ++e) for (f = e + 1; f &lt; M; ++f) {<br>      A[len] = (P[e] + P[f]) / 2.0;<br>      B[len] = A[len] + (P[f] - P[e]) * Pt(0, 1);<br>      ++len;<br>    }<br>//pv(A,A+len);pv(B,B+len);<br>    <br>    for (i = 0; i &lt; M; ++i) {<br>      //  for edge P[i] - P[i + 1]<br>      sumAll += (P[i + 1] - P[i]).abs();<br>      K = 0;<br>      for (g = 0; g &lt; len; ++g) {<br>        if (iLL(P[i], P[i + 1], A[g], B[g])) {<br>          Pt p = pLL(P[i], P[i + 1], A[g], B[g]);<br>          if (sig((p - P[i]).dot(p - P[i + 1])) &lt;= 0) {<br>            ps[K++] = mp((p - P[i]).abs(), p);<br>          }<br>        }<br>      }<br>      ps[K++] = mp(0.0, P[i]);<br>      sort(ps, ps + K);<br>      ps[K] = mp((P[i + 1] - P[i]).abs(), P[i + 1]);<br>      for (k = 0; k &lt; K; ++k) {<br>        Pt p = (ps[k].second + ps[k + 1].second) / 2.0;<br>        double dai = 0.0, tmp;<br>        int jm = ~0;<br>        for (j = 0; j &lt; M; ++j) {<br>          tmp = (p - P[j]).abs();<br>          if (dai &lt; tmp) {<br>            dai = tmp;<br>            jm = j;<br>          }<br>        }<br>        sumOK += solve(P[jm], ps[k].second, ps[k + 1].second);<br>      }<br>    }<br>    <br>    return sumOK / sumAll;<br>    <br>  }<br>  <br>};<br></td>