<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class Unicorn {<br>    const int MOD = 1000000007;<br><br>  public int countWays(int R, int C, int L, int seed, string word) {<br>        char[,] chessboard = new char[R, C];<br>        long x = seed;<br>        long d = (65535 / L)+1;<br>        for (int r=0; r&lt;R; r++)<br>            for (int c=0; c&lt;C; c++) {<br>                x = (x * 25173 + 13849) % 65536;<br>                chessboard[r,c] = (char) (65+(x / d));<br>            }<br>        int[,] can = new int[R, C];<br>        for (int r = 0; r &lt; R; r++)<br>            for (int c = 0; c &lt; C; c++)<br>                if (chessboard[r, c] == word[0])<br>                    ++can[r, c];<br>        for (int i = 1; i &lt; word.Length; ++i)<br>        {<br>            int[,] canSums = buildSums(can, R, C);<br>            int[,] newCan = new int[R, C];<br>            for (int r = 0; r &lt; R; r++)<br>                for (int c = 0; c &lt; C; c++)<br>                    if (chessboard[r, c] == word[i])<br>                    {<br>                        int res = 0;<br>                        res += getRect(canSums, 0, r - 2, 0, c - 2, R, C);<br>                        if (res &gt;= MOD)<br>                            res -= MOD;<br>                        res -= getItem(can, r - 2, c - 2, R, C);<br>                        if (res &lt; 0)<br>                            res += MOD;<br>                        res += getRect(canSums, r + 2, R - 1, 0, c - 2, R, C);<br>                        if (res &gt;= MOD)<br>                            res -= MOD;<br>                        res -= getItem(can, r + 2, c - 2, R, C);<br>                        if (res &lt; 0)<br>                            res += MOD;<br>                        res += getRect(canSums, 0, r - 2, c + 2, C - 1, R, C);<br>                        if (res &gt;= MOD)<br>                            res -= MOD;<br>                        res -= getItem(can, r - 2, c + 2, R, C);<br>                        if (res &lt; 0)<br>                            res += MOD;<br>                        res += getRect(canSums, r + 2, R - 1, c + 2, C - 1, R, C);<br>                        if (res &gt;= MOD)<br>                            res -= MOD;<br>                        res -= getItem(can, r + 2, c + 2, R, C);<br>                        if (res &lt; 0)<br>                            res += MOD;<br>                        newCan[r, c] = res;<br>                    }<br>            can = newCan;<br>        }<br>        int ret = 0;<br>        for (int r = 0; r &lt; R; r++)<br>            for (int c = 0; c &lt; C; c++)<br>            {<br>                ret += can[r, c];<br>                if (ret &gt;= MOD)<br>                    ret -= MOD;<br>            }<br>        return ret;<br>  }<br><br>    private int getItem(int[,] can, int r, int c, int R, int C)<br>    {<br>        if (r &lt; 0 || r &gt;= R || c &lt; 0 || c &gt;= C)<br>            return 0;<br>        return can[r, c];<br>    }<br><br>    private int[,] buildSums(int[,] can, int R, int C)<br>    {<br>        int[,] sum1 = new int[R, C];<br>        for (int r = 0; r &lt; R; r++)<br>            for (int c = 0; c &lt; C; c++)<br>            {<br>                if (c &gt; 0)<br>                    sum1[r, c] = sum1[r, c - 1];<br>                sum1[r, c] += can[r, c];<br>                if (sum1[r, c] &gt;= MOD)<br>                {<br>                    sum1[r, c] -= MOD;<br>                }<br>            }<br>        int[,] sum2 = new int[R, C];<br>        for (int r = 0; r &lt; R; r++)<br>            for (int c = 0; c &lt; C; c++)<br>            {<br>                if (r &gt; 0)<br>                    sum2[r, c] = sum2[r - 1, c];<br>                sum2[r, c] += sum1[r, c];<br>                if (sum2[r, c] &gt;= MOD)<br>                {<br>                    sum2[r, c] -= MOD;<br>                }<br>            }<br>        return sum2;<br>    }<br><br>    int getRect(int[,] sums, int r1, int r2, int c1, int c2, int R, int C)<br>    {<br>        if (r1 &lt; 0)<br>            r1 = 0;<br>        if (r2 &gt;= R)<br>            r2 = R - 1;<br>        if (c1 &lt; 0)<br>            c1 = 0;<br>        if (c2 &gt;= C)<br>            c2 = C - 1;<br>        if (r1 &gt; r2 || c1 &gt; c2)<br>            return 0;<br>        int res = get(sums, r2, c2) - get(sums, r1 - 1, c2);<br>        if (res &lt; 0)<br>            res += MOD;<br>        res -= get(sums, r2, c1 - 1);<br>        if (res &lt; 0)<br>            res += MOD;<br>        res += get(sums, r1 - 1, c1 - 1);<br>        if (res &gt;= MOD)<br>            res -= MOD;<br>        return res;<br>    }<br><br>    private int get(int[,] sums, int r, int c)<br>    {<br>        if (r &lt; 0 || c &lt; 0)<br>            return 0;<br>        return sums[r, c];<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>