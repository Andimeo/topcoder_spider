<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class ConnectingAirports {<br>    class Edge {<br>        int s;<br>        int t;<br>        int c;<br>        int f;<br>        Edge r;<br>        boolean good;<br> <br>        public Edge(int s, int t, int c) {<br>            this.s = s;<br>            this.t = t;<br>            this.c = c;<br>            this.f = 0;<br>        }<br>    }<br> <br>    class Graph {<br>        int n;<br>        ArrayList&lt;Edge&gt; edges[];<br> <br>        public Graph(int n) {<br>            this.n = n;<br>            edges = new ArrayList[n];<br>            for (int i = 0; i &lt; n; i++) {<br>                edges[i] = new ArrayList&lt;Edge&gt;();<br>            }<br>        }<br> <br>        Edge addEdge(int s, int t, int c) {<br>            Edge ef = new Edge(s, t, c);<br>            Edge er = new Edge(t, s, 0);<br>            ef.r = er;<br>            er.r = ef;<br>            edges[s].add(ef);<br>            edges[t].add(er);<br>            return ef;<br>        }<br> <br>        Edge addEdge2(int s, int t, int c) {<br>            Edge ef = new Edge(s, t, c);<br>            Edge er = new Edge(t, s, 0);<br>            ef.r = er;<br>            ef.good = true;<br>            er.r = ef;<br>            edges[s].add(ef);<br>            edges[t].add(er);<br>            return ef;<br>        }<br> <br>        boolean[] u;<br> <br>        int dfs(int i, int t, int c) {<br>            if (i == t) {<br>                return c;<br>            }<br>            u[i] = true;<br> <br>            for (Edge e : edges[i]) {<br>                if (e.f &lt; e.c &amp;&amp; !u[e.t]) {<br>                    int cap = dfs(e.t, t, Math.min(c, e.c - e.f));<br>                    if (cap &gt; 0) {<br>                        e.f += cap;<br>                        e.r.f -= cap;<br>                        return cap;<br>                    }<br>                }<br>            }<br> <br>            return 0;<br>        }<br> <br>        int maxFlow(int s, int t) {<br>            u = new boolean[n];<br> <br>            int flow = 0;<br>            while (true) {<br>                Arrays.fill(u, false);<br>                int df = dfs(s, t, Integer.MAX_VALUE);<br>                if (df == 0) {<br>                    break;<br>                }<br>                flow += df;<br>            }<br> <br>            return flow;<br>        }<br>    }<br> <br>    public String[] getSchedule(int[] capacityA, int[] capacityU) {<br>        int m = capacityA.length;<br>        int n = capacityU.length;<br> <br>        Graph g = new Graph(m + n + 2);<br>        Edge[] fromS = new Edge[m];<br>        Edge[] toT = new Edge[n];<br>        int sum = 0;<br>        for (int i = 0; i &lt; m; i++) {<br>            fromS[i] = g.addEdge(m + n, i, capacityA[i]);<br>            sum += capacityA[i];<br>        }<br>        int sum2 = 0;<br>        for (int i = 0; i &lt; n; i++) {<br>            toT[i] = g.addEdge(m + i, m + n + 1, capacityU[i]);<br>            sum2 += capacityU[i]; <br>        }<br>        if (sum != sum2) {<br>            return new String[]{};<br>        }<br>        for (int i = 0; i &lt; m; i++) {<br>            for (int j = 0; j &lt; n; j++) {<br>                g.addEdge2(i, m + j, 1);<br>            }<br>        }<br> <br>        if (g.maxFlow(n + m, n + m + 1) != sum) {<br>            return new String[]{};<br>        }<br> <br>        for (int i = 0; i &lt; m; i++) {<br>            for (Edge e : g.edges[i]) {<br>                if (e.c &gt; 0) {<br>                    if (e.f == 0) {<br>                        e.c = 0;<br>                        continue;<br>                    }<br>                    e.c = 0;<br>                    e.f--;<br>                    e.r.f++;<br>                    fromS[i].f--;<br>                    fromS[i].r.f++;<br>                    toT[e.t - m].f--;<br>                    toT[e.t - m].r.f++;<br>                    if (g.maxFlow(m + n, m + n + 1) == 0) {<br>                        e.c = 1;<br>                        e.f++;<br>                        e.r.f--;<br>                        fromS[i].f++;<br>                        fromS[i].r.f--;<br>                        toT[e.t - m].f++;<br>                        toT[e.t - m].r.f--;<br>                    }<br>                }<br>            }<br>        }<br> <br>        String[] r = new String[m];<br>        for (int i = 0; i &lt; m; i++) {<br>            r[i] = "";<br>            for (Edge e : g.edges[i]) {<br>                if (e.good) {<br>                    if (e.f &gt; 0) {<br>                        r[i] += "1";<br>                    } else {<br>                        r[i] += "0";<br>                    }<br>                }<br>            }<br>        }<br>        return r;<br>    }<br> <br>}<br> <br> <br>// Powered by PopsEdit<br> <br>// Powered by CodeProcessor<br></td>