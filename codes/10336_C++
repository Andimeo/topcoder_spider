<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cmath&gt;<br> <br>using namespace std;<br> <br>int count_bit(int a)<br>{<br>  int res = 0;<br>  for(; a; a &gt;&gt;= 1) res += a &amp; 1;<br>  return res;<br>}<br> <br>int max_bit(int a)<br>{<br>  int res = -1;<br>  for(int i = 0; a &gt;&gt; i; ++i) if((a &gt;&gt; i) &amp; 1) res = i;<br>  return res;<br>}<br> <br>int inverse_bit(int a, int s)<br>{<br>  int res = 0;<br>  for(int i = 0; a &gt;&gt; i; ++i) res |= ((a &gt;&gt; i) &amp; 1) &lt;&lt; (s - i - 1);<br>  return res;<br>}<br> <br> <br> <br>void FFT_complex(const double* src_r, const double* src_i, double* res_r, double* res_i, int size, double theta)<br>{<br>  int max_b = max_bit(size);<br>  double *cos_t = new double[size], *sin_t = new double[size];<br>  for(int i = 0; i &lt; size; ++i)<br>  {<br>    cos_t[i] = cos(i * theta / size);<br>    sin_t[i] = sin(i * theta / size);<br>    res_r[i] = src_r[inverse_bit(i, max_b)];<br>    res_i[i] = src_i[inverse_bit(i, max_b)];<br>  }<br>  int d = 1 &lt;&lt; (max_b - 1);<br>  for(int i = 0; (1 &lt;&lt; i) &lt; size; ++i)<br>  {<br>    for(int k = 0; k &lt; size; k += (2 &lt;&lt; i))<br>    {<br>      for(int j = 0; j &lt; (1 &lt;&lt; i); ++j)<br>      {<br>        double r1 = res_r[j + k], r2 = res_r[j + k + (1 &lt;&lt; i)];<br>        double i1 = res_i[j + k], i2 = res_i[j + k + (1 &lt;&lt; i)];<br>        res_r[j + k] = r1 + r2 * cos_t[(size &gt;&gt; (i + 1)) * j] - i2 * sin_t[(size &gt;&gt; (i + 1)) * j];<br>        res_i[j + k] = i1 + r2 * sin_t[(size &gt;&gt; (i + 1)) * j] + i2 * cos_t[(size &gt;&gt; (i + 1)) * j];<br>        res_r[j + k + (1 &lt;&lt; i)] = r1 + r2 * cos_t[d + (size &gt;&gt; (i + 1)) * j] - i2 * sin_t[d + (size &gt;&gt; (i + 1)) * j];<br>        res_i[j + k + (1 &lt;&lt; i)] = i1 + r2 * sin_t[d + (size &gt;&gt; (i + 1)) * j] + i2 * cos_t[d + (size &gt;&gt; (i + 1)) * j];<br>      }<br>    }<br>  }<br>}<br> <br>void cyclic_convo(const double* a, const double* b, double* res, int size)<br>{<br>  int n = 1 &lt;&lt; (max_bit(size) + 2);<br>  if(count_bit(size) == 1) n = size;<br>  double *a_r = new double[n], *a_i = new double[n];<br>  double *ar_r = new double[n], *ar_i = new double[n];<br>  memset(a_r, 0, n * sizeof(double));<br>  memset(a_i, 0, n * sizeof(double));<br>  memcpy(a_r, a, size * sizeof(double));<br>  memcpy(a_i, b, size * sizeof(double));<br>  FFT_complex(a_r, a_i, ar_r, ar_i, n, -M_PI * 2);<br>  for(int i = 0; i &lt; n; ++i)<br>  {<br>    double p = ar_r[i], q = ar_i[i], r = ar_r[(n - i) % n], s = ar_i[(n - i) % n];<br>    a_r[i] = (p * q + r * s) / 2;<br>    a_i[i] = ((r * r + q * q) - (p * p + s * s)) / 4;<br>  }<br>  FFT_complex(a_r, a_i, ar_r, ar_i, n, M_PI * 2);<br>  memcpy(res, ar_r, size * sizeof(double));<br>  for(int i = size; i &lt; n; ++i) res[i % size] += ar_r[i];<br>  for(int i = 0; i &lt; size; ++i) res[i] /= n;<br>  delete[] a_r;<br>  delete[] a_i;<br>  delete[] ar_r;<br>  delete[] ar_i;<br>}<br> <br> <br> <br>double x[600000], y[600000];<br>double res[600000];<br> <br>class CircularShifts {<br>public:<br>  int maxScore(int N, int Z0, int A, int B, int M)<br>  {<br>    Z0 %= M;<br>    for(int i = 0; i &lt; 2 * N; ++i) {<br>      if(i &lt; N) x[i] = Z0 % 100;<br>      else y[i - N] = Z0 % 100;<br>      Z0 = ((long long)Z0 * A + B) % M;<br>    }<br>    reverse(y, y + N);<br>    cyclic_convo(x, y, res, N);<br>    double r = 0;<br>    for(int i = 0; i &lt; N; ++i) r = max(r, res[i]);<br>    return (int)(r + 0.5);<br>  }<br>};<br> <br> <br>//Powered by [KawigiEdit] 2.0!<br></td>