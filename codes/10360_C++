<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;iostream&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;math.h&gt;<br>#include&lt;vector&gt;<br>#include&lt;set&gt;<br>#include&lt;list&gt;<br>#include&lt;map&gt;<br>#include&lt;deque&gt;<br>#include&lt;stack&gt;<br>#include&lt;queue&gt;<br>#include&lt;string&gt;<br>#include&lt;sstream&gt;<br>#include&lt;time.h&gt;<br>#include&lt;numeric&gt;<br>#include&lt;functional&gt;<br><br>using namespace std;<br>#define INF  ((1 &lt;&lt; 31) - 1)<br>#define eps 0.00000001<br>#define PI 3.14159265358979323846<br>#define sz(v) ((int)(v).size())<br>#define MP make_pair<br>#define PB push_back<br>#define all(v) (v).begin(), (v).end()<br>typedef long long ll;<br><br>double sqr(int x) {<br>  return 1.0 * x * x;<br>};<br><br>class FeudaliasBattle{<br>public:<br>  double getMinimumTime(vector &lt;int&gt; bX, vector &lt;int&gt; bY, vector &lt;int&gt; sX, vector &lt;int&gt; sY, int TO, int recharge, int speed) {<br>    double d[2][2];<br>    double takeOff = 1.0 * TO / 60.0;<br>    for (int i = 0; i &lt; 2; ++i)<br>      for (int j = 0; j &lt; 2; ++j) {<br>        d[i][j] = sqrt(sqr(sX[i] - bX[j]) + sqr(sY[i] - bY[j]));<br>      };<br>    vector&lt;double&gt; res;<br>    res.PB(takeOff + max(d[0][0] / speed, recharge + takeOff + d[0][1] / speed));<br>    res.PB(takeOff + max(d[0][1] / speed, recharge + takeOff + d[0][0] / speed));<br>    res.PB(takeOff + max(d[1][0] / speed, recharge + takeOff + d[1][1] / speed));<br>    res.PB(takeOff + max(d[1][1] / speed, recharge + takeOff + d[1][0] / speed));<br>    res.PB(max(takeOff + d[0][0]/ speed, takeOff + d[1][1]/ speed));<br>    res.PB(max(takeOff + d[0][1]/ speed, takeOff + d[1][0]/ speed));<br>    return *min_element(all(res));<br>  };<br>};<br></td>