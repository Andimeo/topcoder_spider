<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class ChuckContest {<br>    const int penaltyTime = 20;<br>    const int INF = 1000000;<br><br>    class SegmentSet<br>    {<br>        public List&lt;int&gt; Ls = new List&lt;int&gt;();<br>        public List&lt;int&gt; Rs = new List&lt;int&gt;();<br><br>        public SegmentSet(int[] ls, int[] rs)<br>        {<br>            Ls.AddRange(ls);<br>            Rs.AddRange(rs);<br>        }<br><br>        public void Clear()<br>        {<br>            Ls.Clear();<br>            Rs.Clear();<br>        }<br>    }<br><br>  public string chuckRules(int numProblems, string[] lowerBounds, string[] upperBounds, int[] partTimes) {<br>        int n = lowerBounds.Length;<br>        SegmentSet[,] best = new SegmentSet[numProblems + 1, penaltyTime];<br>        for (int i = 0; i &lt;= numProblems; ++i)<br>            for (int j = 0; j &lt; penaltyTime; ++j)<br>            {<br>                best[i, j] = new SegmentSet(new int[0], new int[0]);<br>            }<br>        best[0, 0] = new SegmentSet(new int[] { 0 }, new int[] { penaltyTime });<br>        int elapsed = 0;<br>        for (int step = 0; step &lt; n; ++step)<br>        {<br>            int finish = partTimes[step];<br>            for (int prevProblems = 0; prevProblems &lt; numProblems; ++prevProblems)<br>            {<br>                for (int prevPenaltyMod = 0; prevPenaltyMod &lt; penaltyTime; ++prevPenaltyMod)<br>                    if (best[prevProblems, prevPenaltyMod].Ls.Count &gt; 0)<br>                    {<br>                        for (int submitTime = elapsed + 1; submitTime &lt;= finish &amp;&amp; submitTime &lt;= elapsed + penaltyTime; ++submitTime)<br>                        {<br>                            int newPenaltyMod = (prevPenaltyMod + submitTime) % penaltyTime;<br>                            int newL = best[prevProblems, prevPenaltyMod].Ls[0] + submitTime;<br>                            unite(best[prevProblems + 1, newPenaltyMod], newL, INF + newPenaltyMod);<br>                        }<br>                    }<br>            }<br>            int worstProblems = int.Parse(lowerBounds[step].Split(' ')[0]);<br>            int worstPenalty = int.Parse(lowerBounds[step].Split(' ')[1]);<br>            int bestProblems = int.Parse(upperBounds[step].Split(' ')[0]);<br>            int bestPenalty = int.Parse(upperBounds[step].Split(' ')[1]);<br>            for (int problems = 0; problems &lt;= numProblems; ++problems)<br>                for (int penaltyMod = 0; penaltyMod &lt; penaltyTime; ++penaltyMod)<br>                {<br>                    if (problems &lt; worstProblems || problems &gt; bestProblems)<br>                    {<br>                        best[problems, penaltyMod].Clear();<br>                    }<br>                    if (problems == worstProblems)<br>                    {<br>                        intersect(best[problems, penaltyMod], penaltyMod, ((worstPenalty - 1 - penaltyMod + penaltyTime) / penaltyTime) * penaltyTime + penaltyMod);<br>                    }<br>                    if (problems == bestProblems)<br>                    {<br>                        intersect(best[problems, penaltyMod], ((bestPenalty - penaltyMod + penaltyTime) / penaltyTime) * penaltyTime + penaltyMod, INF + penaltyMod);<br>                    }<br>                }<br>            elapsed = finish;<br>        }<br>        int resProblems = -1;<br>        int resPenalty = 0;<br>        for (int problems = 0; problems &lt;= numProblems; ++problems)<br>            for (int penaltyMod = 0; penaltyMod &lt; penaltyTime; ++penaltyMod)<br>                if (best[problems, penaltyMod].Ls.Count &gt; 0)<br>                {<br>                    int curPenalty = best[problems, penaltyMod].Ls[0];<br>                    if (problems &gt; resProblems || problems == resProblems &amp;&amp; curPenalty &lt; resPenalty)<br>                    {<br>                        resProblems = problems;<br>                        resPenalty = curPenalty;<br>                    }<br>                }<br>        if (resProblems &lt; 0)<br>            return "";<br>        else<br>            return resProblems + " " + resPenalty;<br>  }<br><br>    private void intersect(SegmentSet segmentSet, int nl, int nr)<br>    {<br>        if (nl &gt;= nr)<br>            segmentSet.Clear();<br>        else<br>        {<br>            while (segmentSet.Ls.Count &gt; 0 &amp;&amp; segmentSet.Rs[0] &lt;= nl)<br>            {<br>                segmentSet.Ls.RemoveAt(0);<br>                segmentSet.Rs.RemoveAt(0);<br>            }<br>            if (segmentSet.Ls.Count &gt; 0)<br>            {<br>                segmentSet.Ls[0] = Math.Max(segmentSet.Ls[0], nl);<br>                int i = 0;<br>                while (i &lt; segmentSet.Ls.Count &amp;&amp; segmentSet.Rs[i] &lt;= nr)<br>                    ++i;<br>                if (i &lt; segmentSet.Ls.Count)<br>                {<br>                    if (segmentSet.Ls[i] &lt; nr)<br>                    {<br>                        segmentSet.Rs[i] = Math.Min(segmentSet.Rs[i], nr);<br>                        ++i;<br>                    }<br>                    while (i &lt; segmentSet.Ls.Count)<br>                    {<br>                        segmentSet.Ls.RemoveAt(segmentSet.Ls.Count - 1);<br>                        segmentSet.Rs.RemoveAt(segmentSet.Rs.Count - 1);<br>                    }<br>                }<br>            }<br>        }<br>    }<br><br>    private void unite(SegmentSet segmentSet, int nl, int nr)<br>    {<br>        int i = 0;<br>        while (i &lt; segmentSet.Ls.Count &amp;&amp; segmentSet.Rs[i] &lt; nl)<br>            ++i;<br>        if (i &lt; segmentSet.Ls.Count &amp;&amp; segmentSet.Ls[i] &lt;= nl)<br>        {<br>            segmentSet.Rs[i] = Math.Max(segmentSet.Rs[i], nr);<br>        }<br>        else<br>        {<br>            segmentSet.Ls.Insert(i, nl);<br>            segmentSet.Rs.Insert(i, nr);<br>        }<br>        while (i &lt; segmentSet.Ls.Count - 1 &amp;&amp; segmentSet.Rs[i] &gt;= segmentSet.Ls[i + 1])<br>        {<br>            segmentSet.Rs[i] = Math.Max(segmentSet.Rs[i], segmentSet.Rs[i + 1]);<br>            segmentSet.Ls.RemoveAt(i + 1);<br>            segmentSet.Rs.RemoveAt(i + 1);<br>        }<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>