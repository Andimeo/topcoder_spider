<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class PalindromePhrases <br>{<br>  const int INF = 987654321;<br><br>  long[, , ,] f;<br>  int n;<br><br>  void init()<br>  {<br>    int l0 = f.GetLength(0);<br>    int l1 = f.GetLength(1);<br>    int l2 = f.GetLength(2);<br>    int l3 = f.GetLength(3);<br>    for (int i = 0; i &lt; l0; i++)<br>    {<br>      for (int j = 0; j &lt; l1; j++)<br>      {<br>        for (int u = 0; u &lt; l2; u++)<br>        {<br>          for (int v = 0; v &lt; l3; v++)<br>          {<br>            f[i, j, u, v] = -1;<br>          }<br>        }<br>      }<br>    }<br>  }<br><br>  long calc(int mask, int side, int x, int len)<br>  {<br>    //if (mask == 0)<br>    //{<br>    //    return 0;<br>    //}<br><br>    if (f[mask, side, x, len] != -1) return f[mask, side, x, len];<br><br>    long res = 0;<br>    if (len == 0)<br>    {<br>      res++;<br>      for (int i = 0; i &lt; n; i++)<br>      {<br>        if (isOn(mask, i))<br>        {<br>          res += calc(turnOff(mask, i), 0, i, words[i].Length);<br>        }<br>      }<br>    }<br>    else if (side == 0)<br>    {<br>      if (good[x, words[x].Length-len, words[x].Length-1]) <br>      {<br>        res++;<br>      }<br><br>      for (int i = 0; i &lt; n; i++)<br>      {<br>        if (isOn(mask, i))<br>        {<br>          int common = A[x, len, i];<br><br>          if (common &gt;= len)<br>          {<br>            res += calc(turnOff(mask, i), 1, i, words[i].Length - len);<br>          }<br>          else if (common == words[i].Length)<br>          {<br>            res += calc(turnOff(mask, i), 0, x, len - common);<br>          }<br>        }<br>      }<br>    }<br>    else if (side == 1)<br>    {<br>      if (good[x, 0, len - 1])<br>      {<br>        res++;<br>      }<br>      for (int i = 0; i &lt; n; i++)<br>      {<br>        if (isOn(mask, i))<br>        {<br>          int common = B[x, len, i];<br><br>          if (common &gt;= len)<br>          {<br>            res += calc(turnOff(mask, i), 0, i, words[i].Length - len);<br>          }<br>          else if (common == words[i].Length)<br>          {<br>            res += calc(turnOff(mask, i), 1, x, len - common);<br>          }<br>        }<br>      }<br>    }<br><br>    return f[mask, side, x, len] = res;<br>  }<br><br>  string[] words;<br>  bool[, ,] good;<br><br>  int[,,] A, B;<br><br>  static bool IsPalindrome(string s)<br>  {<br>    if (s.Length &lt;= 1) return true;<br>    int x = 0;<br>    int y = s.Length - 1;<br>    while (x &lt; y &amp;&amp; s[x] == s[y])<br>    {<br>      x++;<br>      y--;<br>    }<br>    return x &gt;= y;<br>  } <br><br>  public long getAmount(string[] words) <br>  {<br>    this.words = words;<br>    n = words.Length;<br><br>    f = new long[1 &lt;&lt; n, 2, n, 14];<br>    init();<br><br>    good = new bool[n, 14, 14];<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>      for (int j = 0; j &lt; words[i].Length; j++)<br>      {<br>        for (int k = j; k &lt; words[i].Length; k++)<br>        {<br>          string s = words[i].Substring(j, k - j + 1);<br>          if (IsPalindrome(s))<br>            good[i, j, k] = true;<br>        }<br>      }<br>    }<br><br>    A = new int[n, 14, n];<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>      for (int h = 1; h &lt;= words[i].Length; ++h)<br>      {<br>        for (int j = 0; j &lt; n; j++)<br>        {<br>          if (i == j) continue;<br><br>          int k = 0;<br><br>          int ci = words[i].Length - h;<br>          int cj = words[j].Length - 1;<br>          while (ci &lt; words[i].Length &amp;&amp; cj &gt;= 0 &amp;&amp; words[i][ci] == words[j][cj])<br>          {<br>            k++;<br>            ci++;<br>            cj--;<br>          }<br><br>          A[i, h, j] = k;<br>        }<br>      }<br>    }<br><br>    B = new int[n, 14, n];<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>      for (int h = 1; h &lt;= words[i].Length; ++h)<br>      {<br>        for (int j = 0; j &lt; n; j++)<br>        {<br>          if (i == j) continue;<br><br>          int k = 0;<br><br>          int ci = h-1;<br>          int cj = 0;<br>          while (ci &gt;= 0 &amp;&amp; cj &lt; words[j].Length &amp;&amp; words[i][ci] == words[j][cj])<br>          {<br>            k++;<br>            ci--;<br>            cj++;<br>          }<br><br>          B[i, h, j] = k;<br>        }<br>      }<br>    }<br><br>    return calc((1 &lt;&lt; n) - 1, 0, 0, 0) - 1;<br>  }<br><br>  bool isOn(int x, int b)<br>  {<br>    return (x &amp; (1 &lt;&lt; b)) &gt; 0;<br>  }<br><br>  int turnOn(int x, int b)<br>  {<br>    return x | (1 &lt;&lt; b);<br>  }<br><br>  int turnOff(int x, int b)<br>  {<br>    return x &amp; ~(1 &lt;&lt; b);<br>  }<br><br><br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>