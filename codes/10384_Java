<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class KingdomMap {<br>    static class Vertex {<br>        List&lt;Edge&gt; adj = new ArrayList&lt;Edge&gt;();<br>    }<br> <br>    static class Edge {<br>        int dest;<br>        int edgeId;<br>    }<br> <br> <br>    public int[] getRoadsToRemove(int n, String[] roads) {<br>        StringBuilder all = new StringBuilder();<br>        for (String x : roads)<br>            all.append(x);<br>        if (all.toString().length() == 0)<br>            return new int[0];<br>        String[] edges = all.toString().split(",");<br>        int[] edgeA = new int[edges.length];<br>        int[] edgeB = new int[edges.length];<br>        int index = 0;<br>        for (String edge : edges) {<br>            String[] part = edge.split(" ");<br>            edgeA[index] = Integer.parseInt(part[0]);<br>            edgeB[index] = Integer.parseInt(part[1]);<br>            ++index;<br>        }<br>        Vertex[] v = new Vertex[n];<br>        for (int i = 0; i &lt; n; ++i) {<br>            v[i] = new Vertex();<br>        }<br>        for (int i = 0; i &lt; edges.length; ++i) {<br>            Edge e = new Edge();<br>            e.dest = edgeB[i];<br>            e.edgeId = i;<br>            v[edgeA[i]].adj.add(e);<br>            e = new Edge();<br>            e.dest = edgeA[i];<br>            e.edgeId = i;<br>            v[edgeB[i]].adj.add(e);<br>        }<br>        boolean[] kill = new boolean[edges.length];<br>        int numKill = 0;<br>        int willGet = getAmounts(n, v, kill)[1];<br>        for (int i = 0; i &lt; edges.length; ++i) {<br>            kill[i] = true;<br>            int amt = getAmounts(n, v, kill)[1];<br>            if (amt != willGet) {<br>                if (amt != willGet - 1)<br>                    throw new RuntimeException();<br>                kill[i] = false;<br>            } else {<br>                ++numKill;<br>            }<br>        }<br>        int[] res = new int[numKill];<br>        int at = 0;<br>        for (int i = 0; i &lt; edges.length; ++i) {<br>            if (kill[i]) {<br>                res[at++] = i;<br>            }<br>        }<br>        return res;<br>    }<br> <br>    private int[] getAmounts(int n, Vertex[] v, boolean[] kill) {<br>        int[] res = new int[4];<br>        boolean[] visited = new boolean[n];<br>        for (int i = 0; i &lt; n; ++i)<br>            if (!visited[i]) {<br>                int[] am = getIt(n, visited, i, -1, v, kill);<br>                for (int j = 0; j &lt; 4; ++j)<br>                    res[j] += am[j];<br>            }<br>        return res;<br>    }<br> <br>    private int[] getIt(int n, boolean[] visited, int at, int parent, Vertex[] v, boolean[] kill) {<br>        visited[at] = true;<br>        int[] delta = new int[v[at].adj.size()];<br>        int[] delta2 = new int[v[at].adj.size()];<br>        int sumcd = 0;<br>        int sumc = 0;<br>        int k = 0;<br>        for (Edge e : v[at].adj) {<br>            if (e.dest == parent || kill[e.edgeId])<br>                continue;<br>            int[] am = getIt(n, visited, e.dest, at, v, kill);<br>            delta[k] = am[0] + 1 - Math.max(am[1], am[2] + 1);<br>            delta2[k++] = am[3] + 1 - am[1];<br>            sumcd += Math.max(am[1], am[2] + 1);<br>            sumc += am[1];<br>        }<br>        int[] res = new int[4];<br>        res[2] = sumc;<br>        Arrays.sort(delta, 0, k);<br>        Arrays.sort(delta2, 0, k);<br>        res[0] = res[2];<br>        if (k &gt; 0)<br>            res[0] = Math.max(res[0], sumcd + delta[k - 1]);<br>        res[3] = res[0];<br>        if (k &gt; 1)<br>            res[3] = Math.max(res[3], sumcd + delta[k - 1] + delta[k - 2]);<br>        res[1] = res[3];<br>        if (k &gt; 0)<br>            res[1] = Math.max(res[1], sumc + delta2[k - 1]);<br>        return res;<br>    }<br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>