<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class SquareFreeSets {<br>    const int MOD = 1000000007;<br><br>    class Numbers<br>    {<br>        public List&lt;int&gt; a;<br><br>        public Numbers(List&lt;int&gt; a)<br>        {<br>            this.a = new List&lt;int&gt;(a);<br>            this.a.Sort();<br>        }<br><br>        public override bool Equals(object obj)<br>        {<br>            Numbers o = (Numbers)obj;<br>            if (a.Count != o.a.Count)<br>                return false;<br>            for (int i = 0; i &lt; a.Count; ++i)<br>                if (a[i] != o.a[i])<br>                    return false;<br>            return true;<br>        }<br><br>        public override int GetHashCode()<br>        {<br>            int res = a.Count;<br>            foreach (int x in a)<br>                res = unchecked(res * 31373 + x);<br>            return res;<br>        }<br>    }<br><br>    public int countPerfect(int N, int K)<br>    {<br>        List&lt;int&gt; primes = new List&lt;int&gt;();<br>        for (int p = 2; p &lt;= N; ++p)<br>        {<br>            bool ok = true;<br>            for (int i = 2; i * i &lt;= p; ++i)<br>                if (p % i == 0)<br>                {<br>                    ok = false;<br>                    break;<br>                }<br>            if (ok)<br>            {<br>                primes.Add(p);<br>            }<br>        }<br>        if (K &gt; primes.Count)<br>            K = primes.Count;<br>        int numSmall = primes.Count - 1;<br>        while (numSmall &gt; 0 &amp;&amp; primes[numSmall - 1] * primes[numSmall] &gt; N)<br>            --numSmall;<br>        Dictionary&lt;Numbers, int&gt; combinations = new Dictionary&lt;Numbers, int&gt;();<br>        buildAll(N, K, primes, numSmall, new List&lt;int&gt;(), ref combinations);<br>        int res = 0;<br>        int[,] c = new int[primes.Count + 1, primes.Count + 1];<br>        c[0, 0] = 1;<br>        for (int i = 1; i &lt;= primes.Count; ++i)<br>        {<br>            c[i, 0] = 1;<br>            for (int j = 1; j &lt;= primes.Count; ++j)<br>            {<br>                c[i, j] = (c[i - 1, j] + c[i - 1, j - 1]) % MOD;<br>            }<br>        }<br>        int[,] freeAm = new int[K + 1, primes.Count + 1];<br>        for (int i = 0; i &lt;= primes.Count; ++i)<br>            freeAm[0, i] = 1;<br>        for (int size = 1; size &lt;= K; ++size) {<br>            freeAm[size, 0] = 1;<br>            for (int cnt = 1; cnt &lt;= primes.Count; ++cnt)<br>            {<br>                freeAm[size, cnt] = freeAm[size - 1, cnt];<br>                if (size &lt;= primes.Count)<br>                    freeAm[size, cnt] = (freeAm[size, cnt] + c[cnt, size]) % MOD;<br>            }<br>        }<br>        foreach (Numbers numbers in combinations.Keys) {<br>            int[] am = new int[K + 1];<br>            am[0] = 1;<br>            int latest = numSmall;<br>            for (int i = numbers.a.Count - 1; i &gt;= 0; --i)<br>            {<br>                while (latest &lt; primes.Count &amp;&amp; primes[latest] * numbers.a[i] &lt;= N)<br>                    ++latest;<br>                for (int j = K; j &gt;= 1; --j)<br>                {<br>                    if (numSmall + j &lt;= latest)<br>                        am[j] = (int) ((am[j] + ((long) am[j - 1]) * (latest - numSmall - j + 1)) % MOD);<br>                }<br>            }<br>            for (int j = 0; j &lt;= K; ++j)<br>                if (numSmall + j &lt;= primes.Count)<br>                    res = (int) ((res + am[j] * (long)freeAm[K - numbers.a.Count, primes.Count - numSmall - j]) % MOD);<br>        }<br>        return (res + MOD - 1) % MOD;<br>  }<br><br>    private void buildAll(int N, int K, List&lt;int&gt; primes, int numSmall, List&lt;int&gt; prefix, ref Dictionary&lt;Numbers, int&gt; combinations)<br>    {<br>        Numbers numbers = new Numbers(prefix);<br>        combinations[numbers] = 1;<br>        if (numSmall == 0)<br>            return;<br>        buildAll(N, K, primes, numSmall - 1, prefix, ref combinations);<br>        if (prefix.Count &lt; K) {<br>            List&lt;int&gt; newPrefix = new List&lt;int&gt;(prefix);<br>            newPrefix.Add(primes[numSmall - 1]);<br>            buildAll(N, K, primes, numSmall - 1, newPrefix, ref combinations);<br>        }<br>        for (int i = 0; i &lt; prefix.Count; ++i)<br>            if (prefix[i] * primes[numSmall - 1] &lt;= N)<br>            {<br>                List&lt;int&gt; newPrefix = new List&lt;int&gt;(prefix);<br>                newPrefix[i] = prefix[i] * primes[numSmall - 1];<br>                buildAll(N, K, primes, numSmall - 1, newPrefix, ref combinations);<br>            }<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>