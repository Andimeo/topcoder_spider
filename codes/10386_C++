<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;climits&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cctype&gt;<br>#include &lt;ctime&gt;<br>#include &lt;float.h&gt;<br>using namespace std;<br><br>typedef vector&lt;int&gt; vi;<br><br>#define For(i,a,b) for (int i(a),_b(b); i &lt;= _b; ++i)<br>#define Ford(i,a,b) for (int i(a),_b(b); i &gt;= _b; --i)<br>#define Rep(i,n) for (int i(0),_n(n); i &lt; _n; ++i)<br>#define Repd(i,n) for (int i((n)-1); i &gt;= 0; --i)<br>#define All(v) (v).begin(), (v).end()<br>#define MP make_pair<br><br>template&lt;typename T&gt; inline int size(const T&amp; c) { return (int)c.size(); }<br><br>const int mod = 1000000007;<br><br>inline void add(int&amp; a, int b) {<br>  a += b;<br>  if (a &gt;= mod)<br>    a -= mod;<br>}<br><br>vector&lt;int&gt; primes;<br>int n, k;<br>map&lt;pair&lt;pair&lt;int,int&gt;,vector&lt;int&gt; &gt;,int&gt; memo;<br><br>int solve(int g, vector&lt;int&gt; cur, int pos) {<br>  if (pos == size(primes) || primes[pos] &gt; n) {<br>    if (g+size(cur) &gt; 0)<br>      return 1;<br>    else<br>      return 0;<br>  }<br>  int p = primes[pos];<br>  while (size(cur) &gt; 0 &amp;&amp; cur.back()*p &gt; n) {<br>    ++g;<br>    cur.pop_back();<br>  }<br>  pair&lt;pair&lt;int,int&gt;,vector&lt;int&gt; &gt; state = MP(MP(g, pos), cur);<br>  if (memo.count(state))<br>    return memo[state];<br>  int&amp; res = memo[state];<br>  res = solve(g, cur, pos+1);<br>  if (g+size(cur) &lt; k) {<br>    vi v = cur;<br>    v.push_back(p);<br>    sort(All(v));<br>    add(res, solve(g, v, pos+1));<br>  }<br>  Rep(i, size(cur)) {<br>    vi v = cur;<br>    v[i] *= p;<br>    sort(All(v));<br>    add(res, solve(g, v, pos+1));<br>  }<br>  return res;<br>}<br><br>class SquareFreeSets {<br>  public:<br>  int countPerfect(int N, int K) {<br>    n = N;<br>    k = K;<br>    For(i, 2, 500) {<br>      bool prime = true;<br>      For(j, 2, i-1)<br>        prime &amp;= i%j != 0;<br>      if (prime) <br>        primes.push_back(i);<br>    }<br>    memo.clear();<br>    return solve(0, vi(), 0);<br>  }<br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.12 [modified TZTester]<br>// Powered by CodeProcessor<br></td>