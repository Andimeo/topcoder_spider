<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;utility&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;cctype&gt;<br>#include &lt;numeric&gt;<br>#include &lt;queue&gt;<br><br>using namespace std;<br><br>typedef long long LL;<br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt;vector&lt;int&gt; &gt; VVI;<br>typedef pair&lt;int,int&gt; PII;<br>typedef vector&lt;PII&gt; VPII;<br><br>#define ST first<br>#define ND second<br>#define MP make_pair<br>#define PB push_back<br>#define ALL(X) (X).begin(),(X).end()<br>#define REP(i,n) for (int i = 0; i &lt; (n); ++i)<br>#define FOR(i,a,b) for (int i = (a); i &lt;= (b); ++i)<br>#define FORD(i,a,b) for (int i = (a); i &gt;= (b); --i)<br>#define SIZE(X) (int)(X).size()<br>#define FOREACH(it,X) for( __typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it)<br><br>void wypisz(VI v){<br>  cout &lt;&lt; "{" ;<br>  REP(i,SIZE(v)){<br>    if (i) printf(",");<br>    printf("%d",v[i]);<br>  }<br>  cout &lt;&lt; "}" &lt;&lt; endl;<br>}<br><br>void wypisz(VS v){<br> cout &lt;&lt; "{";<br>  REP(i,SIZE(v)){<br>    if (i) cout &lt;&lt; "," &lt;&lt; endl;<br>    cout &lt;&lt; "\"" &lt;&lt; v[i] &lt;&lt; "\"";<br>  }<br>  cout &lt;&lt; "}" &lt;&lt; endl;<br>}<br><br><br>const int K = 11;<br>const int BASE = 128 * 1024;<br><br>struct Wezel{<br>  int dokad[K];<br>} drzewo[2*BASE];<br>int stany;<br>int alfabet;<br>int przejscia[K][K];<br><br>void zmien(int pos,int naco){<br>  pos += BASE;<br>  REP(i,stany) drzewo[pos].dokad[i] = przejscia[i][naco];<br>  while (pos &gt; 1){<br>    pos /= 2;<br>    REP(i,stany) drzewo[pos].dokad[i] = drzewo[2*pos+1].dokad[drzewo[2*pos].dokad[i]];<br>  }<br>}<br><br>int x[2*BASE], c[2*BASE];<br><br>class Automaton {<br>  public:<br>  int numberOfMatchings(vector &lt;string&gt; transitions, int stringLength, vector &lt;int&gt; x0, vector &lt;int&gt; xa, vector &lt;int&gt; c0, vector &lt;int&gt; ca, int modifications) {<br>    stany = SIZE(transitions);<br>    alfabet = SIZE(transitions[0]);<br>    REP(i,stany) REP(j,alfabet) przejscia[i][j] = transitions[i][j]-'A';<br><br>    REP(i,2*BASE) REP(j,stany) drzewo[i].dokad[j] = j;<br>    REP(i,stringLength) zmien(i,0);<br>    int letters = alfabet;<br>    int initElements = SIZE(x0);<br>    <br>    for (int i = 0; i &lt; initElements; i++) {<br>      x[i] = x0[i] % stringLength;<br>      c[i] = c0[i] % letters;<br>    }<br><br>    for (int i = initElements; i &lt; modifications; i++) {<br>      x[i] = 0;<br>      c[i] = 0;  <br>      for (int j = i - initElements; j &lt; i; j++) {<br>        x[i] = (x[i] + xa[j - i + (LL)initElements] * x[j]) % stringLength;<br>        c[i] = (c[i] + ca[j - i + (LL)initElements] * c[j]) % letters;<br>      }<br>    }<br><br>    int res = drzewo[1].dokad[0] == stany-1;<br>    REP(i,modifications){<br>      zmien(x[i],c[i]);<br>      res += drzewo[1].dokad[0] == stany-1;<br>    }<br>    return res;<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>