<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br>import java.text.*;<br>import java.math.*;<br>import java.awt.geom.*;<br> <br>public class TheBoredJohn<br>{<br>  int gcd(int a, int b) {<br>    while (b != 0) {<br>      int tmp = a % b;<br>      a = b;<br>      b = tmp;<br>    }<br>    return a;<br>  }<br>  <br>  static class Pair implements Comparable&lt;Pair&gt; {<br>    int u, v;<br>    <br>    Pair(int u, int v) {<br>      this.u = u;<br>      this.v = v;<br>    }<br>    <br>    public int hashCode() {<br>      return new int[] {u, v}.hashCode();<br>    }<br>    <br>    public boolean equals(Object o) {<br>      Pair p = (Pair) o;<br>      return u == p.u &amp;&amp; v == p.v;<br>    }<br>    <br>    public int compareTo(Pair b) {<br>      if (u == b.u) {<br>        return v - b.v;<br>      }<br>      return u - b.u;<br>    }<br>  }<br>  <br>  public long killMonsters(int n, long k, String[] missing)<br>  {<br>    --n;<br>    int[] div = new int[n + 1];<br>    for (int i = 4; i &lt;= n; i += 2) {<br>      div[i] = 2;<br>    }<br>    for (int i = 3; i &lt;= n; i += 2) {<br>      if (div[i] != 0) {<br>        continue;<br>      }<br>      for (int j = 3 * i; j &lt;= n; j += 2 * i) {<br>        div[j] = i;<br>      }<br>    }<br>    int[] phi = new int[n + 1];<br>    phi[1] = 1;<br>    for (int i = 2; i &lt;= n; ++i) {<br>      if (div[i] == 0) {<br>        phi[i] = i - 1;<br>      } else {<br>        int p = div[i];<br>        int j = i / p;<br>        phi[i] = p - 1;<br>        while (j % p == 0) {<br>          j /= p;<br>          phi[i] *= p;<br>        }<br>        phi[i] *= phi[j];<br>      }<br>    }<br>    StringBuilder sb = new StringBuilder();<br>    for (String s : missing) {<br>      sb.append(s);<br>    }<br>    TreeMap&lt;Pair, Integer&gt; map = new TreeMap&lt;Pair, Integer&gt;();<br>    for (String s : sb.toString().split(",")) {<br>      String[] tmp = s.split(" ");<br>      int u = Integer.parseInt(tmp[0]);<br>      int v = Integer.parseInt(tmp[1]);<br>      int g = gcd(u, v);<br>      u /= g;<br>      v /= g;<br>      Pair p = new Pair(u, v);<br>      if (!map.containsKey(p)) {<br>        map.put(p, n / Math.max(u, v));<br>      }<br>      map.put(p, map.get(p) - 1);<br>    }<br>    PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;();<br>    int[] count = new int[n + 1];<br>    for (int i = 0; i &lt;= n; ++i) {<br>      count[i] = phi[i] * 2;<br>    }<br>    boolean lr = true;<br>    for (Pair p : map.keySet()) {<br>      q.add(-map.get(p));<br>      int u = Math.min(p.u, p.v);<br>      int v = Math.max(p.u, p.v);<br>      if (u != 0 || v != 1 || p.u == 0 &amp;&amp; p.v == 1) {<br>        count[v]--;<br>      } else {<br>        lr = false;<br>      }<br>    }<br>    long ans = 0;<br>    if (k &gt; 0 &amp;&amp; lr) {<br>      --k;<br>      ans += n;<br>    }<br>    for (int i = 1; i &lt;= n &amp;&amp; k &gt; 0; ++i) {<br>      long len = n / i;<br>      while (!q.isEmpty() &amp;&amp; -q.peek() &gt; len &amp;&amp; k &gt; 0) {<br>        ans += -q.poll();<br>        --k;<br>      }<br>      ans += Math.min(k, count[i]) * len;<br>      k -= Math.min(k, count[i]);<br>    }<br>    while (!q.isEmpty() &amp;&amp; k &gt; 0) {<br>      ans += -q.poll();<br>      --k;<br>    }<br>    return ans;<br>  }<br>}<br>//Powered by [KawigiEditNonTest] modified by pivanof!<br></td>