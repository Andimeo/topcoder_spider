<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class ArrayTransformations {<br>    class Edge {<br>        public int dest;<br>        public long cap;<br>        public long cost;<br>        public long lower;<br>        public long flow;<br>        public Edge rev;<br>    }<br>    long K;<br>    public int minimalValue(string[] initialArray, int K, int M) {<br>        this.K = K;<br>        StringBuilder b = new StringBuilder();<br>        foreach (string s in initialArray)<br>            b.Append(s);<br>        int[] a = Array.ConvertAll&lt;string, int&gt;(b.ToString().Split(' '), int.Parse);<br>        int n = a.Length + 7;<br>        List&lt;Edge&gt;[] o = new List&lt;Edge&gt;[n];<br>        for (int i = 0; i &lt; n; ++i)<br>            o[i] = new List&lt;Edge&gt;();<br>        addEdge(o, 0, 1);<br>        addEdge(o, 2, 3);<br>        for (int i = 0; i &lt;= a.Length; ++i) {<br>            addEdge(o, 1, 4 + i);<br>            addEdge(o, 4 + i, 2);<br>        }<br>        Edge[] those = new Edge[a.Length];<br>        for (int i = 0; i &lt; a.Length; ++i) {<br>            those[i] = addEdge(o, 4 + i, 5 + i);<br>            those[i].cost = 1;<br>            those[i].rev.cost = -1;<br>        }<br>        Edge[] fs = new Edge[n - 2];<br>        Edge[] ft = new Edge[n - 2];<br>        for (int i = 0; i &lt; n - 2; ++i) {<br>            fs[i] = addEdge(o, n - 2, i);<br>            fs[i].cap = 0;<br>            ft[i] = addEdge(o, i, n - 1);<br>            ft[i].cap = 0;<br>        }<br>        addEdge(o, 3, 0);<br>        int left = -1;<br>        int right = 2000000;<br>        while (right - left &gt; 1) {<br>            int middle = (left + right) / 2;<br>            for (int i = 0; i &lt; a.Length; ++i) {<br>                int need = Math.Max(0, a[i] - middle);<br>                those[i].lower = need;<br>            }<br>            long cost;<br>            if (minCostMaxFlow(n, o, 0, 3, fs, ft, out cost)) {<br>                if (cost &lt;= M) {<br>/*                    if (middle == 1) {<br>                    Console.WriteLine(middle);<br>                    for (int i = 0; i &lt; n; ++i)<br>                        foreach (Edge e in o[i])<br>                            Console.WriteLine(i + " " + e.dest + " " + e.flow + " " + e.lower);<br>                    }*/<br>                    right = middle;<br>                } else {<br>                    left = middle;<br>                }<br>            } else {<br>                left = middle;<br>            }<br>        }<br>        return right;<br>    }<br><br>    bool minCostMaxFlow(int n, List&lt;Edge&gt;[] o, int s, int t, Edge[] fs, Edge[] ft, out long cost) {<br>//        Console.WriteLine("?");<br>        cost = 0;<br>        long[] delta = new long[n];<br>        for (int i = 0; i &lt; n; ++i) {<br>            List&lt;Edge&gt; l = o[i];<br>            foreach (Edge e in l) {<br>                e.flow = 0;<br>                if (e.lower &gt; 0) {<br>                    cost += e.lower * e.cost;<br>                    delta[i] -= e.lower;<br>                    delta[e.dest] += e.lower;<br>                }<br>            }<br>        }<br>        long sum = 0;<br>        for (int i = 0; i &lt; n - 2; ++i) {<br>            long positive = Math.Max(0, delta[i]);<br>            long negative = Math.Max(0, -delta[i]);<br>            sum += positive;<br>            fs[i].cap = positive;<br>            ft[i].cap = negative;<br>        }<br>        return sum == mcmf(n, o, n - 2, n - 1, ref cost);<br>    }<br><br>    long mcmf(int n, List&lt;Edge&gt;[] o, int s, int t, ref long cost) {<br>        long[] phi = new long[n];<br>        long res = 0;<br>        while (true) {<br>            bool[] mark = new bool[n];<br>            long[] dist = new long[n];<br>            int[] prev = new int[n];<br>            Edge[] pe = new Edge[n];<br>            for (int i = 0; i &lt; n; ++i)<br>                dist[i] = long.MaxValue;<br>            dist[s] = 0;<br>            prev[s] = -1;<br>            long mxDist = 0;<br>            while (true) {<br>                long minDist = long.MaxValue;<br>                int mi = -1;<br>                for (int i = 0; i &lt; n; ++i)<br>                    if (!mark[i] &amp;&amp; dist[i] &lt; minDist) {<br>                        minDist = dist[i];<br>                        mi = i;<br>                    }<br>                if (mi &lt; 0)<br>                    break;<br>                mxDist = minDist;<br>                mark[mi] = true;<br>                foreach (Edge e in o[mi]) {<br>                    if (e.flow &gt;= e.cap)<br>                        continue;<br>                    long ndist = minDist + e.cost + phi[mi] - phi[e.dest];<br>                    if (ndist &lt; dist[e.dest]) {<br>                        dist[e.dest] = ndist;<br>                        prev[e.dest] = mi;<br>                        pe[e.dest] = e;<br>                    }<br>                }<br>            }<br>            if (dist[t] == long.MaxValue)<br>                break;<br>            long by = long.MaxValue;<br>            int at = t;<br>            while (at != s) {<br>                by = Math.Min(by, pe[at].cap - pe[at].flow);<br>                at = prev[at];<br>            }<br>            cost += by * (dist[t] - phi[s] + phi[t]);<br>            res += by;<br>            at = t;<br>            while (at != s) {<br>                pe[at].flow += by;<br>                pe[at].rev.flow -= by;<br>                at = prev[at];<br>            }<br>            for (int i = 0; i &lt; n; ++i)<br>                if (dist[i] == long.MaxValue)<br>                    phi[i] += mxDist;<br>                else<br>                    phi[i] += dist[i];<br>        }<br>        return res;<br>    }<br><br>    Edge addEdge(List&lt;Edge&gt;[] o, int a, int b) {<br>        Edge e = new Edge();<br>        e.dest = b;<br>        e.cap = K;<br>        e.cost = 0;<br>        e.lower = 0;<br>        e.flow = 0;<br>        Edge re = new Edge();<br>        re.dest = a;<br>        re.cap = 0;<br>        re.cost = 0;<br>        re.lower = 0;<br>        re.flow = 0;<br>        e.rev = re;<br>        re.rev = e;<br>        o[a].Add(e);<br>        o[b].Add(re);<br>        return e;<br>    }<br>}<br><br><br>// Powered by FileEdit<br></td>