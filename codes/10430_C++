<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;iostream&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cctype&gt;<br>using namespace std;<br><br>struct FractalWheels{<br>  vector &lt;int&gt; describeWheel(int N, vector &lt;string&gt; edges);<br>};<br>vector&lt;int&gt; adj[1000];<br>int N;<br>int F[1000];<br>int getF(int p){<br>  return F[p]==-1?p:F[p]=getF(F[p]);<br>}<br>bool merge(int a,int b){<br>  a=getF(a),b=getF(b);<br>  if(a!=b){<br>    F[a]=b;<br>    return true;<br>  }<br>  return false;<br>}<br>int color[1000],colors;<br>bool check(int p,int d,int h,vector&lt;int&gt; &amp;D){<br>  int cntToFather=0;<br>  int cntToBrother=0;<br>  int cntToSon=0;<br>  vector&lt;int&gt; sons;<br>  for(int i=0;i&lt;adj[p].size();i++){<br>    int q=adj[p][i];<br>    if(D[q]==D[p])<br>      cntToBrother++;<br>    if(D[q]==D[p]-1)<br>      cntToFather++;<br>    if(D[q]==D[p]+1)<br>      cntToSon++,sons.push_back(q);<br>  }<br>  if(D[p]!=0&amp;&amp;cntToFather!=1)<br>    return false;<br>  if(D[p]!=0&amp;&amp;cntToBrother!=2)<br>    return false;<br>  if(D[p]!=d&amp;&amp;cntToSon!=h)<br>    return false;<br>  if(D[p]==d&amp;&amp;cntToSon!=0)<br>    return false;<br>  if(D[p]!=d){<br>    for(int i=0;i&lt;sons.size();i++){<br>      if(color[sons[i]]!=-1)<br>        return false;<br>      color[sons[i]]=colors;<br>    }<br>    colors++;<br>  }<br>  for(int i=0;i&lt;sons.size();i++)<br>    if(!check(sons[i],d,h,D))<br>      return false;<br>  return true;<br>}<br>vector &lt;int&gt; FractalWheels::describeWheel(int N, vector &lt;string&gt; edges){<br>  ::N=N;<br>  string S=accumulate(edges.begin(),edges.end(),string());<br>  replace(S.begin(),S.end(),',',' ');<br>  istringstream ssin(S);<br>  vector&lt;pair&lt;int,int&gt; &gt; E;<br>  for(int a,b;ssin&gt;&gt;a&gt;&gt;b;E.push_back(make_pair(a,b)));<br>  if((N-1)*2!=E.size())<br>    return vector&lt;int&gt;();<br>  for(int i=0;i&lt;E.size();i++){<br>    adj[E[i].first].push_back(E[i].second);<br>    adj[E[i].second].push_back(E[i].first);<br>  }<br>  for(int c=0;c&lt;N;c++){<br>    vector&lt;int&gt; D(N,-1);<br>    D[c]=0;<br>    queue&lt;int&gt; Q;<br>    Q.push(c);<br>    int maxD=0;<br>    while(!Q.empty()){<br>      int p=Q.front();<br>      Q.pop();<br>      for(int i=0;i&lt;adj[p].size();i++){<br>        int q=adj[p][i];<br>        if(D[q]==-1){<br>          maxD=D[q]=D[p]+1;<br>          Q.push(q);<br>        }<br>      }<br>    }<br>    if(find(D.begin(),D.end(),-1)!=D.end())<br>      continue;<br>    vector&lt;int&gt; CNT(maxD+1);<br>    for(int i=0;i&lt;N;i++)<br>      CNT[D[i]]++;<br>    if(CNT[1]&lt;3)<br>      continue;<br>    int h=CNT[1];<br>    bool found=false;<br>    for(int i=2;i&lt;=maxD;i++)<br>      if(CNT[i]!=CNT[i-1]*h)<br>        found=true;<br>    if(found)<br>      continue;<br>    colors=0;<br>    memset(color,-1,sizeof(color));<br>    if(!check(c,maxD,h,D))<br>      continue;<br>    memset(F,-1,sizeof(F));<br>    vector&lt;vector&lt;pair&lt;int,int&gt; &gt; &gt; coloredEdges(colors);<br>    for(int i=0;i&lt;N;i++)<br>      for(int j=0;j&lt;adj[i].size();j++){<br>        int k=adj[i][j];<br>        if(color[i]==color[k]&amp;&amp;i&lt;k)<br>          coloredEdges[color[i]].push_back(make_pair(i,k));<br>      }<br>    for(int i=0;i&lt;colors;i++)<br>      if(coloredEdges[i].size()!=h)<br>        found=true;<br>    if(found)<br>      continue;<br>    for(int i=0;i&lt;colors;i++){<br>      int comps=h;<br>      for(int j=0;j&lt;h;j++)if(merge(coloredEdges[i][j].first,coloredEdges[i][j].second))<br>        comps--;<br>      if(comps!=1)<br>        found=true;<br>    }<br>    if(found)<br>      continue;<br>    vector&lt;int&gt; ret;<br>    ret.push_back(maxD-1);<br>    ret.push_back(h);<br>    return ret;<br>  }<br>  return vector&lt;int&gt;();<br>}<br><br><br>// Powered by FileEdit<br></td>