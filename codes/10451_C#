<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br><br>struct Point : IEquatable&lt;Point&gt;<br>{<br>    public int X; public int Y;<br>    public Point(int x, int y) { X = x; Y = y; }<br>    public bool Equals(Point p) { return p.X == X &amp;&amp; p.Y == Y; }<br>    public override int GetHashCode() { return (int)(X * 3137 + Y); }<br>}<br><br>public class MazeMaker <br>{<br>  const int INF = 987654321;<br><br>  public int longestPath(string[] maze, int startRow, int startCol, int[] moveRow, int[] moveCol) <br>  {<br>        Point start = new Point(startRow, startCol);<br>        Dictionary&lt;Point, int&gt; f = new Dictionary&lt;Point, int&gt;();<br>        f[start] = 0;<br>        Queue&lt;Point&gt; q = new Queue&lt;Point&gt;();<br>        q.Enqueue(start);<br>        int m = maze.Length;<br>        int n = maze[0].Length;<br>        while (q.Count &gt; 0)<br>        {<br>            Point p = q.Dequeue();<br>            int cost = f[p];<br><br>            for (int i = 0; i &lt; moveRow.Length; i++)<br>            {<br>                int u = p.X + moveRow[i];<br>                int v = p.Y + moveCol[i];<br>                if (u &gt;= 0 &amp;&amp; v &gt;= 0 &amp;&amp; u &lt; m &amp;&amp; v &lt; n &amp;&amp; maze[u][v] != 'X')<br>                {<br>                    Point next = new Point(u, v);<br>                    if (!f.ContainsKey(next) || f[next] &gt; cost + 1)<br>                    {<br>                        //if (next.Equals(end)) return cost + 1;<br>                        f[next] = cost + 1;<br>                        q.Enqueue(next);<br>                    }<br>                }<br>            }<br>        }<br><br>        int res = 0;<br>        for (int i = 0; i &lt; m; i++)<br>        {<br>            for (int j = 0; j &lt; n; j++)<br>            {<br>                if (maze[i][j] == '.')<br>                {<br>                    Point p = new Point(i, j);<br>                    if (!f.ContainsKey(p))<br>                    {<br>                        return -1;<br>                    }<br>                    res = Math.Max(res, f[p]);<br>                }<br>            }<br>        }<br><br>        return res;<br>  }<br><br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>