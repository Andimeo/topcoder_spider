<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class CubePainting {<br>  public int count(string[] cube) {<br>        int[, ,] id = new int[7, 7, 7];<br>        int k = 0;<br>        int[][] where = new int[54][];<br>        int[] faceId = new int[54];<br>        bool[,] adj = new bool[54, 54];<br>        for (int i = 0; i &lt; 3; ++i)<br>        {<br>            for (int j = -1; j &lt;= 1; j += 2)<br>            {<br>                int[] face = new int[3];<br>                face[i] = j;<br>                int[] d1 = new int[3];<br>                d1[(i + 1) % 3] = 1;<br>                int[] d2 = new int[3];<br>                d2[(i + 2) % 3] = 1;<br>                for (int x = -1; x &lt;= 1; ++x)<br>                    for (int y = -1; y &lt;= 1; ++y)<br>                    {<br>                        where[k] = add(mul(3, face), add(mul(2 * x, d1), mul(2 * y, d2)));<br>                        id[where[k][0] + 3, where[k][1] + 3, where[k][2] + 3] = k;<br>                        faceId[k] = i;<br>                        ++k;<br>                    }<br>            }<br>        }<br>        if (k != 54)<br>            throw new Exception();<br>        for (int i = 0; i &lt; 3; ++i)<br>        {<br>            for (int j = -1; j &lt;= 1; j += 2)<br>            {<br>                int[] face = new int[3];<br>                face[i] = j;<br>                int[] d1 = new int[3];<br>                d1[(i + 1) % 3] = 1;<br>                int[] d2 = new int[3];<br>                d2[(i + 2) % 3] = 1;<br>                for (int x = -1; x &lt;= 1; ++x)<br>                    for (int y = -1; y &lt;= 1; ++y)<br>                    {<br>                        int[] pos = add(mul(3, face), add(mul(2 * x, d1), mul(2 * y, d2)));<br>                        setAdj(adj, id, pos, doMove(pos, face, d1));<br>                        setAdj(adj, id, pos, doMove(pos, face, d2));<br>                        setAdj(adj, id, pos, doMove(pos, face, mul(-1, d1)));<br>                        setAdj(adj, id, pos, doMove(pos, face, mul(-1, d2)));<br>                    }<br>            }<br>        }<br>        int[] nadj = new int[54];<br>        int[] nfadj = new int[54];<br>        int[] seq = new int[54];<br>        bool[] used = new bool[54];<br>        int[,] stateA = new int[54, 100];<br>        int[,] stateB = new int[54, 100];<br>        int[, ,] stateWhere = new int[54, 54, 54];<br>        for (int i = 0; i &lt; 54; ++i)<br>            for (int j = 0; j &lt; 54; ++j)<br>                for (int kk = 0; kk &lt; 54; ++kk)<br>                    stateWhere[i, j, kk] = -1;<br>        int[] stateSize = new int[54];<br>        int[,] adjId = new int[54, 4];<br>        for (int i = 0; i &lt; 54; ++i) {<br>            k = 0;<br>            for (int j = 0; j &lt; 54; ++j) {<br>                if (adj[i, j])<br>                    adjId[i, k++] = j;<br>            }<br>        }<br>        for (int i = 0; i &lt; 54; ++i)<br>        {<br>            int bj = -1;<br>            for (int j = 0; j &lt; 54; ++j)<br>            {<br>                if (!used[j])<br>                {<br>                    if (bj &lt; 0 || nadj[j] &gt; nadj[bj] || nadj[j] == nadj[bj] &amp;&amp; nfadj[j] &gt; nfadj[bj])<br>                    {<br>                        bj = j;<br>                    }<br>                }<br>            }<br>            seq[i] = bj;<br>            used[bj] = true;<br>            for (int j = 0; j &lt; 54; ++j)<br>                if (adj[bj, j])<br>                {<br>                    ++nadj[j];<br>                    if (faceId[bj] == faceId[j])<br>                        ++nfadj[j];<br>                }<br>            stateSize[i] = 0;<br>            for (int j = 0; j &lt; 54; ++j)<br>                if (used[j])<br>                    for (int jj = 0; jj &lt; 54; ++jj)<br>                        if (!used[jj])<br>                            if (adj[j, jj])<br>                            {<br>                                stateA[i, stateSize[i]] = j;<br>                                stateB[i, stateSize[i]] = jj;<br>                                stateWhere[i, j, jj] = stateSize[i];<br>                                ++stateSize[i];<br>                            }<br>        }<br>        int[] am = new int[] { 1 };<br>        bool[] dead = new bool[54];<br>        processFace(dead, cube, id, 0, 0, new int[] { 0, 0, 1 }, new int[] { 1, 0, 0 }, new int[] { 0, -1, 0 });<br>        processFace(dead, cube, id, 3, 0, new int[] { 0, -1, 0 }, new int[] { 1, 0, 0 }, new int[] { 0, 0, -1 });<br>        processFace(dead, cube, id, 3, 3, new int[] { 1, 0, 0 }, new int[] { 0, 1, 0 }, new int[] { 0, 0, -1 });<br>        processFace(dead, cube, id, 3, 6, new int[] { 0, 1, 0 }, new int[] { -1, 0, 0 }, new int[] { 0, 0, -1 });<br>        processFace(dead, cube, id, 3, 9, new int[] { -1, 0, 0 }, new int[] { 0, -1, 0 }, new int[] { 0, 0, -1 });<br>        processFace(dead, cube, id, 6, 0, new int[] { 0, 0, -1 }, new int[] { 1, 0, 0 }, new int[] { 0, 1, 0 });<br>        used = new bool[54];<br>        for (int i = 0; i &lt; 54; ++i)<br>        {<br>            int[] nam = new int[1 &lt;&lt; stateSize[i]];<br>            int needCnt = dead[seq[i]] ? 0 : 2;<br>            for (int prevSet = 0; prevSet &lt; am.Length; ++prevSet)<br>                if (am[prevSet] != 0)<br>                {<br>                    for (int edgeSet = 0; edgeSet &lt; 16; ++edgeSet)<br>                    {<br>                        int cnt = 0;<br>                        for (int j = 0; j &lt; 4; ++j)<br>                            if ((edgeSet &amp; (1 &lt;&lt; j)) != 0)<br>                                ++cnt;<br>                        if (cnt == needCnt)<br>                        {<br>                            int nextSet = 0;<br>                            bool ok = true;<br>                            for (int j = 0; j &lt; 4; ++j)<br>                            {<br>                                int a = seq[i];<br>                                int b = adjId[a, j];<br>                                if (used[b])<br>                                {<br>                                    int twhere = stateWhere[i - 1, b, a];<br>                                    if (twhere &lt; 0)<br>                                        throw new Exception();<br>                                    if ((prevSet &amp; (1 &lt;&lt; twhere)) &gt; 0 ^ (edgeSet &amp; (1 &lt;&lt; j)) &gt; 0)<br>                                    {<br>                                        ok = false;<br>                                        break;<br>                                    }<br>                                }<br>                                int nwhere = stateWhere[i, a, b];<br>                                if (nwhere &gt;= 0 &amp;&amp; (edgeSet &amp; (1 &lt;&lt; j)) &gt; 0)<br>                                    nextSet += (1 &lt;&lt; nwhere);<br>                            }<br>                            if (i &gt; 0) {<br>                                for (int j = 0; j &lt; stateSize[i - 1]; ++j)<br>                                {<br>                                    int twhere = stateWhere[i, stateA[i - 1, j], stateB[i - 1, j]];<br>                                    if (twhere &gt;= 0 &amp;&amp; (prevSet &amp; (1 &lt;&lt; j)) &gt; 0)<br>                                        nextSet += (1 &lt;&lt; twhere);<br>                                }<br>                            }<br>                            if (ok)<br>                            {<br>                                nam[nextSet] = (nam[nextSet] + am[prevSet]) % 1000000007;<br>                            }<br>                        }<br>                    }<br>                }<br>            am = nam;<br>            used[seq[i]] = true;<br>        }<br><br>        return am[0];<br>  }<br><br>    private void processFace(bool[] dead, string[] cube, int[, ,] id, int srow, int scol, int[] face, int[] dcol, int[] drow)<br>    {<br>        for (int r = 0; r &lt; 3; ++r)<br>            for (int c = 0; c &lt; 3; ++c)<br>                if (cube[srow + r][scol + c] == '*')<br>                {<br>                    int[] pos = add(mul(3, face), add(mul(2 * (r - 1), drow), mul(2 * (c - 1), dcol)));<br>                    dead[id[pos[0] + 3, pos[1] + 3, pos[2] + 3]] = true;<br>                }<br>    }<br><br>    private void setAdj(bool[,] adj, int[, ,] id, int[] p1, int[] p2)<br>    {<br>        adj[id[p1[0] + 3, p1[1] + 3, p1[2] + 3], id[p2[0] + 3, p2[1] + 3, p2[2] + 3]] = true;<br>        adj[id[p2[0] + 3, p2[1] + 3, p2[2] + 3], id[p1[0] + 3, p1[1] + 3, p1[2] + 3]] = true;<br>    }<br><br>    private int[] doMove(int[] pos, int[] face, int[] dir)<br>    {<br>        pos = add(pos, mul(2, dir));<br>        bool ok = true;<br>        for (int i = 0; i &lt; 3; ++i)<br>        {<br>            if (Math.Abs(pos[i]) &gt; 3)<br>                ok = false;<br>        }<br>        if (!ok)<br>        {<br>            pos = add(pos, add(mul(-1, dir), mul(-1, face)));<br>        }<br>        return pos;<br>    }<br><br>    private int[] mul(int p, int[] a)<br>    {<br>        int[] res = new int[3];<br>        for (int i = 0; i &lt; 3; ++i)<br>            res[i] = a[i] * p;<br>        return res;<br>    }<br><br>    private int[] add(int[] a, int[] b)<br>    {<br>        int[] res = new int[3];<br>        for (int i = 0; i &lt; 3; ++i)<br>        {<br>            res[i] = a[i] + b[i];<br>        }<br>        return res;<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>