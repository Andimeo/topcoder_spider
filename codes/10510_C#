<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class TheEncryptionDivOne {<br>    const int MOD = 1234567891;<br><br>    class State<br>    {<br>        public int[,] am = new int[3, 3];<br><br>        public State()<br>        {<br>        }<br>        <br>        public State(State old)<br>        {<br>            for (int a = 0; a &lt; 3; ++a)<br>                for (int b = 0; b &lt; 3; ++b)<br>                    am[a, b] = old.am[a, b];<br>        }<br><br>        public override bool Equals(object obj)<br>        {<br>            State s = (State) obj;<br>            for (int a = 0; a &lt; 3; ++a)<br>                for (int b = 0; b &lt; 3; ++b)<br>                    if (am[a, b] != s.am[a, b])<br>                        return false;<br>            return true;<br>        }<br><br>        public override int GetHashCode()<br>        {<br>            int z = 0;<br>            for (int a = 0; a &lt; 3; ++a)<br>                for (int b = 0; b &lt; 3; ++b)<br>                    z = unchecked(z * 31371 + am[a, b]);<br>            return z;<br>        }<br>    }<br><br>    Dictionary&lt;State, int&gt; cache;<br><br>    public int count(string msg, string encMsg)<br>    {<br>        cache = new Dictionary&lt;State, int&gt;();<br>        Dictionary&lt;char, char&gt; know = new Dictionary&lt;char, char&gt;();<br>        Dictionary&lt;char, char&gt; rknow = new Dictionary&lt;char, char&gt;();<br>        for (int i = 0; i &lt; msg.Length; ++i)<br>        {<br>            char a = msg[i];<br>            char b = encMsg[i];<br>            if (char.ToLower(a) == char.ToLower(b))<br>                return 0;<br>            if (know.ContainsKey(a) &amp;&amp; know[a] != b)<br>                return 0;<br>            if (rknow.ContainsKey(b) &amp;&amp; rknow[b] != a)<br>                return 0;<br>            know[a] = b;<br>            rknow[b] = a;<br>        }<br>        int[] amLeft = new int[26];<br>        int[] amRight = new int[26];<br>        for (int i = 0; i &lt; 26; ++i)<br>        {<br>            amLeft[i] = 2;<br>            amRight[i] = 2;<br>        }<br>        foreach (KeyValuePair&lt;char, char&gt; pair in know)<br>        {<br>            --amLeft[char.ToLower(pair.Key) - 'a'];<br>            --amRight[char.ToLower(pair.Value) - 'a'];<br>        }<br>        State start = new State();<br>        for (int i = 0; i &lt; amLeft.Length; ++i)<br>        {<br>            ++start.am[amLeft[i], amRight[i]];<br>        }<br>        return doit(start);<br>  }<br><br>    private int doit(State start)<br>    {<br>        int res;<br>        if (cache.TryGetValue(start, out res))<br>            return res;<br>        int sa;<br>        int sb = 0;<br>        for (sa = 1; sa &lt; 3; ++sa)<br>        {<br>            for (sb = 0; sb &lt; 3; ++sb)<br>                if (start.am[sa, sb] &gt; 0)<br>                {<br>                    break;<br>                }<br>            if (sb &lt; 3)<br>                break;<br>        }<br>        if (sa &gt;= 3)<br>            res = 1;<br>        else<br>        {<br>            res = 0;<br>            for (int a = 0; a &lt; 3; ++a)<br>                for (int b = 1; b &lt; 3; ++b)<br>                    if (start.am[a, b] &gt; 0)<br>                    {<br>                        int cnt = start.am[a, b];<br>                        if (sa == a &amp;&amp; sb == b)<br>                            --cnt;<br>                        cnt *= b;<br>                        if (cnt &gt; 0)<br>                        {<br>                            State next = new State(start);<br>                            --next.am[sa, sb];<br>                            --next.am[a, b];<br>                            ++next.am[sa - 1, sb];<br>                            ++next.am[a, b - 1];<br>                            long sum = (long)res + cnt * (long) doit(next);<br>                            sum %= MOD;<br>                            res = (int)sum;<br>                        }<br>                    }<br>        }<br>        cache[start] = res;<br>        return res;<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>