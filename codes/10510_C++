<td class="problemText" colspan="8" valign="middle" align="left">
            #define _CRT_SECURE_NO_DEPRECATE <br>#include &lt;iostream&gt; <br>#include &lt;memory&gt; <br>#include &lt;vector&gt; <br>#include &lt;algorithm&gt; <br>#include &lt;string&gt; <br>#include &lt;utility&gt; <br>#include &lt;functional&gt; <br>#include &lt;cstdio&gt; <br>#include &lt;cstdlib&gt; <br>#include &lt;cstring&gt; <br>#include &lt;cmath&gt; <br>#include &lt;cassert&gt; <br>#include &lt;sstream&gt; <br>#include &lt;map&gt;<br> <br>using namespace std;<br> <br> <br>int MOD = 1234567891;<br> <br>class TheEncryptionDivOne<br>{<br>public:<br>  int P1[52], P2[52];<br>  int C[26], D[26];<br>  map&lt;vector&lt;int&gt;, int&gt; Hash;<br>  int count(int E[3][3])<br>  {<br>    vector&lt;int&gt; State;<br>    for (int i = 0; i &lt; 3; i++)<br>      for (int j = 0; j &lt; 3; j++)<br>        State.push_back(E[i][j]);<br>    if (Hash.find(State) != Hash.end())<br>      return Hash[State];<br>    for (int i = 0; i &lt; 3; i++)<br>      for (int j = 0; j &lt; 3; j++)<br>        if (i &gt; 0 &amp;&amp; E[i][j] &gt; 0)<br>        {<br>          int Results = 0;<br>          for (int u = 0; u &lt; 3; u++)<br>            for (int v = 0; v &lt; 3; v++)<br>              if (v &gt; 0 &amp;&amp; E[u][v] &gt; 0)<br>              {<br>                int multiply = (i == u &amp;&amp; j == v) ? (E[u][v] - 1) : E[u][v];<br>                if (v == 2)<br>                  multiply *= 2;<br>                if (multiply == 0)<br>                  continue;<br>                E[i][j]--;<br>                E[i-1][j]++;<br>                E[u][v]--;<br>                E[u][v-1]++;<br>                int Temporary = count(E);<br>                Results = ((long long)Results + (long long)Temporary * multiply) % MOD;<br>                E[i][j]++;<br>                E[i-1][j]--;<br>                E[u][v]++;<br>                E[u][v-1]--;<br>              }<br>          return Hash[State] = Results;<br>        }<br>    return Hash[State] = 1;<br>  }<br>  int count(string S1, string S2)<br>  {<br>    int N = S1.length();<br>    for (int I = 0; I &lt; N; I++)<br>      if (tolower(S1[I]) == tolower(S2[I]))<br>        return 0;<br>    memset(P1, 255, sizeof(P1));<br>    memset(P2, 255, sizeof(P2));<br>    for (int I = 0; I &lt; N; I++)<br>    {<br>      int v1 = (S1[I]&lt;='Z')?(S1[I]-'A'):(26+S1[I]-'a');<br>      int v2 = (S2[I]&lt;='Z')?(S2[I]-'A'):(26+S2[I]-'a');<br>      if (P1[v1] &gt;= 0 &amp;&amp; P1[v1] != v2)<br>        return 0;<br>      if (P2[v2] &gt;= 0 &amp;&amp; P2[v2] != v1)<br>        return 0;<br>      P1[v1] = v2;<br>      P2[v2] = v1;<br>    }<br>    memset(C, 0, sizeof(C));<br>    memset(D, 0 ,sizeof(D));<br>    for (int I = 0; I &lt; 52; I++)<br>    {<br>      if (P1[I] &lt; 0)<br>        C[I % 26]++;<br>      if (P2[I] &lt; 0)<br>        D[I % 26]++;<br>    }<br>    Hash.clear();<br>    int E[3][3];<br>    memset(E, 0, sizeof(E));<br>    for (int I = 0; I &lt; 26; I++)<br>      E[C[I]][D[I]]++;<br>    int Results = count(E);<br>    return Results;<br>  }<br>};<br></td>