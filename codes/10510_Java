<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Set;<br>import java.util.HashSet;<br><br>public class TheEncryptionDivOne {<br>    private static final int MOD = 1234567891;<br>    private int fac(int n) {<br>        long ans = 1;<br>        for (int i = 1; i &lt;= n; ++i) {<br>            ans *= i;<br>            ans %= MOD;<br>        }<br>        return (int)ans;<br>    }<br><br>  public int count(String msg, String encMsg) {<br>        long ans = 0;<br>    int l = msg.length();<br>        for (int i = 0; i &lt; l; i++) {<br>            if (Character.toLowerCase(msg.charAt(i)) == Character.toLowerCase(encMsg.charAt(i)))<br>                return 0;<br>            for (int j = i + 1; j &lt; l; j++) {<br>                if (msg.charAt(i) == msg.charAt(j) &amp;&amp; encMsg.charAt(i) != encMsg.charAt(j))<br>                    return 0;<br>                if (msg.charAt(i) != msg.charAt(j) &amp;&amp; encMsg.charAt(i) == encMsg.charAt(j))<br>                    return 0;<br>            }<br>        }<br>        Set&lt;Character&gt; a = new HashSet&lt;Character&gt;();<br>        Set&lt;Character&gt; b = new HashSet&lt;Character&gt;();<br>        for (char c = 'a'; c &lt;= 'z'; c++) {<br>            a.add(c);<br>            b.add(c);<br>        }<br>        for (char c = 'A'; c &lt;= 'Z'; c++) {<br>            a.add(c);<br>            b.add(c);<br>        }<br>        for (char c : msg.toCharArray())<br>            a.remove(c);<br>        for (char c : encMsg.toCharArray())<br>            b.remove(c);<br>        int x = 0;<br>        for (char c = 'a'; c &lt;= 'z'; c++) {<br>            if (a.contains(c) &amp;&amp; a.contains(Character.toUpperCase(c)) &amp;&amp; b.contains(c) &amp;&amp; b.contains(Character.toUpperCase(c)))<br>                ++x;<br>        }<br>        int y = 0;<br>        for (char c = 'a'; c &lt;= 'z'; c++) {<br>            if (a.contains(c) &amp;&amp; a.contains(Character.toUpperCase(c)) &amp;&amp; (b.contains(c) ^ b.contains(Character.toUpperCase(c))))<br>                ++y;<br>            if ((a.contains(c) ^ a.contains(Character.toUpperCase(c))) &amp;&amp; (b.contains(c) &amp;&amp; b.contains(Character.toUpperCase(c))))<br>                ++y;<br>        }<br>        int z = 0;<br>        for (char c = 'a'; c &lt;= 'z'; c++) {<br>            if ((a.contains(c) ^ a.contains(Character.toUpperCase(c))) &amp;&amp; (b.contains(c) ^ b.contains(Character.toUpperCase(c))))<br>                ++z;<br>        }<br>        int n = a.size();<br>        ans = fac(n);<br>        for (int i = 1; ; i++) {<br>            long[] d = new long[i + 3];<br>            d[0] = 1;<br>            for (int j = 0; j &lt; x; j++) {<br>                for (int k = i; k &gt;= 0; k--) {<br>                    d[k + 2] = (d[k + 2] + 2 * d[k]) % MOD;<br>                    d[k + 1] = (d[k + 1] + 4 * d[k]) % MOD;<br>                }<br>            }<br>            for (int j = 0; j &lt; y; j++) {<br>                for (int k = i; k &gt;= 0; k--) {<br>                    d[k + 1] = (d[k + 1] + 2 * d[k]) % MOD;<br>                }<br>            }<br>            for (int j = 0; j &lt; z; j++) {<br>                for (int k = i; k &gt;= 0; k--) {<br>                    d[k + 1] = (d[k + 1] + d[k]) % MOD;<br>                }<br>            }<br>            if (d[i] == 0)<br>                break;<br>            long cur = (d[i] * fac(n - i)) % MOD;<br>            if (i % 2 == 1)<br>                ans = (ans - cur + MOD) % MOD;<br>            else<br>                ans = (ans + cur) % MOD;<br>        }<br>        return (int)ans;<br>  }<br><br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.12 [modified TZTester]<br>// Powered by CodeProcessor<br></td>