<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class StairsColoring {<br>    const long MOD = 1000000123;<br><br>  public int coloringCount(int N, int K) {<br>        long numStaircases = (getC(2 * N, N, MOD - 1) - getC(2 * N, N - 1, MOD - 1) + MOD - 1) % (MOD - 1);<br>        return (int) pow(K, numStaircases, MOD);<br>  }<br><br>    private long getC(long n, long k, long MOD)<br>    {<br>        List&lt;long&gt; primes = new List&lt;long&gt;();<br>        long t = MOD;<br>        for (long i = 2; i * i &lt;= t; ++i)<br>        {<br>            if (t % i == 0)<br>            {<br>                primes.Add(i);<br>                while (t % i == 0)<br>                    t /= i;<br>            }<br>        }<br>        if (t &gt; 1)<br>            primes.Add(t);<br>        long z = 1;<br>        long res = 0;<br>        foreach (long p in primes) {<br>            long curAns = getCPrime(n, k, p);<br>            long nres;<br>            chineseRestore(z, res, p, curAns, out nres);<br>            z *= p;<br>            res = nres;<br>        }<br>        return res;<br>    }<br><br>    private void chineseRestore(long n1, long r1, long n2, long r2, out long res)<br>    {<br>        long sn1 = n1;<br>        long sn2 = n2;<br>        long p1 = 1;<br>        long q1 = 0;<br>        long p2 = 0;<br>        long q2 = 1;<br>        while (n2 &gt; 0)<br>        {<br>            long q = n1 / n2;<br>            n1 = n1 - q * n2;<br>            p1 = p1 - q * p2;<br>            q1 = q1 - q * q2;<br>            if (p1 &gt; sn2)<br>            {<br>                long zz = p1 / sn2;<br>                p1 -= zz * sn2;<br>                q1 += zz * sn1;<br>            }<br>            if (q1 &gt; sn1)<br>            {<br>                long zz = q1 / sn1;<br>                q1 -= zz * sn1;<br>                p1 += zz * sn2;<br>            }<br>            {<br>                long t = n1;<br>                n1 = n2;<br>                n2 = t;<br>            }<br>            {<br>                long t = p1;<br>                p1 = p2;<br>                p2 = t;<br>            }<br>            {<br>                long t = q1;<br>                q1 = q2;<br>                q2 = t;<br>            }<br>        }<br>        if (n1 != 1)<br>            throw new Exception();<br>        n1 = sn1;<br>        n2 = sn2;<br>        long prod = n1 * n2;<br>        res = (((q1 * n2) % prod * r1 + (p1 * n1) % prod * r2) % prod + prod) % prod;<br>    }<br><br>    private long getCPrime(long _n, long _k, long p)<br>    {<br>        long res = 1;<br>        while (_n &gt; 0 || _k &gt; 0)<br>        {<br>            long n = _n % p;<br>            long k = _k % p;<br>            _n /= p;<br>            _k /= p;<br>            long f1 = 1;<br>            for (long i = n - k + 1; i &lt;= n; ++i)<br>                f1 = (f1 * i) % p;<br>            long f2 = 1;<br>            for (long i = 1; i &lt;= k; ++i)<br>                f2 = (f2 * i) % p;<br>            res = (res * ((f1 * pow(f2, p - 2, p)) % p)) % p;<br>        }<br>        return res;<br>    }<br><br>    private long pow(long a, long k, long MOD)<br>    {<br>        if (k == 0)<br>            return 1 % MOD;<br>        else if (k % 2 == 0)<br>            return pow((a * a) % MOD, k / 2, MOD);<br>        else<br>            return (a * pow(a, k - 1, MOD)) % MOD;<br>    }<br><br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>