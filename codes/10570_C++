<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br>#define REP(i,n) for(int _n=n, i=0;i&lt;_n;++i)<br>#define FOREACH(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)<br>typedef long long LL;<br>const LL INFLL = 1000000000000000000LL;<br>template&lt;class T&gt; inline int size(const T&amp;c) { return c.size(); }<br> <br>int C;<br>vector&lt;LL&gt; xs, ys;<br>vector&lt;vector&lt;LL&gt; &gt; wanted; // [0..2C-1] -&gt; list of y<br> <br>void pseudoRandom(vector&lt;LL&gt; &amp;v, int N, LL xzero, LL xprod, LL xadd, LL xmod) {<br>  v.resize(N);<br>  LL x = xzero;<br>  REP(i,N) {<br>    v[i] = x;<br>    x = (x * xprod + xadd) % xmod;<br>  }<br>}<br> <br>void fixYS() {<br>  REP(i, size(xs)) { ys[i] = 2*ys[i]+1-xs[i]; }<br>}<br> <br>inline int mod2C(LL x) {<br>  return (int(x%(2*C)) + 2*C) % (2*C);<br>}<br> <br>void calcWanted() {<br>  wanted.clear(); wanted.resize(2*C);<br>  REP(i,size(xs)) {<br>    LL x = xs[i], y = ys[i];<br>    int x1 = mod2C(x);<br>    wanted[x1].push_back(y - (x-x1));<br>  }<br>}<br> <br>inline LL myabs(LL x) { return x&gt;=0 ? x : -x; }<br> <br>LL calcDiffs(int a, LL val) {<br>  LL res = 0;<br>  FOREACH(it, wanted[a]) res += myabs(val - *it);<br>  return res;<br>}<br> <br>LL match(int a,int b,LL val) {<br>  LL res = calcDiffs(a, val);<br>  LL val2 = a + 2*C - (val-b);<br>  res += calcDiffs(b, val2);<br>  return res;<br>}<br> <br>LL cacheMatch[32][32];<br>LL matchPair(int a, int b) { // a,b &lt;= 2*C<br>  LL &amp;res = cacheMatch[a][b];<br>  if(res != -1) return res;<br>  LL v = b;<br>  LL step = LL(2*C) &lt;&lt; 32;<br>  res = match(a,b,v);<br>  while(step &gt;= 2*C) {<br>    for(;;) {<br>      LL newval = match(a,b,v+step);<br>      if(newval &lt; res) { res = newval; v += step; }<br>      else break;<br>    }<br>    for(;;) {<br>      LL newval = match(a,b,v-step);<br>      if(newval &lt; res) { res = newval; v -= step; }<br>      else break;<br>    }<br>    step &gt;&gt;= 1;<br>  }<br>  //fprintf(stderr, "mp(%d,%d)=%lld\n", a, b, res);<br>  return res;<br>}<br> <br>LL cacheCalc[1&lt;&lt;16];<br> <br>LL calc(int done, int ss) {<br>  LL &amp;res = cacheCalc[ss];<br>  if(res != -1) return res;<br>  if(done == C) res = 0;<br>  else {<br>    res = INFLL;<br>    REP(i,C) if((ss&amp;(1&lt;&lt;i))==0) {<br>      res = min(res, matchPair(2*done, 2*i+1) + calc(done+1, ss^(1&lt;&lt;i)));<br>    }<br>  }<br>  return res;<br>}<br> <br>struct FunctionalEquation {<br>long long minAbsSum(int C1, int N, int xzero, int xprod, int xadd, int xmod, int yzero, int yprod, int yadd, int ymod) {<br>  C = C1;<br>  pseudoRandom(xs, N, xzero, xprod, xadd, xmod);<br>  pseudoRandom(ys, N, yzero, yprod, yadd, ymod);<br>  fixYS();<br>  calcWanted();<br>  memset(cacheCalc, -1, sizeof(cacheCalc));<br>  memset(cacheMatch, -1, sizeof(cacheMatch));<br>  return calc(0,0)/2;<br>}<br> <br>};<br> <br>// Powered by FileEdit<br> <br>// Powered by TomekAI<br>// Powered by TZTester 1.01 [25-Feb-2003]<br> <br>// Powered by CodeProcessor<br></td>