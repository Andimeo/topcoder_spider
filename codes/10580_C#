<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br><br>class PeopleYouMayKnow<br>{<br>    public class MaxFlowProblem<br>    {<br>        public int n;<br>        public int[,] capacity;<br>        public int[,] flow;<br><br>        public MaxFlowProblem(int n)<br>        {<br>            this.n = n;<br>            capacity = new int[n, n];<br>        }<br><br>        public void AddEdge(int from, int to, int cap)<br>        {<br>            capacity[from, to] = cap;<br>        }<br><br>        public int Solve()<br>        {<br>            flow = new int[n, n];<br>            int[] parent = new int[n];<br>            int[] cap = new int[n];<br>            int maxflow = 0;<br>            for (; ; )<br>            {<br>                for (int i = 0; i &lt; n; i++)<br>                    parent[i] = -1;<br>                parent[0] = -2;<br>                cap[0] = int.MaxValue;<br>                Queue&lt;int&gt; Q = new Queue&lt;int&gt;();<br>                Q.Enqueue(0);<br>                while (Q.Count &gt; 0 &amp;&amp; parent[n - 1] == -1)<br>                {<br>                    int open = Q.Dequeue();<br>                    for (int i = 0; i &lt; n; ++i)<br>                    {<br>                        if (parent[i] == -1 &amp;&amp; capacity[open, i] &gt; flow[open, i])<br>                        {<br>                            parent[i] = open;<br>                            cap[i] = Math.Min(cap[open], capacity[open, i] - flow[open, i]);<br>                            Q.Enqueue(i);<br>                        }<br>                    }<br>                }<br><br>                if (parent[n - 1] == -1)<br>                    return maxflow;<br>                int j = n - 1;<br>                while (j != 0)<br>                {<br>                    flow[parent[j], j] += cap[n - 1];<br>                    flow[j, parent[j]] -= cap[n - 1];<br>                    j = parent[j];<br>                }<br>                maxflow += cap[n - 1];<br>            }<br>        }<br>    }<br>    public int maximalScore(string[] friends, int person1, int person2)<br>    {<br>        int n = friends.Length;<br>        List&lt;int&gt; s1 = new List&lt;int&gt;();<br>        List&lt;int&gt; s2 = new List&lt;int&gt;();<br>        int result = 0;<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            if (friends[person1][i] == 'Y' &amp;&amp; friends[person2][i] == 'Y')<br>                ++result;<br>            else if (friends[person1][i] == 'Y')<br>                s1.Add(i);<br>            else if (friends[person2][i] == 'Y')<br>                s2.Add(i);<br>        }<br><br>        MaxFlowProblem flow = new MaxFlowProblem(s1.Count + s2.Count + 2);<br>        for (int i = 0; i &lt; s1.Count; ++i)<br>            flow.AddEdge(0, i + 1, 1);<br>        for (int i = 0; i &lt; s2.Count; ++i)<br>            flow.AddEdge(i + s1.Count + 1, s1.Count + s2.Count + 1, 1);<br>        for (int i = 0; i &lt; s1.Count; ++i)<br>            for (int j = 0; j &lt; s2.Count; ++j)<br>                if (friends[s1[i]][s2[j]] == 'Y')<br>                    flow.AddEdge(i + 1, j + s1.Count + 1, 1);<br>        return result + flow.Solve();<br>    }<br>}<br></td>