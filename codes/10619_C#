<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class TheCardLineDivOne {<br>    string ranks = "23456789TJQKA";<br>    string suits = "SCDH";<br>    int MODULO = 1234567891;<br><br>    public int count(string[] cards)<br>    {<br>        int[,] am = new int[3, 3];<br>        for (int i = 0; i &lt; ranks.Length; ++i)<br>        {<br>            int a = 0;<br>            int b = 0;<br>            foreach (string c in cards)<br>                if (ranks.IndexOf(c[0]) == i)<br>                {<br>                    if (suits.IndexOf(c[1]) &lt; 2)<br>                        ++a;<br>                    else<br>                        ++b;<br>                }<br>            ++am[a, b];<br>        }<br>        Dictionary&lt;long, int[,,]&gt; cache = new Dictionary&lt;long, int[,,]&gt;();<br>        long res = 0;<br>        for (int a = 0; a &lt; 3; ++a)<br>            for (int b = 0; b &lt; 3; ++b)<br>                if (am[a, b] &gt; 0)<br>                {<br>                    if (b &gt; 0)<br>                    {<br>                        --am[a, b];<br>                        ++am[a, b - 1];<br>                        res += get(am, a, b - 1, 1, cache) * (am[a, b] + 1) * b;<br>                        res %= MODULO;<br>                        ++am[a, b];<br>                        --am[a, b - 1];<br>                    }<br>                    if (a &gt; 0)<br>                    {<br>                        --am[a, b];<br>                        ++am[a - 1, b];<br>                        res += get(am, a - 1, b, 0, cache) * (am[a, b] + 1) * a;<br>                        res %= MODULO;<br>                        ++am[a, b];<br>                        --am[a - 1, b];<br>                    }<br>                }<br>        return (int)res;<br>  }<br><br>    private long get(int[,] am, int lastA, int lastB, int lastColor, Dictionary&lt;long, int[,,]&gt; cache)<br>    {<br>        if (am[0, 0] == ranks.Length)<br>            return 1;<br>        long state = 0;<br>        for (int a = 0; a &lt; 3; ++a)<br>            for (int b = 0; b &lt; 3; ++b)<br>                state += (long) am[a, b] &lt;&lt; (a * 12 + b * 4);<br>        int[, ,] z;<br>        if (!cache.ContainsKey(state))<br>        {<br>            z = new int[3, 3, 2];<br>            for (int a = 0; a &lt; 3; ++a)<br>                for (int b = 0; b &lt; 3; ++b)<br>                    for (int c = 0; c &lt; 2; ++c)<br>                        z[a, b, c] = -1;<br>            cache[state] = z;<br>        }<br>        else<br>        {<br>            z = cache[state];<br>        }<br>        if (z[lastA, lastB, lastColor] &gt;= 0)<br>            return z[lastA, lastB, lastColor];<br>        long res = 0;<br>        // Same rank but different color<br>        if (lastB &gt; 0 &amp;&amp; lastColor == 0)<br>        {<br>            int a = lastA;<br>            int b = lastB;<br>            --am[a, b];<br>            ++am[a, b - 1];<br>            res += get(am, a, b - 1, 1, cache) * b;<br>            res %= MODULO;<br>            ++am[a, b];<br>            --am[a, b - 1];<br>        }<br>        if (lastA &gt; 0 &amp;&amp; lastColor == 1)<br>        {<br>            int a = lastA;<br>            int b = lastB;<br>            --am[a, b];<br>            ++am[a - 1, b];<br>            res += get(am, a - 1, b, 0, cache) * a;<br>            res %= MODULO;<br>            ++am[a, b];<br>            --am[a - 1, b];<br>        }<br>        // Same color<br>        for (int sa = 0; sa &lt; 3; ++sa)<br>            for (int sb = 0; sb &lt; 3; ++sb)<br>            {<br>                if (am[sa, sb] == 0)<br>                    continue;<br>                int a = sa;<br>                int b = sb;<br>                int mul;<br>                if (lastColor == 0) {<br>                    mul = a;<br>                    --a;<br>                } else {<br>                    mul = b;<br>                    --b;<br>                }<br>                if (a &lt; 0 || b &lt; 0)<br>                    continue;<br>                --am[sa, sb];<br>                ++am[a, b];<br>                res += get(am, a, b, lastColor, cache) * (am[sa, sb] + 1) * mul;<br>                res %= MODULO;<br>                --am[a, b];<br>                ++am[sa, sb];<br>            }<br>        z[lastA, lastB, lastColor] = (int)res;<br>        return res;<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>