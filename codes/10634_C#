<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class PizzaDelivery {<br>  public int deliverAll(string[] terrain) {<br>        int xi = 0, xj = 0;<br>        int n = terrain.Length;<br>        int m = terrain[0].Length;<br>        int cp = 0;<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            for (int j = 0; j &lt; m; j++)<br>            {<br>                if (terrain[i][j] == 'X')<br>                {<br>                    xi = i;<br>                    xj = j;<br>                } else if (terrain[i][j] == '$') {<br>                    cp++;<br>                }<br>            }<br>        }<br>        int ci = xi;<br>        int cj = xj;<br>        int[] di = new int[4] {0, 0, 1, -1};<br>        int[] dj = new int[4] {1, -1, 0, 0};<br>        bool[,] used = new bool[n, m];<br>        int[,] dist = new int[n, m];<br>        int inf = 1000000;<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            for (int j = 0; j &lt; m; j++)<br>            {<br>                dist[i, j] = inf;<br>            }<br>        }<br>        dist[ci, cj] = 0;<br>        while (true)<br>        {<br>            used[ci, cj] = true;<br>            for (int k = 0; k &lt; 4; k++)<br>            {<br>                int ni = ci + di[k];<br>                int nj = cj + dj[k];<br>                if (ni &gt;= 0 &amp;&amp; nj &gt;= 0 &amp;&amp; ni &lt; n &amp;&amp; nj &lt; m)<br>                {<br>                    if (!used[ni, nj])<br>                    {<br>                        if (terrain[ni][nj] != '$' &amp;&amp; terrain[ci][cj] != '$' &amp;&amp; terrain[ni][nj] != 'X' &amp;&amp; terrain[ci][cj] != 'X')<br>                        {<br>                            int v1 = terrain[ni][nj] - '0';<br>                            int v2 = terrain[ci][cj] - '0';<br>                            int d = Math.Abs(v1 - v2);<br>                            if (d == 0)<br>                            {<br>                                if (dist[ni, nj] &gt; dist[ci, cj] + 1)<br>                                {<br>                                    dist[ni, nj] = dist[ci, cj] + 1;<br>                                }<br>                            }<br>                            else if (d == 1)<br>                            {<br>                                if (dist[ni, nj] &gt; dist[ci, cj] + 3)<br>                                {<br>                                    dist[ni, nj] = dist[ci, cj] + 3;<br>                                }<br>                            }<br>                            else<br>                            {<br><br>                            }<br>                        }<br>                        else<br>                        {<br>                            if (dist[ni, nj] &gt; dist[ci, cj] + 2)<br>                            {<br>                                dist[ni, nj] = dist[ci, cj] + 2;<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br>            bool found = false;<br>            for (int i = 0; i &lt; n; i++)<br>            {<br>                for (int j = 0; j &lt; m; j++)<br>                {<br>                    if (!used[i, j])<br>                    {<br>                        if (!found)<br>                        {<br>                            found = true;<br>                            ci = i;<br>                            cj = j;<br>                        }<br>                        else<br>                        {<br>                            if (dist[i, j] &lt; dist[ci, cj])<br>                            {<br>                                ci = i;<br>                                cj = j;<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br>            if (!found)<br>            {<br>                break;<br>            }<br>        }<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            for (int j = 0; j &lt; m; j++)<br>            {<br>                if (terrain[i][j] == '$' &amp;&amp; dist[i, j] == inf)<br>                {<br>                    return -1;<br>                }<br>            }<br>        }<br>        int[] distances = new int[cp];<br>        int cc = 0;<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            for (int j = 0; j &lt; m; j++)<br>            {<br>                if (terrain[i][j] == '$') {<br>                    distances[cc] = dist[i, j];<br>                    cc++;<br>                }<br>            }<br>        }<br>        Array.Sort(distances);<br>        int pp = 1 &lt;&lt; cp;<br>        int best = -1;<br>        for (int i = 0; i &lt; pp; i++)<br>        {<br>            int first = 0;<br>            int second = 0;<br>            int last_first = 0;<br>            int last_second = 0;<br>            for (int k = 0; k &lt; cp; k++)<br>            {<br>                if ((i &amp; (1 &lt;&lt; k)) != 0)<br>                {<br>                    first += 2 * distances[k];<br>                    last_first = distances[k];<br>                }<br>                else<br>                {<br>                    second += 2 * distances[k];<br>                    last_second = distances[k];<br>                }<br>            }<br>            first -= last_first;<br>            second -= last_second;<br>            if (best == -1) best = Math.Max(first, second);<br>            else<br>            {<br>                best = Math.Min(best, Math.Max(first, second));<br>            }<br>        }<br>        return best;<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>