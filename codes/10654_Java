<td class="problemText" colspan="8" valign="middle" align="left">
            import static java.lang.Math.*;<br>import static java.math.BigInteger.*;<br>import static java.util.Arrays.*;<br>import static java.util.Collections.*;<br>import java.math.*;<br>import java.util.*;<br><br>public class TransportationNetwork {<br>  public double minCost(int[] cityX, int[] cityY, double roadCost, double airportCost) {<br>    int n = cityX.length;<br>    List&lt;E&gt; es = new ArrayList&lt;E&gt;();<br>    for (int i = 0; i &lt; n; i++) {<br>      for (int j = 0; j &lt; i; j++) {<br>        es.add(new E(i, j, dis(cityX[i] - cityX[j], cityY[i] - cityY[j]) * roadCost));<br>      }<br>    }<br>    Collections.sort(es);<br>    UnionFind uf = new UnionFind(n);<br>    int num = n;<br>    double min = n * airportCost;<br>    double cost = 0;<br>    for (E e : es) {<br>      if (!uf.same(e.v, e.u)) {<br>        cost += e.cost;<br>        uf.union(e.v, e.u);<br>        num--;<br>        min = min(min, cost + num * airportCost);<br>      }<br>    }<br>    min = min(min, cost);<br>    return min;<br>  }<br>  double dis(double x, double y) {<br>    return sqrt(x * x + y * y);<br>  }<br>  class E implements Comparable&lt;E&gt; {<br>    int u, v;<br>    double cost;<br>    E(int u, int v, double cost) {<br>      this.u = u;<br>      this.v = v;<br>      this.cost = cost;<br>    }<br>    public int compareTo(E o) {<br>      return Double.compare(cost, o.cost);<br>    }<br>  }<br>  class UnionFind {<br>    int[] ps, num;<br>    UnionFind(int size) {<br>      ps = new int[size];<br>      num = new int[size];<br>      for (int i = 0; i &lt; size; i++) {<br>        ps[i] = i;<br>        num[i] = 1;<br>      }<br>    }<br>    void union(int x, int y) {<br>      x = find(x); y = find(y);<br>      if (x == y) return;<br>      if (num[x] &lt; num[y]) {<br>        int t = x; x = y; y = t;<br>      }<br>      ps[y] = x;<br>      num[x] += num[y];<br>    }<br>    int find(int x) {<br>      if (x != ps[x]) ps[x] = find(ps[x]);<br>      return ps[x];<br>    }<br>    boolean same(int x, int y) {<br>      return find(x) == find(y);<br>    }<br>  }<br>  void debug(Object...os) {<br>    System.err.println(deepToString(os));<br>  }<br>}<br></td>