<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br><br>using namespace std;<br><br>#define SIZE(X) ((int)(X.size()))<br>#define LENGTH(X) ((int)(X.length()))<br>typedef long long int64;<br>template&lt;class T&gt; inline void checkmin(T &amp;a,T b){if(b&lt;a) a=b;}<br><br>const int64 oo=1000000000LL*1000000000LL;<br><br>class LongJourney<br>{<br>public:<br>  int64 G[60][60];<br>  int n;<br>  int64 p[60];<br>  int64 SD[60],D[60][60];<br>  int64 L;<br>  int64 F[60][60];<br>  bool visited[60][60];<br>  int64 minimumCost(vector &lt;int&gt; _p, int _L, vector &lt;string&gt; roads)<br>  {<br>    n=SIZE(_p);<br>    for (int i=0;i&lt;n;i++)<br>      p[i]=_p[i];<br>    L=_L;<br>    string str="";<br>    for (int i=0;i&lt;SIZE(roads);i++)<br>      str+=roads[i];<br>    for (int i=0;i&lt;LENGTH(str);i++)<br>      if (str[i]==',')<br>        str[i]=' ';<br>    istringstream sin(str);<br>    for (int i=0;i&lt;n;i++)<br>      for (int j=0;j&lt;n;j++)<br>        G[i][j]=oo;<br>    for (int i=0;i&lt;n;i++)<br>      G[i][i]=0;<br>    for (int u,v,w;sin&gt;&gt;u&gt;&gt;v&gt;&gt;w;)<br>      G[u][v]=G[v][u]=w;<br>    for (int k=0;k&lt;n;k++)<br>      for (int i=0;i&lt;n;i++)<br>        for (int j=0;j&lt;n;j++)<br>          checkmin(G[i][j],G[i][k]+G[k][j]);<br>    for (int i=0;i&lt;n;i++)<br>    {<br>      SD[i]=0;<br>      D[i][SD[i]++]=0;<br>      D[i][SD[i]++]=L;<br>      for (int j=0;j&lt;n;j++)<br>        if (G[i][j]&gt;0 &amp;&amp; G[i][j]&lt;L)<br>          D[i][SD[i]++]=G[i][j];<br>    }<br>    for (int i=0;i&lt;n;i++)<br>      for (int j=0;j&lt;SD[i];j++)<br>        F[i][j]=oo;<br>    memset(visited,false,sizeof(visited));<br>    F[0][0]=0;<br>    while (1)<br>    {<br>      int64 min_dist=oo;<br>      int x=-1,y=-1;<br>      for (int i=0;i&lt;n;i++)<br>        for (int j=0;j&lt;SD[i];j++)<br>          if (!visited[i][j] &amp;&amp; F[i][j]&lt;min_dist)<br>          {<br>            min_dist=F[i][j];<br>            x=i;<br>            y=j;<br>          }<br>      if (min_dist&gt;=oo)<br>        break;<br>      visited[x][y]=true;<br>      for (int x2=0;x2&lt;n;x2++) if (D[x][y]&gt;=G[x][x2])<br>        for (int y2=0;y2&lt;SD[x2];y2++) if (!visited[x2][y2])<br>          if (D[x2][y2]&gt;=D[x][y]-G[x][x2])<br>            checkmin(F[x2][y2],F[x][y]+(D[x2][y2]-D[x][y]+G[x][x2])*p[x2]);<br>    }<br>    int64 result=F[1][0];<br>    if (result&gt;=oo)<br>      return -1;<br>    return result;<br>  }<br>};<br></td>