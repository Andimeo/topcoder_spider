<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class LongJourney {<br>    static final long INF = Long.MAX_VALUE / 3;<br> <br>    public long minimumCost(int[] _fuelPrices, int _fuelTank, String[] roads) {<br>        long[] fuelPrices = new long[_fuelPrices.length];<br>        for (int i = 0; i &lt; fuelPrices.length; ++i)<br>            fuelPrices[i] = _fuelPrices[i];<br>        long fuelTank = _fuelTank;<br>        int n = fuelPrices.length;<br>        long[][] dist = new long[n][n];<br>        for (int i = 0; i &lt; n; ++i) {<br>            Arrays.fill(dist[i], INF);<br>            dist[i][i] = 0;<br>        }<br>        StringBuilder builder = new StringBuilder();<br>        for (String x : roads)<br>            builder.append(x);<br>        for (String edgeStr : builder.toString().split(" ", -1)) {<br>            String[] parts = edgeStr.split(",",  -1);<br>            int a = Integer.parseInt(parts[0]);<br>            int b = Integer.parseInt(parts[1]);<br>            int fuel = Integer.parseInt(parts[2]);<br>            dist[a][b] = Math.min(dist[a][b], fuel);<br>            dist[b][a] = Math.min(dist[b][a], fuel); <br>        }<br>        for (int k = 0; k &lt; n; ++k)<br>            for (int i = 0; i &lt; n; ++i)<br>                for (int j = 0; j &lt; n; ++j)<br>                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);<br>        long[][] edge = new long[2 * n][2 * n];<br>        for (int i = 0; i &lt; 2 * n; ++i)<br>            Arrays.fill(edge[i], INF);<br>        for (int i = 0; i &lt; n; ++i) {<br>            edge[i][i + n] = Math.min(edge[i][i + n], fuelPrices[i] * fuelTank);<br>            for (int j = 0; j &lt; n; ++j) {<br>                long toTravel = dist[i][j];<br>                if (toTravel &lt;= fuelTank) {<br>                    edge[i][j] = Math.min(edge[i][j], toTravel * fuelPrices[i]);<br>                    edge[i + n][j + n] = Math.min(edge[i + n][j + n], toTravel * fuelPrices[j]);<br>                    if (toTravel == fuelTank)<br>                        edge[i + n][j] = Math.min(edge[i + n][j], 0);<br>                    for (int k = 0; k &lt; n; ++k) {<br>                        long toTravel2 = dist[j][k];<br>                        if (toTravel2 &lt;= fuelTank) {<br>                            long extra = toTravel2 - (fuelTank - toTravel);<br>                            if (extra &gt; 0) {<br>                                edge[i + n][k] = Math.min(edge[i + n][k], extra * fuelPrices[j]);<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br> <br>        }<br>        long[] cheapest = new long[2 * n];<br>        Arrays.fill(cheapest, INF);<br>        cheapest[0] = 0;<br>        boolean updated;<br>        do {<br>            updated = false;<br>            for (int i = 0; i &lt; 2 * n; ++i)<br>                if (cheapest[i] &lt; INF)<br>                    for (int j = 0; j &lt; 2 * n; ++j)<br>                        if (cheapest[i] + edge[i][j] &lt; cheapest[j]) {<br>                            updated = true;<br>                            cheapest[j] = cheapest[i] + edge[i][j];<br>                        }<br>        } while (updated);<br>        return cheapest[1] &lt; INF ? cheapest[1] : -1;<br>    }<br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>