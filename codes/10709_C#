<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br><br>public class NumbersAndMatches {<br>    string S;<br>    Dictionary&lt;string, long&gt; mem;<br>    bool[][] digmap = new bool[10][];<br>    int[,] movecost = new int[10,10];<br>    int[,] matchprofit = new int[10,10];<br>    public long differentNumbers(long N, int K) {<br><br>        S = N.ToString();<br>        mem = new Dictionary&lt;string, long&gt;();<br>        for (int i = 0; i &lt;= K; i++) {<br>            mem.Add(matchhash(S.Length, 0, i),1);<br>        }<br><br>        string[] sdigmap = new string[] { "1110111", "0010011", "1011101", "1011011", "0111010", "1101011", "1101111", "1010010", "1111111", "1111011" };<br>        for (int i = 0; i &lt; 10; i++) {<br>            digmap[i] = new bool[7];<br>            for (int j = 0; j &lt; 7; j++) {<br>                if (sdigmap[i][j] == '1') digmap[i][j] = true;<br>            }<br>        }<br><br>        for (int i = 0; i &lt; 10; i++) {<br>            for (int j = 0; j &lt; 10; j++) {<br>                int profit = 0;<br>                int cost = 0;<br>                for (int a = 0; a &lt; 7; a++) {<br>                    if (digmap[i][a] != digmap[j][a]) {<br>                        if (digmap[i][a]) {<br>                            profit++;<br>                        } else {<br>                            cost++;<br>                        }<br>                    }<br>                }<br>                int moves = 0;<br>                while (profit &gt; 0 &amp;&amp; cost &gt; 0) {<br>                    moves++;<br>                    profit--;<br>                    cost--;<br>                }<br>                movecost[i, j] = moves;<br>                if (profit &gt; 0) {<br>                    matchprofit[i, j] = profit;<br>                    movecost[i, j] += profit;<br>                }<br>                if (cost &gt; 0) {<br>                    matchprofit[i, j] = -cost;<br>                }<br>            }<br>        }<br><br>        long ret = ways(0, 0, K);<br>        return ret;<br><br>    }<br><br>    private long ways(int pos, int matchesextra, int movesleft) {<br>        if (movesleft &lt; 0) return 0;<br>        if (pos == S.Length &amp;&amp; matchesextra != 0) return 0;<br>        if (pos == S.Length) return 1;<br>        string hash = matchhash(pos, matchesextra, movesleft);<br>        if (mem.ContainsKey(hash)) return mem[hash];<br>        if (pos==S.Length) return 0;<br>        long ret = 0;<br>        int D = S[pos] - '0';<br>        for (int d = 0; d &lt;= 9; d++) {<br>            long val = ways(pos + 1, matchesextra + matchprofit[D, d], movesleft - movecost[D, d]);<br>            ret += val;<br>        }<br>        mem.Add(hash, ret);<br>        return ret;<br>    }<br><br>    private string matchhash(int pos, int matchesextra, int movesleft) {<br>        return string.Format("{0} {1} {2}", pos, matchesextra, movesleft);<br>    }<br>}<br></td>