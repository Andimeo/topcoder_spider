<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br> <br>using namespace std;<br> <br>typedef long double dbl;<br>typedef long long ll;<br>typedef pair &lt;int, int&gt; pii;<br>typedef vector &lt;int&gt; vi;<br> <br>#define forn(i,n) for (int i = 0; i &lt; (int)(n); i++)<br>#define fi first<br>#define mp make_pair<br>#define pb push_back<br>#define se second<br> <br>int d1[55][55];<br>dbl d2[55][55];<br>const int maxk = 4000;<br>dbl d[maxk][55];<br>int c[maxk][55];<br> <br>class BuildingCities {<br>  public:<br>    int findMinimumCities( int maxDirect, int maxTravel, vector &lt;int&gt; cityX, vector &lt;int&gt; cityY )<br>    {<br>      int n = cityX.size();<br>      forn (i, n) forn (j, n) {<br>        d1[i][j] = 0;<br>        while (sqr(maxDirect * (d1[i][j] + 1)) &lt; sqr(cityX[i] - cityX[j]) + sqr(cityY[i] - cityY[j]))<br>          d1[i][j]++;<br>        d2[i][j] = sqrt(sqr(cityX[i] - cityX[j]) + sqr(cityY[i] - cityY[j]));<br>      }<br>      forn (i, maxk)<br>        forn (j, n)<br>          d[i][j] = 1e100, c[i][j] = 0;<br>      d[0][0] = 0.0;<br>      set &lt;pair &lt;dbl, pii&gt; &gt; s;<br>      forn (i, maxk)<br>        forn (j, n)<br>          s.insert(mp(d[i][j], mp(i, j)));<br>      while (s.size()) {<br>        pair &lt;dbl, pii&gt; tmp = *s.begin(); s.erase(*s.begin());<br>        c[tmp.se.fi][tmp.se.se] = 1;<br>        forn (t, n) {<br>          int ti = tmp.se.fi + d1[tmp.se.se][t];<br>          if (ti &gt;= maxk) continue;<br>          if (c[ti][t]) continue;<br>          if (d[ti][t] &lt;= tmp.fi + d2[tmp.se.se][t]) continue;<br>          s.erase(mp(d[ti][t], mp(ti, t)));<br>          d[ti][t] = tmp.fi + d2[tmp.se.se][t];<br>          s.insert(mp(d[ti][t], mp(ti, t)));<br>        }<br>      }<br>      forn (i, maxk)<br>        if (d[i][n - 1] &lt;= maxTravel + 1e-6)<br>          return i;<br>      return -1;<br>    }<br>  private:<br>    int sqr( int a )<br>    {<br>      return a * a;<br>    }<br>};<br> <br> <br>// Powered by PopsEdit<br></td>