<td class="problemText" colspan="8" valign="middle" align="left">
            #define KASE 0<br>#define _CRT_SECURE_NO_DEPRECATE<br><br>#include &lt;cstdio&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;cassert&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br><br>using namespace std;<br>typedef long long ll;<br><br>#define EPS 1e-10<br>#define REP(t, n) for(int t=0; t&lt;(int)(n); ++t)<br>#define FOR(t, x, y) for(int t=x; t&lt;(int)(y); ++t)<br><br>#define all(v) (v).begin(), (v).end()<br>#define CLR(v) memset(v, 0, sizeof(v))<br>#define sz size()<br><br>class ColorfulDecoration<br>{<br>public:<br>  int n;<br>  vector&lt;int&gt; xa,ya,xb,yb;<br><br>  bool w[100][100];<br>#define A(t) (2*(t))<br>#define B(t) (2*(t)+1)<br>  bool conflict(long long xa, long long ya, long long xb, long long yb, int L)<br>  {<br>    long long Ax1, Ay1, Ax2, Ay2;<br>    long long Bx1, By1, Bx2, By2;<br>    <br>    Ax1 = xa * 2 - L; Ay1 = ya * 2 - L;<br>    Ax2 = xa * 2 + L; Ay2 = ya * 2 + L;<br>    Bx1 = xb * 2 - L; By1 = yb * 2 - L;<br>    Bx2 = xb * 2 + L; By2 = yb * 2 + L;<br>    <br>    return (Ax2 &gt; Bx1) &amp;&amp; (Ax1 &lt; Bx2) &amp;&amp; (Ay2 &gt; By1) &amp;&amp; (Ay1 &lt; By2) ;<br>  }<br>  void sayConflict(int u, int v)<br>  {<br>    // u =&gt; ~v<br>    // v =&gt; ~u<br>    w[u][v^1] = true;<br>    w[v][u^1] = true;<br>  }<br>  bool able(int L)<br>  {<br>    int N = 2*n;<br>    memset(w, 0, sizeof(w));<br>    REP(i, n) REP(j, n) if(i!=j)<br>    {<br>      if( conflict(xa[i], ya[i], xa[j], ya[j], L) )<br>        sayConflict(A(i), A(j));<br>      if( conflict(xa[i], ya[i], xb[j], yb[j], L) )<br>        sayConflict(A(i), B(j));<br>      if( conflict(xb[i], yb[i], xa[j], ya[j], L) )<br>        sayConflict(B(i), A(j));<br>      if( conflict(xb[i], yb[i], xb[j], yb[j], L) )<br>        sayConflict(B(i), B(j));<br>    }<br>    REP(k, N) REP(i, N) REP(j, N) {<br>      if(w[i][k] &amp;&amp; w[k][j])<br>        w[i][j] = true;<br>    }<br>    REP(i, N)<br>    {<br>      if(w[i][i^1] &amp;&amp; w[i^1][i])<br>        return false;<br>    }<br>    return true;<br>  }<br>  int getMaximum(vector &lt;int&gt; xa, vector &lt;int&gt; ya, vector &lt;int&gt; xb, vector &lt;int&gt; yb)<br>  {<br>    this-&gt;xa = xa; this-&gt;xb = xb;<br>    this-&gt;ya = ya; this-&gt;yb = yb;<br>    n = xa.size();<br><br>    int l = 0, r = 1000000000;<br>    int ans  = 0;<br><br>    while(l &lt;= r)<br>    {<br>      int mid =(l+r) / 2;<br>      if(able(mid))<br>        ans = mid, l = mid + 1;<br>      else r = mid - 1;<br>    }<br>    return ans;<br>  }<br><br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester (Modified 2009)<br>// Powered by CodeProcessor<br></td>