<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br>public class ColorfulMaze<br>{<br>    class Maze<br>    {<br>        public int[,] colors;<br>        public List&lt;int&gt;[] G;<br>        void DFS(int x, int y, int m, bool[,] isSafe)<br>        {<br>            if (x &lt; 0 || x &gt;= height || y &lt; 0 || y &gt;= width)<br>                return;<br>            if (colors[x, y] &gt;= 0)<br>                return;<br>            if (!isSafe[x, y])<br>                return;<br>            colors[x, y] = m;<br>            DFS(x - 1, y, m, isSafe);<br>            DFS(x + 1, y, m, isSafe);<br>            DFS(x, y - 1, m, isSafe);<br>            DFS(x, y + 1, m, isSafe);<br>        }<br>        public Maze(int[] c)<br>        {<br>            colors = new int[height, width];<br>            for (int i = 0; i &lt; height; ++i)<br>                for (int j = 0; j &lt; width; ++j)<br>                {<br>                    colors[i, j] = -1;<br>                    isSafe[i, j] = true;<br>                    if (map[i, j] == '#')<br>                        isSafe[i, j] = false;<br>                    if (map[i, j] &gt;= 'A' &amp;&amp; map[i, j] &lt;= 'G')<br>                        isSafe[i, j] = (c[map[i, j] - 'A'] == 2);<br>                }<br>            int m = 0;<br>            for (int i = 0; i &lt; height; ++i)<br>                for (int j = 0; j &lt; width; ++j)<br>                    if (colors[i, j] &lt; 0 &amp;&amp; isSafe[i, j])<br>                    {<br>                        DFS(i, j, m, isSafe);<br>                        m++;<br>                    }<br>            G = new List&lt;int&gt;[m];<br>            for (int i = 0; i &lt; m; ++i)<br>                G[i] = new List&lt;int&gt;();<br>            used.Clear();<br>            for (int i = 0; i &lt; height; ++i)<br>                for (int j = 0; j &lt; width; ++j)<br>                    if (colors[i, j] &gt;= 0)<br>                        for (int di = -1; di &lt;= 1; ++di)<br>                            for (int dj = -1; dj &lt;= 1; ++dj)<br>                                if (Math.Abs(di) + Math.Abs(dj) == 1)<br>                                {<br>                                    int x = i + di;<br>                                    int y = j + dj;<br>                                    if (x &lt; 0 || x &gt;= height || y &lt; 0 || y &gt;= width || isSafe[x, y])<br>                                        continue;<br>                                    if (map[x, y] == '#')<br>                                        continue;<br>                                    if (map[x, y] &gt;= 'A' &amp;&amp; map[x, y] &lt;= 'G' &amp;&amp; c[map[x, y] - 'A'] == 1)<br>                                        continue;<br>                                    int value = colors[i, j] * 10000 + x * 100 + y;<br>                                    if (used.ContainsKey(value))<br>                                        continue;<br>                                    used.Add(value, false);<br>                                    G[colors[i, j]].Add(x * 100 + y);<br>                                }<br>            for (int i = 0; i &lt; m; ++i)<br>                G[i].TrimExcess();<br>        }<br>    }<br>    class State<br>    {<br>        public int p, d, state;<br>        public State(int x, int y, int d, int[] c)<br>        {<br>            this.d = d;<br>            state = 0;<br>            for (int i = 0; i &lt; 7; ++i)<br>                state = state * 3 + c[i];<br>            if (maps[state] == null)<br>                maps[state] = new Maze(c);<br>            Maze maze = maps[state];<br>            p = maze.colors[x, y];<br>        }<br>        public override bool Equals(object obj)<br>        {<br>            State s = (State)obj;<br>            return p == s.p &amp;&amp; d == s.d &amp;&amp; state == s.state;<br>        }<br>        public override int GetHashCode()<br>        {<br>            return (state * 2500 + p) * 3 + d;<br>        }<br>    };<br>    static Dictionary&lt;State, double&gt; dictionary;<br>    static Maze[] maps;<br>    static bool[,] isSafe;<br>    static int height, width;<br>    static char[, ] map;<br>    static double[] probability;<br>    static Dictionary&lt;int, bool&gt; used;<br>    static int end_x, end_y, start_x, start_y;<br>    double doIt(int x, int y, int d, int[] c)<br>    {<br>        State state = new State(x, y, d, c);<br>        if (dictionary.ContainsKey(state))<br>            return dictionary[state];<br>        double results = 0;<br>        int p = state.p;<br>        Maze maze = maps[state.state];<br>        if (maze.colors[x, y] == maze.colors[end_x, end_y])<br>        {<br>            dictionary.Add(state, 1.0);<br>            return 1.0;<br>        }<br>        List&lt;int&gt; all = maze.G[p];<br>        foreach (int position in all)<br>        {<br>            int x2 = position / 100;<br>            int y2 = position % 100;<br>            int d1 = map[x2, y2] - 'A';<br>            double exp = 0;<br>            if (probability[d] &gt; 1e-5)<br>            {<br>                c[d1] = 2;<br>                double t = doIt(x2, y2, d, c);<br>                c[d1] = 0;<br>                exp += t * probability[d1];<br>            }<br>            if (probability[d] &lt; 1.0 - 1e-5 &amp;&amp; d == 0)<br>            {<br>                c[d1] = 1;<br>                double t = 0;<br>                for (int di = -1; di &lt;= 1; ++di)<br>                    for (int dj = -1; dj &lt;= 1; ++dj)<br>                        if (Math.Abs(di) + Math.Abs(dj) == 1)<br>                        {<br>                            int x3 = x2 + di;<br>                            int y3 = y2 + dj;<br>                            if (x3 &lt; 0 || x3 &gt;= height || y3 &lt; 0 || y3 &gt;= width)<br>                                continue;<br>                            if (map[x3, y3] == '#')<br>                                continue;<br>                            double next = 0;<br>                            if (map[x3, y3] &gt;= 'A' &amp;&amp; map[x3, y3] &lt;= 'G')<br>                            {<br>                                int d2 = map[x3, y3] - 'A';<br>                                if (c[d2] == 1)<br>                                    continue;<br>                                if (c[d2] == 2)<br>                                    next = doIt(x3, y3, 1, c);<br>                                else<br>                                {<br>                                    if (probability[d2] &gt; 1e-5)<br>                                    {<br>                                        c[d2] = 2;<br>                                        next = doIt(x3, y3, 1, c) * probability[d2];<br>                                        c[d2] = 0;<br>                                    }<br>                                    c[d2] = 1;<br>                                    c[d2] = 0;<br>                                }<br>                            }<br>                            else<br>                                next = doIt(x3, y3, 1, c);<br>                            if (next &gt; t)<br>                                t = next;<br>                        }<br>                c[d1] = 0;<br>                exp += t * (1 - probability[d1]);<br>            }<br>            if (exp &gt; results)<br>                results = exp;<br>        }<br>        dictionary.Add(state, results);<br>        return results;<br>    }<br>    public double getProbability(string[] maze, int[] trap)<br>  {<br>        dictionary = new Dictionary&lt;State, double&gt;();<br>        used = new Dictionary&lt;int, bool&gt;();<br>        maps = new Maze[3000];<br>        height = maze.Length;<br>        width = maze[0].Length;<br>        map = new char[height, width];<br>        isSafe = new bool[height, width];<br>        for (int i = 0; i &lt; height; ++i)<br>            for (int j = 0; j &lt; width; ++j)<br>            {<br>                map[i, j] = maze[i][j];<br>                if (map[i, j] == '$')<br>                {<br>                    start_x = i;<br>                    start_y = j;<br>                    map[i, j] = '.';<br>                }<br>                if (map[i, j] == '!')<br>                {<br>                    end_x = i;<br>                    end_y = j;<br>                    map[i, j] = '.';<br>                }                <br>            }<br>        probability = new double[7];<br>        for (int i = 0; i &lt; 7; ++i)<br>            probability[i] = (100 - trap[i]) / 100.0;<br>        int[] c = new int[7];<br>        double ret = doIt(start_x, start_y, 0, c);<br>        return ret;  <br>  }<br>}<br></td>