<td class="problemText" colspan="8" valign="middle" align="left">
            //NameInput<br>#include "string"<br>#include "bitset"<br>#include "vector"<br>#include "queue"<br>#include "stack"<br>#include "list"<br>#include "map"<br>#include "set"<br>#include "algorithm"<br>#include "functional"<br>#include "numeric"<br>#include "utility"<br>#include "sstream"<br>#include "iostream"<br>#include "complex"<br>#include "stdio.h"<br>#include "float.h"<br>#include "math.h"<br>#include "stdlib.h"<br>#include "assert.h"<br>#include "stdarg.h"<br>#include "string.h"<br>#include "time.h"<br>#include "ctype.h"<br>using namespace std;<br>#define UNIQUE(C) {sort(ALL(C)); C.resize(unique(ALL(C)) - C.begin());}<br>#define DTOI(X) static_cast&lt;int&gt;((X) + ((X) &lt; 0.0 ? -eps : eps))<br>#define DFORCE(X, Y) DTOI(Y((X) + eps))<br>#define CAST(X, Y) {stringstream ss; ss &lt;&lt; (X); ss &gt;&gt; (Y);}<br><br>#define SIZE(N, V) int N = static_cast&lt;int&gt;((V).size())<br>#define GSIZE(N, V) (N) = static_cast&lt;int&gt;((V).size())<br>#define ALL(V) (V).begin(), (V).end()<br>const double eps = 1e-9;<br>typedef long long i64;<br><br>int oo = 0x3FFFFFFF;<br><br>string seq;<br>string name;<br>int S, N;<br><br>int memo[2500][2500];<br>int f(int n, int s) {<br>  if ( n &gt;= N ) return 0;<br>  int&amp; best = memo[n][s];<br>  if ( best &gt;= 0 ) return best;<br>  best = oo;<br>  /* up */ {<br>    int p = seq.find(name[n], s);<br>    if ( p == string::npos ) p = seq.find(name[n]);<br>    best = f(n + 1, p) + ((p - s) % S + S) % S;<br>  }<br>  /* down */ {<br>    int p = seq.find_last_of(name[n], s);<br>    if ( p == string::npos ) p = seq.find_last_of(name[n], S - 1);<br>    best = min(best, f(n + 1, p) + ((s - p) % S + S) % S);<br>  }<br>  return best;<br>}<br><br>class NameInput {<br>public:<br>  int countUpDownKeyPresses(vector &lt;string&gt; predictionSequence, vector &lt;string&gt; names) {<br>    seq = predictionSequence[0];<br>    name = names[0];<br>    GSIZE(S, predictionSequence);<br>    GSIZE(N, names);<br>    for ( int i = 1; i &lt; S; ++i ) seq += predictionSequence[i];<br>    for ( int i = 1; i &lt; N; ++i ) name += names[i];<br>    GSIZE(S, seq);<br>    GSIZE(N, name);<br>    for ( int i = 0; i &lt; N; ++i ) if ( seq.find(name[i]) == string::npos ) return -1;<br>    memset(memo, -1, sizeof(memo));<br>    int sol = f(0, 0);<br>    return sol;<br>  }<br>};<br><br><br>// Powered by FileEdit<br>// Powered by moj 4.1 [modified TZTester]<br>// Powered by CodeProcessor<br></td>