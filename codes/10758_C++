<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>using namespace std;<br> <br>char lit[]="RGBY";<br>#define Q 1000000007<br> <br>#define VAR(a,b) typeof(b) a=(b)<br>#define FOR(i,a,b) for(VAR(i,a);i&lt;=b;++i)<br>#define FORD(i,a,b) for(VAR(i,a);i&gt;=b;--i)<br>#define REP(i,a) for(int i=0;i&lt;(a);++i)<br>#define FORE(a,b) for(typeof((b).begin()) a=(b).begin();a!=(b).end();++a)<br> <br>int t[57][4][57], w[57][2513];<br> <br>class ColorfulTiles <br>{<br>  public:<br>  int rozw(string s, int K)<br>  {<br>    REP(i,4) t[0][i][1] = 1, t[0][i][0] = 0;<br>    REP(i,4) if(lit[i]==s[0])<br>    {<br>      t[0][i][1] = 0;<br>      t[0][i][0] = 1;<br>    }<br>    FOR(i,1,s.size()-1) REP(j,4) REP(k,K+1) if(k &gt;= (lit[j]!=s[i])) <br>    {<br>      t[i][j][k] = 0;<br>      REP(u,4) if(u != j)<br>      t[i][j][k] = (t[i][j][k] + t[i-1][u][k - (lit[j]!=s[i])]) % Q; <br>    } else t[i][j][k] = 0;<br>    long long ret = 0;<br>    REP(j,4) REP(k,K+1) ret += t[s.size()-1][j][k];<br>    return ret % Q;<br>  }<br>  int theCount(vector &lt;string&gt; s, int K) <br>  {<br>    int n = s.size(),m = s[0].size();<br>    if(m==1 || n==1)<br>    {<br>      string t;<br>      FORE(i,s) t+=*i;<br>      return rozw(t,K);<br>    }<br>    int ret =0 ;<br>    char p[7] = "BGRY";<br>    do<br>    {<br>      int blad = 0;<br>      REP(i,K+1) w[0][i] = 1;<br>      REP(i,n) <br>      {<br>        char a[2];<br>        a[0] = p[0], a[1] = p[1];<br>        if(i%2) a[0] = p[2], a[1] = p[3];<br>        int b1 = 0;<br>        REP(j,m) if(s[i][j] != a[j%2]) b1++;<br>        blad += b1;<br>        swap(a[0], a[1]);<br>        int b2 = 0;<br>        REP(j,m) if(s[i][j] != a[j%2]) b2++;<br>        REP(x,K+1) w[i+1][x] = 0;<br>        REP(x,K+1)<br>        {<br>          if(x+b1 &lt;= K)        w[i+1][x+b1] = (w[i+1][x+b1] + w[i][x]) % Q;<br>          if(x+b2 &lt;= K &amp;&amp; i&gt;1) w[i+1][x+b2] = (w[i+1][x+b2] + w[i][x]) % Q;<br>        }<br>      }<br>      if(blad &lt;= K) ret--;<br>      ret += w[n][K];<br>      ret %= Q;<br>      <br>      REP(i,K+1) w[0][i] = 1;<br>      REP(j,m) <br>      {<br>        char a[2];<br>        a[0] = p[0], a[1] = p[1];<br>        if(j%2) a[0] = p[2], a[1] = p[3];<br>        int b1 = 0;<br>        REP(i,n) if(s[i][j] != a[i%2]) b1++;<br>        blad += b1;<br>        swap(a[0], a[1]);<br>        int b2 = 0;<br>        REP(i,n) if(s[i][j] != a[i%2]) b2++;<br>        REP(x,K+1) w[j+1][x] = 0;<br>        REP(x,K+1)<br>        {<br>          if(x+b1 &lt;= K)        w[j+1][x+b1] = (w[j+1][x+b1] + w[j][x]) % Q;<br>          if(x+b2 &lt;= K &amp;&amp; j&gt;1) w[j+1][x+b2] = (w[j+1][x+b2] + w[j][x]) % Q;<br>        }<br>      }<br>      ret += w[m][K];<br>      ret %= Q;<br>    }<br>    while(next_permutation(p,p+4));<br>    ret += Q;<br>    return ret % Q;<br>  }<br>  <br> <br>};<br> <br>// Powered by PopsEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>