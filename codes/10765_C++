<td class="problemText" colspan="8" valign="middle" align="left">
            #include "cfloat"<br>#include "cmath"<br>#include "cstdio"<br>#include "ctime"<br>#include "algorithm"<br>#include "map"<br>#include "numeric"<br>#include "queue"<br>#include "set"<br>#include "string"<br>#include "utility"<br>#include "vector"<br>#include "iostream"<br>using namespace std;<br>typedef long long i64;<br><br>i64 dp[2][2][41];<br><br>struct RoadOrFlightHard {<br>  const vector&lt;i64&gt; Generate(int n, i64 first, i64 prod, i64 add, i64 mod) {<br>    vector&lt;i64&gt; v(n);<br>    v[0] = first % mod;<br>    for (int i = 1; i &lt; n; ++i)<br>      v[i] = ((prod * v[i - 1]) % mod + add) % mod;<br>    return v;<br>  }<br><br>  i64 minTime(int n, int roadFirst, int roadProd, int roadAdd, int roadMod, int flightFirst, int flightProd, int flightAdd, int flightMod, int m) {<br>    const vector&lt;i64&gt; road = Generate(n, roadFirst, roadProd, roadAdd, roadMod);<br>    const vector&lt;i64&gt; flight = Generate(n, flightFirst, flightProd, flightAdd, flightMod);<br>    memset(dp, 0, sizeof(dp));<br>    for (int i = n - 1; i &gt;= 0; --i) {<br>      const int me = i % 2, old = 1 - me;<br>      for (int fl = 0; fl &lt; 2; ++fl)<br>        for (int k = 0; k &lt;= m; ++k) {<br>          i64&amp; best = dp[me][fl][k];<br>          best = dp[old][0][k] + road[i];<br>          if (fl == 1)<br>            best = min(best, dp[old][fl][k] + flight[i]);<br>          else if (k &gt; 0)<br>            best = min(best, dp[old][1][k - 1] + flight[i]);<br>        }<br>    }<br>    return dp[0][0][m];<br>  }<br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>