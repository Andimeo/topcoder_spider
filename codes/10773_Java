<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br>import java.text.*;<br>import java.math.*;<br> <br> <br>public class TheCitiesAndRoadsDivOne<br>{<br>  final long MOD = 1234567891;<br>  <br>  int es, vs;<br>  boolean[] col;<br>  boolean[][] g;<br>  <br>  long modPow(long x, int pow) {<br>    long r = 1;<br>    while (pow &gt; 0) {<br>      if (pow % 2 == 1) {<br>        r = (r * x) % MOD;<br>      }<br>      pow /= 2;<br>      x = (x * x) % MOD;<br>    }<br>    return r;<br>  }<br>  <br>  public int find(String[] map)<br>  {<br>    int n = map.length;<br>    g = new boolean[n][n];<br>    for (int i = 0; i &lt; n; ++i) {<br>      for (int j = 0; j &lt; n; ++j) {<br>        g[i][j] = map[i].charAt(j) == 'Y';<br>      }<br>    }<br>    col = new boolean[n];<br>    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();<br>    int cyc = -1;<br>    for (int i = 0; i &lt; n; ++i) {<br>      if (!col[i]) {<br>        vs = es = 0;<br>        dfs(i);<br>        list.add(vs);<br>        es /= 2;<br>        if (vs == es) {<br>          if (cyc != -1) {<br>            throw new AssertionError();<br>          }<br>          cyc = list.size() - 1;<br>        }<br>      }<br>    }<br>    n = list.size();<br>    int[] a = new int[n];<br>    for (int i = 0; i &lt; n; ++i) {<br>      a[i] = list.get(i);<br>    }<br>    long[] sum = new long[1 &lt;&lt; n];<br>    long[] mul = new long[1 &lt;&lt; n];<br>    mul[0] = 1;<br>    for (int i = 1; i &lt; 1 &lt;&lt; n; ++i) {<br>      int t = 0;<br>      while ((i &amp; (1 &lt;&lt; t)) == 0) {<br>        ++t;<br>      }<br>      sum[i] = (sum[i ^ (1 &lt;&lt; t)] + a[t]) % MOD;<br>      mul[i] = (mul[i ^ (1 &lt;&lt; t)] * a[t]) % MOD;<br>    }<br>    if (cyc != -1) {<br>      int mask = 1 &lt;&lt; cyc;<br>      return (int)solve(a, mask, sum[mask], sum[((1 &lt;&lt; n) - 1) ^ mask], mul[((1 &lt;&lt; n) - 1) ^ mask]);<br>    }<br>    long ans = 0;<br>    long[] fact = new long[100];<br>    long tt = 1;<br>    fact[3] = 1;<br>    for (int i = 3; i &lt; 99; ++i) {<br>      tt = (tt * i) % MOD;<br>      fact[i + 1] = tt;<br>    }<br>    for (int mask = 0; mask &lt; 1 &lt;&lt; n; ++mask) {<br>      long cycles = 0;<br>      int m = Integer.bitCount(mask);<br>      if (m == 0) {<br>        cycles = 1;<br>      } else if (m == 1) {<br>        int i = Integer.numberOfTrailingZeros(mask);<br>        cycles = (a[i] - 2) * (a[i] - 1) / 2;<br>      } else if (m == 2) {<br>        long u = -1, v = -1;<br>        for (int i = 0; i &lt; n; ++i) {<br>          if ((mask &amp; (1 &lt;&lt; i)) != 0) {<br>            if (u == -1) {<br>              u = a[i];<br>            } else {<br>              v = a[i];<br>            }<br>          }<br>        }<br>        long edges = (u * v) % MOD;<br>        cycles = ((edges * (edges - 1)) / 2) % MOD;<br>      } else {<br>        cycles = fact[m];<br>        cycles = (cycles * mul[mask]) % MOD;<br>        cycles = (cycles * mul[mask]) % MOD;<br>      }<br>      if (cycles == 0) {<br>        continue;<br>      }<br>      long add = solve(a, mask, sum[mask], sum[((1 &lt;&lt; n) - 1) ^ mask], mul[((1 &lt;&lt; n) - 1) ^ mask]) * cycles;<br>      ans = (ans + add) % MOD;<br>    }<br>    return (int)ans;<br>  }<br>  <br>  long solve(int[] a, int mask, long sum0, long sum1, long mul0) {<br>    int n = a.length;<br>    long cycle = sum0;<br>    long ans = cycle;<br>    long sum = (sum1 + cycle) % MOD;<br>    int count = mask == 0 ? n - 1 : n - Integer.bitCount(mask);<br>    if (mask == 0) {<br>      ans = 1;<br>    }<br>    for (int i = 0; i &lt; n; ++i) {<br>      if ((mask &amp; (1 &lt;&lt; i)) == 0) {<br>        ans = (ans * a[i]) % MOD;<br>      }<br>    }<br>    if (ans != (mask == 0 ? mul0 : (sum0 * mul0) % MOD)) {<br>      throw new AssertionError(ans + " " + (mask == 0 ? mul0 : (sum0 * mul0) % MOD));<br>    }<br>    if (count == 0) {<br>      return 1;<br>    }<br>    ans = (ans * modPow(sum, count - 1)) % MOD;<br>    return ans;<br>  }<br>  <br>  void dfs(int i) {<br>    if (col[i]) {<br>      return;<br>    }<br>    ++vs;<br>    col[i] = true;<br>    for (int j = 0; j &lt; g.length; ++j) {<br>      if (g[i][j]) {<br>        ++es;<br>        dfs(j);<br>      }<br>    }<br>  }<br>  <br>  <br>}<br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>