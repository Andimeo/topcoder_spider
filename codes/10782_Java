<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br><br>public class TimeTravellingTour {<br>    static final long INF = 1000000000000000000L;<br><br>    static class Vertex {<br>        boolean mark = false;<br>        long[][] best;<br>        List&lt;Edge&gt; adj = new ArrayList&lt;Edge&gt;();<br>    }<br><br>    static class Edge {<br>        Vertex src;<br>        Vertex dst;<br>        long cost;<br><br>        Edge(Vertex src, Vertex dst, long cost) {<br>            this.src = src;<br>            this.dst = dst;<br>            this.cost = cost;<br>        }<br>    }<br><br>    public long determineCost(int N, int[] cities, String[] roads) {<br>        StringBuilder builder = new StringBuilder();<br>        for (String x : roads) builder.append(x);<br>        String[] parts = builder.toString().split(" +");<br>        Vertex[] v = new Vertex[N];<br>        for (int i = 0; i &lt; N; ++i) {<br>            v[i] = new Vertex();<br>            v[i].best = new long[cities.length][cities.length + 1];<br>            for (int j = 0; j &lt; cities.length; ++j)<br>                Arrays.fill(v[i].best[j], INF);<br>        }<br>        for (int i = 0; i &lt; parts.length; ++i) {<br>            String[] p = parts[i].split(",");<br>            Vertex a = v[Integer.parseInt(p[0])];<br>            Vertex b = v[Integer.parseInt(p[1])];<br>            int cost = Integer.parseInt(p[2]);<br>            Edge ab = new Edge(a, b, cost);<br>            a.adj.add(ab);<br>            Edge ba = new Edge(b, a, cost);<br>            b.adj.add(ba);<br>        }<br>        for (int i = 0; i &lt; cities.length; ++i)<br>            v[cities[i]].best[i][1] = 0;<br>        for (int len = 1; len &lt;= cities.length; ++len) {<br>            for (int first = 0; first + len &lt;= cities.length; ++first) {<br>                for (int subLen = 1; subLen &lt; len; ++subLen) {<br>                    for (Vertex vv : v) {<br>                        vv.best[first][len] = Math.min(vv.best[first][len], vv.best[first][subLen] + vv.best[first + subLen][len - subLen]);<br>                    }<br>                }<br>                for (Vertex vv : v)<br>                    vv.mark = false;<br>                while (true) {<br>                    long min = INF;<br>                    Vertex minV = null;<br>                    for (Vertex vv : v)<br>                        if (!vv.mark &amp;&amp; vv.best[first][len] &lt; min) {<br>                            min = vv.best[first][len];<br>                            minV = vv;<br>                        }<br>                    if (minV == null)<br>                        break;<br>                    minV.mark = true;<br>                    for (Edge e : minV.adj) {<br>                        e.dst.best[first][len] = Math.min(e.dst.best[first][len], min + e.cost);<br>                    }<br>                }<br>            }<br>        }<br>        long res = v[0].best[0][cities.length];<br>        if (res == INF)<br>            res = -1;<br>        return res;<br>    }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>