<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;sstream&gt; <br>#include &lt;iostream&gt;<br>#include &lt;string.h&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;numeric&gt;<br>#include &lt;math.h&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;stack&gt;<br>#include &lt;queue&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>using namespace std;<br> <br>typedef int flow_type;<br> <br>const int MAXN = 256;<br>const int MAXM = MAXN * MAXN * 4;<br>const flow_type INF = 1 &lt;&lt; 30;<br> <br>flow_type cap[MAXM];<br>int to[MAXM];<br>int last[MAXN];<br>int next[MAXM];<br>int source , sink;<br>int num;<br> <br>int flow_d[MAXN];<br> <br>void add_edge ( int x , int y , flow_type c ) {<br>  to[num] = y;<br>  to[num + 1] = x;<br>  <br>  cap[num] = c;<br>  cap[num + 1] = 0;<br>  <br>  next[num] = last[x];<br>  next[num + 1] = last[y];<br>  <br>  last[x] = num;<br>  last[y] = num + 1;<br>  <br>  num += 2;<br>}<br> <br>int flow_bfs() {<br>  int i , j , sz;<br>  static int q[MAXN];<br>  <br>  memset ( flow_d , -1 , sizeof flow_d );<br>  <br>  q[sz = 0] = sink;<br>  flow_d[sink] = 0;<br>  for (i = 0; i &lt;= sz; i++) {<br>    for (j = last[ q[i] ]; j &gt; 0; j = next[j]) {<br>      if ( flow_d[ to[j] ] == -1 &amp;&amp; cap[ j ^ 1 ] ) {<br>        flow_d[ to[j] ] = flow_d[ q[i] ] + 1;<br>        q[ ++ sz ] = to[j];<br>      }<br>    }<br>  }<br>      <br>  return flow_d[source] != -1;<br>}<br> <br>flow_type flow_dfs ( int x , flow_type flow ) {<br>  if ( x == sink ) return flow;<br>  int i;<br>  <br>  for (i = last[x]; i &gt; 0; i = next[i] )<br>    if ( cap[i] &amp;&amp; flow_d[ to[i] ] + 1 == flow_d[x] ) {<br>      int y = flow_dfs ( to[i] , min ( flow , cap[i] ) );<br>      <br>      if ( y != -1 ) {<br>        cap[i] -= y;<br>        cap[i ^ 1] += y;<br>        return y;<br>      }<br>    }<br>    <br>  flow_d[x] = -5;<br>  return -1;<br>}<br> <br>void flow_init() {<br>  num = 2;<br>  memset ( last , 0 , sizeof last );<br>}<br> <br>flow_type dinitz() {<br>  flow_type maxflow = 0 , flow;<br> <br>  while ( flow_bfs() )<br>    while ( ((flow = flow_dfs ( source , INF )) != -1) )<br>      maxflow += flow;<br> <br>  return maxflow;<br>}<br>/*<br>vertices are numbered from 1<br>CHECK MAXN!!!<br>call flow_init()<br>IF YOU CHANGE flow_type CHANGE INF!!!<br>*/<br> <br>int getDist ( int x1 , int y1 , int x2 , int y2 ) {<br>  return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2 );<br>}<br> <br>int solve ( vector &lt;int&gt; x, vector &lt;int&gt; y, vector &lt;int&gt; bx, vector &lt;int&gt; by, vector &lt;int&gt; px, vector &lt;int&gt; py, int rad ) {<br>  int i , j;<br>  int n = (int)x.size() , m = (int)bx.size() , r = (int)px.size();<br>  <br>  flow_init();<br>  <br>  source = m + r + 1;<br>  sink = source + 1;<br>  <br>  for (i = 0; i &lt; m; i++) {<br>    int dist = 1 &lt;&lt; 30;<br>    <br>    for (j = 0; j &lt; n; j++)<br>      dist = min ( dist , getDist ( x[j] , y[j] , bx[i] , by[i] ) );<br>    <br>    add_edge ( source , i + 1 , dist );<br>    <br>    for (j = 0; j &lt; r; j++)<br>      if ( getDist ( bx[i] , by[i] , px[j] , py[j] ) &lt;= rad * rad )<br>        add_edge ( i + 1 , m + j + 1 , INF );<br>      <br>  }<br>  <br>  for (i = 0; i &lt; r; i++) {<br>    int dist = 1 &lt;&lt; 30;<br>    <br>    for (j = 0; j &lt; n; j++)<br>      dist = min ( dist , getDist ( x[j] , y[j] , px[i] , py[i] ) );<br>    <br>    add_edge ( m + i + 1 , sink , dist );<br>  }<br>  <br>  return dinitz();<br>}<br> <br>class GreenWarfare {<br>  public:<br>  int minimumEnergyCost(vector &lt;int&gt; canonX, vector &lt;int&gt; canonY, vector &lt;int&gt; baseX, vector &lt;int&gt; baseY, vector &lt;int&gt; plantX, vector &lt;int&gt; plantY, int energySupplyRadius) {<br>    return solve ( canonX, canonY, baseX, baseY, plantX, plantY, energySupplyRadius );<br>  }<br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.12 [modified TZTester]<br>// Powered by CodeProcessor<br></td>