<td class="problemText" colspan="8" valign="middle" align="left">
            import static java.lang.Math.*;<br>import static java.math.BigInteger.*;<br>import static java.util.Arrays.*;<br>import static java.util.Collections.*;<br>import java.math.*;<br>import java.util.*;<br><br>public class GreenWarfare {<br>  public int minimumEnergyCost(int[] canonX, int[] canonY, int[] baseX, int[] baseY, int[] plantX, int[] plantY, int energySupplyRadius) {<br>    int cN = canonX.length;<br>    int bN = baseX.length;<br>    int pN = plantX.length;<br>    int[] bCost = new int[bN], pCost = new int[pN];<br>    for (int i = 0; i &lt; bN; i++) {<br>      int cost = INF;<br>      for (int j = 0; j &lt; cN; j++) {<br>        cost = min(cost, sq(canonX[j] - baseX[i]) + sq(canonY[j] - baseY[i]));<br>      }<br>      bCost[i] = cost;<br>    }<br>    for (int i = 0; i &lt; pN; i++) {<br>      int cost = INF;<br>      for (int j = 0; j &lt; cN; j++) {<br>        cost = min(cost, sq(canonX[j] - plantX[i]) + sq(canonY[j] - plantY[i]));<br>      }<br>      pCost[i] = cost;<br>    }<br>    V s = new V(), t = new V();<br>    V[] bs = new V[bN], ps = new V[pN];<br>    for (int i = 0; i &lt; bN; i++) bs[i] = new V();<br>    for (int i = 0; i &lt; pN; i++) ps[i] = new V();<br>    for (int i = 0; i &lt; bN; i++) {<br>      bs[i].add(t, bCost[i]);<br>    }<br>    for (int i = 0; i &lt; pN; i++) {<br>      s.add(ps[i], pCost[i]);<br>    }<br>    for (int i = 0; i &lt; bN; i++) {<br>      for (int j = 0; j &lt; pN; j++) if (sq(baseX[i] - plantX[j]) + sq(baseY[i] - plantY[j]) &lt;= sq(energySupplyRadius)) {<br>        ps[j].add(bs[i], INF);<br>      }<br>    }<br>    return dinic(s, t);<br>  }<br>  int sq(int x) {<br>    return x * x;<br>  }<br>  int INF = 1 &lt;&lt; 29;<br>  int dinic(V s, V t) {<br>    int flow = 0;<br>    for (int p = 1; ; p++) {<br>      Queue&lt;V&gt; que = new LinkedList&lt;V&gt;();<br>      s.level = 0;<br>      s.p = p;<br>      que.offer(s);<br>      while (!que.isEmpty()) {<br>        V v = que.poll();<br>        v.iter = v.es.size() - 1;<br>        for (E e : v.es) if (e.to.p &lt; p &amp;&amp; e.cap &gt; 0) {<br>          e.to.level = v.level + 1;<br>          e.to.p = p;<br>          que.offer(e.to);<br>        }<br>      }<br>      if (t.p &lt; p) return flow;<br>      for (int f; (f = dfs(s, t, INF)) &gt; 0; ) flow += f;<br>    }<br>  }<br>  int dfs(V v, V t, int f) {<br>    if (v == t) return f;<br>    for (; v.iter &gt;= 0; v.iter--) {<br>      E e = v.es.get(v.iter);<br>      if (v.level &lt; e.to.level &amp;&amp; e.cap &gt; 0) {<br>        int d = dfs(e.to, t, min(f, e.cap));<br>        if (d &gt; 0) {<br>          e.cap -= d;<br>          e.rev.cap += d;<br>          return d;<br>        }<br>      }<br>    }<br>    return 0;<br>  }<br>  class V {<br>    ArrayList&lt;E&gt; es = new ArrayList&lt;E&gt;();<br>    int level, p, iter;<br>    void add(V to, int cap) {<br>      E e = new E(to, cap), rev = new E(this, 0);<br>      e.rev = rev; rev.rev = e;<br>      es.add(e); to.es.add(rev);<br>    }<br>  }<br>  class E {<br>    V to;<br>    E rev;<br>    int cap;<br>    E(V to, int cap) {<br>      this.to = to;<br>      this.cap = cap;<br>    }<br>  }<br>  void debug(Object...os) {<br>    System.err.println(deepToString(os));<br>  }<br>}<br></td>