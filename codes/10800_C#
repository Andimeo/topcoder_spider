<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br>public class GameWithGraphAndTree<br>{<br>    const int MOD = 1000000007;<br>    int n;<br>    bool[,] graph;<br>    int[,] combinations;<br>    int[,][] subsets;<br>    int[] degree, height;<br>    int[,] children;<br>    int[, ,] value;<br>    bool[, ,] visited;<br>    int[,] order;<br>    long doIt(int root, int current, int mask, int d)<br>    {<br>        if (d &lt; 0)<br>            return 1;<br>        if (visited[root, mask, order[current, d]])<br>            return value[root, mask, order[current, d]];<br>        int count_set = 0;<br>        for (int i = 0; i &lt; n; ++i)<br>            if ((mask &amp; (1 &lt;&lt; i)) &gt; 0)<br>                count_set++;<br>        long results = 0;<br>        int next = children[current, d];<br>        for (int i = 0; i &lt; n; ++i)<br>            if (graph[root, i] &amp;&amp; (mask &amp; (1 &lt;&lt; i)) &gt; 0)<br>            {<br>                int[] labels = new int[count_set - 1];<br>                int count_labels = 0;<br>                for (int j = 0; j &lt; n; ++j)<br>                    if (j != i &amp;&amp; (mask &amp; (1 &lt;&lt; j)) &gt; 0)<br>                        labels[count_labels++] = (1 &lt;&lt; j);<br>                for (int k = 0; k &lt; combinations[count_set - 1, height[next] - 1]; ++k)<br>                {<br>                    int mset = subsets[count_set - 1, height[next] - 1][k];<br>                    int subset1 = 0;<br>                    for (int j = 0; j &lt; count_set - 1; ++j)<br>                        if ((mset &amp; (1 &lt;&lt; j)) &gt; 0)<br>                            subset1 |= labels[j];<br>                    int subset2 = mask - (1 &lt;&lt; i) - subset1;<br>                    long temporary1 = doIt(i, next, subset1, degree[next] - 1);<br>                    long temporary2 = doIt(root, current, subset2, d - 1);<br>                    results = (results + temporary1 * temporary2) % MOD;<br>                }<br>            }<br>        visited[root, mask, order[current, d]] = true;<br>        value[root, mask, order[current, d]] = (int)results;<br>        return results;<br>    }<br>    public int calc(string[] str_graph, string[] tree)<br>    {<br>        combinations = new int[15, 15];<br>        subsets = new int[15, 15][];<br>        for (int i = 0; i &lt; 15; ++i)<br>        {<br>            combinations[i, 0] = combinations[i, i] = 1;<br>            for (int j = 1; j &lt;= i - 1; ++j)<br>                combinations[i, j] = combinations[i - 1, j - 1] + combinations[i - 1, j];<br>            for (int j = 0; j &lt;= i; ++j)<br>            {<br>                subsets[i, j] = new int[combinations[i, j]];<br>                combinations[i, j] = 0;<br>            }<br>            for (int subset = 0; subset &lt; (1 &lt;&lt; i); ++subset)<br>            {<br>                int count = 0;<br>                for (int j = 0; j &lt; i; ++j)<br>                    if ((subset &amp; (1 &lt;&lt; j)) &gt; 0)<br>                        ++count;<br>                subsets[i, count][combinations[i, count]++] = subset;<br>            }<br>        }<br>        n = str_graph.Length;<br>        if (n == 1)<br>            return 1;<br>        graph = new bool[n, n];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>                graph[i, j] = str_graph[i][j] == 'Y';<br>        degree = new int[n];<br>        children = new int[n, n];<br>        bool[] used = new bool[n];<br>        used[0] = true;<br>        height = new int[n];<br>        int[] queue = new int[n];<br>        int count_queue = 0;<br>        queue[count_queue++] = 0;<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>                for (int k = 0; k &lt; n; ++k)<br>                    if (used[j] &amp;&amp; !used[k] &amp;&amp; tree[j][k] == 'Y')<br>                    {<br>                        used[k] = true;<br>                        children[j, degree[j]++] = k;<br>                        queue[count_queue++] = k;<br>                    }<br>        for (int i = n - 1; i &gt;= 0; --i)<br>        {<br>            height[queue[i]] = 1;<br>            for (int j = 0; j &lt; degree[queue[i]]; ++j)<br>                height[queue[i]] += height[children[queue[i], j]];<br>        }<br>        order = new int[n, n];<br>        int count_order = 0;<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; degree[i]; ++j)<br>                order[i, j] = count_order++;<br>        long results = 0;<br>        value = new int[n, 1 &lt;&lt; n, n];<br>        visited = new bool[n, 1 &lt;&lt; n, n];<br>        for (int i = 0; i &lt; n; ++i)<br>            results = (results + doIt(i, 0, (1 &lt;&lt; n) - 1 - (1 &lt;&lt; i), degree[0] - 1)) % MOD;<br>        return (int)results;<br>    }<br>}<br></td>