<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>public class GameWithGraphAndTree {<br>  int n;<br>  long[][][] res;<br>  int[] num;<br>  int[] prev;<br>  long mod = 1000000007;<br>  String[] g, t;<br>  int[][] ne;<br>  public int calc(String[] g1, String[] t1) {<br>    g = g1;<br>    t = t1;<br>    n = g.length;<br>    res = new long[n][n][1&lt;&lt;n];<br>    num = new int[n];<br>    prev = new int[n];<br>    prev[0] = -1;<br>    find(0);<br>    ne = new int[n][n + 1];<br>    for(int i = 0; i &lt; n; i++) {<br>      for(int j = 0; j &lt; n; j++)<br>        Arrays.fill(res[i][j], -1);<br>      for(int j = 0; j &lt;= n; j++) {<br>        ne[i][j] = ne(i, j);<br>      }<br>    }<br>    long tmpr = 0;<br>    for(int i = 0; i &lt; n; i++)<br>      tmpr += get(0, ne[0][0], i, 0);<br>    tmpr %= mod;<br>    return (int)tmpr;<br>  }<br>  <br>  int ne(int a, int b) {<br>    while(b &lt; n &amp;&amp; (t[a].charAt(b) == 'N' || b == prev[a]))<br>      b++;<br>    return b;<br>  }<br>  <br>  int find(int a) {<br>    int res = 1;<br>    for(int i = 0; i &lt; n; i++) {<br>      if(t[a].charAt(i) == 'Y' &amp;&amp; i != prev[a]) {<br>        prev[i] = a;<br>        res += find(i);<br>      }<br>    }<br>    return num[a] = res;<br>  }<br>  long get(int a, int b, int val, int mask) {<br>    mask |= 1 &lt;&lt; val;<br>//    System.out.println(a + " " + b +" " + mask);<br>    if(b == n)<br>      return 1;<br>    if(res[b][val][mask] != -1)<br>      return res[b][val][mask];<br>    long r = 0;<br>    for(int i = 0; i &lt; n; i++)<br>      if(g[val].charAt(i) != 'N' &amp;&amp; (mask&amp;(1&lt;&lt;i)) == 0) {<br>        int tmpmask = mask | (1&lt;&lt;i);<br>        for(int mask1 = tmpmask; mask1 &lt; (1&lt;&lt;n); mask1 = (mask1 + 1) | tmpmask) {<br>          if(Integer.bitCount(mask1 - mask) == num[b]) {<br>//            System.out.println(ne[i][0] + " " + ne[a][b + 1]);<br>            r += get(b, ne[b][0], i, (1&lt;&lt;n) - 1 - mask1 + mask) * get(a, ne[a][b + 1], val, mask1);<br>            r %= mod;<br>          }<br>        }<br>      }<br>    return res[b][val][mask] = r;<br>  }<br>}<br></td>