<td class="problemText" colspan="8" valign="middle" align="left">
            //  SRM 468 (C)<br><br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;utility&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;complex&gt;<br><br>using namespace std;<br><br>typedef unsigned uint;<br>typedef long long Int;<br>typedef vector&lt;int&gt; vint;<br>typedef vector&lt;string&gt; vstr;<br>typedef pair&lt;int,int&gt; pint;<br>#define mp make_pair<br><br>template&lt;class T&gt; void pv(T a, T b) { for (T i = a; i != b; ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; endl; }<br><br>namespace BM {<br>  #define MAXN1 210<br>  #define MAXN2 210<br>  #define MAXM  40010<br>  int n1, n2, m, ptr[MAXN1], next[MAXM], zu[MAXM];<br>  int to[MAXN1], fr[MAXN2], us[MAXN2], ze;<br>  inline void init(int _n1, int _n2) {<br>    n1 = _n1; n2 = _n2; m = 0; memset(ptr, ~0, n1 &lt;&lt; 2);<br>  }<br>  inline void ae(int u, int v) {<br>    next[m] = ptr[u]; ptr[u] = m; zu[m] = v; ++m;<br>  }<br>  int augment(int u) {<br>    int i, v;<br>    for (i = ptr[u]; ~i; i = next[i]) if (us[v = zu[i]] != ze) {<br>      us[v] = ze;<br>      if (!~fr[v] || augment(fr[v])) {<br>        to[u] = v; fr[v] = u; return 1;<br>      }<br>    }<br>    return 0;<br>  }<br>  int fof() {<br>    memset(to, ~0, n1 &lt;&lt; 2); memset(fr, ~0, n2 &lt;&lt; 2); memset(us, ~0, n2 &lt;&lt; 2);<br>    int ret = 0;<br>    for (ze = 0; ze &lt; n1; ++ze) ret += augment(ze);<br>    return ret;<br>  }<br>}<br><br>int N, M, I;<br>int S[60];<br>int X[510], Y[510], A[510], B[510];<br>int U, V, tr[60][110];<br>vector&lt;pint&gt; g[60][110];<br>int bi[60];<br>bool is[60][110];<br><br>struct MallSecurity {<br>  <br>  int maxGuards(int _N, vector &lt;string&gt; escDescription) {<br>    <br>    <br>    N = _N;<br>    <br>    string esc = "";<br>    for (vstr::iterator it = escDescription.begin(); it != escDescription.end(); ++it) {<br>      esc += *it;<br>    }<br>    for (string::iterator it = esc.begin(); it != esc.end(); ++it) {<br>      if (*it == ',') *it = ' ';<br>    }<br>    istringstream iss(esc);<br>    int a, b, c, x, y;<br>    for (; iss &gt;&gt; a &gt;&gt; b &gt;&gt; c; ) {<br>      x = (c + 0) % N;<br>      y = (c + 1) % N;<br>      if (S[x] &lt; a) S[x] = a;<br>      if (S[y] &lt; b) S[y] = b;<br>      --a;<br>      --b;<br>      g[x][a].push_back(mp(y, b));<br>      g[y][b].push_back(mp(x, a));<br>      X[M] = x;<br>      Y[M] = y;<br>      A[M] = a;<br>      B[M] = b;<br>      ++M;<br>    }<br>    <br>    int i, j, h, m;<br>    <br>    I = 0;<br>    for (i = 0; i &lt; N; ++i) {<br>      if (S[I] &gt; S[i]) I = i;<br>    }<br>    <br>    for (i = I + 1; i &lt; N; ++i) {<br>      bi[i] = i % 2;<br>    }<br>    for (i = 0; i &lt; I; ++i) {<br>      bi[i] = (N + i) % 2;<br>    }<br>    bi[I] = -1;<br>    <br>    for (i = 0; i &lt; N; ++i) if (i != I) {<br>      for (j = 0; j &lt; S[i]; ++j) {<br>        tr[i][j] = (bi[i] == 0) ? U++ : V++;<br>      }<br>    }<br>    <br>pv(S,S+N);<br>pv(bi,bi+N);<br>    <br>    int ans = 0, tmp;<br>    <br>    for (h = 0; h &lt; 1 &lt;&lt; S[I]; ++h) {<br>//cout&lt;&lt;"h = "&lt;&lt;h&lt;&lt;endl;<br>      memset(is, 0, sizeof(is));<br>      tmp = __builtin_popcount(h);<br>      for (j = 0; j &lt; S[I]; ++j) if (h &amp; 1 &lt;&lt; j) {<br>        for (vector&lt;pint&gt;::iterator it = g[I][j].begin(), en = g[I][j].end(); it != en; ++it) {<br>          if (!is[it-&gt;first][it-&gt;second]) {<br>            is[it-&gt;first][it-&gt;second] = 1;<br>            --tmp;<br>          }<br>        }<br>      }<br>      BM::init(U, V);<br>      for (m = 0; m &lt; M; ++m) {<br>        if (!is[X[m]][A[m]] &amp;&amp; !is[Y[m]][B[m]] &amp;&amp; X[m] != I &amp;&amp; Y[m] != I) {<br>//cout&lt;&lt;X[m]&lt;&lt;" "&lt;&lt;A[m]&lt;&lt;"  "&lt;&lt;Y[m]&lt;&lt;" "&lt;&lt;B[m]&lt;&lt;endl;<br>          if (bi[X[m]] == 0) {<br>            BM::ae(tr[X[m]][A[m]], tr[Y[m]][B[m]]);<br>          } else {<br>            BM::ae(tr[Y[m]][B[m]], tr[X[m]][A[m]]);<br>          }<br>        }<br>      }<br>      tmp += U + V - BM::fof();<br>      if (ans &lt; tmp) ans = tmp;<br>    }<br>    <br>    <br>    return ans;<br>    <br>    <br>  }<br>  <br>};<br></td>