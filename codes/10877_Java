<td class="problemText" colspan="8" valign="middle" align="left">
            import static java.lang.Math.*;<br>import static java.math.BigInteger.*;<br>import static java.util.Arrays.*;<br>import static java.util.Collections.*;<br>import java.math.*;<br>import java.util.*;<br><br>public class MallSecurity {<br>  public int maxGuards(int N, String[] escDescription) {<br>    StringBuilder sb = new StringBuilder();<br>    for (String s : escDescription) sb.append(s);<br>    String[] ss = sb.toString().split(",");<br>    int[] num = new int[N];<br>    for (String s : ss) {<br>      String[] ts = s.split(" ");<br>      int c = Integer.parseInt(ts[2]) - 1;<br>      num[c] = max(num[c], Integer.parseInt(ts[0]));<br>      num[(c + 1) % N] = max(num[(c + 1) % N], Integer.parseInt(ts[1]));<br>    }<br>    int p = 0;<br>    for (int i = 0; i &lt; N; i++) if (num[p] &gt; num[i]) p = i;<br>    ArrayList&lt;V&gt; all = new ArrayList&lt;V&gt;();<br>    V[][] vss = new V[N][];<br>    for (int i = 0; i &lt; N; i++) {<br>      vss[i] = new V[num[i]];<br>      for (int j = 0; j &lt; num[i]; j++) {<br>        all.add(vss[i][j] = new V());<br>      }<br>    }<br>    for (String s : ss) {<br>      String[] ts = s.split(" ");<br>      int c = Integer.parseInt(ts[2]) - 1;<br>      vss[c][Integer.parseInt(ts[0]) - 1].connect(vss[(c + 1) % N][Integer.parseInt(ts[1]) - 1]);<br>    }<br>    V[] vs = all.toArray(new V[0]);<br>    int res = 0; //vs.length - hopcroftKarp(vs);<br>    for (int i = 0; i &lt; 1 &lt;&lt; num[p]; i++) {<br>      for (V v : vs) {<br>        v.pair = null;<br>        v.ok = true;<br>      }<br>      for (int j = 0; j &lt; num[p]; j++) {<br>        if ((i &gt;&gt; j &amp; 1) == 0) {<br>          vss[p][j].ok = false;<br>        } else {<br>          for (V v : vss[p][j]) v.ok = false;<br>        }<br>      }<br>      int n = 0;<br>      for (V v : vs) if (v.ok) n++;<br>      res = max(res, n - hopcroftKarp(vs));<br>    }<br>    return res;<br>  }<br>  int hopcroftKarp(V[] vs) {<br>    for (int match = 0;;) {<br>      Queue&lt;V&gt; que = new LinkedList&lt;V&gt;();<br>      for (V v : vs) if (v.ok) v.level = -1;<br>      for (V v : vs) if (v.ok &amp;&amp; v.pair == null) {<br>        v.level = 0;<br>        que.offer(v);<br>      }<br>      while (!que.isEmpty()) {<br>        V v = que.poll();<br>        for (V u : v) if (u.ok) {<br>          V w = u.pair;<br>          if (w != null &amp;&amp; w.level &lt; 0) {<br>            w.level = v.level + 1;<br>            que.offer(w);<br>          }<br>        }<br>      }<br>      for (V v : vs) if (v.ok) v.used = false;<br>      int d = 0;<br>      for (V v : vs) if (v.ok &amp;&amp; v.pair == null &amp;&amp; dfs(v)) d++;<br>      if (d == 0) return match;<br>      match += d;<br>    }<br>  }<br>  boolean dfs(V v) {<br>    v.used = true;<br>    for (V u : v) if (u.ok) {<br>      V w = u.pair;<br>      if (w == null || !w.used &amp;&amp; v.level &lt; w.level &amp;&amp; dfs(w)) {<br>        v.pair = u;<br>        u.pair = v;<br>        return true;<br>      }<br>    }<br>    return false;<br>  }<br>  class V extends ArrayList&lt;V&gt; {<br>    V pair;<br>    int level;<br>    boolean used;<br>    boolean ok;<br>    void connect(V v) {<br>      add(v);<br>      v.add(this);<br>    }<br>  }<br>  void debug(Object...os) {<br>    System.err.println(deepToString(os));<br>  }<br>}<br></td>