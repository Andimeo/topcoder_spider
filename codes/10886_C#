<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br>public class BatmanAndRobin<br>{<br>    int distance(int x1, int y1, int x2, int y2)<br>    {<br>        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);<br>    }<br>    int outer(int x1, int y1, int x2, int y2, int x3, int y3)<br>    {<br>        return (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);<br>    }<br>    int inner(int x1, int y1, int x2, int y2, int x3, int y3)<br>    {<br>        return (x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1);<br>    }<br>    int getConvexArea(int[] x, int[] y)<br>    {<br>        int n = x.Length;<br>        int firstPoint = 0;<br>        for (int i = 0; i &lt; n; ++i)<br>            if (x[i] &lt; x[firstPoint] || x[i] == x[firstPoint] &amp;&amp; y[i] &lt; y[firstPoint])<br>                firstPoint = i;<br>        int area = 0;<br>        int lastPoint = firstPoint;<br>        do<br>        {<br>            int nextPoint = -1;<br>            for (int i = 0; i &lt; n; ++i)<br>                if (i != lastPoint)<br>                {<br>                    if (nextPoint &lt; 0)<br>                        nextPoint = i;<br>                    else<br>                    {<br>                        int ck = outer(x[lastPoint], y[lastPoint], x[i], y[i], x[nextPoint], y[nextPoint]);<br>                        if (ck &gt; 0 || ck == 0 &amp;&amp; distance(x[lastPoint], y[lastPoint], x[i], y[i]) &gt; distance(x[lastPoint], y[lastPoint], x[nextPoint], y[nextPoint]))<br>                            nextPoint = i;<br>                    }<br>                }<br>            if (nextPoint &lt; 0)<br>                break;<br>            area += outer(0, 0, x[lastPoint], y[lastPoint], x[nextPoint], y[nextPoint]);<br>            lastPoint = nextPoint;<br>        } while (lastPoint != firstPoint);<br>        return area;<br>    }<br>    public double minArea(int[] x, int[] y)<br>    {<br>        int n = x.Length;<br>        if (n &lt;= 2)<br>            return 0;<br>        int results = 1 &lt;&lt; 30;<br>        int[,] points = new int[n, 2];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = i + 1; j &lt; n; ++j)<br>            {<br>                int m = 0;<br>                int c1 = 0, c2 = 0;<br>                bool is_dup = false;<br>                for (int k = 0; k &lt; n; ++k)<br>                    if (outer(x[i], y[i], x[j], y[j], x[k], y[k]) == 0)<br>                    {<br>                        if (k &lt; i)<br>                            is_dup = true;<br>                        points[m, 0] = inner(x[i], y[i], x[j], y[j], x[k], y[k]);<br>                        points[m, 1] = k;<br>                        ++m;<br>                    }<br>                    else if (outer(x[i], y[i], x[j], y[j], x[k], y[k]) &lt; 0)<br>                        ++c1;<br>                    else<br>                        ++c2;<br>                if (is_dup)<br>                    continue;<br>                for (int k = 0; k &lt; m; ++k)<br>                    for (int l = k + 1; l &lt; m; ++l)<br>                        if (points[l, 0] &lt; points[k, 0])<br>                        {<br>                            int t = points[l, 0];<br>                            points[l, 0] = points[k, 0];<br>                            points[k, 0] = t;<br>                            t = points[l, 1];<br>                            points[l, 1] = points[k, 1];<br>                            points[k, 1] = t;<br>                        }<br>                for (int s = 0; s &lt; 2; ++s)<br>                {<br>                    for (int k = 0; k &lt;= m; ++k)<br>                    {<br>                        int[] x1 = new int[c1 + k];<br>                        int[] y1 = new int[c1 + k];<br>                        int[] x2 = new int[c2 + m - k];<br>                        int[] y2 = new int[c2 + m - k];<br>                        int d1 = 0, d2 = 0;<br>                        for (int l = 0; l &lt; n; ++l)<br>                            if (outer(x[i], y[i], x[j], y[j], x[l], y[l]) &lt; 0)<br>                            {<br>                                x1[d1] = x[l];<br>                                y1[d1] = y[l];<br>                                ++d1;<br>                            }<br>                            else if (outer(x[i], y[i], x[j], y[j], x[l], y[l]) &gt; 0)<br>                            {<br>                                x2[d2] = x[l];<br>                                y2[d2] = y[l];<br>                                ++d2;<br>                            }<br>                        for (int l = 0; l &lt; m; ++l)<br>                            if (l &lt; k)<br>                            {<br>                                x1[d1] = x[points[l, 1]];<br>                                y1[d1] = y[points[l, 1]];<br>                                ++d1;<br>                            }<br>                            else<br>                            {<br>                                x2[d2] = x[points[l, 1]];<br>                                y2[d2] = y[points[l, 1]];<br>                                ++d2;<br>                            }<br>                        int area1 = getConvexArea(x1, y1);<br>                        int area2 = getConvexArea(x2, y2);<br>                        results = Math.Min(results, Math.Max(area1, area2));<br>                    }<br>                    for (int k = 0; k &lt; m - 1 - k; ++k)<br>                    {<br>                        int t = points[m - 1 - k, 0];<br>                        points[m - 1 - k, 0] = points[k, 0];<br>                        points[k, 0] = t;<br>                        t = points[m - 1 - k, 1];<br>                        points[m - 1 - k, 1] = points[k, 1];<br>                        points[k, 1] = t;<br>                    }<br>                }<br>            }<br>        return (double)results / 2.0;<br>    }<br>}<br></td>