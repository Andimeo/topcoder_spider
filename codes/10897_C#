<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br>public class VacationTours<br>{<br>    class Edge<br>    {<br>        public int dest;<br>        public int cap;<br>        public int cost;<br>        public int flow;<br>        public Edge rev;<br>    }<br>    int mcmf(int n, List&lt;Edge&gt;[] o, int s, int t, ref int cost)<br>    {<br>        int[] phi = new int[n];<br>        int res = 0;<br>        while (true)<br>        {<br>            bool[] mark = new bool[n];<br>            int[] dist = new int[n];<br>            int[] prev = new int[n];<br>            Edge[] pe = new Edge[n];<br>            for (int i = 0; i &lt; n; ++i)<br>                dist[i] = int.MaxValue;<br>            dist[s] = 0;<br>            prev[s] = -1;<br>            int mxDist = 0;<br>            while (true)<br>            {<br>                int minDist = int.MaxValue;<br>                int mi = -1;<br>                for (int i = 0; i &lt; n; ++i)<br>                    if (!mark[i] &amp;&amp; dist[i] &lt; minDist)<br>                    {<br>                        minDist = dist[i];<br>                        mi = i;<br>                    }<br>                if (mi &lt; 0)<br>                    break;<br>                mxDist = minDist;<br>                mark[mi] = true;<br>                foreach (Edge e in o[mi])<br>                {<br>                    if (e.flow &gt;= e.cap)<br>                        continue;<br>                    int ndist = minDist + e.cost + phi[mi] - phi[e.dest];<br>                    if (ndist &lt; dist[e.dest])<br>                    {<br>                        dist[e.dest] = ndist;<br>                        prev[e.dest] = mi;<br>                        pe[e.dest] = e;<br>                    }<br>                }<br>            }<br>            if (dist[t] == int.MaxValue)<br>                break;<br>            int by = int.MaxValue;<br>            int at = t;<br>            while (at != s)<br>            {<br>                by = Math.Min(by, pe[at].cap - pe[at].flow);<br>                at = prev[at];<br>            }<br>            cost += by * (dist[t] - phi[s] + phi[t]);<br>            res += by;<br>            at = t;<br>            while (at != s)<br>            {<br>                pe[at].flow += by;<br>                pe[at].rev.flow -= by;<br>                at = prev[at];<br>            }<br>            for (int i = 0; i &lt; n; ++i)<br>                if (dist[i] == int.MaxValue)<br>                    phi[i] += mxDist;<br>                else<br>                    phi[i] += dist[i];<br>        }<br>        return res;<br>    }<br> <br>    Edge addEdge(List&lt;Edge&gt;[] o, int a, int b, int cap, int cost)<br>    {<br>        Edge e = new Edge();<br>        e.dest = b;<br>        e.cap = cap;<br>        e.cost = cost;<br>        e.flow = 0;<br>        Edge re = new Edge();<br>        re.dest = a;<br>        re.cap = 0;<br>        re.cost = -cost;<br>        re.flow = 0;<br>        e.rev = re;<br>        re.rev = e;<br>        o[a].Add(e);<br>        o[b].Add(re);<br>        return e;<br>    }<br>    int getCost(char c)<br>    {<br>        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')<br>            return c - 'A';<br>        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')<br>            return c - 'a' + 26;<br>        if (c &gt;= '0' &amp;&amp; c &lt;= '9')<br>            return c - '0' + 26 + 26;<br>        return (c == '+') ? 62 : 63;<br>    }<br>    public int getIncome(string[] c, string[] d, int fee)<br>  {<br>        int n = c.Length;<br>        int results = 0;<br>        for (int flow = 1; flow &lt;= n; ++flow)<br>        {<br>            List&lt;Edge&gt;[] o = new List&lt;Edge&gt;[n + n + 1];<br>            for (int i = 0; i &lt; n + n + 1; ++i)<br>                o[i] = new List&lt;Edge&gt;();<br>            addEdge(o, n + n, 0, flow, 0);<br>            for (int i = 0; i &lt; n; ++i)<br>                for (int j = 0; j &lt; n; ++j)<br>                    if (i != j)<br>                    {<br>                        int cost = getCost(c[i][j]) * 64 + getCost(d[i][j]);<br>                        if (i == 0)<br>                            addEdge(o, 0, j + j, 1, cost);<br>                        else if (j == 0)<br>                            addEdge(o, i + i + 1, 1, 1, cost);<br>                        else<br>                            addEdge(o, i + i + 1, j + j, 1, cost);<br>                    }<br>            for (int i = 0; i &lt; n; ++i)<br>                if (i &gt; 0)<br>                    addEdge(o, i + i, i + i + 1, 1, 0);<br>            int costs = 0;<br>            if (mcmf(n + n + 1, o, n + n, 1, ref costs) != flow)<br>                break;<br>            results = Math.Max(results, flow * fee - costs);<br>        }<br>        return results;<br>  }<br>}<br></td>