<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br><br>using namespace std;<br><br>#define SIZE(X) ((int)(X.size()))<br>template&lt;class T&gt; inline void checkmax(T &amp;a,T b){if(b&gt;a) a=b;}<br><br>const int maxn=20000+5;<br>const int maxm=100000+5;<br>const int oo=100000000;<br><br>int node,nedge,src,dest;<br>int head[maxn],point[maxm],next[maxm],flow[maxm],capa[maxm],cost[maxm];<br>int dist[maxn],expand[maxn],prev[maxn],edge[maxn];<br>bool changed[maxn];<br><br>void init(int _node,int _src,int _dest)<br>{<br>  node=_node;<br>  src=_src;<br>  dest=_dest;<br>  nedge=0;<br>  for (int i=0;i&lt;node;i++) head[i]=-1;<br>}<br>void addedge(int u,int v,int c,int w)<br>{<br>  point[nedge]=v,capa[nedge]=c,cost[nedge]=+w,flow[nedge]=0,next[nedge]=head[u],head[u]=(nedge++);<br>  point[nedge]=u,capa[nedge]=0,cost[nedge]=-w,flow[nedge]=0,next[nedge]=head[v],head[v]=(nedge++);<br>}<br><br><br>class VacationTours<br>{<br>public:<br>  int calc(char c)<br>  {<br>    if (c&gt;='A' &amp;&amp; c&lt;='Z') return c-'A';<br>    if (c&gt;='a' &amp;&amp; c&lt;='z') return c-'a'+26;<br>    if (c&gt;='0' &amp;&amp; c&lt;='9') return c-'0'+52;<br>    if (c=='+') return 62;<br>    return 63;<br>  }<br>  int calc(char c,char b)<br>  {<br>    return calc(c)*64+calc(b);<br>  }<br>  int getIncome(vector &lt;string&gt; c, vector &lt;string&gt; d, int fee)<br>  {<br>    int n=SIZE(c);<br>    init(n+n,0,n);<br>    for (int i=1;i&lt;n;i++)<br>    {<br>      addedge(src,i,1,calc(c[0][i],d[0][i]));<br>      addedge(i+n,dest,1,calc(c[i][0],d[i][0]));<br>      addedge(i,i+n,1,0);<br>    }<br>    for (int i=1;i&lt;n;i++)<br>      for (int j=1;j&lt;n;j++)<br>        if (i!=j)<br>          addedge(i+n,j,1,calc(c[i][j],d[i][j]));<br>    int R=0;<br>    int s1=0,s2=0;<br>    while (1)<br>    {<br>      for (int i=0;i&lt;node;i++) dist[i]=oo,prev[i]=-1,changed[i]=false;<br>      dist[src]=0;<br>      changed[src]=true;<br>      expand[src]=oo;<br>      while (1)<br>      {<br>        bool ok=true;<br>        for (int i=0;i&lt;node;i++) if (changed[i])<br>        {<br>          changed[i]=false;<br>          for (int k=head[i];k&gt;=0;k=next[k])<br>            if (flow[k]&lt;capa[k] &amp;&amp; dist[i]+cost[k]&lt;dist[point[k]])<br>            {<br>              dist[point[k]]=dist[i]+cost[k];<br>              changed[point[k]]=true;<br>              prev[point[k]]=i;<br>              edge[point[k]]=k;<br>              expand[point[k]]=min(expand[i],capa[k]-flow[k]);<br>              ok=false;<br>            }<br>        }<br>        if (ok) break;<br>      }<br>      if (prev[dest]&lt;0) break;<br>      int d=expand[dest];<br>      s1+=d*fee;<br>      s2+=d*dist[dest];<br>      for (int k=dest;k!=src;k=prev[k])<br>      {<br>        flow[edge[k]]+=d;<br>        flow[edge[k]^1]-=d;<br>      }<br>      checkmax(R,s1-s2);<br>    }<br>    return R;<br>  }<br>};<br></td>