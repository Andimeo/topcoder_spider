<td class="problemText" colspan="8" valign="middle" align="left">
            import static java.lang.Math.*;<br>import static java.math.BigInteger.*;<br>import static java.util.Arrays.*;<br>import static java.util.Collections.*;<br>import java.math.*;<br>import java.util.*;<br><br>public class VacationTours {<br>  public int getIncome(String[] c, String[] d, int fee) {<br>    int n = c.length;<br>    int[][] g = new int[n][n];<br>    for (int i = 0; i &lt; n; i++) {<br>      for (int j = 0; j &lt; n; j++) {<br>        g[i][j] = f(c[i].charAt(j)) * 64 + f(d[i].charAt(j));<br>      }<br>    }<br>    V[] vs = new V[n * 2];<br>    V[] in = new V[n], out = new V[n];<br>    for (int i = 0; i &lt; n; i++) {<br>      vs[i * 2] = in[i] = new V();<br>      vs[i * 2 + 1] = out[i] = new V();<br>      if (i &gt; 0) {<br>        in[i].add(out[i], 1, 0);<br>      }<br>    }<br>    for (int i = 0; i &lt; n; i++) {<br>      for (int j = 0; j &lt; n; j++) if (i != j) {<br>        out[i].add(in[j], 1, g[i][j]);<br>      }<br>    }<br>    return minCostFlow(vs, out[0], in[0], fee);<br>  }<br>  int f(char c) {<br>    if ('A' &lt;= c &amp;&amp; c &lt;= 'Z') return c - 'A';<br>    if ('a' &lt;= c &amp;&amp; c &lt;= 'z') return 26 + c - 'a';<br>    if ('0' &lt;= c &amp;&amp; c &lt;= '9') return 52 + c - '0';<br>    if (c == '+') return 62;<br>    if (c == '/') return 63;<br>    throw new RuntimeException();<br>  }<br>  int INF = 1 &lt;&lt; 29;<br>  int minCostFlow(V[] vs, V s, V t, int fee) {<br>    int res = 0;<br>    for (;;) {<br>      for (V v : vs) v.min = INF;<br>      PriorityQueue&lt;E&gt; que = new PriorityQueue&lt;E&gt;();<br>      s.min = 0;<br>      que.offer(new E(s, 0, 0));<br>      while (!que.isEmpty()) {<br>        E crt = que.poll();<br>        if (crt.cost == crt.to.min) {<br>          for (E e : crt.to.es) {<br>            int tmp = crt.cost + e.cost + crt.to.h - e.to.h;<br>            if (e.cap &gt; 0 &amp;&amp; e.to.min &gt; tmp) {<br>              e.to.min = tmp;<br>              e.to.prev = e;<br>              que.offer(new E(e.to, 0, e.to.min));<br>            }<br>          }<br>        }<br>      }<br>      if (t.min == INF) return res;<br>      int tmp = 0;<br>      for (E e = t.prev; e != null; e = e.rev.to.prev) {<br>        tmp += e.cost;<br>        e.rev.cap++;<br>        e.cap--;<br>      }<br>      if (tmp &lt; fee) res += fee - tmp;<br>      else return res;<br>      for (V v : vs) v.h += v.min;<br>    }<br>  }<br>  class V {<br>    ArrayList&lt;E&gt; es = new ArrayList&lt;E&gt;();<br>    E prev;<br>    int min, h;<br>    void add(V to, int cap, int cost) {<br>      E e = new E(to, cap, cost), rev = new E(this, 0, -cost);<br>      e.rev = rev; rev.rev = e;<br>      es.add(e); to.es.add(rev);<br>    }<br>  }<br>  class E implements Comparable&lt;E&gt; {<br>    V to;<br>    E rev;<br>    int cap, cost;<br>    E(V to, int cap, int cost) {<br>      this.to = to;<br>      this.cap = cap;<br>      this.cost = cost;<br>    }<br>    public int compareTo(E o) {<br>      return cost - o.cost;<br>    }<br>  }<br>  void debug(Object...os) {<br>    System.err.println(deepToString(os));<br>  }<br>}<br></td>