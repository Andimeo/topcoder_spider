<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class BreakingChocolate {<br>    static boolean useShifts = true;<br> <br>    public int minSteps(int W, int H, int[] sx, int[] sy) {<br>        W = recalc(W, sx);<br>        H = recalc(H, sy);<br>        int[][] am = new int[W + 1][H + 1];<br>        for (int i = 0; i &lt; W; ++i) {<br>            int sum = 0;<br>            for (int j = 0; j &lt; H; ++j) {<br>                for (int k = 0; k &lt; sx.length; ++k)<br>                    if (sx[k] == i + 1 &amp;&amp; sy[k] == j + 1)<br>                        ++sum;<br>                am[i + 1][j + 1] = am[i][j + 1] + sum;<br>            }<br>        }<br>        short[][][][] minSteps = new short[W + 1][H + 1][][];<br>        for (int w1 = 0; w1 &lt;= W; ++w1)<br>            for (int h1 = 0; h1 &lt;= H; ++h1) {<br>                minSteps[w1][h1] = new short[W - w1 + 1][H - h1 + 1];<br>            }<br>        return get(minSteps, 0, 0, W, H, am) - 1;<br>    }<br> <br>    int getAm(int[][] am, int w1, int h1, int w2, int h2) {<br>        return am[w2][h2] - am[w1][h2] - am[w2][h1] + am[w1][h1];<br>    }<br> <br>    private int get(short[][][][] minSteps, int w1, int h1, int w2, int h2, int[][] am) {<br>        if (minSteps[w1][h1][w2 - w1][h2 - h1] &gt; 0)<br>            return minSteps[w1][h1][w2 - w1][h2 - h1];<br>        int have = getAm(am, w1, h1, w2, h2); <br>        int res;<br>        if (have == (w2 - w1) * (h2 - h1) || have == 0) {<br>            res = 1;<br>        } else {<br>            int numShifts = 0;<br>            int sw1 = w1;<br>            int sw2 = w2;<br>            int sh1 = h1;<br>            int sh2 = h2;<br>            if (useShifts) {<br>                if (getAm(am, w1, h1, w1 + 1, h2) == 0) {<br>                    ++numShifts;<br>                    ++w1;<br>                    while (getAm(am, w1, h1, w1 + 1, h2) == 0)<br>                        ++w1;<br>                }<br>                if (getAm(am, w2 - 1, h1, w2, h2) == 0) {<br>                    ++numShifts;<br>                    --w2;<br>                    while (getAm(am, w2 - 1, h1, w2, h2) == 0)<br>                        --w2;<br>                }<br>                if (getAm(am, w1, h1, w2, h1 + 1) == 0) {<br>                    ++numShifts;<br>                    ++h1;<br>                    while (getAm(am, w1, h1, w2, h1 + 1) == 0)<br>                        ++h1;<br>                }<br>                if (getAm(am, w1, h2 - 1, w2, h2) == 0) {<br>                    ++numShifts;<br>                    --h2;<br>                    while (getAm(am, w1, h2 - 1, w2, h2) == 0)<br>                        --h2;<br>                }<br>            }<br>            if (numShifts &gt; 0) {<br>                res = numShifts + get(minSteps, w1, h1, w2, h2, am);<br>                w1 = sw1;<br>                h1 = sh1;<br>                w2 = sw2;<br>                h2 = sh2;<br>            } else {<br>                res = Short.MAX_VALUE;<br>                for (int i = w1 + 1; i &lt; w2; ++i) {<br>                    int u1 = get(minSteps, w1, h1, i, h2, am);<br>                    int u2 = get(minSteps, i, h1, w2, h2, am);<br>                    res = Math.min(res, u1 + u2);<br>                }<br>                for (int i = h1 + 1; i &lt; h2; ++i) {<br>                    res = Math.min(res, get(minSteps, w1, h1, w2, i, am) + get(minSteps, w1, i, w2, h2, am));<br>                }<br>            }<br>        }<br>        minSteps[w1][h1][w2 - w1][h2 - h1] = (short) res;<br>        return res;<br>    }<br> <br>    private int recalc(int W, int[] sx) {<br>        TreeSet&lt;Integer&gt; interesting = new TreeSet&lt;Integer&gt;();<br>        interesting.add(0);<br>        interesting.add(W);<br>        for (int x : sx) {<br>            interesting.add(x - 1);<br>            interesting.add(x);<br>        }<br>        int index = 0;<br>        int[] nsx = new int[sx.length];<br>        int nw = -1;<br>        for (int x : interesting) {<br>            for (int i = 0; i &lt; sx.length; ++i)<br>                if (sx[i] == x)<br>                    nsx[i] = index;<br>            if (W == x)<br>                nw = index;<br>            ++index;<br>        }<br>        W = nw;<br>        for (int i = 0; i &lt; sx.length; ++i)<br>            sx[i] = nsx[i];<br>        return W;<br>    }<br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>