<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br><br>public class LineSegments {<br>    public long intersections(int N, int xFirst, int xAdd, int xProd, int xMod, int yFirst, int yAdd, int yProd, int yMod) {<br>       int[] x = new int[N];<br>        int[] y = new int[N];<br>        x[0] = xFirst;<br>        y[0] = yFirst;<br>        for (int i = 1; i &lt; N; ++i) {<br>            x[i] = (int) ((x[i - 1] * (long) xProd + xAdd) % xMod);<br>            y[i] = (int) ((y[i - 1] * (long) yProd + yAdd) % yMod);<br>        }<br>        long res = 0;<br>        for (int origin = 0; origin &lt; N; ++origin) {<br>            int[] dx = new int[N - 1];<br>            int[] dy = new int[N - 1];<br>            final double[] alpha = new double[N - 1];<br>            int k = 0;<br>            for (int i = 0; i &lt; N; ++i) {<br>                if (i == origin)<br>                    continue;<br>                dx[k] = x[i] - x[origin];<br>                dy[k] = y[i] - y[origin];<br>                alpha[k] = Math.atan2(dy[k], dx[k]);<br>                ++k;<br><br>            }<br>            Integer[] perm = new Integer[N - 1];<br>            for (int i = 0; i &lt; N - 1; ++i) perm[i] = i;<br>            Arrays.sort(perm, new Comparator&lt;Integer&gt;() {<br>                public int compare(Integer o1, Integer o2) {<br>                    return Double.compare(alpha[o1], alpha[o2]);<br>                }<br>            });<br>            int[] ndx = new int[N - 1];<br>            int[] ndy = new int[N - 1];<br>            double[] nalpha = new double[N - 1];<br>            for (int i = 0; i &lt; N - 1; ++i) {<br>                ndx[i] = dx[perm[i]];<br>                ndy[i] = dy[perm[i]];<br>                nalpha[i] = alpha[perm[i]];<br>            }<br>            dx = ndx;<br>            dy = ndy;<br>            int j = 0;<br>            long cur = 0;<br>            for (int i = 0; i &lt; N - 1; ++i) {<br>                while (j &lt; i + N - 1) {<br>                    double delta = nalpha[j % (N - 1)] - nalpha[i];<br>                    if (delta &lt; 0)<br>                        delta += 2 * Math.PI;<br>                    if (delta &gt; Math.PI)<br>                        break;<br>                    ++j;<br>                }<br>                cur += (long) (j - i - 1) * (j - i - 2) / 2;<br>            }<br>            cur = (long) (N - 1) * (N - 2) * (N - 3) / 6 - cur;<br>            res += cur;<br>        }<br>        res = (long) N * (N - 1) * (N - 2) * (N - 3) / 24 - res;<br>        return res;<br>    }<br>}<br><br><br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>