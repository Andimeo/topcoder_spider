<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;stack&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;math.h&gt;<br>using namespace std;<br><br>typedef long long ll;<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;vi&gt; vvi;<br>typedef vector&lt;string&gt; vs;<br>typedef pair&lt;int,int&gt; ii;<br>typedef vector&lt;ii&gt; vii;<br>#define sz(a) (int)((a).size())<br>#define two(n) (1&lt;&lt;(n))<br>#define all(c) (c).begin(),(c).end()<br>#define loop(i,n) for(int i=0;i&lt;(int)(n);i++)<br>#define loopsn(i,s,n) for(int i=(s);i&lt;(int)(n);i++)<br>#define dloop(i,n) for(int i=(n)-1;i&gt;=0;i--)<br>#define tr(it,c) for(it=(c).begin(); it!=(c).end(); it++)<br><br>class SquaresCovering<br>{<br>public:<br>  int minCost(vector &lt;int&gt; x, vector &lt;int&gt; y, vector &lt;int&gt; cost, vector &lt;int&gt; sides);<br>};<br><br>int SquaresCovering::minCost(vector &lt;int&gt; x, vector &lt;int&gt; y, vector &lt;int&gt; cost, vector &lt;int&gt; sides)<br>{<br>  int n = sz(x), m = sz(cost);<br>  set&lt;ii&gt; topleft;<br>  loop(i, n) loop(j, n)<br>    topleft.insert(ii(x[i], y[j]));<br><br>  map&lt;int, int&gt; cover;<br>  set&lt;ii&gt;::iterator its;<br>  map&lt;int,int&gt;::iterator itm;<br>  tr(its, topleft) loop(j, m)<br>  {<br>    int mask = 0;<br>    loop(k, n)<br>      if(x[k]&gt;=its-&gt;first &amp;&amp; x[k]&lt;=its-&gt;first+sides[j] &amp;&amp; y[k]&gt;=its-&gt;second &amp;&amp; y[k]&lt;=its-&gt;second+sides[j])<br>        mask |= two(k);<br>    itm = cover.find(mask);<br>    if(itm == cover.end())<br>      cover.insert(ii(mask, cost[j]));<br>    else<br>      itm-&gt;second = min(itm-&gt;second, cost[j]);<br>  }<br><br>  vi value(two(n), INT_MAX);<br>  value[0] = 0;<br>  loop(i, two(n))<br>  {<br>    if(value[i] != INT_MAX)<br>      tr(itm, cover)<br>      {<br>        int mask = itm-&gt;first | i;<br>        if(mask == i) continue;<br>        int newcost = itm-&gt;second + value[i];<br>        value[mask] = min(value[mask], newcost);<br>      }<br>  }<br>  return value[two(n)-1];<br>}<br></td>