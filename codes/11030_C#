<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class TheAirTripDivOne<br>{<br>    class Edge<br>    {<br>        public long b, f, t, p;<br>        public Edge()<br>        {<br>        }<br><br>    }<br>    public int find(int n, string[] flights, int time)<br>    {<br>        List&lt;Edge&gt;[] g = new List&lt;Edge&gt;[n];<br>        for (int i = 0; i &lt; n; i++)<br>            g[i] = new List&lt;Edge&gt;();<br>        string[] s = string.Join("", flights).Split(' ');<br>        foreach (string x in s)<br>        {<br>            int[] ar = Array.ConvertAll&lt;string, int&gt;(x.Split(','), int.Parse);<br>            ar[0]--;<br>            ar[1]--;<br>            Edge cur = new Edge();<br>            cur.b = ar[1];<br>            cur.f = ar[2];<br>            cur.t = ar[3];<br>            cur.p = ar[4];<br>            g[ar[0]].Add(cur);<br>        }<br>        long low = 1;<br>        long high = int.MaxValue;<br>        while (low &lt; high)<br>        {<br>            long min = (low + high +1) / 2;<br>            if (ok(min, n, time, g))<br>                low = min;<br>            else<br>                high = min - 1;<br>        }<br>        if (!ok(low, n, time, g))<br>            low = -1;<br>        return (int)low;<br><br>    }<br><br>    private bool ok(long min, int n, int time, List&lt;Edge&gt;[] g)<br>    {<br>        long[] d = new long[n];<br>        for (int i = 0; i &lt; n; i++)<br>            d[i] = int.MaxValue;<br>        d[0] = 0;<br>        bool[] vis = new bool[n];<br>        while (true)<br>        {<br>            int best = -1;<br>            for (int i = 0; i &lt; n; i++)<br>                if (!vis[i])<br>                {<br>                    if (best == -1 || d[best] &gt; d[i])<br>                        best = i;<br>                }<br>            if (best == -1 || d[best] &gt; time)<br>                break;<br>            vis[best] = true;<br>            foreach (Edge e in g[best])<br>            {<br><br>                long nd;<br>                if (d[best] == 0)<br>                    nd = 1;<br>                else<br>                    nd = d[best] + min;<br>                if (nd &lt;= e.f)<br>                {<br>                    nd = e.f;<br>                }<br>                else<br>                {<br>                    nd -= e.f;<br>                    long next = nd / e.p;<br>                    if (nd % e.p != 0)<br>                        next++;<br>                    nd = e.f + next * e.p;<br>                }<br>                d[e.b] = Math.Min(d[e.b], nd + e.t);<br>            }<br><br>        }<br>        return d[n - 1] &lt;= time;<br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>