<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;list&gt;<br>#include &lt;complex&gt;<br>#include &lt;queue&gt;<br>#include &lt;climits&gt;<br>#include &lt;cstdio&gt;<br> <br>using namespace std;<br> <br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef long long ll;<br>typedef complex&lt;double&gt; pnt;<br>typedef pair&lt;int, int&gt; pii;<br> <br>#define RA(x) (x).begin(), (x).end()<br>#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)<br>#define SZ(x) ((int) (x).size())<br> <br>template&lt;class T&gt;<br>void splitstr(const string &amp;s, vector&lt;T&gt; &amp;out)<br>{<br>    istringstream in(s);<br>    out.clear();<br>    copy(istream_iterator&lt;T&gt;(in), istream_iterator&lt;T&gt;(), back_inserter(out));<br>}<br> <br> <br>class TheAirTripDivOne<br>{<br>public:<br>    int find(int n, vector &lt;string&gt; flights, int time);<br>};<br> <br>struct flight<br>{<br>    int trg;<br>    ll first;<br>    ll period;<br>    ll time;<br> <br>    flight() {}<br>    flight(int trg, ll first, ll period, ll time) : trg(trg), first(first), period(period), time(time) {}<br>};<br> <br>struct pqitem<br>{<br>    int trg;<br>    ll prio;<br> <br>    pqitem() {}<br>    pqitem(int trg, ll prio) : trg(trg), prio(prio) {}<br> <br>    bool operator &lt;(const pqitem &amp;b) const<br>    {<br>        return prio &gt; b.prio;<br>    }<br>};<br> <br>int TheAirTripDivOne::find(int N, vector &lt;string&gt; flights_strs, int T)<br>{<br>    string flights_str = accumulate(RA(flights_strs), string());<br>    vector&lt;string&gt; flights_arr;<br>    splitstr(flights_str, flights_arr);<br> <br>    vector&lt;vector&lt;flight&gt; &gt; flights(N);<br>    FE(i, flights_arr)<br>    {<br>        int a, b;<br>        ll f, p, t;<br>        sscanf(i-&gt;c_str(), "%d,%d,%lld,%lld,%lld", &amp;a, &amp;b, &amp;f, &amp;t, &amp;p);<br> <br>        a--;<br>        b--;<br>        flights[a].push_back(flight(b, f, p, t));<br>    }<br> <br>    int low = 0;<br>    int high = T + 1;<br>    while (high - low &gt; 1)<br>    {<br>        int safety = (low + high) / 2;<br>        priority_queue&lt;pqitem&gt; q;<br>        ll prio[N];<br>        fill(prio, prio + N, LLONG_MAX);<br>        q.push(pqitem(0, -safety));<br>        prio[0] = -safety;<br>        while (!q.empty())<br>        {<br>            int trg = q.top().trg;<br>            ll p = q.top().prio;<br>            q.pop();<br>            if (p != prio[trg])<br>                continue;<br> <br>            FE(e, flights[trg])<br>            {<br>                ll t;<br>                if (p + safety &lt;= e-&gt;first)<br>                    t = e-&gt;first;<br>                else<br>                    t = (p + safety - e-&gt;first + e-&gt;period - 1) / e-&gt;period * e-&gt;period + e-&gt;first;<br>                t += e-&gt;time;<br>                if (t &gt; T) continue;<br> <br>                if (t &lt; prio[e-&gt;trg])<br>                {<br>                    prio[e-&gt;trg] = t;<br>                    q.push(pqitem(e-&gt;trg, t));<br>                }<br>            }<br>        }<br>        if (prio[N - 1] == LLONG_MAX)<br>            high = safety;<br>        else<br>            low = safety;<br>    }<br>    if (low &lt;= 0) return -1;<br>    else return low;<br>}<br> <br> <br>// Powered by FileEdit<br></td>