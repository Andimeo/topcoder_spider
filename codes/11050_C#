<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br>using kp.Algo;<br><br>public class TravellingPurchasingMan<br>{<br>  private const int INF = int.MaxValue / 2;<br><br>  public int maxStores( int N, string[] interestingStores, string[] roads )<br>  {<br>    int[,] d = new int[N, N];<br>    for ( int i = 0; i &lt; N; ++i )<br>      for ( int j = 0; j &lt; N; ++j )<br>        d[i, j] = i == j ? 0 : INF;<br>    foreach ( string road in roads )<br>    {<br>      string[] data = road.Split();<br>      int a = int.Parse( data[0] );<br>      int b = int.Parse( data[1] );<br>      int len = int.Parse( data[2] );<br>      d[a, b] = d[b, a] = len;<br>    }<br>    for ( int k = 0; k &lt; N; ++k )<br>      for ( int i = 0; i &lt; N; ++i )<br>        for ( int j = 0; j &lt; N; ++j )<br>          d[i, j] = Math.Min( d[i, j], d[i, k] + d[k, j] );<br>    int m = interestingStores.Length;<br>    int[] open = new int[m], close = new int[m], dur = new int[m];<br>    for ( int i = 0; i &lt; m; ++i )<br>    {<br>      string[] data = interestingStores[i].Split();<br>      open[i] = int.Parse( data[0] );<br>      close[i] = int.Parse( data[1] );<br>      dur[i] = int.Parse( data[2] );<br>    }<br><br>    int res = 0;<br>    int[,] dp = new int[m, 1 &lt;&lt; m];<br>    for ( int mask = 1; mask &lt; ( 1 &lt;&lt; m ); ++mask )<br>    {<br>      for ( int i = 0; i &lt; m; ++i )<br>      {<br>        dp[i, mask] = INF;<br>        if ( BitUtils.BitInMask( mask, i ) )<br>        {<br>          if ( mask == ( 1 &lt;&lt; i ) )<br>          {<br>            if ( d[N - 1, i] &lt; INF &amp;&amp; d[N - 1, i] &lt;= close[i] )<br>            {<br>              dp[i, mask] = Math.Max( d[N - 1, i], open[i] ) + dur[i];<br>            }<br>          }<br>          else<br>          {<br>            for ( int j = 0; j &lt; m; ++j )<br>              if ( BitUtils.BitInMask( mask, j ) )<br>              {<br>                int best = dp[j, mask ^ ( 1 &lt;&lt; i )];<br>                if ( best &lt; INF &amp;&amp; d[j, i] &lt; INF &amp;&amp; best + d[j, i] &lt;= close[i] )<br>                {<br>                  dp[i, mask] = Math.Min( dp[i, mask], Math.Max( best + d[j, i], open[i] ) + dur[i] );<br>                }<br>              }<br>          }<br><br>          if ( dp[i, mask] &lt; INF )<br>            res = Math.Max( res, BitUtils.CountOnes( mask ) );<br>        }<br>      }<br>    }<br>    return res;<br>  }<br><br>}<br><br>namespace kp.Algo { }<br><br>namespace kp.Algo<br>{<br>  static class BitUtils<br>  {<br>    public static bool BitInMask( int mask, int bit )<br>    {<br>      return ( mask &amp; ( 1 &lt;&lt; bit ) ) != 0;<br>    }<br>    public static int CountOnes( int x )<br>    {<br>      if ( x &lt; 0 ) throw new Exception( "Can't count bits in negative number" );<br>      int res = 0;<br>      while ( x &gt; 0 )<br>      {<br>        ++res;<br>        x &amp;= ( x - 1 );<br>      }<br>      return res;<br>    }<br>  }<br>}<br><br><br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CleanSharp 1.0<br>// Powered by CodeProcessor<br></td>