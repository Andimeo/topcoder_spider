<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Text;<br>using System.Text.RegularExpressions;<br>using System.Collections;<br><br>public class PathFinding {<br>    int R,C;<br>    bool[,] W;<br>    int[,,,] mem;<br>    class Pos {<br>        public Pos( int RA, int CA, int RB, int CB, int M ) {<br>            ra=RA;rb=RB;ca=CA;cb=CB;m=M;<br>        }<br>        public bool same( Pos p ) {<br>            return p.ra==this.ra&amp;&amp;p.rb==this.rb&amp;&amp;p.ca==this.ca&amp;&amp;p.cb==this.cb;<br>        }<br>        public int ra=0,rb=0,ca=0,cb=0,m=0;<br>    }<br>    public int minTurns(string[] B) {<br>        R = B.Length;<br>        C = B[0].Length;<br>        W = new bool[R,C];<br>        int ra=0,rb=0,ca=0,cb=0;<br>        mem = new int[R,C,R,C];<br>        for ( int r = 0 ; r != R; r++ )<br>            for ( int c = 0; c != C; c++ ) {<br>                if ( B[r][c] == 'X' )<br>                    W[r,c] = true;<br>                else if ( B[r][c] == 'A' ) {<br>                    ra=r;ca=c;<br>                } else if ( B[r][c] == 'B' ) {<br>                    rb=r;cb=c;<br>                }<br>                for ( int r1=0; r1!=R;r1++) for ( int c1=0;c1!=C;c1++)<br>                mem[r,c,r1,c1] = Int32.MaxValue;<br>            }<br>        Pos start = new Pos( ra, ca, rb, cb, 0 );<br>        Pos end = new Pos( rb, cb, ra, ca , 0);<br>        int res = Int32.MaxValue;<br>        Queue q = new Queue();<br>        q.Enqueue(start);<br>        while( q.Count != 0 ) {<br>            Pos p = (Pos)q.Dequeue();<br>            if ( p.same(end) ) {<br>                res = Math.Min( p.m, res );<br>            } else {<br>                if ( mem[p.ra,p.ca,p.rb,p.cb] &gt;= p.m ) {<br>                    mem[p.ra,p.ca,p.rb,p.cb] = p.m;<br>                    for ( int dra = -1 ; dra &lt;= 1; dra++ ) {<br>                        for ( int dca = -1; dca &lt;= 1; dca++ ) {<br>                            int nra = p.ra+dra;<br>                            int nca = p.ca+dca;<br>                            if ( nra&lt;0||nra&gt;=R||nca&lt;0||nca&gt;=C||W[nra,nca]) continue;<br>                            for ( int drb = -1; drb &lt;= 1; drb++ ) {<br>                                for ( int dcb = -1; dcb &lt;= 1; dcb++ ) {<br>                                    if ( dra==0&amp;&amp;drb==0&amp;&amp;dca==0&amp;&amp;dcb==0) continue;<br>                                    int nrb = p.rb+drb;<br>                                    int ncb = p.cb+dcb;<br>                                    if ( nrb&lt;0||nrb&gt;=R||ncb&lt;0||ncb&gt;=C||W[nrb,ncb]) continue;<br>                                    if (nra==p.rb&amp;&amp;nca==p.cb&amp;&amp;nrb==p.ra&amp;&amp;ncb==p.ca) continue;<br>                                    if(nra==nrb&amp;&amp;nca==ncb) continue;<br>                                    if ( mem[nra,nca,nrb,ncb] &lt;= p.m+1 ) continue;<br>                                    mem[nra,nca,nrb,ncb] = p.m+1;<br>                                    q.Enqueue( new Pos(nra,nca,nrb,ncb,p.m+1));<br>                                }<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        return res==Int32.MaxValue ? -1 : res;<br>    }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>