<td class="problemText" colspan="8" valign="middle" align="left">
            #pragma warning( disable : 4786 )<br><br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;functional&gt;<br>#include &lt;deque&gt;<br><br>using namespace std;<br><br>int gt[ 20 ][ 20 ][ 20 ][ 20 ];<br><br>bool wal[ 20 ][ 20 ];<br><br>int dx[] = { 0, 1, 1, 1, 0, 0, -1, -1, -1 };<br>int dy[] = { 0, 1, 0, -1, 1, -1, 1, 0, -1 };<br><br>deque&lt; pair&lt; pair&lt; int, int &gt;, pair&lt; int, int &gt; &gt; &gt; daq;<br><br>bool vald( int x, int y ) {<br>  return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; 20 &amp;&amp; y &lt; 20 &amp;&amp; !wal[ x ][ y ];<br>};<br><br>class PathFinding {<br>  public:<br>  int minTurns(vector &lt;string&gt; a) {<br>    memset( gt, 0x40, sizeof( gt ) );<br>    memset( wal, 0xff, sizeof( wal ) );<br>    int ax = -1;<br>    int ay = -1;<br>    int bx = -1;<br>    int by = -1;<br>    for( int i = 0; i &lt; a.size(); i++ ) {<br>      for( int j = 0; j &lt; a[ 0 ].size(); j++ ) {<br>        switch( a[ i ][ j ] ) {<br>        case '.':<br>          wal[ j ][ i ] = false;<br>          break;<br>        case 'X':<br>          wal[ j ][ i ] = true;<br>          break;<br>        case 'A':<br>          ax = j;<br>          ay = i;<br>          wal[ j ][ i ] = false;<br>          break;<br>        case 'B':<br>          bx = j;<br>          by = i;<br>          wal[ j ][ i ] = false;<br>          break;<br>        }<br>      }<br>    }<br>    gt[ ax ][ ay ][ bx ][ by ] = 0;<br>    daq.push_back( make_pair( make_pair( ax, ay ), make_pair( bx, by ) ) );<br>    while( daq.size() ) {<br>      pair&lt; pair&lt; int, int &gt;, pair&lt; int, int &gt; &gt; ti = *daq.begin();<br>      daq.pop_front();<br>      int td = gt[ ti.first.first ][ ti.first.second ][ ti.second.first ][ ti.second.second ] + 1;<br>      pair&lt; int, int &gt; na;<br>      pair&lt; int, int &gt; nb;<br>      for( int x = 0; x &lt; 9; x++ ) {<br>        if( vald( ti.first.first + dx[ x ], ti.first.second + dy[ x ] ) ) {<br>          na = ti.first;<br>          na.first += dx[ x ];<br>          na.second += dy[ x ];<br>          for( int y = 0; y &lt; 9; y++ ) {<br>            if( vald( ti.second.first + dx[ y ], ti.second.second + dy[ y ] ) ) {<br>              nb = ti.second;<br>              nb.first += dx[ y ];<br>              nb.second += dy[ y ];<br>              if( ( na != ti.second || nb != ti.first ) &amp;&amp; na != nb ) {<br>                if( gt[ na.first ][ na.second ][ nb.first ][ nb.second ] &gt; td ) {<br>                  gt[ na.first ][ na.second ][ nb.first ][ nb.second ] = td;<br>                  daq.push_back( make_pair( na, nb ) );<br>                }<br>              }<br>            }<br>          }<br>        }<br>      }<br>    }<br>    if( gt[ bx ][ by ][ ax ][ ay ] &gt; 1000000 ) {<br>      return -1;<br>    } else {<br>      return gt[ bx ][ by ][ ax ][ ay ];<br>    }<br>  }<br>};<br></td>