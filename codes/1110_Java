<td class="problemText" colspan="8" valign="middle" align="left">
            public class PathFinding<br>{<br>char[][] grid = new char[24][24];<br>int nr, nc;<br>int dist[][] = new int[24*24][24*24];<br>int queue[]= new int[24*24*24*24];<br>int qptr = 0, qtail = 0;<br>int dr[] = {0,-1,-1,-1,0,0,1,1,1};<br>int dc[] = {0,-1,0,1,-1,1,-1,0,1};<br> <br>public int minTurns(String[] bd)<br>{<br>   int sa = 0, sb = 0;<br> <br>   for (int r = 0; r &lt; 24; r++) for (int c = 0; c &lt; 24; c++) grid[r][c] = 'X';<br>   nr = bd.length; nc = bd[0].length();<br>   for (int r = 0; r &lt; nr; r++)<br>      for (int c = 0; c &lt; nc; c++) {<br>         grid[r+1][c+1] = bd[r].charAt(c);<br>         if (grid[r+1][c+1] == 'A') {<br>            sa = 24 * (r+1) + (c+1);<br>            grid[r+1][c+1] = '.';<br>         } else if (grid[r+1][c+1] == 'B') {<br>            sb = 24 * (r+1) + (c+1);<br>            grid[r+1][c+1] = '.';<br>         }<br>      }<br> <br>   for (int i = 0; i &lt; 24*24; i++) for (int j = 0; j &lt; 24*24; j++) dist[i][j] = -1;<br>   dist[sa][sb] = 0;<br>   queue[qptr++] = sa * 24 * 24 + sb;<br> <br>   while (qptr != qtail) {<br>      int cur = queue[qtail++];<br>      int a = cur / (24 * 24);<br>      int b = cur % (24 * 24);<br>      int ar = a / 24, ac = a % 24;<br>      int br = b / 24, bc = b % 24;<br> <br>//      System.out.println(dist[a][b] + ": " + ar + "," + ac + " " + br + "," + bc);<br>      for (int i = 0; i &lt; 9; i++) {<br>         int arr = ar + dr[i], acc = ac + dc[i];<br>         if (grid[arr][acc] == 'X') continue;<br> <br>         for (int j = 0; j &lt; 9; j++) {<br>            int brr = br + dr[j], bcc = bc + dc[j];<br>            if (grid[brr][bcc] == 'X') continue;<br> <br>//            System.out.println(" * " + arr + "," + acc + " " + brr + "," + bcc);<br>            // check for collision<br>            if (arr == brr &amp;&amp; acc == bcc) continue;<br> <br>            // check for swap positions<br>            if (ar == brr &amp;&amp; ac == bcc &amp;&amp; br == arr &amp;&amp; bc == acc) continue;<br> <br>            // check for duplicate position<br>            int aa = arr * 24 + acc;<br>            int bb = brr * 24 + bcc;<br>            if (dist[aa][bb] &gt;= 0) continue;<br> <br>            // new position<br>            dist[aa][bb] = dist[a][b] + 1;<br>            queue[qptr++] = aa * 24 * 24 + bb;<br>         }<br>      }<br>   }<br>   return dist[sb][sa];<br>}<br>}<br></td>