<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;fstream&gt;<br>#include &lt;numeric&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;bitset&gt;<br>#include &lt;list&gt;<br>#include &lt;stdexcept&gt;<br>#include &lt;functional&gt;<br>#include &lt;utility&gt;<br>#include &lt;ctime&gt;<br>using namespace std;<br><br>#define PB push_back<br>#define MP make_pair<br><br>#define REP(i,n) for(i=0;i&lt;(n);++i)<br>#define FOR(i,l,h) for(i=(l);i&lt;=(h);++i)<br>#define FORD(i,h,l) for(i=(h);i&gt;=(l);--i)<br><br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt;double&gt; VD;<br>typedef long long LL;<br>typedef pair&lt;int,int&gt; PII;<br><br>int step[55][55][55];<br>queue &lt;int&gt; Q;<br>int R,C;<br>int move[4][2]={-1,0,0,1,1,0,0,-1};<br>vector &lt;string&gt; mp;<br><br>bool in(int x,int y)<br>{<br>  if(x&lt;0||y&lt;0||x&gt;=R||y&gt;=C)<br>    return false;<br>  return true;<br>}<br><br>int bfs(int sX,int sY,int eX,int eY,int K)<br>{<br>  int cX,cY,cK,nX,nY,nK;<br>  while(!Q.empty()) Q.pop();<br>  memset(step,0xff,sizeof(step));<br>  step[sX][sY][K]=0;<br>  Q.push((sX*C+sY)*51+K);<br>  while(!Q.empty())<br>  {<br>    int u=Q.front();<br>    Q.pop();<br>    cK=u%51;<br>    u/=51;<br>    cX=u/C,cY=u%C;<br>    if(cX==eX&amp;&amp;cY==eY) return step[cX][cY][cK];<br>    if(mp[cX][cY]&gt;='1'&amp;&amp;mp[cX][cY]&lt;='9')<br>    {<br>      for(int d=0;d&lt;4;d++)<br>      {<br>        nX=cX+(mp[cX][cY]-'0')*move[d][0];<br>        nY=cY+(mp[cX][cY]-'0')*move[d][1];<br>        nK=cK;<br>        if(!in(nX,nY)) continue;<br>        if(mp[nX][nY]=='0'&amp;&amp;(nX!=eX||nY!=eY)) continue;<br>        if(step[nX][nY][nK]!=-1) continue;<br>        step[nX][nY][nK]=step[cX][cY][cK]+1;<br>        Q.push(((nX*C+nY))*51+nK);<br>      }<br>    }<br>    else if(mp[cX][cY]=='.')<br>    {<br>      if(cK&gt;0)<br>      {<br>        for(int i=1;i&lt;10;i++)<br>        {<br>          for(int d=0;d&lt;4;d++)<br>          {<br>            nX=cX+i*move[d][0];<br>            nY=cY+i*move[d][1];<br>            nK=cK-1;<br>            if(!in(nX,nY)) continue;<br>            if(mp[nX][nY]=='0'&amp;&amp;(nX!=eX||nY!=eY)) continue;<br>            if(step[nX][nY][nK]!=-1) continue;<br>            step[nX][nY][nK]=step[cX][cY][cK]+1;<br>            Q.push((nX*C+nY)*51+nK);<br>          }<br>        }<br>      }<br>    }<br>  }<br>  return -1;<br>}<br><br>class NumberLabyrinthDiv2<br>{<br>public:<br>    int getMinimumNumberOfMoves(vector &lt;string&gt; board, int r1, int c1, int r2, int c2, int K)<br>    {<br>    mp=board;<br>    R=mp.size(),C=mp[0].length();<br>    int ret=bfs(r1,c1,r2,c2,K);<br>    return ret;<br>    }<br>    <br><br>};<br><br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>