<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;numeric&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;queue&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstring&gt;<br>using namespace std;<br><br><br>int LCS(const string &amp;s1, const string &amp;s2){<br>  int l=min(s1.length(), s2.length());<br>  for(int i=0; i&lt;l; i++)<br>    if(s1[i]!=s2[i])<br>      return i;<br>  return l;<br>}<br><br>class YetAnotherHamiltonianPath {<br>  public:<br>  int leastCost(vector &lt;string&gt; label) {<br>    int res=0;<br>    int n=label.size();<br>    for(int i=0; i&lt;n; i++)<br>      res+=(i&lt;2 ? 1 : 2)*label[i].size()*label[i].size();<br>    for(; n&gt;2; n--){<br>      int best1=-1, best2=-1, best=-1;<br>      for(int i=0; i&lt;n; i++)<br>      for(int j=i+1; j&lt;n; j++){<br>        if(i==0 &amp;&amp; j==1)<br>          continue;<br>        int l=LCS(label[i], label[j]);<br>        if(l&gt;best){<br>          best1=i;<br>          best2=j;<br>          best=l;<br>        }<br>      }<br>      res-=best*best;<br>      label[best1]=label[best1].substr(0, best);<br>      label.erase(label.begin()+best2);<br>    }<br>    int l=LCS(label[0], label[1]);<br>    res-=l*l;<br>    return res;<br>  }<br>  <br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>