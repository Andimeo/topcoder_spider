<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cmath&gt;<br>#include &lt;algorithm&gt;<br><br>using namespace std;<br><br>class BarbarianInvasion2<br>{<br>public:<br>  double minimumTime(vector &lt;int&gt; boundaryX, vector &lt;int&gt; boundaryY, vector &lt;int&gt; cityX, vector &lt;int&gt; cityY)<br>  {<br>    double low = 0, high = 10000;<br>    int n = cityX.size();<br>    while (high - low &gt; max(1.0, low) * 1e-10)<br>    {<br>      double radius = (low + high) / 2.0;<br>      double sum[32];<br>      for (int i = 0; i &lt; (1 &lt;&lt; n); ++i)<br>        sum[i] = 0;<br>      bool broken = false;<br>      for (int i = 0; i &lt; boundaryX.size(); ++i)<br>      {<br>        double x0 = boundaryX[i];<br>        double y0 = boundaryY[i];<br>        double dx = boundaryX[(i + 1) % boundaryX.size()] - x0;<br>        double dy = boundaryY[(i + 1) % boundaryY.size()] - y0;<br>        vector&lt;double&gt; segments;<br>        segments.push_back(0);<br>        segments.push_back(1);<br>        for (int j = 0; j &lt; n; ++j)<br>        {<br>          double alpha = dx * dx + dy * dy;<br>          double beta = 2 * dx * (x0 - cityX[j]) + 2 * dy * (y0 - cityY[j]);<br>          double gamma = (x0 - cityX[j]) * (x0 - cityX[j]) + (y0 - cityY[j]) * (y0 - cityY[j]) - radius * radius;<br>          double delta = beta * beta - 4 * alpha * gamma;<br>          if (delta &gt;= 0)<br>          {<br>            double x1 = (-beta + sqrt(delta)) / (2 * alpha);<br>            if (x1 &gt; 0 &amp;&amp; x1 &lt; 1)<br>              segments.push_back(x1);<br>            double x2 = (-beta - sqrt(delta)) / (2 * alpha);<br>            if (x2 &gt; 0 &amp;&amp; x2 &lt; 1)<br>              segments.push_back(x2);<br>          }<br>          double slope = ((cityX[j] - x0) * dx + (cityY[j] - y0) * dy) / (dx * dx + dy * dy);<br>          if (slope &gt; 0 &amp;&amp; slope &lt; 1)<br>            segments.push_back(slope);<br>        }<br>        sort(segments.begin(), segments.end());<br>        for (int j = 0; j + 1 &lt; segments.size(); ++j)<br>        {<br>          double t = (segments[j] + segments[j + 1]) / 2;<br>          double mid_x = x0 + t * dx;<br>          double mid_y = y0 + t * dy;<br>          int inside = 0;<br>          for (int k = 0; k &lt; n; ++k)<br>            if ((mid_x - cityX[k]) * (mid_x - cityX[k]) + (mid_y - cityY[k]) * (mid_y - cityY[k]) &lt;= radius * radius)<br>              inside |= (1 &lt;&lt; k);<br>          if (inside == 0)<br>            broken = true;<br>          sum[inside] += sqrt(dx * dx + dy * dy) * (segments[j + 1] - segments[j]);<br>        }<br>      }<br>      if (broken)<br>        low = radius;<br>      else<br>      {<br>        int size = n + (1 &lt;&lt; n) + 2;<br>        double flow[50][50];<br>        double tot = 0;<br>        for (int i = 0; i &lt; (1 &lt;&lt; n); ++i)<br>          tot += sum[i];<br>        double avg = tot / n;<br>        memset(flow, 0, sizeof(flow));<br>        for (int i = 0; i &lt; n; ++i)<br>          flow[0][i + 1] = avg;<br>        for (int i = 0; i &lt; (1 &lt;&lt; n); ++i)<br>          for (int j = 0; j &lt; n; ++j)<br>            if (i &amp; (1 &lt;&lt; j))<br>              flow[j + 1][i + n + 1] = avg;<br>        for (int i = 0; i &lt; (1 &lt;&lt; n); ++i)<br>          flow[i + n + 1][size - 1] = sum[i];<br>        int last[50];<br>        while (1)<br>        {<br>          memset(last, 255, sizeof(last));<br>          last[0] = 0;<br>          while (last[size - 1] &lt; 0)<br>          {<br>            bool ok = true;<br>            for (int i = 0; i &lt; size; ++i)<br>              if (last[i] &gt;= 0)<br>                for (int j = 0; j &lt; size; ++j)<br>                  if (flow[i][j] &gt; 1e-11 &amp;&amp; last[j] &lt; 0)<br>                  {<br>                    last[j] = i;<br>                    ok = false;<br>                  }<br>            if (ok) <br>              break;<br>          }<br>          if (last[size - 1] &lt; 0)<br>            break;<br>          double add = tot;<br>          for (int i = size - 1; i &gt; 0; i = last[i])<br>            if (flow[last[i]][i] &lt; add)<br>              add = flow[last[i]][i];<br>          tot -= add;<br>          for (int i = size - 1; i &gt; 0; i = last[i])<br>          {<br>            flow[last[i]][i] -= add;<br>            flow[i][last[i]] += add;<br>          }<br>        }<br>        if (tot &gt; 1e-11)<br>          low = radius;<br>        else<br>          high = radius;<br><br>      }<br>    }<br>    return low;<br>  }<br>};<br></td>