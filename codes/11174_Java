<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import static java.lang.Math.*;<br> <br>public class BarbarianInvasion2 {<br>  public static void p(Object... o){System.out.println(Arrays.deepToString(o));}<br>  public double minimumTime(int[] boundaryX, int[] boundaryY, int[] cityX, int[] cityY) {<br>    N = cityX.length;<br>    C = new Point[N];<br>    for(int i = 0; i &lt; N;i++)<br>      C[i] =new Point(cityX[i], cityY[i]);<br>    B = new Point[boundaryX.length];<br>    for(int i = 0; i &lt; B.length;i++)<br>      B[i] = new Point(boundaryX[i], boundaryY[i]);<br>    <br>    double low = 0;<br>    double high = 5000;<br>    for(int i = 0; i &lt; 200;i++){<br>      double mid = (low+high)/2;<br>      if(pos(mid)){<br>        high = mid;<br>      }else{<br>        low = mid;<br>      }<br>    }<br>    return low;<br>  }<br>  static int N;<br>  static Point[] B, C;<br>  private boolean pos(double r) {<br>    Circle[] P = new Circle[N];<br>    for(int i = 0; i &lt; N;i++)<br>      P[i] = new Circle(C[i], r);<br>    double total = 0;<br>    double have = 0;<br>    double[] amt = new double[1&lt;&lt;N];<br>    for(int i = 0; i &lt; B.length;i++){<br>      Line l = new Line(B[i], B[(i+1)%B.length]);<br>      if(l.b.dist(l.a) &lt; eps)<br>        continue;<br>      total += l.b.dist(l.a);<br>      ArrayList&lt;Point&gt; inter = new ArrayList&lt;Point&gt;();<br>      inter.add(l.a);<br>      inter.add(l.b);<br>      for(Circle p:P){<br>        ArrayList&lt;Point&gt; ninter = circline(p, l);<br>        if(ninter == null)<br>          continue;<br>        for(Point in:ninter){<br>          if(onseg(l, in))<br>            inter.add(in);<br>        }<br>      }<br>      Collections.sort(inter, new Comp(l.b.sub(l.a).scale(1)));<br>      for(int j = 0; j &lt; inter.size()-1;j++){<br>        Point a = inter.get(j);<br>        Point b = inter.get(j+1);<br>        Point m = a.add(b).mult(0.5);<br>        double len = a.dist(b);<br>        int on = 0;<br>        for(int k = 0; k &lt; N;k++){<br>          if(C[k].dist(m) &lt;= r){<br>            on |= 1&lt;&lt;k;<br>          }<br>        }<br>        amt[on] += len;<br>        have += len;<br>      }<br>    }<br>    if(!EQ(have, total))<br>      return false;<br>    int NV = (1&lt;&lt;N)+N+2;<br>    double[][] F = new double[NV][NV];<br>    int st = NV-2;<br>    int en = NV-1;<br>    for(int i = 0; i &lt; (1&lt;&lt;N);i++){<br>      amt[i] /= total;<br>      F[st][i] = amt[i];<br>      for(int j = 0; j &lt; N;j++)<br>        if((i &amp; (1&lt;&lt;j)) != 0)<br>          F[i][(1&lt;&lt;N)+j] = 1;<br>    }<br>    for(int j = 0; j &lt; N;j++)<br>      F[(1&lt;&lt;N)+j][en] = 1./N;<br>    double flow = maxf(st, en, F);<br>    <br>    return EQ(flow, 1.0);<br>  }<br>  private double maxf(int st, int en, double[][] F) {<br>    double flow = 0;<br>    boolean[] V = new boolean[F.length];<br>    while(true){<br>      Arrays.fill(V, false);<br>      double nf = dfs(st, en, F, V, 1);<br>      if(nf &lt; 1e-12)<br>        break;<br>      flow += nf;<br>    }<br>    return flow;<br>  }<br>  private double dfs(int at, int en, double[][] F, boolean[] V, double f) {<br>    if(V[at])<br>      return 0.0;<br>    V[at] = true;<br>    if(at == en)<br>      return f;<br>    for(int i = 0; i &lt; F.length;i++){<br>      if(EQ(F[at][i], 0.0))<br>        continue;<br>      double nf = dfs(i, en, F, V, min(f, F[at][i]));<br>      if(nf &gt; 1e-12){<br>        F[at][i] -= nf;<br>        F[i][at] += nf;<br>        return nf;<br>      }<br>    }<br>    return 0;<br>  }<br>  static class Comp implements Comparator&lt;Point&gt;{<br>    Point sort;<br>    Comp(Point sort){<br>      this.sort = sort;<br>    }<br>    public int compare(Point a, Point b) {<br>      double va = sort.dot(a);<br>      double vb = sort.dot(b);<br>      if(va &lt; vb)<br>        return -1;<br>      if(va &gt; vb)<br>        return 1;<br>      return 0;<br>    }<br>  }<br>  <br>  <br>  static double eps = 5e-11;<br>  static boolean EQ(double a, double b){return abs(a-b) &lt; eps;}<br>  static double SQ(double d){return d*d;}<br>  static boolean onseg(Line l, Point p){ //tested<br>    return online(l, p) &amp;&amp; between(l.a.x, l.b.x, p.x) &amp;&amp; between(l.a.y, l.b.y, p.y);<br>  }<br>  private static boolean between(double a, double b, double c) {<br>    return min(a,b)-eps &lt;= c &amp;&amp; c &lt;= max(a,b)+eps;<br>  }<br>  static boolean online(Line l, Point p){ //tested<br>    return EQ(ccw(l.a, l.b, p), 0);<br>  }<br>  static double ccw(Point p1, Point p2, Point p3){//tested<br>    return p2.sub(p1).cross(p3.sub(p1)); //left is 1, right is -1<br>  }<br>  static class Point{<br>    double x, y;<br>    public Point(double x, double y){this.x = x;this.y = y;}<br>    Point add(Point p){return new Point(x+p.x, y+p.y);}<br>    Point sub(Point p){return new Point(x-p.x, y-p.y);}<br>    Point mult(double d){return new Point(x*d, y*d);}<br>    double dot(Point p){return x*p.x+ y*p.y;}<br>    double cross(Point p){return x*p.y - y*p.x;}<br>    double len(){return hypot(x, y);}<br>    Point scale(double d){return mult(d/len());}<br>    double dist(Point p){return sub(p).len();}<br>    Point perp(){return new Point(-y, x);}<br>  }  <br>  static class Circle{<br>    Point p;double r;<br>    public Circle(Point p, double r){this.p = p;this.r = r;}<br>  }<br>  static Point pointline(Point p, Line l){<br>    Point v = l.b.sub(l.a).scale(1);<br>    double dot = p.sub(l.a).dot(v);<br>    return l.a.add(v.mult(dot));<br>  }<br>  static ArrayList&lt;Point&gt; circline(Circle c, Line l){//tested<br>    Point x = pointline(c.p, l);<br>    double d = x.dist(c.p);<br>    if(d &gt; c.r) return new ArrayList&lt;Point&gt;();<br>    double h = sqrt(max(0, SQ(c.r) - SQ(d)));<br>    Point perp = l.a.sub(l.b);<br>    return makeVec(x.add(perp.scale(h)), x.add(perp.scale(-h)));<br>  }<br>  static class Line{<br>    Point a, b;<br>    Line(Point a, Point b){this.a = a;this.b = b;}<br>  }<br>  static ArrayList&lt;Point&gt; makeVec(Point...P){<br>    ArrayList&lt;Point&gt; ans = new ArrayList&lt;Point&gt;();<br>    for(Point p:P)<br>      ans.add(p);<br>    return ans;<br>  }<br>}<br></td>