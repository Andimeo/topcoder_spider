<td class="problemText" colspan="8" valign="middle" align="left">
            import java.math.BigInteger;<br>import java.util.Arrays;<br><br>public class AppleTrees {<br>  private static final long MOD = 1000000007;<br><br>  public int theCount(int D, int[] r) {<br>    int n = r.length;<br>    long[][] q = new long[n + 1][80 * n + 1];<br>    q[1][0] = 1;<br>    long[][] qq = new long[n + 1][80 * n + 1];<br>    Arrays.sort(r);<br>    for (int i = n - 1; i &gt;= 0; i--) {<br>      for (int j = 1; j &lt;= n; j++) {<br>        for (int k = 0; k &lt;= 80 * n; k++) {<br>          if (q[j][k] == 0)<br>            continue;<br>          qq[j - 1][k] += q[j][k] * j;<br>          qq[j][k + r[i] - 1] += q[j][k] * 2 * j;<br>          if (j &lt; n)<br>            qq[j + 1][k + 2 * r[i] - 2] += q[j][k] * j;<br>        }<br>      }<br>      for (int j = 0; j &lt;= n; j++) {<br>        for (int k = 0; k &lt;= 80 * n; k++) {<br>          q[j][k] = qq[j][k] % MOD;<br>          qq[j][k] = 0;<br>        }<br>      }<br>    }<br>    long[] f = new long[D + n + 1];<br>    long[] of = new long[D + n + 1];<br>    f[0] = of[0] = 1;<br>    BigInteger mod = BigInteger.valueOf(MOD);<br>    for (int i = 1; i &lt;= D + n; i++) {<br>      f[i] = (f[i - 1] * i) % MOD;<br>      of[i] = (of[i - 1] * BigInteger.valueOf(i).modInverse(mod).longValue()) % MOD;<br>    }<br>    long ans = 0;<br>    for (int i = n; i &lt;= 81 * n &amp;&amp; i &lt;= D; i++) {<br>      long cur = (q[0][i - n] * f[D - i + n]) % MOD;<br>      cur = (cur * of[n]) % MOD;<br>      cur = (cur * of[D - i]) % MOD;<br>      ans += cur;<br>    }<br>    return (int) (ans % MOD);<br>  }<br><br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.12 [modified TZTester]<br>// Powered by CodeProcessor<br></td>