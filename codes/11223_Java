<td class="problemText" colspan="8" valign="middle" align="left">
            import java.math.BigInteger;<br><br>public class FoxJumping {<br>    int MODULO = 10007;<br><br>    public int getCount(int Tx, int Ty, int Mx, int My, int R, int[] _bad) {<br>        int[][] waysX = new int[R + 1][Tx + 1];<br>        int[][] waysY = new int[R + 1][Ty + 1];<br>        waysX[0][0] = 1;<br>        waysY[0][0] = 1;<br>        for (int steps = 0; steps &lt; R; ++steps) {<br>            int oldSum = 0;<br>            for (int sum = 0; sum &lt;= Tx; ++sum) {<br>                oldSum += waysX[steps][sum];<br>                if (sum - Mx - 1 &gt;= 0)<br>                    oldSum -= waysX[steps][sum - Mx - 1];<br>                waysX[steps + 1][sum] = oldSum % MODULO;<br>            }<br>            oldSum = 0;<br>            for (int sum = 0; sum &lt;= Ty; ++sum) {<br>                oldSum += waysY[steps][sum];<br>                if (sum - My - 1 &gt;= 0)<br>                    oldSum -= waysY[steps][sum - My - 1];<br>                waysY[steps + 1][sum] = oldSum % MODULO;<br>            }<br>        }<br>        int[] bad = new int[_bad.length + 1];<br>        for (int i = 0; i &lt; _bad.length; ++i)<br>            bad[i + 1] = _bad[i] / 10;<br>        int[][] sumWays = new int[R + 1][Math.min(Tx, Ty) / 10 + 1];<br>        sumWays[0][0] = 1;<br>        for (int steps = 0; steps &lt; R; ++steps) {<br>            int[] arr = sumWays[steps];<br>            int[] narr = sumWays[steps + 1];<br>            for (int got = 0; got &lt; arr.length; ++got) {<br>                for (int cur : bad) {<br>                    if (got + cur &lt; narr.length) {<br>                        narr[got + cur] += arr[got];<br>                    }<br>                }<br>            }<br>            for (int i = 0; i &lt; narr.length; ++i)<br>                narr[i] %= MODULO;<br>        }<br>        int[] inv = new int[MODULO];<br>        for (int i = 1; i &lt; MODULO; ++i)<br>            inv[i] = BigInteger.valueOf(i).modInverse(BigInteger.valueOf(MODULO)).intValue();<br>        int res = 0;<br>        int comb = 1;<br>        for (int steps = 0; steps &lt;= R; ++steps) {<br>            int sign = (steps % 2 == 0) ? 1 : -1;<br>            for (int badSum = 0; badSum &lt; sumWays[steps].length; ++badSum) {<br>                int cur = waysX[R - steps][Tx - badSum * 10] * waysY[R - steps][Ty - badSum * 10] % MODULO;<br>                cur = cur * sumWays[steps][badSum] % MODULO;<br>                cur = cur * comb % MODULO;<br>                res = (res + sign * cur + MODULO) % MODULO;<br>            }<br>            comb *= (R - steps);<br>            comb %= MODULO;<br>            comb *= inv[steps + 1];<br>            comb %= MODULO;<br>        }<br>        return res;<br>    }<br>}<br></td>