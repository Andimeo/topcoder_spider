<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br>public class InfiniteLab<br>{<br>    int[,] BFS(string[] map, long r, int c, long min_r, long max_r)<br>    {<br>        int H = map.Length;<br>        int W = map[0].Length;<br>        int[,] distance = new int[max_r - min_r + 1, W];<br>        for (int i = 0; i &lt;= max_r - min_r; ++i)<br>            for (int j = 0; j &lt; W; ++j)<br>                distance[i, j] = -1;<br>        long[] qx = new long[(max_r - min_r + 1) * W];<br>        int[] qy = new int[(max_r - min_r + 1) * W];<br>        int[] dr = {0, 0, -1, 1 };<br>        int[] dc = {-1, 1, 0, 0 };<br>        qx[0] = r;<br>        qy[0] = c;<br>        distance[r - min_r, c] = 0;<br>        int cl = 0;<br>        int op = 1;<br>        while (cl &lt; op)<br>        {<br>            r = qx[cl];<br>            c = qy[cl];<br>            ++cl;<br>            for (int direction = 0; direction &lt; 4; ++direction)<br>            {<br>                long r0 = r + dr[direction];<br>                int c0 = c + dc[direction];<br>                if (r0 &gt;= min_r &amp;&amp; r0 &lt;= max_r &amp;&amp; c0 &gt;= 0 &amp;&amp; c0 &lt; W &amp;&amp; map[(r0 % H + H) % H][c0] != '#' &amp;&amp; distance[r0 - min_r, c0] &lt; 0)<br>                {<br>                    distance[r0 - min_r, c0] = distance[r - min_r, c] + 1;<br>                    qx[op] = r0;<br>                    qy[op] = c0;<br>                    ++op;<br>                }<br>            }<br>            int sr = (int)((r % H + H) % H);<br>            if (map[sr][c] == 'T')<br>            {<br>                int c0 = 0;<br>                while (c0 == c || map[sr][c0] != 'T')<br>                    ++c0;<br>                if (distance[r - min_r, c0] &lt; 0)<br>                {<br>                    distance[r - min_r, c0] = distance[r - min_r, c] + 1;<br>                    qx[op] = r;<br>                    qy[op] = c0;<br>                    ++op;<br>                }<br>            }<br>        }<br>        return distance;<br>    }<br>    public long getDistance(string[] map, long r1, int c1, long r2, int c2)<br>  {<br>        if (r1 &gt; r2)<br>        {<br>            long t = r1;<br>            r1 = r2;<br>            r2 = t;<br>            int tt = c1;<br>            c1 = c2;<br>            c2 = tt;<br>        }<br>        int H = map.Length;<br>        int W = map[0].Length;<br>        if (r2 - r1 &lt;= 2000)<br>        {<br>            int[,] d = BFS(map, r1, c1, Math.Min(r1, r2) - 1000, Math.Max(r1, r2) + 1000);<br>            return d[r2 - Math.Min(r1, r2) + 1000, c2];<br>        }<br>        int[,] d1 = BFS(map, r1, c1, r1 - 1000, r1 + 1000);<br>        int[,] d2 = BFS(map, r2, c2, r2 - 1000, r2 + 1000);<br>        long results = -1;<br>        for (int i = 0; i &lt; W; ++i)<br>        {<br>            int[,] d0 = BFS(map, 0, i, -1000, 1000);<br>            for (int d = 1; d &lt;= 20; ++d)<br>            {<br>                long x1 = r1 + 500;<br>                long x2 = r2 - 500;<br>                while (x1 % H != 0)<br>                    --x1;<br>                while ((x2 - x1) % (d * H) != 0)<br>                    ++x2;<br>                if (d1[x1 - r1 + 1000, i] &lt; 0)<br>                    continue;<br>                if (d2[x2 - r2 + 1000, i] &lt; 0)<br>                    continue;<br>                int p = d0[d * H + 1000, i];<br>                if (p &lt; 0)<br>                    continue;<br>                long distance = (x2 - x1) / (d * H) * (long)p + (long)d1[x1 - r1 + 1000, i] + (long)d2[x2 - r2 + 1000, i];<br>                if (results &lt; 0 || distance &lt; results)<br>                    results = distance;<br>            }<br>        }<br>        return results;<br>  }<br>}<br></td>