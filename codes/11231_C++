<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cmath&gt;<br>#include &lt;sstream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>using namespace std;<br>#define pb push_back<br>#define INF 1000000000<br>#define L(s) (int)((s).size())<br>#define FOR(i,a,b) for (int _n(b), i(a); i &lt;= _n; i++)<br>#define FORD(i,a,b) for(int i=(a),_b=(b);i&gt;=_b;i--)<br>#define rep(i,n) FOR(i,1,(n))<br>#define rept(i,n) FOR(i,0,(n)-1)<br>#define C(a) memset((a),0,sizeof(a))<br>#define ll long long<br>#define mp make_pair<br>#define pii pair&lt;int,int&gt;<br>#define x first<br>#define y second<br>#define pll pair&lt;ll,ll&gt;<br>#define INFLL 1000000000000000000LL<br><br>char mas[22][22];<br>int n,m;<br>int ds[1002][22],dh[22],dl[22],sm[22][22];<br>ll mt[22][22],res[22][22],tmp[22][22],o[22][22];<br>inline void mul(ll a[][22],ll b[][22])<br>{<br>  rept(i,m)<br>  {<br>    rept(j,m)<br>    {<br>      ll t=INFLL;<br>      rept(z,m)<br>      {<br>        t=min(t,a[i][z]+b[z][j]);<br>      }<br>      tmp[i][j]=t;<br>    }<br>  }<br>  rept(i,m) rept(j,m) a[i][j]=tmp[i][j];<br>}<br>inline int norm(ll r)<br>{<br>  r%=n;<br>  if (r&lt;0) r+=n;<br>  return (int)r;<br>}<br>const int di[]={0,1,0,-1};<br>const int dj[]={1,0,-1,0};<br>queue&lt;pii&gt; q;<br>void bfs(int bi,int bj)<br>{<br>  memset(ds,63,sizeof(ds));<br>  if (mas[norm(bi)][bj]=='#') return;<br>  ds[bi+500][bj]=0;<br>  while (!q.empty()) q.pop();<br>  q.push(mp(bi,bj));<br>  while (!q.empty())<br>  {<br>    int ci=q.front().x;<br>    int cj=q.front().y;<br>    int cd=ds[ci+500][cj];<br>    q.pop();<br>    rept(l,4)<br>    {<br>      int ni=ci+di[l];<br>      int nj=cj+dj[l];<br>      if (nj&lt;0 || nj&gt;=m) continue;<br>      if (abs(ni)&gt;n*(m+3)) continue;<br>      if (mas[norm(ni)][nj]=='#') continue;<br>      if (cd+1&lt;ds[ni+500][nj])<br>      {<br>        ds[ni+500][nj]=cd+1;<br>        q.push(mp(ni,nj));<br>      }<br>    }<br>    if (mas[norm(ci)][cj]=='T')<br>    {<br>      rept(j,m)<br>      {<br>        if (j!=cj &amp;&amp; mas[norm(ci)][j]=='T')<br>        {<br>          if (cd+1&lt;ds[ci+500][j])<br>          {<br>            ds[ci+500][j]=cd+1;<br>            q.push(mp(ci,j));<br>          }<br>          break;<br>        }<br>      }<br>    }<br>  }<br>}<br>class InfiniteLab <br>  {<br>    public:<br>       long long getDistance( vector &lt;string&gt; ma, long long r1, int c1, long long r2, int c2 )<br>    {<br>      if (r1&lt;r2)<br>      {<br>        swap(r1,r2);<br>        swap(c1,c2);<br>      }<br>      n=L(ma); m=L(ma[0]);<br>      rept(i,n) rept(j,m) mas[i][j]=ma[i][j];<br>      ll d=r1-norm(r1);<br>      r1-=d; r2-=d;<br>      bfs((int)r1,c1);<br>      if (-r2&lt;=n*(m+2))<br>      {<br>        int o=ds[(int)r2+500][c2];<br>        if (o&gt;=INF) return -1; else<br>        return o;<br>      }<br>      ll prev=r2+1;<br>      while (prev%n!=0) ++prev;<br>      rept(j,m) dh[j]=ds[500][j];<br>      bfs(norm(r2),c2);<br>      rept(j,m) dl[j]=ds[n+500][j];<br>      rept(j,m)<br>      {<br>        bfs(0,j);<br>        rept(z,m) sm[j][z]=ds[500-n][z];<br>      }<br>      prev/=n;<br>      rept(i,m)<br>      {<br>        rept(j,m)<br>        {<br>          if (sm[i][j]&lt;INF) mt[i][j]=sm[i][j]; else<br>          mt[i][j]=INFLL;<br>          if (i==j) res[i][j]=0; else<br>          res[i][j]=INFLL;<br>        }<br>      }<br>      ll st=prev;<br>      while (st)<br>      {<br>        if (st%2) mul(res,mt);<br>        mul(mt,mt);<br>        st/=2;<br>      }<br>      ll ans=INFLL;<br>      rept(i,m)<br>      {<br>        rept(j,m)<br>        {<br>          ll t=res[i][j];<br>          if (dh[i]&lt;INF) t+=dh[i]; else<br>          continue;<br>          if (dl[j]&lt;INF) t+=dl[j]; else<br>          continue;<br>          ans=min(ans,t);<br>        }<br>      }<br>      if (ans==INFLL) ans=-1;<br>      return ans;<br>    }<br>  };<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>