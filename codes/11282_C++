<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>struct disjoin_set{<br>  int parent[55], rank[55];<br>  int Find(int x){<br>    if (parent[x] != x)  parent[x] = Find(parent[x]);<br>    return parent[x];<br>  }<br>  void MakeSet(int id){<br>    parent[id] = id;<br>    rank[id] = 1;<br>  }<br>  void Union(int x, int y){<br>    int xRoot = Find(x);<br>    int yRoot = Find(y);<br>    if (xRoot == yRoot) return;<br>    if (rank[xRoot] &lt; rank[yRoot])<br>      parent[xRoot] = yRoot;<br>    else if (rank[yRoot] &lt; rank[xRoot])<br>      parent[yRoot] = xRoot;<br>    else{<br>      parent[yRoot] = xRoot;<br>      rank[xRoot]++;<br>    }<br>  }<br>};<br><br>struct node{<br>  int x, y, l;<br>  node(){}<br>  node(int xx, int yy, int ll){<br>    x = xx; y = yy; l = ll;<br>  }<br>};<br><br>bool cmp1(const node &amp;a, const node &amp;b){<br>  return a.l &gt; b.l;<br>}<br><br>bool cmp2(const node &amp;a, const node &amp;b){<br>  return a.l &lt; b.l;<br>}<br><br>class KingdomReorganization{<br>public:<br>  int cost(char ch){<br>    if ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z')<br>      return ch - 'A';<br>    else<br>      return ch - 'a' + 26;<br>  }<br>  int getCost(vector &lt;string&gt; kingdom, vector &lt;string&gt; build, vector &lt;string&gt; destroy){<br>    vector&lt;node&gt; E1, E2;<br>    int n = kingdom.size();<br>    for (int i = 0; i &lt; n; i++)<br>      for (int j = 0; j &lt; i; j++)<br>        if (kingdom[i][j] == '1')<br>          E1.push_back(node(i, j, cost(destroy[i][j])));<br>        else<br>          E2.push_back(node(i, j, cost(build[i][j])));<br>    disjoin_set S;<br>    for (int i = 0; i &lt; n; i++)<br>      S.MakeSet(i);<br>    vector&lt;node&gt;::iterator ii;<br>    int cost = 0;<br>    sort(E1.begin(), E1.end(), cmp1);<br>    for (ii = E1.begin(); ii != E1.end(); ii++)<br>      if (S.Find(ii-&gt;x) != S.Find(ii-&gt;y))<br>        S.Union(ii-&gt;x, ii-&gt;y);<br>      else<br>        cost += ii-&gt;l;<br>    sort(E2.begin(), E2.end(), cmp2);<br>    for (ii = E2.begin(); ii != E2.end(); ii++)<br>      if (S.Find(ii-&gt;x) != S.Find(ii-&gt;y)){<br>        S.Union(ii-&gt;x, ii-&gt;y);<br>        cost += ii-&gt;l;<br>      }<br>    return cost;<br>  }<br>};<br></td>