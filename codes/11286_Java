<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class FoxSearchingRuins {<br>    static class RunningMaxes {<br>        int[] v;<br> <br>        public RunningMaxes(int size) {<br>            v = new int[size];<br>        }<br> <br>        public void update(int at, int what) {<br>            if (at &lt; 0) at = 0;<br>            while (at &lt; v.length) {<br>                v[at] = Math.max(v[at], what);<br>                at = at | (at + 1);<br>            }<br>        }<br> <br>        public int getMax(int right) {<br>            int res = 0;<br>            while (right &gt;= 0) {<br>                res = Math.max(res, v[right]);<br>                right = (right &amp; (right + 1)) - 1;<br>            }<br>            return res;<br>        }<br>    }<br> <br>  public long theMinTime(int W, int H, int jewelCount, int LR, int goalValue, int timeX, int timeY, int[] _seeds) {<br>        long[] seeds = new long[_seeds.length];<br>        for (int i = 0; i &lt; seeds.length; ++i) seeds[i] = _seeds[i];<br>        int[] x = new int[jewelCount];<br>        int[] y = new int[jewelCount];<br>        int[] v = new int[jewelCount];<br>        x[0] = (int) ((seeds[1] * seeds[0] + seeds[2]) % W);<br>        y[0] = (int) ((seeds[4] * seeds[3] + seeds[5]) % H);<br>        v[0] = (int) ((seeds[7] * seeds[6] + seeds[8]) % seeds[9]);<br>        for (int i = 1; i &lt; jewelCount; ++i) {<br>            x[i] = (int) ((seeds[1] * x[i-1] + seeds[2]) % W);<br>            y[i] = (int) ((seeds[4] * y[i-1] + seeds[5]) % H);<br>            v[i] = (int) ((seeds[7] * v[i-1] + seeds[8]) % seeds[9]);<br>        }<br>        RunningMaxes[] xplusmoves = new RunningMaxes[W + LR + 1];<br>        for (int i = 0; i &lt; xplusmoves.length; ++i)<br>            xplusmoves[i] = new RunningMaxes(W);<br>        RunningMaxes[] xminusmoves = new RunningMaxes[W + LR + 1];<br>        for (int i = 0; i &lt; xminusmoves.length; ++i)<br>            xminusmoves[i] = new RunningMaxes(W);<br>        TreeSet&lt;Integer&gt; allYs = new TreeSet&lt;Integer&gt;();<br>        for (int ay : y) allYs.add(ay);<br>        long res = Long.MAX_VALUE;<br>        for (int nextY : allYs) {<br>            int[] totalV = new int[W];<br>            for (int i = 0; i &lt; jewelCount; ++i)<br>                if (y[i] == nextY)<br>                    totalV[x[i]] += v[i];<br>            int[] possible = new int[W];<br>            int npossible = 0;<br>            for (int ax = 0; ax &lt; W; ++ax) if (totalV[ax] &gt; 0) possible[npossible++] = ax;<br>            int[][] nbest1 = new int[npossible][LR + 1];<br>            int[][] nbest2 = new int[npossible][LR + 1];<br>            for (int i = 0; i &lt; npossible; ++i) {<br>                int ax = possible[i];<br>                for (int moves = 0; moves &lt;= LR; ++moves) {<br>                    nbest1[i][moves] = totalV[ax] + Math.max(xminusmoves[ax + LR - moves].getMax(ax), xplusmoves[ax + moves].getMax(W - 1 - ax));<br>                    if (i &gt; 0 &amp;&amp; moves &gt;= possible[i] - possible[i - 1])<br>                        nbest1[i][moves] = Math.max(nbest1[i][moves], nbest1[i - 1][moves - (possible[i] - possible[i - 1])] + totalV[ax]);<br>                }<br>            }<br>            for (int i = npossible - 1; i &gt;= 0; --i) {<br>                int ax = possible[i];<br>                for (int moves = 0; moves &lt;= LR; ++moves) {<br>                    nbest2[i][moves] = totalV[ax] + Math.max(xminusmoves[ax + LR - moves].getMax(ax), xplusmoves[ax + moves].getMax(W - 1 - ax));<br>                    if (i + 1 &lt; npossible &amp;&amp; moves &gt;= possible[i + 1] - possible[i])<br>                        nbest2[i][moves] = Math.max(nbest2[i][moves], nbest2[i + 1][moves - (possible[i + 1] - possible[i])] + totalV[ax]);<br>                }<br>            }<br>            for (int i = 0; i &lt; npossible; ++i) {<br>                int ax = possible[i];<br>                for (int moves = 0; moves &lt;= LR; ++moves) {<br>                    int best = Math.max(nbest1[i][moves], nbest2[i][moves]);<br>                    if (best &gt;= goalValue) {<br>                        res = Math.min(res, (long) moves * timeX + (long) nextY * timeY);<br>                    }<br>                    xminusmoves[ax + LR - moves].update(ax, best);<br>                    xplusmoves[ax + moves].update(W - 1 - ax, best);<br>                }<br>            }<br>        }<br>        return res == Long.MAX_VALUE ? -1 : res;<br>  }<br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>