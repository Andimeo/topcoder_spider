<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;iosfwd&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;cctype&gt;<br>#include &lt;vector&gt;<br>#include &lt;bitset&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;map&gt;<br>#include &lt;deque&gt;<br>#include &lt;string&gt;<br>#include &lt;list&gt;<br>#include &lt;iterator&gt;<br>#include &lt;sstream&gt;<br>#include &lt;complex&gt;<br>#include &lt;fstream&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;algorithm&gt;<br><br>using namespace std;<br><br>#define SHOW(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl<br>#define LET(x, a) __typeof(a) x = a<br>#define FOREACH(it, v) for(LET(it, (v).begin()); it != (v).end(); ++it)<br><br>typedef long long LL;<br><br>template &lt;class T&gt; inline int size(const T&amp; c) {return (int) c.size();}<br><br>struct Graph<br>{<br>  vector &lt; vector &lt;int&gt; &gt; matrix;<br>  vector &lt;int&gt; matchedWith, level, parent, weight;<br>  vector &lt;bool&gt; S, T; int N;<br>  void initialize(int N) {<br>    this -&gt; N = N;<br>    matrix.assign(2 * N + 1, vector &lt;int&gt; (2 * N + 1, 0));<br>  }<br>  void addEdge(int u, int v, int w) {<br>    matrix[u + 1][v + 1 + N] = w;<br>  }<br>  bool augmentPath(int u) {<br>    level.assign(2 * N + 1, 0);<br>    parent.assign(2 * N + 1, 0);<br>    queue &lt;int&gt; q; q.push(u);<br>    level[u] = 1; int last = 0;<br>    while (!q.empty() &amp;&amp; (last == 0)) {<br>      int v = q.front(); q.pop();<br>      if (level[v] &amp; 1) {<br>        for (int w = N + 1; w &lt;= (2 * N); w++) {<br>          if (!level[w] &amp;&amp; (matrix[v][w] == weight[v] + weight[w])) {<br>            if (!matchedWith[w]) {<br>              parent[w] = v; last = w;<br>              break;<br>            }<br>            else if(matchedWith[w] != v) {<br>              parent[w] = v; q.push(w);<br>              level[w]  = level[v] + 1;<br>            }<br>          }<br>        }<br>      }<br>      else {<br>        int w = matchedWith[v];<br>        parent[w] = v; q.push(w);<br>        level[w] = level[v] + 1;<br>      }<br>    }<br>    if (last != 0) {<br>      for (int w = last; w != 0; w = parent[parent[w]])<br>        matchedWith[w] = parent[w], matchedWith[parent[w]]  = w;<br>      return true;<br>    }<br>    else {<br>      for (int v = 1; v &lt;= N; v++) {<br>        if (level[v] != 0) S[v] = true;<br>        if (level[N + v] != 0) T[N + v] = true;<br>      }<br>      return false;<br>    }<br>  }<br>  int matching() {<br>    matchedWith.assign(2 * N + 1, 0);<br>    weight.assign(2 * N + 1, 0);<br>    for (int i = 1; i &lt;= N; i++) {<br>      int nmax = 0;<br>      for (int j = N + 1; j &lt;= (2 * N); j++)<br>        nmax = max(nmax, matrix[i][j]);<br>      weight[i] = nmax;<br>      weight[i + N] = 0;<br>    }<br>    int nMatch   = 0;<br>    while (true) {<br>      S.assign(2 * N + 1, false);<br>      T.assign(2 * N + 1, false);<br>      for (int i = 1; i &lt;= N; i++)<br>        if (!matchedWith[i] &amp;&amp; augmentPath(i))<br>          nMatch++;<br>      if(nMatch == N) break;<br>      int bottle = (1 &lt;&lt; 30);<br>      for (int i = 1; i &lt;= N; i++)<br>        if(S[i] == true)<br>          for (int j = N + 1; j &lt;= (2 * N); j++)<br>            if(T[j] == false) {<br>              int slack = weight[i] + weight[j] - matrix[i][j];<br>              bottle = min(bottle, slack);<br>            }<br>      for (int i = 1; i &lt;= N; i++) {<br>        if(S[i] == true) weight[i] -= bottle;<br>        if(T[i + N] == true) weight[i + N]  += bottle;<br>      }<br>    }<br>    int matching = 0;<br>    for (int i = 1; i &lt;= N; ++i)<br>      matching += matrix[i][matchedWith[i]];<br>    return matching;<br>  }<br>};<br><br><br>struct DoubleRoshambo<br>{<br>  bool greater(char x, char y) {<br>    if (x == 'R' &amp;&amp; y == 'S') return true;<br>    if (x == 'S' &amp;&amp; y == 'P') return true;<br>    if (x == 'P' &amp;&amp; y == 'R') return true;<br>    return false;<br>  }<br>  int score(string&amp; x, string&amp; y) {<br>    if (greater(x[1], y[1]) &amp;&amp; greater(x[0], y[0]))<br>      return 2;<br>    else if (greater(x[1], y[1]) &amp;&amp; x[0] == y[0])<br>      return 1;<br>    else<br>      return 0;<br>  }<br>  int maxScore(vector &lt;string&gt; A, vector &lt;string&gt; E) {<br>    Graph graph; graph.initialize(size(A));<br>    for (int i = 0; i &lt; size(A); ++i)<br>      for (int j = 0; j &lt; size(E); ++j)<br>        graph.addEdge(i, j, score(A[i], E[j]));<br>    return graph.matching();<br>  }<br>};<br></td>