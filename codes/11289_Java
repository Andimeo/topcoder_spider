<td class="problemText" colspan="8" valign="middle" align="left">
            /** @author lucis  */<br>import java.util.Arrays;<br>public class DoubleRoshambo {<br> <br>  public int maxScore(String[] A, String[] E) {<br>    int source = A.length+E.length;<br>    int sink = source+1;<br>    int numNodes = sink+1;<br>    int[][] capacity = new int[numNodes][numNodes];<br>    int[][] cost = new int[numNodes][numNodes];<br>    <br>    for (int i = 0; i &lt; A.length; i++) {<br>      capacity[source][i] = 1;<br>      cost[source][i] = 0;<br>    }<br>    <br>    for (int i = 0; i &lt; E.length; i++) {<br>      capacity[A.length+i][sink] = 1;<br>      cost[A.length+i][sink] = 0;<br>    }<br> <br>    for (int a = 0; a &lt; A.length; a++) {<br>      for (int e = 0; e &lt; E.length; e++) {<br>        int aIndex = a;<br>        int eIndex = A.length+e;<br>        <br>        capacity[aIndex][eIndex] = 1;<br>        cost[aIndex][eIndex] = -1*scoreAVsB(A[a], E[e]);<br>        cost[eIndex][aIndex] = -1*cost[aIndex][eIndex];<br>      }<br>    }<br>    <br>    return -1*minCostMaxFlow(capacity, cost, source, sink);<br>  }<br>  <br>  private int scoreAVsB(String a, String b) {<br>    char aLeft = a.charAt(0);<br>    char aRight = a.charAt(1);<br>    char bLeft = b.charAt(0);<br>    char bRight = b.charAt(1);<br> <br>    if(beats(aRight, bRight) &amp;&amp; beats(aLeft, bLeft)) return 2;<br>    if(beats(aRight, bRight) &amp;&amp; aLeft == bLeft) return 1;<br>    return 0;<br>  }<br>  <br>  private boolean beats(char a, char b) {<br>    if(a == 'P' &amp;&amp; b == 'R') return true;<br>    if(a == 'S' &amp;&amp; b == 'P') return true;<br>    if(a == 'R' &amp;&amp; b == 'S') return true;<br>    return false;<br>  }<br>  <br>  public static int minCostMaxFlow(int[][] capacity, int[][] cost, int source, int sink) {<br>    final int NO_PARENT = -1;<br>    final int INF = Integer.MAX_VALUE/5;<br>    int nodes = capacity.length;<br>    int result = 0;<br>    boolean minPathFound;<br>    <br>    do {<br>      int[] distance = new int[nodes];<br>      int[] parent = new int[nodes];<br> <br>      Arrays.fill(distance, INF);<br>      Arrays.fill(parent, NO_PARENT);<br>      distance[source] = 0;<br>      <br>      for (int i = 0; i &lt; distance.length; i++) {<br>        if(capacity[source][i] &gt; 0) {<br>          parent[i] = source;<br>          distance[i] = cost[source][i];<br>        }<br>      }<br>      while(true) {<br>        boolean updated = false;<br>        for (int i = 0; i &lt; nodes; i++) {<br>          if(distance[i] &lt; INF) {<br>            for (int j = 0; j &lt; nodes; j++) {<br>              if(capacity[i][j] &gt; 0) {<br>                int costByI = distance[i]+cost[i][j];<br>                if(distance[j] &gt; costByI) {<br>                  parent[j] = i;<br>                  distance[j] = costByI;<br>                  updated = true;<br>                }<br>              }<br>            }<br>          }<br>        }<br>        if(!updated) break;<br>      }<br>      <br>      minPathFound = parent[sink] != NO_PARENT;<br>      <br>      if(minPathFound) {<br>        int removed = 0;<br>        result += distance[sink];<br>        int curr = sink;<br>        while(curr != NO_PARENT) {<br>          int parNode = parent[curr];<br>          if(parNode != NO_PARENT) {<br>            capacity[parNode][curr]--;<br>            capacity[curr][parNode]++;<br>            removed++;<br>          }<br>          curr = parNode;<br>        }<br>      }<br>    } while (minPathFound);<br>    <br>    return result;<br>  }<br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>