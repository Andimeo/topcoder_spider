<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class OneDimensionalBalls<br>{<br>    public long countValidGuesses(int[] firstPicture, int[] secondPicture)<br>    {<br>        int i, j, k;<br>        Dictionary&lt;int, int&gt; useddist = new Dictionary&lt;int, int&gt;();<br>        Dictionary&lt;int, int&gt; second = new Dictionary&lt;int, int&gt;();<br>        for (j = 0; j &lt; secondPicture.Length; j++) second[secondPicture[j]] = 1;<br>        long res = 0;<br>        Array.Sort(firstPicture);<br>        Array.Sort(secondPicture);<br>        for (i = 0; i &lt; firstPicture.Length; i++)<br>        {<br>            for (j = 0; j &lt; secondPicture.Length; j++)<br>            {<br>                int dist = Math.Abs(firstPicture[i] - secondPicture[j]);<br>                if (useddist.ContainsKey(dist)) continue;<br>                useddist[dist] = 1;<br>                if (dist == 0) continue;<br><br>                int[] num = new int[firstPicture.Length]; // base number<br>                int[] connect = new int[firstPicture.Length];// conneting<br>                int[] has = new int[secondPicture.Length]; //can connect<br>                Dictionary&lt;int, int&gt; pre = new Dictionary&lt;int, int&gt;();<br>                for (k = 0; k &lt; firstPicture.Length; k++)<br>                {<br>                    int back = firstPicture[k] - dist;<br>                    int next = firstPicture[k] + dist;<br>                    int now = k;<br>                    if (second.ContainsKey(back))<br>                    {<br>                        if (pre.ContainsKey(back))<br>                        {<br>                            now = pre[back];<br>                        }<br>                        else<br>                        {<br>                            has[now]++;<br>                        }<br>                    }<br>                    if (second.ContainsKey(next))<br>                    {<br>                        has[now]++;<br>                        pre[next] = now;<br>                    }<br><br>                    connect[now]++;<br>                    num[k] = now;<br>                }<br>                long add = 1;<br>                for (k = 0; k &lt; firstPicture.Length; k++)<br>                {<br>                    if (connect[k] != 0)<br>                    {<br>                        if (connect[k] &lt; has[k])<br>                        {<br>                            add *= connect[k] + 1;<br>                        }<br>                        else if (connect[k] == has[k])<br>                        {<br>                            add *= 1;<br>                        }<br>                        else<br>                        {<br>                            add = 0;<br>                            break;<br>                        }<br>                    }<br>                }<br>                res += add;<br>            }<br>        }<br>        return res;<br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>