<td class="problemText" colspan="8" valign="middle" align="left">
            // {{{ Boilerplate Code &lt;--------------------------------------------------<br>//<br>// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}<br> <br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;deque&gt;<br>#include &lt;functional&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;numeric&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>#include &lt;cstring&gt;<br> <br>#define FOR(I,A,B)  for(int I = (A); I &lt; (B); ++I)<br>#define REP(I,N)  FOR(I,0,N)<br>#define ALL(A)    (A).begin(), (A).end()<br> <br>using namespace std;<br> <br>// }}}<br> <br>vector&lt; pair&lt;int,int&gt; &gt; loc;<br>int idx[55][55];<br>vector&lt;string&gt; grid;<br>int m,n;<br>bool bomb[55][55];<br>int cover[55][55];<br>int dx[4] = {-1,0,1,0};<br>int dy[4] = {0,1,0,-1};<br> <br>class FoxBomb<br>{<br>public:<br>  int getMinimumCost(vector &lt;string&gt; _grid)<br>  {<br>    grid = _grid;<br>    m = grid.size();  n = grid[0].size();<br>    memset(idx,-1,sizeof(idx));<br> <br>    loc.clear();<br>    for (int i = 0; i &lt; m; i++)<br>      for (int j = 0; j &lt; n; j++) if (grid[i][j] == '.' &amp;&amp; loc.empty()) {<br>        memset(bomb,false,sizeof(bomb));<br>        loc.push_back(make_pair(i,j));<br>        bomb[i][j] = true;<br> <br>        queue&lt; pair&lt;int,int&gt; &gt; q;<br>        q.push(make_pair(i,j));<br>        while (!q.empty()) {<br>          int ux = q.front().first,uy = q.front().second;<br>    q.pop();<br>    for (int dir = 0; dir &lt; 4; dir++) {<br>      int vx = ux + dx[dir],vy = uy + dy[dir];<br>      if (vx &lt; 0 || vx &gt;= m || vy &lt; 0 || vy &gt;= n || grid[vx][vy] == '#' || bomb[vx][vy]) continue;<br>      bomb[vx][vy] = true;<br>      loc.push_back(make_pair(vx,vy));<br>      q.push(make_pair(vx,vy));<br>    }<br>        }<br>      }<br> <br>    for (int i = 0; i &lt; loc.size(); i++) idx[loc[i].first][loc[i].second] = i;<br> <br>    memset(cover,0,sizeof(cover));<br>    for (int i = 0; i &lt; m; i++)<br>      for (int j = 0; j &lt; n; j++) if (grid[i][j] == '.') update(i,j,1);<br> <br>    for (int i = loc.size() - 1; i &gt;= 0; i--) {<br>      int ux = loc[i].first,uy = loc[i].second;<br>      bomb[ux][uy] = false;<br>      update(ux,uy,-1);<br>      if (!allCover()) {<br>        bomb[ux][uy] = true;<br>        update(ux,uy,1);<br>      }<br>    }<br>    int ret = 0;<br>    for (int i = 0; i &lt; m; i++)<br>      for (int j = 0; j &lt; n; j++) ret += bomb[i][j];<br>    return ret;<br>  }<br> <br>  bool allCover() {<br>    for (int i = 0; i &lt; m; i++)<br>      for (int j = 0; j &lt; n; j++) if (grid[i][j] == '.' &amp;&amp; !cover[i][j]) return false;<br>    return true;<br>  }<br> <br>  void update(int x,int y,int d) {<br>    int z = x - 1;<br>    while (z &gt;= 0 &amp;&amp; grid[z][y] == '.') {<br>      cover[z][y] += d;  z--;<br>    }<br>    z = x + 1;<br>    while (z &lt; m &amp;&amp; grid[z][y] == '.') {<br>      cover[z][y] += d;  z++;<br>    }<br>    z = y - 1;<br>    while (z &gt;= 0 &amp;&amp; grid[x][z] == '.') {<br>      cover[x][z] += d;  z--;<br>    }<br>    z = y + 1;<br>    while (z &lt; n &amp;&amp; grid[x][z] == '.') {<br>      cover[x][z] += d;  z++;<br>    }<br>    cover[x][y] += d;<br>  }<br>};<br> <br> <br>// Edited by VimCoder 0.3.2<br>// http://www.dogcows.com/vimcoder<br></td>