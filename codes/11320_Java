<td class="problemText" colspan="8" valign="middle" align="left">
            import java.io.PrintStream;<br>import java.util.Arrays;<br>import java.util.Random;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class FoxBomb {<br>    int[][] visible;<br>    int[][] adjacent;<br>    int[][] answer;<br>    boolean[] mark;<br>    int n;<br>    <br>    public int getMinimumCost(String[] grid) {<br>        n = 0;<br>        int[][] id = new int[grid.length][grid[0].length()];<br>        for (int r = 0; r &lt; grid.length; ++r) {<br>            Arrays.fill(id[r], -1);<br>            for (int c = 0; c &lt; grid[0].length(); ++c) {<br>                if (grid[r].charAt(c) == '.')<br>                    id[r][c] = n++;<br>            }<br>        }<br>        visible = new int[n][];<br>        adjacent = new int[n][];<br>        for (int r = 0; r &lt; grid.length; ++r) {<br>            for (int c = 0; c &lt; grid[0].length(); ++c) {<br>                if (id[r][c] &lt; 0) continue;<br>                {<br>                    int cnt = 1;<br>                    for (int rr = r - 1; rr &gt;= 0; --rr) {<br>                        if (id[rr][c] &lt; 0) break;<br>                        ++cnt;<br>                    }<br>                    for (int rr = r + 1; rr &lt; id.length; ++rr) {<br>                        if (id[rr][c] &lt; 0) break;<br>                        ++cnt;<br>                    }<br>                    for (int cc = c - 1; cc &gt;= 0; --cc) {<br>                        if (id[r][cc] &lt; 0) break;<br>                        ++cnt;<br>                    }<br>                    for (int cc = c + 1; cc &lt; id[r].length; ++cc) {<br>                        if (id[r][cc] &lt; 0) break;<br>                        ++cnt;<br>                    }<br>                    int cid = id[r][c];<br>                    visible[cid] = new int[cnt];<br>                    cnt = 0;<br>                    visible[cid][cnt++] = cid;<br>                    for (int rr = r - 1; rr &gt;= 0; --rr) {<br>                        if (id[rr][c] &lt; 0) break;<br>                        visible[cid][cnt++] = id[rr][c];<br>                    }<br>                    for (int rr = r + 1; rr &lt; id.length; ++rr) {<br>                        if (id[rr][c] &lt; 0) break;<br>                        visible[cid][cnt++] = id[rr][c];<br>                    }<br>                    for (int cc = c - 1; cc &gt;= 0; --cc) {<br>                        if (id[r][cc] &lt; 0) break;<br>                        visible[cid][cnt++] = id[r][cc];<br>                    }<br>                    for (int cc = c + 1; cc &lt; id[r].length; ++cc) {<br>                        if (id[r][cc] &lt; 0) break;<br>                        visible[cid][cnt++] = id[r][cc];<br>                    }<br>                }<br>                {<br>                    int cnt = 0;<br>                    for (int rr = r - 1; rr &gt;= 0; --rr) {<br>                        if (id[rr][c] &lt; 0) break;<br>                        ++cnt;<br>                        break;<br>                    }<br>                    for (int rr = r + 1; rr &lt; id.length; ++rr) {<br>                        if (id[rr][c] &lt; 0) break;<br>                        ++cnt;<br>                        break;<br>                    }<br>                    for (int cc = c - 1; cc &gt;= 0; --cc) {<br>                        if (id[r][cc] &lt; 0) break;<br>                        ++cnt;<br>                        break;<br>                    }<br>                    for (int cc = c + 1; cc &lt; id[r].length; ++cc) {<br>                        if (id[r][cc] &lt; 0) break;<br>                        ++cnt;<br>                        break;<br>                    }<br>                    int cid = id[r][c];<br>                    adjacent[cid] = new int[cnt];<br>                    cnt = 0;<br>                    for (int rr = r - 1; rr &gt;= 0; --rr) {<br>                        if (id[rr][c] &lt; 0) break;<br>                        adjacent[cid][cnt++] = id[rr][c];<br>                        break;<br>                    }<br>                    for (int rr = r + 1; rr &lt; id.length; ++rr) {<br>                        if (id[rr][c] &lt; 0) break;<br>                        adjacent[cid][cnt++] = id[rr][c];<br>                        break;<br>                    }<br>                    for (int cc = c - 1; cc &gt;= 0; --cc) {<br>                        if (id[r][cc] &lt; 0) break;<br>                        adjacent[cid][cnt++] = id[r][cc];<br>                        break;<br>                    }<br>                    for (int cc = c + 1; cc &lt; id[r].length; ++cc) {<br>                        if (id[r][cc] &lt; 0) break;<br>                        adjacent[cid][cnt++] = id[r][cc];<br>                        break;<br>                    }<br>                }<br>            }<br>        }<br>        answer = new int[n][];<br>        for (int i = 0; i &lt; n; ++i) {<br>            int cnt = adjacent[i].length;<br>            if (i != 0) --cnt;<br>            answer[i] = new int[1 &lt;&lt; cnt];<br>            Arrays.fill(answer[i], INF);<br>        }<br>        mark = new boolean[n];<br>        dfs(0, -1);<br>        return answer[0][answer[0].length - 1];<br>    }<br>    <br>    static final int INF = (int) 1e9;<br> <br>    private void dfs(int root, int parent) {<br>        for (int x : adjacent[root]) {<br>            if (x != parent) {<br>                dfs(x, root);<br>            }<br>        }<br>        answer[root][0] = 1;<br>        for (int x : visible[root]) {<br>            for (int y : visible[x])<br>                mark[y] = true;<br>            dfs2(root, parent, true);<br>            for (int y : visible[x])<br>                mark[y] = false;<br>        }<br>    }<br>    <br>    private int dfs2(int root, int parent, boolean update) {<br>        if (!mark[root])<br>            return answer[root][answer[root].length - 1];<br>        int cnt = adjacent[root].length;<br>        if (parent &gt;= 0) --cnt;<br>        int[] chd = new int[cnt];<br>        int ptr = 0;<br>        for (int x : adjacent[root]) {<br>            if (x != parent)<br>                chd[ptr++] = dfs2(x, root, false);<br>        }<br>        if (update) {<br>            for (int oldSet = 0; oldSet &lt; (1 &lt;&lt; cnt); ++oldSet) {<br>                if (answer[root][oldSet] &gt;= INF) continue;<br>                int oldAns = answer[root][oldSet];<br>                if (oldSet == 0) oldAns = 0;<br>                for (int takeSet = 1; takeSet &lt; (1 &lt;&lt; cnt); ++takeSet)<br>                    if ((oldSet &amp; takeSet) == 0) {<br>                        int ans = oldAns + 1;<br>                        for (int i = 0; i &lt; cnt; ++i)<br>                            if ((takeSet &amp; (1 &lt;&lt; i)) != 0)<br>                                ans += chd[i];<br>                        answer[root][oldSet | takeSet] = Math.min(answer[root][oldSet | takeSet], ans);<br>                    }<br>            }<br>            return -1;<br>        } else {<br>            int res = INF;<br>            for (int subset = 0; subset &lt; (1 &lt;&lt; cnt); ++subset) {<br>                int cur = answer[root][subset];<br>                if (subset == 0) cur = 0;<br>                for (int i = 0; i &lt; cnt; ++i)<br>                    if (((subset &amp; (1 &lt;&lt; i)) == 0))<br>                        cur += chd[i];<br>                res = Math.min(res, cur);<br>            }<br>            return res;<br>        }<br>    }<br> <br>    }<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>