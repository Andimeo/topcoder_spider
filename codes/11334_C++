<td class="problemText" colspan="8" valign="middle" align="left">
            //  SRM 506 (B)<br> <br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;utility&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;complex&gt;<br> <br>using namespace std;<br> <br>typedef unsigned uint;<br>typedef long long Int;<br>typedef vector&lt;int&gt; vint;<br>typedef vector&lt;string&gt; vstr;<br>typedef pair&lt;int,int&gt; pint;<br>#define mp make_pair<br> <br>template&lt;class T&gt; void pv(T a, T b) { for (T i = a; i != b; ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; endl; }<br> <br>namespace MCF {<br>  #define MAXN 210<br>  #define MAXM 100010<br>  #define wint int<br>  #define cint int<br>  const wint EPS = 0;<br>  const wint INF = 1001001001;<br>  const cint cEPS = 0;<br>  const cint cINF = 1001001001;<br>  int n, m, ptr[MAXN], next[MAXM], zu[MAXM];<br>  wint capa[MAXM], tof;<br>  cint cost[MAXM], toc, d[MAXN], pot[MAXN];<br>  int pree[MAXN];<br>  void init(int _n) {<br>    n = _n; m = 0; memset(ptr, ~0, n &lt;&lt; 2);<br>  }<br>  void ae(int u, int v, wint w, cint c) {<br>    next[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] =  c; ++m;<br>    next[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;<br>  }<br>  bool primaldual(int src, int ink, wint flo = INF, bool normal = 1) {<br>    wint f;<br>    cint c, t;<br>    int i, u, v;<br>    if (normal) memset(pot, 0, n * sizeof(cint));<br>  /*<br>    for (bool cont = 1; cont; ) {<br>      cont = 0;<br>      for (u = 0; u &lt; n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (~i &amp; 1) {<br>        if (pot[zu[i]] &gt; pot[u] + cost[i]) {<br>          pot[zu[i]] = pot[u] + cost[i]; cont = 1;<br>        }<br>      }<br>    }<br>  //*/<br>    for (toc = 0, tof = 0; tof + EPS &lt; flo; ) {<br>      priority_queue&lt; pair&lt;cint,int&gt; &gt; q;<br>      for (u = 0; u &lt; n; ++u) d[u] = cINF;<br>      for (d[src] = 0, q.push(mp(-0, src)); !q.empty(); ) {<br>        c = -q.top().first; u = q.top().second; q.pop();<br>        if (d[u] == c) {<br>          for (i = ptr[u]; ~i; i = next[i]) if (capa[i] &gt; EPS) {<br>            t = c + cost[i] + pot[u] - pot[v = zu[i]];<br>            if (d[v] &gt; t &amp;&amp; (normal || t &lt;= c + cEPS)) {<br>              d[v] = t; pree[v] = i; q.push(mp(-t, v));<br>            }<br>          }<br>        }<br>      }<br>      if (d[ink] == cINF || (!normal &amp;&amp; d[ink] - pot[src] + pot[ink] &gt; cEPS)) return 0;<br>      f = flo - tof;<br>      for (v = ink; v != src; v = zu[i ^ 1]) {<br>        i = pree[v];<br>        if (f &gt; capa[i]) f = capa[i];<br>      }<br>      for (v = ink; v != src; v = zu[i ^ 1]) {<br>        i = pree[v];<br>        capa[i] -= f; capa[i ^ 1] += f;<br>      }<br>      tof += f;<br>      toc += f * (d[ink] - pot[src] + pot[ink]);<br>      for (u = 0; u &lt; n; ++u) pot[u] += d[u];<br>    }<br>    return 1;<br>  }<br>}<br> <br>#define CAR(u) (u)<br>#define DIS(v) (C + 1 + (v))<br>#define SRC (C + 1 + D)<br>#define INK (C + 1 + D + 1)<br> <br>int N;<br>int C, D;<br>int dist[110][110];<br>int as[110], bs[110];<br> <br>struct SlimeXGrandSlimeAuto {<br>  <br>  int tr(char c) {<br>    if ('0' &lt;= c &amp;&amp; c &lt;= '9') return 1 + (c - '0');<br>    if ('a' &lt;= c &amp;&amp; c &lt;= 'z') return 11 + (c - 'a');<br>    if ('A' &lt;= c &amp;&amp; c &lt;= 'Z') return 37 + (c - 'A');<br>    return 0;<br>  }<br>  <br>  int travel(vector &lt;int&gt; cars, vector &lt;int&gt; districts, vector &lt;string&gt; roads, int inverseWalkSpeed, int inverseDriveSpeed) {<br>    int i, j, k;<br>    int u, v;<br>    <br>    N = roads.size();<br>    C = cars.size();<br>    D = districts.size();<br>    <br>    for (i = 0; i &lt; N; ++i) for (j = 0; j &lt; N; ++j) {<br>      dist[i][j] = (i != j) ? MCF::cINF : 0;<br>    }<br>    for (i = 0; i &lt; N; ++i) for (j = 0; j &lt; N; ++j) if (roads[i][j] != '.') {<br>      dist[i][j] = tr(roads[i][j]);<br>    }<br>    for (k = 0; k &lt; N; ++k) for (i = 0; i &lt; N; ++i) for (j = 0; j &lt; N; ++j) {<br>      if (dist[i][j] &gt; dist[i][k] + dist[k][j]) {<br>        dist[i][j] = dist[i][k] + dist[k][j];<br>      }<br>    }<br>    <br>    for (v = 0; v &lt; D; ++v) {<br>      bs[v] = districts[v];<br>    }<br>    as[0] = 0;<br>    for (v = 1; v &lt; D; ++v){<br>      as[v] = bs[v - 1];<br>    }<br>    <br>    MCF::init(C + D + 3);<br>    for (u = 0; u &lt; C; ++u) {<br>      MCF::ae(SRC, CAR(u), 1, 0);<br>    }<br>    MCF::ae(SRC, CAR(C), MCF::INF, 0);<br>    for (v = 0; v &lt; D; ++v) {<br>      MCF::ae(DIS(v), INK, 1, 0);<br>    }<br>    for (u = 0; u &lt; C; ++u) for (v = 0; v &lt; D; ++v) {<br>      MCF::ae(CAR(u), DIS(v), 1, dist[as[v]][cars[u]] * inverseWalkSpeed + dist[cars[u]][bs[v]] * inverseDriveSpeed);<br>    }<br>    for (v = 0; v &lt; D; ++v) {<br>      MCF::ae(CAR(C), DIS(v), 1, dist[as[v]][bs[v]] * inverseWalkSpeed);<br>    }<br>    <br>    bool res = MCF::primaldual(SRC, INK, D);<br>cout&lt;&lt;"res = "&lt;&lt;res&lt;&lt;endl;<br>    return MCF::toc;<br>    <br>  }<br>  <br>};<br></td>