<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class SlimeXGrandSlimeAuto {<br>    static final int INF = Integer.MAX_VALUE / 3;<br> <br>  public int travel(int[] cars, int[] districts, String[] roads, int inverseWalkSpeed, int inverseDriveSpeed) {<br>        int numCities = roads.length;<br>        int[][] dist = new int[numCities][numCities];<br>        for (int i = 0; i &lt; numCities; ++i)<br>            for (int j = 0; j &lt; numCities; ++j) {<br>                if (i == j)<br>                    continue;<br>                char ch = roads[i].charAt(j);<br>                if (ch == '.')<br>                    dist[i][j] = INF;<br>                else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9')<br>                    dist[i][j] = 1 + ch - '0';<br>                else if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')<br>                    dist[i][j] = 11 + ch - 'a';<br>                else if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')<br>                    dist[i][j] = 37 + ch - 'A';<br>                else<br>                    throw new RuntimeException();<br>            }<br>        for (int k = 0; k &lt; numCities; ++k)<br>            for (int i = 0; i &lt; numCities; ++i)<br>                for (int j = 0; j &lt; numCities; ++j)<br>                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);<br>        int numVertices = 2 + districts.length + cars.length;<br>        int s = numVertices - 1;<br>        int t = numVertices - 2;<br>        int[][] cap = new int[numVertices][numVertices];<br>        int[][] cost = new int[numVertices][numVertices];<br>        for (int i = 0; i &lt; districts.length; ++i) {<br>            int src = i == 0 ? 0 : districts[i - 1];<br>            int dst = districts[i];<br>            cap[s][i] = 1;<br>            cap[i][t] = 1;<br>            cost[i][t] = inverseWalkSpeed * dist[src][dst];<br>            cost[t][i] = -cost[i][t];<br>            for (int j = 0; j &lt; cars.length; ++j) {<br>                cap[i][j + districts.length] = 1;<br>                cost[i][j + districts.length] = inverseWalkSpeed * dist[src][cars[j]] + inverseDriveSpeed * dist[cars[j]][dst];<br>                cost[j + districts.length][i] = -cost[i][j + districts.length];<br>            }<br>        }<br>        for (int j = 0; j &lt; cars.length; ++j) {<br>            cap[j + districts.length][t] = 1;<br>        }<br>        return minCostMaxFlow(numVertices, cap, cost, s, t);<br>  }<br> <br>    private int minCostMaxFlow(int numVertices, int[][] cap, int[][] cost, int s, int t) {<br>        int res = 0;<br>        while (true) {<br>            int[] prev = new int[numVertices];<br>            int[] dist = new int[numVertices];<br>            Arrays.fill(dist, INF);<br>            dist[s] = 0;<br>            while (true) {<br>                boolean updated = false;<br>                for (int i = 0; i &lt; numVertices; ++i)<br>                    if (dist[i] &lt; INF)<br>                        for (int j = 0; j &lt; numVertices; ++j)<br>                            if (cap[i][j] &gt; 0 &amp;&amp; dist[i] + cost[i][j] &lt; dist[j]) {<br>                                dist[j] = dist[i] + cost[i][j];<br>                                prev[j] = i;<br>                                updated = true;<br>                            }<br>                if (!updated) break;<br>            }<br>            if (dist[t] &gt;= INF) break;<br>            res += dist[t];<br>            int cur = t;<br>            while (cur != s) {<br>                int pr = prev[cur];<br>                --cap[pr][cur];<br>                ++cap[cur][pr];<br>                cur = pr;<br>            }<br>        }<br>        return res;<br>    }<br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>