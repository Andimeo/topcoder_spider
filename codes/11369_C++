<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;string&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;sstream&gt;<br><br>using namespace std;<br><br>#define pb push_back<br>#define SZ(c) (int)(c).size()<br>#define FOR(i,a,b) for (int _b=(b), i=(a); i &lt;= _b; i++)<br>#define REP(i,n) for (int i=0,_n=(n); i &lt; _n; i++)<br>#define CLEAR(x) memset(x,0,sizeof x);<br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;VI&gt; VVI;<br><br>typedef long long LL;<br><br>#define MOD 1000000007<br><br>class CircuitDesign {<br>public:<br>  int n;<br>  VI a[128];<br>  int degbig[128];<br>  bool used[128];<br>  VI comp;<br>  LL fact[128];<br>  bool bad;<br>  void dfs(int v, int prev = -1)<br>  {<br>    used[v]=true;<br>    comp.pb(v);<br>    REP(i,SZ(a[v]))<br>    {<br>      if (prev == a[v][i]) continue;<br>      if (used[a[v][i]])<br>      {<br>        bad = true;<br>        break;<br>      }<br>      used[a[v][i]] = true;<br>      dfs(a[v][i],v);<br>    }<br>  }<br>  int countPerms(int n, vector &lt;int&gt; top, vector &lt;int&gt; bottom) {<br>    fact[0]=1;<br>    FOR(i,1,127)<br>      fact[i] = (fact[i-1]*(LL)i)%MOD;<br>    this-&gt;n=n;<br>    REP(i,n*2)<br>      a[i].clear();<br>    REP(i,SZ(top))<br>    {<br>      int x = top[i]-1;<br>      int y = bottom[i]-1+n;<br>      a[x].pb(y);<br>      a[y].pb(x);<br>    }<br>    CLEAR(used);<br>    LL res = 1;<br>    REP(i,2*n)<br>    {<br>      degbig[i]=0;<br>      if (SZ(a[i]) &gt; 1)<br>        REP(j,SZ(a[i]))<br>          if (SZ(a[a[i][j]]) &gt; 1)<br>            degbig[i]++;<br>      if (degbig[i] &gt; 2)<br>        return 0;<br>    }<br>    int comps = 0;<br>    bad = false;<br>    REP(is,2*n) if (!used[is] &amp;&amp; !a[is].empty())<br>    {<br>      ++comps;<br>      comp.clear();<br>      dfs(is);<br>      if (bad)<br>        return 0;<br>      int bighere = 0;<br>      int bighere2 = 0;<br>      REP(i,SZ(comp))<br>      {<br>        if (degbig[comp[i]] &lt; SZ(a[comp[i]]))<br>          res = (res * fact[SZ(a[comp[i]]) - degbig[comp[i]]]) % MOD;<br>        if (SZ(a[comp[i]]) &gt; 1)<br>        {<br>          ++bighere;<br>          if (degbig[comp[i]] == 2)<br>            ++bighere2;<br>        }<br>      }<br>      if (bighere &gt; 0 &amp;&amp; bighere2 == bighere)<br>        return 0;<br>      if (bighere &gt; 1)<br>        res = (res*2)%MOD;<br>    }<br>    res = (res*fact[comps])%MOD;<br>    int fr1 = 0;<br>    int fr2 = 0;<br>    REP(i,n) if (!used[i]) fr1++;<br>    REP(i,n) if (!used[i+n]) fr2++;<br>    REP(i,fr1)<br>      res = (res * (n-i))%MOD;<br>    REP(i,fr2)<br>      res = (res * (n-i))%MOD;<br>    return res;<br>  }<br>  <br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>