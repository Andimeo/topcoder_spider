<td class="problemText" colspan="8" valign="middle" align="left">
            /**<br> * Generated by Contest helper plug-in<br> * Actual solution is at the bottom<br> */<br>public class CircuitDesign {<br>  private static final int MOD = 1000000007;<br><br>  public int countPerms(int n, int[] top, int[] bottom) {<br>    long[] factorial = new long[n + 1];<br>    factorial[0] = 1;<br>    for (int i = 1; i &lt;= n; i++)<br>      factorial[i] = (factorial[i - 1] * i) % MOD;<br>    for (int i = 0; i &lt; top.length; i++) {<br>      top[i]--;<br>      bottom[i]--;<br>    }<br>    long result = 1;<br>    boolean[] used = new boolean[n];<br>    for (int aTop : top)<br>      used[aTop] = true;<br>    int count = n;<br>    for (boolean cell : used) {<br>      if (!cell) {<br>        result *= count--;<br>        result %= MOD;<br>      }<br>    }<br>    used = new boolean[n];<br>    for (int aTop : bottom)<br>      used[aTop] = true;<br>    count = n;<br>    for (boolean cell : used) {<br>      if (!cell) {<br>        result *= count--;<br>        result %= MOD;<br>      }<br>    }<br>    boolean[][] connected = new boolean[2 * n][2 * n];<br>    for (int i = 0; i &lt; top.length; i++)<br>      connected[top[i]][bottom[i] + n] = connected[bottom[i] + n][top[i]] = true;<br>    int[] degree = new int[2 * n];<br>    for (int i = 0; i &lt; top.length; i++) {<br>      degree[top[i]]++;<br>      degree[n + bottom[i]]++;<br>    }<br>    int[] specialDegree = new int[2 * n];<br>    for (int i = 0; i &lt; top.length; i++) {<br>      if (degree[top[i]] &gt; 1 &amp;&amp; degree[n + bottom[i]] &gt; 1) {<br>        specialDegree[top[i]]++;<br>        specialDegree[bottom[i] + n]++;<br>      }<br>    }<br>    boolean[] visited = new boolean[2 * n];<br>    int componentCount = 0;<br>    int[] queue = new int[2 * n];<br>    for (int i = 0; i &lt; 2 * n; i++) {<br>      if (degree[i] &gt; 1 &amp;&amp; !visited[i]) {<br>        componentCount++;<br>        visited[i] = true;<br>        if (specialDegree[i] == 0) {<br>          result = (result * factorial[degree[i]]) % MOD;<br>          for (int j = 0; j &lt; 2 * n; j++) {<br>            if (connected[i][j])<br>              visited[j] = true;<br>          }<br>          continue;<br>        }<br>        int ones = 0;<br>        int size = 1;<br>        queue[0] = i;<br>        result = result * 2 % MOD;<br>        for (int j = 0; j &lt; size; j++) {<br>          int c = queue[j];<br>          if (specialDegree[c] &gt; 2)<br>            return 0;<br>          if (specialDegree[c] == 2)<br>            result = result * factorial[degree[c] - 2] % MOD;<br>          else {<br>            ones++;<br>            result = result * factorial[degree[c] - 1] % MOD;<br>          }<br>          for (int k = 0; k &lt; 2 * n; k++) {<br>            if (connected[c][k] &amp;&amp; !visited[k]) {<br>              visited[k] = true;<br>              if (degree[k] &gt; 1)<br>                queue[size++] = k;<br>            }<br>          }<br>        }<br>        if (ones == 0)<br>          return 0;<br>      }<br>    }<br>    int edges = 0;<br>    for (int i = 0; i &lt; 2 * n; i++) {<br>      if (degree[i] == 1 &amp;&amp; !visited[i])<br>        edges++;<br>    }<br>    edges /= 2;<br>    componentCount += edges;<br>    result = result * factorial[componentCount] % MOD;<br>    return (int) result;<br>  }<br><br><br>}<br><br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.15 [modified TZTester]<br>// Powered by CodeProcessor<br></td>