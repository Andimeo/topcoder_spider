<td class="problemText" colspan="8" valign="middle" align="left">
            /**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class MonochromePuzzle {<br>    int INF = 1000;<br> <br>   public int getMinimum(String[] board) {<br>       int n = board.length;<br>       boolean[][] graph = new boolean[n][n];<br>       int[] deg = new int[n];<br>       for (int i = 0; i &lt; n; ++i) {<br>           for (int j = i; j &lt; n; ++j) {<br>               char c1 = board[i].charAt(j);<br>               char c2 = board[j].charAt(i);<br>               if (c1 != c2)<br>                   return -1;<br>               if (c1 == '.') continue;<br>               if (i == j)<br>                   return -1;<br>               graph[i][j] = true;<br>               graph[j][i] = true;<br>               ++deg[i];<br>               ++deg[j];<br>           }<br>       }<br>       for (int i = 0; i &lt; n; ++i) if (deg[i] != 3) return -1;<br>       int res;<br>       if (n &lt;= 8) {<br>           res = backtrack(n, graph);<br>       } else {<br>           res = clever(n, graph);<br>       }<br>       if (res &gt;= INF)<br>           return -1;<br>       return res;<br>   }<br> <br>    private int clever(int n, boolean[][] graph) {<br>        boolean[][] sideEdge = new boolean[n][n];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = i + 1; j &lt; n; ++j)<br>                if (graph[i][j]) {<br>                    sideEdge[i][j] = sideEdge[j][i] = isSideEdge(n, graph, i, j);<br>                }<br>        int[] num = new int[n];<br>        for (int i = 0; i &lt; n; ++i) {<br>            for (int j = 0; j &lt; n; ++j)<br>                if (sideEdge[i][j]) ++num[i];<br>            if (num[i] != 2) return INF;<br>        }<br>        boolean[] mark = new boolean[n];<br>        int[] seq = new int[n];<br>        int pos = 1;<br>        seq[pos] = 0;<br>        mark[0] = true;<br>        while (true) {<br>            int cur = seq[pos - 1];<br>            boolean got = false;<br>            for (int i = 0; i &lt; n; ++i) if (sideEdge[cur][i] &amp;&amp; !mark[i]) {<br>                got = true;<br>                mark[i] = true;<br>                seq[pos++] = i;<br>                break;<br>            }<br>            if (!got) break;<br>        }<br>        if (pos != n / 2) return INF;<br>        int[] seq2 = new int[n];<br>        for (int i = 0; i &lt; n / 2; ++i) {<br>            int cur = seq[i];<br>            boolean got = false;<br>            for (int j = 0; j &lt; n; ++j) if (!sideEdge[cur][j] &amp;&amp; graph[cur][j] &amp;&amp; !mark[j]) {<br>                got = true;<br>                mark[j] = true;<br>                seq2[i] = j;<br>                break;<br>            }<br>            if (!got) return INF;<br>        }<br>        for (int i = 0; i &lt; n; ++i) if (!mark[i]) return INF;<br>        for (int i = 0; i &lt; n / 2; ++i) {<br>            if (!graph[seq[i]][seq2[i]]) return INF;<br>            if (!graph[seq[i]][seq[(i + 1) % (n / 2)]]) return INF;<br>            if (!graph[seq2[i]][seq2[(i + 1) % (n / 2)]]) return INF;<br>        }<br>        int[] perm = new int[n];<br>        int res = INF;<br>        for (int first = 0; first &lt; 2; ++first)<br>            for (int start = 0; start &lt; n / 2; ++start)<br>                for (int step = -1; step &lt;= 1; step += 2) {<br>                    int[] s1;<br>                    int[] s2;<br>                    if (first == 0) {<br>                        s1 = seq;<br>                        s2 = seq2;<br>                    } else {<br>                        s1 = seq2;<br>                        s2 = seq;<br>                    }<br>                    for (int i = 0; i &lt; n / 2; ++i) {<br>                        int offset = (start + i * step + n / 2) % (n / 2);<br>                        perm[i] = s1[offset];<br>                        perm[n - 1 - i] = s2[offset];<br>                    }<br>                    res = Math.min(res, n - countCycles(perm));<br>                }<br>        return res;<br>    }<br> <br>    private boolean isSideEdge(int n, boolean[][] graph, int i, int j) {<br>        int cnt = 0;<br>        for (int a = 0; a &lt; n; ++a)<br>            if (graph[i][a] &amp;&amp; a != i &amp;&amp; a != j)<br>                for (int b = 0; b &lt; n; ++b)<br>                    if (graph[j][b] &amp;&amp; graph[a][b] &amp;&amp; b != i &amp;&amp; b != j &amp;&amp; b != a)<br>                        ++cnt;<br>        return cnt == 1;<br>    }<br> <br>    private int backtrack(int n, boolean[][] graph) {<br>        int[] perm = new int[n];<br>        boolean[] used = new boolean[n];<br>        return rec(n, graph, perm, 0, used);<br>    }<br> <br>    private int rec(int n, boolean[][] graph, int[] perm, int at, boolean[] used) {<br>        if (at &gt;= n) {<br>            for (int i = 0; i &lt; n; ++i)<br>                for (int j = 0; j &lt; n; ++j) {<br>                    boolean need = (Math.abs(i - j) == 1 || (i + j == n - 1) || (i == 0 &amp;&amp; j == n / 2 - 1) || (i == n / 2 - 1 &amp;&amp; j == 0) || (i == n - 1 &amp;&amp; j == n / 2) || (i == n / 2 &amp;&amp; j == n - 1));<br>                    if (need != graph[perm[i]][perm[j]])<br>                        return INF;<br>                }<br>            return n - countCycles(perm);<br>        } else {<br>            int res = INF;<br>            for (int i = 0; i &lt; n; ++i) if (!used[i]) {<br>                perm[at] = i;<br>                used[i] = true;<br>                res = Math.min(res, rec(n, graph, perm, at + 1, used));<br>                used[i] = false;<br>            }<br>            return res;<br>        }<br>    }<br> <br>    private int countCycles(int[] perm) {<br>        boolean[] mark = new boolean[perm.length];<br>        int res = 0;<br>        for (int i = 0; i &lt; perm.length; ++i) {<br>            if (!mark[i]) {<br>                ++res;<br>                int j = i;<br>                while (!mark[j]) {<br>                    mark[j] = true;<br>                    j = perm[j];<br>                }<br>            }<br>        }<br>        return res;<br>    }<br>}<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>