<td class="problemText" colspan="8" valign="middle" align="left">
            #line 5 "KindAndCruel.cpp"<br>#include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;cstring&gt;<br>using namespace std;<br><br>#define MP make_pair<br>#define PB push_back<br>#define two(X) (1&lt;&lt;(X))<br>#define SIZE(A) ((int)(A.size()))<br>#define LENGTH(A) ((int)A.length())<br><br>typedef long long int64;<br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br><br>const int maxn=51;<br>const int inf=1000000000;<br>const double eps=1e-10;<br>const double pi=acos(-1.0);<br><br>int f[maxn][maxn][maxn],g[250000][3],tot;<br><br>class KindAndCruel<br>{<br>public:<br>int crossTheField(string s, int a, int b)<br>{<br>    int n=s.size();<br>  if (n==1) return 0;<br>    for (int i=0; i&lt;n; i++) for (int j=0; j&lt;a; j++) for (int k=0; k&lt;b; k++) f[i][j][k]=inf;<br>  f[0][0][0]=0; tot=1; g[1][0]=0; g[2][0]=0; g[3][0]=0;<br>  int now=1;<br>  int x,y,z,p,q;<br>  while (now&lt;=tot) {<br>    x=g[now][0]; y=g[now][1]; z=g[now][2];<br>    p=(y+1)%a; q=(z+1)%b;<br>    if (x&gt;0) {<br>      if (((s[x-1]=='K')&amp;&amp;(p!=0))||((s[x-1]=='C')&amp;&amp;(q==0))||(s[x-1]=='.')) {      <br>        if (f[x-1][p][q]==inf) {<br>          ++tot; g[tot][0]=x-1; g[tot][1]=p; g[tot][2]=q;<br>          f[x-1][p][q]=f[x][y][z]+1;<br>        }<br>      }<br>    }<br>    if (x&lt;(n-1)) {<br>      if (((s[x+1]=='K')&amp;&amp;(p!=0))||((s[x+1]=='C')&amp;&amp;(q==0))||(s[x+1]=='.')) {      <br>        if (f[x+1][p][q]==inf) {<br>          ++tot; g[tot][0]=x+1; g[tot][1]=p; g[tot][2]=q;<br>          f[x+1][p][q]=f[x][y][z]+1;<br>          if ((x+1)==(n-1)) return f[x+1][p][q];<br>        }<br>      }<br>    }<br>    if (((s[x]=='K')&amp;&amp;(p!=0))||((s[x]=='C')&amp;&amp;(q==0))||(s[x]=='.')) {      <br>      if (f[x][p][q]==inf) {<br>        ++tot; g[tot][0]=x; g[tot][1]=p; g[tot][2]=q;<br>        f[x][p][q]=f[x][y][z]+1;<br>      }<br>    }<br>    ++now;<br>  }<br>  return -1;<br>}<br><br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>