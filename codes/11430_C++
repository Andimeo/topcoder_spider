<td class="problemText" colspan="8" valign="middle" align="left">
            //  SRM 509 (C)<br> <br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;utility&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;complex&gt;<br> <br>using namespace std;<br> <br>typedef unsigned uint;<br>typedef long long Int;<br>typedef vector&lt;int&gt; vint;<br>typedef vector&lt;string&gt; vstr;<br>typedef pair&lt;int,int&gt; pint;<br>#define mp make_pair<br> <br>template&lt;class T&gt; void pv(T a, T b) { for (T i = a; i != b; ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; endl; }<br> <br>const Int MO = 1000000009;<br> <br>#define MAX 2000010<br>const int LIM = 2000005;<br>Int inv[MAX], fac[MAX], fnv[MAX];<br> <br>int N;<br>int X[110], Y[110], P[110];<br>int TX, TY;<br>int K;<br> <br>namespace SOLVE1 {<br>int d[110];<br>}<br> <br>namespace SOLVE2 {<br>int psLen;<br>pair&lt;pint,int&gt; ps[110];<br>Int way0[110][110][20], way1[110][110][20];<br>Int dp[110][20];<br>}<br> <br>void prepare() {<br>  int i;<br>  fac[0] = fnv[0] = 1;<br>  for (i = 1; i &lt; LIM; ++i) {<br>    inv[i] = (i == 1) ? 1 : ((MO - (MO / i) * inv[MO % i] % MO) % MO);<br>//assert(i*inv[i]%MO==1);<br>    fac[i] = fac[i - 1] * i % MO;<br>    fnv[i] = fnv[i - 1] * inv[i] % MO;<br>  }<br>}<br>Int bn(Int n, Int k) {<br>  if (n &lt; k) return 0;<br>  return fac[n] * fnv[n - k] % MO * fnv[k] % MO;<br>}<br> <br>struct NumberLabyrinthDiv1 {<br>  <br>  Int solve1() {<br>    return 0;<br>  }<br>  <br>  Int calc2(int x, int y, int k) {<br>    if (x &lt; 0 || y &lt; 0) return 0;<br>    Int ret = 0;<br>    int kx, ky;<br>    for (kx = 0; kx &lt;= k; ++kx) {<br>      ky = k - kx;<br>      Int tmp = bn(k, kx);<br>      tmp = tmp * (kx ? bn(x - 1, kx - 1) : x ? 0 : 1) % MO;<br>      tmp = tmp * (ky ? bn(y - 1, ky - 1) : y ? 0 : 1) % MO;<br>      ret += tmp;<br>      ret %= MO;<br>    }<br>//cout&lt;&lt;"calc "&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;" "&lt;&lt;k&lt;&lt;" : "&lt;&lt;ret&lt;&lt;endl;<br>    return ret;<br>  }<br>  Int solve2() {<br>    using namespace SOLVE2;<br>    int i, j, jj;<br>    int k, kk, dk;<br>    <br>    psLen = 0;<br>    ps[psLen++] = mp(mp(0, 0), -1);<br>    for (i = 0; i &lt; N; ++i) if (mp(X[i], Y[i]) &lt; mp(TX, TY)) {<br>      ps[psLen++] = mp(mp(X[i], Y[i]), P[i]);<br>    }<br>    sort(ps, ps + psLen);<br>    ps[psLen] = mp(mp(TX, TY), -1);<br>    <br>    for (i = 0; i &lt; psLen; ++i) {<br>      for (j = i + 1; j &lt;= psLen; ++j) {<br>        for (k = 0; k &lt;= K; ++k) {<br>          int dx = ps[j].first.first - ps[i].first.first;<br>          int dy = ps[j].first.second - ps[i].first.second;<br>          way0[i][j][k] = calc2(dx, dy, k);<br>        }<br>      }<br>    }<br>    for (i = 0; i &lt; psLen; ++i) {<br>      for (j = i + 1; j &lt;= psLen; ++j) {<br>        for (k = 0; k &lt;= K; ++k) {<br>          int dx = ps[j].first.first - ps[i].first.first;<br>          int dy = ps[j].first.second - ps[i].first.second;<br>          int p = ps[i].second;<br>          Int tmp = 0;<br>          if (i == 0) {<br>            tmp += way0[i][j][k];<br>          } else {<br>            tmp += calc2(dx - p, dy, k);<br>            tmp += calc2(dx, dy - p, k);<br>          }<br>          tmp %= MO;<br>          for (jj = i + 1; jj &lt; j; ++jj) {<br>            for (kk = 0; kk &lt;= k; ++kk) {<br>              tmp -= way1[i][jj][kk] * way0[jj][j][k - kk];<br>              tmp %= MO;<br>            }<br>          }<br>          tmp %= MO; tmp += MO; tmp %= MO;<br>          way1[i][j][k] = tmp;<br>        }<br>      }<br>    }<br>/*<br>cout&lt;&lt;"way0 : "&lt;&lt;endl;<br>for(i=0;i&lt;psLen;++i)for(j=i+1;j&lt;=psLen;++j){<br>cout&lt;&lt;i&lt;&lt;"-&gt;"&lt;&lt;j&lt;&lt;" : ";pv(way0[i][j],way0[i][j]+K+1);<br>}<br>cout&lt;&lt;"way1 : "&lt;&lt;endl;<br>for(i=0;i&lt;psLen;++i)for(j=i+1;j&lt;=psLen;++j){<br>cout&lt;&lt;i&lt;&lt;"-&gt;"&lt;&lt;j&lt;&lt;" : ";pv(way1[i][j],way1[i][j]+K+1);<br>}<br>*/<br>    <br>    memset(dp, 0, sizeof(dp));<br>    dp[0][K] = 1;<br>    for (i = 0; i &lt; psLen; ++i) for (k = 0; k &lt;= K; ++k) {<br>      for (j = i + 1; j &lt;= psLen; ++j) for (dk = 0; dk &lt;= k; ++dk) {<br>        dp[j][k - dk] += dp[i][k] * way1[i][j][dk];<br>        dp[j][k - dk] %= MO;<br>      }<br>    }<br>//cout&lt;&lt;"dp : "&lt;&lt;endl;for(i=0;i&lt;=psLen;++i)pv(dp[i],dp[i]+K+1);<br>    <br>    Int ret = 0;<br>    for (k = 0; k &lt;= K; ++k) {<br>      ret += dp[psLen][k];<br>      ret %= MO;<br>    }<br>    return ret;<br>    <br>  }<br>  <br>  Int solve() {<br>    if (K == 0) {<br>      return 0;<br>    } else if (K == 1) {<br>      return solve1();<br>    } else {<br>      return solve2();<br>    }<br>  }<br>  <br>  int getNumberOfPaths(vector &lt;int&gt; _X, vector &lt;int&gt; _Y, vector &lt;int&gt; val, int xFinish, int yFinish, int _K) {<br>    int i;<br>    <br>    prepare();<br>    <br>    N = _X.size();<br>    for (i = 0; i &lt; N; ++i) X[i] = _X[i];<br>    for (i = 0; i &lt; N; ++i) Y[i] = _Y[i];<br>    for (i = 0; i &lt; N; ++i) P[i] = val[i];<br>    TX = xFinish;<br>    TY = yFinish;<br>    K = _K;<br>    <br>    Int res = solve();<br>    res %= MO; res += MO; res %= MO;<br>    return res;<br>    <br>  }<br>  <br>};<br></td>