<td class="problemText" colspan="8" valign="middle" align="left">
            import javax.management.InstanceNotFoundException;<br>import java.util.*;<br> <br>public class PalindromizationDiv1 {<br>    static final long INF = Long.MAX_VALUE / 10;<br> <br>  public int getMinimumCost(String word, String[] operations) {<br>        long[] addCost = new long[26];<br>        Arrays.fill(addCost, INF);<br>        long[] eraseCost = new long[26];<br>        Arrays.fill(eraseCost, INF);<br>        long[][] changeCost = new long[26][26];<br>        for (int i = 0; i &lt; 26; ++i) {<br>            Arrays.fill(changeCost[i], INF);<br>            changeCost[i][i] = 0;<br>        }<br>        for (String x : operations) {<br>            String[] p = x.split(" ", -1);<br>            if (p[0].equals("add")) {<br>                int letter = p[1].charAt(0) - 'a';<br>                addCost[letter] = Math.min(addCost[letter], Integer.parseInt(p[2]));<br>            } else if (p[0].equals("erase")) {<br>                int letter = p[1].charAt(0) - 'a';<br>                eraseCost[letter] = Math.min(eraseCost[letter], Integer.parseInt(p[2]));<br>            } else if (p[0].equals("change")) {<br>                int letter1 = p[1].charAt(0) - 'a';<br>                int letter2 = p[2].charAt(0) - 'a';<br>                changeCost[letter1][letter2] = Math.min(changeCost[letter1][letter2], Integer.parseInt(p[3]));<br>            } else {<br>                throw new RuntimeException();<br>            }<br>        }<br>        for (int k = 0; k &lt; 26; ++k)<br>            for (int i = 0; i &lt; 26; ++i)<br>                for (int j = 0; j &lt; 26; ++j)<br>                    changeCost[i][j] = Math.min(changeCost[i][j], changeCost[i][k] + changeCost[k][j]);<br>        for (int i = 0; i &lt; 26; ++i)<br>            for (int j = 0; j &lt; 26; ++j) {<br>                addCost[i] = Math.min(addCost[i], addCost[j] + changeCost[j][i]);<br>                eraseCost[i] = Math.min(eraseCost[i], changeCost[i][j] + eraseCost[j]);<br>            }<br>        long[][] best = new long[word.length() + 1][word.length()];<br>        for (int len = 2; len &lt;= word.length(); ++len) {<br>            Arrays.fill(best[len], INF);<br>            for (int pos = 0; pos + len &lt;= word.length(); ++pos) {<br>                int firstLetter = word.charAt(pos) - 'a';<br>                int lastLetter = word.charAt(pos + len - 1) - 'a';<br>                for (int become = 0; become &lt; 26; ++become) {<br>                    // ADding before first.<br>                    best[len][pos] = Math.min(best[len][pos], best[len - 1][pos] + addCost[become] + changeCost[lastLetter][become]);<br>                    // Adding after last.<br>                    best[len][pos] = Math.min(best[len][pos], best[len - 1][pos + 1] + addCost[become] + changeCost[firstLetter][become]);<br>                    // Removing first.<br>                    best[len][pos] = Math.min(best[len][pos], best[len - 1][pos + 1] + eraseCost[firstLetter]);<br>                    // Removing last.<br>                    best[len][pos] = Math.min(best[len][pos], best[len - 1][pos] + eraseCost[lastLetter]);<br>                    // Pair first and last.<br>                    best[len][pos] = Math.min(best[len][pos], best[len - 2][pos + 1] + changeCost[firstLetter][become] + changeCost[lastLetter][become]);<br>                }<br>            }<br>        }<br>    long res = best[word.length()][0];<br>        if (res &gt;= INF) res = -1;<br>    return (int) res;<br>  }<br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>