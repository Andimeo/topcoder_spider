<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br> <br>using namespace std;<br> <br>typedef long long LL;<br>#define FOREACH(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)<br>#define PB push_back<br>#define SZ(x) (int)(x).size()<br>#define ZERO(x) memset(x,0,sizeof(x))<br> <br>const int N = 10000;<br> <br>struct Ans {<br>  LL left, right;<br>  LL score;<br>  bool all1;<br> <br>  Ans() {<br>    all1 = true;<br>    left = right = score = 0;<br>  }<br>};<br> <br>Ans findAns(string s) {<br>  int c1 = 0;<br>  int mx = 0;<br>  for (int i = 0; i &lt; SZ(s); ++i) {<br>    if (s[i] == '1')<br>      ++c1;<br>    else {<br>      mx = max(mx, c1);<br>      c1 = 0;<br>    }<br>  }<br>  Ans res;<br>  res.score = max(mx, c1);<br>  res.all1 = (res.score == SZ(s));<br>  res.right = c1;<br>  res.left = 0;<br>  while (res.left &lt; SZ(s) &amp;&amp; s[res.left] == '1')<br>    ++res.left;<br>  return res;<br>}<br> <br>Ans join(Ans a, Ans b) {<br>  Ans res;<br>  res.all1 = a.all1 &amp;&amp; b.all1;<br>  res.right = b.right;<br>  if (b.all1)<br>    res.right += a.right;<br>  res.left = a.left;<br>  if (a.all1)<br>    res.left += b.left;<br>  res.score = max(a.score, b.score);<br>  res.score = max(res.score, a.right + b.left);<br>  return res;<br>}<br> <br>bool visitedFull[N];<br>Ans ans[N];<br>LL len[N];<br>vector&lt;string&gt; first;<br>int n, k;<br> <br>Ans go(int c, LL l, LL r) {<br>  bool full =  false;<br>  if (l == 0 &amp;&amp; r == len[c] - 1)<br>    full = true;<br>  if (full &amp;&amp; visitedFull[c])<br>    return ans[c];<br>  if (full)<br>    visitedFull[c] = true;<br>  if (c &lt; SZ(first)) {<br>    if (full)<br>      return ans[c] = findAns(first[c].substr(l, r - l + 1));<br>    else<br>      return findAns(first[c].substr(l, r - l + 1));<br>  }<br>  vector&lt;int&gt; sons;<br>  int p = c - 1;<br>  while (p &gt;= 0) {<br>    sons.PB(p);<br>    p -= k;<br>  }<br>  Ans res;<br>  LL start = 0;<br> <br>  FOREACH (it, sons) {<br>    LL nxt = start + len[*it] - 1;<br>    if (l &lt;= nxt &amp;&amp; r &gt;= start) {<br>      res = join(res, go(*it, max(l - start, 0LL), min(r - start, nxt - start)));<br>    }<br>    start = nxt + 1;<br>  }<br> <br>  if (full)<br>    return ans[c] = res;<br>  else<br>    return res;<br>}<br> <br>class MagicalGirlLevelThreeDivOne {<br>public:<br>   long long theMaxPower( vector &lt;string&gt; _first, int _n, long long lo, long long hi ) {<br>     if (_n &lt; SZ(_first)) {<br>       return findAns(_first[_n].substr(lo, hi - lo + 1)).score;<br>     }<br>     ZERO(visitedFull);<br>     first = _first;<br>     n = SZ(first);<br>     k = SZ(first);<br>     for (int i = 0; i &lt; n; ++i)<br>       len[i] = SZ(first[i]);<br>     while (len[n - 1] &lt;= hi) {<br>       len[n] = 0;<br>       int c = n - 1;<br>       while (c &gt;= 0) {<br>         len[n] += len[c];<br>         c -= k;<br>       }<br>       ++n;<br>     }<br>     return go(n - 1, lo, hi).score;<br>   }<br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br> <br>// Powered by CodeProcessor<br></td>