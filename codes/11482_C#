<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class MagicalGirlLevelTwoDivOne {<br><br>    long mod = 1000000007;<br><br>    long[] pow5, pow4;<br>    bool[] memo;<br><br>    public int theCount(string[] palette, int n, int m)<br>    {<br>        bool[,] even = new bool[n, m];<br>        bool[,] odd = new bool[n, m];<br>        int i, j;<br>        int h = palette.Length;<br>        int w = palette[0].Length;<br>        int[,] board = new int[h, w];<br><br><br>        long bmul = 1;<br><br>        pow4 = new long[5000];<br>        pow5 = new long[5000];<br>        pow4[0] = pow5[0] = 1;<br>        for (i = 1; i &lt; 5000; i++)<br>        {<br>            pow4[i] = (pow4[i - 1] * 4) % mod;<br>            pow5[i] = (pow5[i - 1] * 5) % mod;<br>        }<br><br>        memo = new bool[1 &lt;&lt; m];<br>        for (i = 0; i &lt; (1 &lt;&lt; m); i++)<br>        {<br>            memo[i] = false;<br>            for (j = 0; j &lt; m; j++)<br>            {<br>                if ((i &gt;&gt; j) % 2 == 1)<br>                {<br>                    memo[i] = !memo[i];<br>                }<br>            }<br>        }<br><br>        for (i = 0; i &lt; h; i++)<br>        {<br>            for (j = 0; j &lt; w; j++)<br>            {<br>                if (palette[i][j] != '.')<br>                {<br>                    board[i, j] = palette[i][j] - '0';<br>                    if (board[i, j] % 2 == 0)<br>                    {<br>                        even[i % n, j % m] = true;<br>                    }<br>                    else<br>                    {<br>                        odd[i % n, j % m] = true;<br>                    }<br>                    if (even[i % n, j % m] &amp;&amp; odd[i % n, j % m]) return 0;<br>                }<br>                else board[i, j] = 0;<br>            }<br>        }<br><br>        for (i = 0; i &lt; h; i++)<br>        {<br>            for (j = 0; j &lt; w; j++)<br>            {<br>                if (palette[i][j] == '.')<br>                {<br>                    if (even[i % n, j % m]) bmul *= 4;<br>                    if (odd[i % n, j % m]) bmul *= 5;<br>                    bmul %= mod;<br>                }<br>            }<br>        }<br><br>        long[] dp = new long[1 &lt;&lt; m];<br>        dp[0] = 1;<br>        for (i = 0; i &lt; n; i++)<br>        {<br>            List&lt;int&gt; kl = new List&lt;int&gt;();<br>            for (j = 0; j &lt; (1 &lt;&lt; m); j++)<br>            {<br>                if (dp[j] != 0) kl.Add(j);<br>            }<br>            long[] nextdp = new long[1 &lt;&lt; m];<br>            long[] mul = new long[1 &lt;&lt; m];<br>            for (int ii = 0; ii &lt; (1 &lt;&lt; m); ii++)<br>            {<br>                mul[ii] = 1;<br>                for (j = 0; j &lt; m; j++)<br>                {<br>                    if (!even[i, j] &amp;&amp; !odd[i, j])<br>                    {<br>                        int counth = (h - i + n - 1) / n;<br>                        int countw = (w - j + m - 1) / m;<br>                        //Console.WriteLine(counth + " " + countw);<br>                        if ((ii &gt;&gt; j) % 2 == 0)<br>                        {<br>                            mul[ii] *= pow4[Math.Max(counth * countw, 0)];<br>                        }<br>                        else<br>                        {<br>                            mul[ii] *= pow5[Math.Max(counth * countw, 0)];<br>                        }<br>                        mul[ii] %= mod;<br>                    }<br>                }<br>            }<br><br>            int d = 0;<br>            int r = 0;<br><br>            for (j = 0; j &lt; m; j++)<br>            {<br>                if (!even[i, j] &amp;&amp; !odd[i, j]) d |= (1 &lt;&lt; j);<br>                if (odd[i, j])<br>                {<br>                    r |= (1 &lt;&lt; j);<br>                }<br>            }<br>            for (j = d; j &gt;= 0; j -= 1)<br>            {<br>                j &amp;= d;<br>                if (!(memo[r] ^ memo[j])) continue;<br>                long next = j ^ r;<br>                foreach (int kk in kl)<br>                {<br>                    nextdp[kk ^ next] = (nextdp[kk ^ next] + (dp[kk] * mul[j])) % mod;<br>                }<br>            }<br>            dp = (long[])nextdp.Clone();<br>        }<br>        //Console.ReadLine();<br>        return (int)((dp[(1 &lt;&lt; m) - 1] % mod) * bmul % mod);<br>    }<br><br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>