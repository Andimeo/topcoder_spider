<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>public class GameOfLifeDivOne {<br>    int T;<br>    int K;<br> <br>  public long theCount(String init, int T, int K) {<br>        this.T = T;<br>        this.K = K;<br>        return outerRec(init.toCharArray(), 0);<br>  }<br> <br>    private long outerRec(char[] init, int pos) {<br>        if (pos &gt;= init.length) {<br>            if (willHave(init) &gt;= K)<br>                return 1;<br>            else<br>                return 0;<br>        }<br>        long res = 0;<br>        if (init[pos] == '?') {<br>            init[pos] = '0';<br>            res += outerRec(init, pos);<br>            init[pos] = '1';<br>            res += outerRec(init, pos);<br>            init[pos] = '?';<br>        } else {<br>            if (pos &gt;= 2 &amp;&amp; init[pos] != init[pos - 1] &amp;&amp; init[pos - 1] == init[pos - 2]) {<br>                char[] rotated = new char[init.length];<br>                int at = pos;<br>                for (int i = 0; i &lt; init.length; ++i) {<br>                    --at;<br>                    if (at &lt; 0) at += init.length;<br>                    rotated[i] = init[at];<br>                }<br>                res += innerRec(rotated);<br>            } else {<br>                res += outerRec(init, pos + 1);<br>            }<br>        }<br>        return res;<br>    }<br> <br>    private int willHave(char[] state) {<br>        int start;<br>        for (start = 0; start &lt; state.length; ++start)<br>            if (state[start] != state[(start + state.length - 1) % state.length])<br>                break;<br>        if (start &gt;= state.length) {<br>            if (state[0] == '1')<br>                return state.length;<br>            else<br>                return 0;<br>        }<br>        int[] blocks = new int[state.length];<br>        int numBlocks = 0;<br>        char curBlock = '2';<br>        for (int i = 0; i &lt; state.length; ++i) {<br>            char cur = state[(i + start) % state.length];<br>            if (cur == curBlock) {<br>                ++blocks[numBlocks - 1];<br>            } else {<br>                ++numBlocks;<br>                blocks[numBlocks - 1] = 1;<br>                curBlock = cur;<br>            }<br>        }<br>        char firstBlock = state[start];<br>        for (start = 0; start &lt; numBlocks; ++start)<br>            if (blocks[start] &gt; 1)<br>                break;<br>        if (start &gt;= numBlocks) {<br>            return state.length / 2;<br>        }<br>        int numOnes = 0;<br>        int res = 0;<br>        for (int i = 0; i &lt;= numBlocks; ++i) {<br>            int curSize = blocks[(i + start) % numBlocks];<br>            char curKind = ((i + start) % 2 == 0) ? firstBlock : (char) (firstBlock ^ 1);<br>            if (curSize &gt; 1) {<br>                if (numOnes % 2 == 0) {<br>                    res += numOnes / 2;<br>                } else {<br>                    int numThisKind = Math.min(numOnes, numOnes / 2 + T);<br>                    if (curKind == '1')<br>                        res += numThisKind;<br>                    else<br>                        res += (numOnes - numThisKind);<br>                }<br>                numOnes = 0;<br>                if (curKind == '1' &amp;&amp; i &lt; numBlocks)<br>                    res += curSize;<br>            } else {<br>                ++numOnes;<br>            }<br>        }<br>        return res;<br>    }<br> <br>    long[][][] cache;<br>    char[] state;<br> <br>    private long innerRec(char[] state) {<br>        this.state = state;<br>        cache = new long[4][state.length + 1][state.length + 1];<br>        for (int i = 0; i &lt; 4; ++i)<br>            for (int j = 0; j &lt;= state.length; ++j)<br>                Arrays.fill(cache[i][j], -1);<br>        return rec(2 + state[0] - '0', 0, 0);<br>    }<br> <br>    private long rec(int stage, int at, int have) {<br>        long res = cache[stage][at][have];<br>        if (res &gt;= 0) return res;<br>        res = 0;<br>        char need = (char) ('0' + (stage % 2));<br>        if (stage &gt;= 2) {<br>            if (at == state.length) {<br>                if (need != state[0]) throw new RuntimeException();<br>                return have &gt;= K ? 1 : 0;<br>            }<br>            if (state[at] == (need ^ 1)) {<br>                res = 0;<br>            } else {<br>                for (int blockSize = 2; at + blockSize &lt;= state.length; ++blockSize) {<br>                    if (state[at + blockSize - 1] == (need ^ 1))<br>                        break;<br>                    res += rec(stage ^ 3, at + blockSize, have + (need == '1' ? blockSize : 0));<br>                }<br>            }<br>        } else {<br>            for (int numOnes = 0; at + numOnes &lt;= state.length; ++numOnes) {<br>                int willGive;<br>                if (numOnes % 2 == 0)<br>                    willGive = numOnes / 2;<br>                else {<br>                    int numThisKind = Math.min(numOnes, numOnes / 2 + T);<br>                    if (need == '1')<br>                        willGive = numThisKind;<br>                    else<br>                        willGive = (numOnes - numThisKind);<br>                }<br>                res += rec(2 + need - '0', at + numOnes, have + willGive);<br>                if (at + numOnes &gt;= state.length) break;<br>                if (state[at + numOnes] == (need ^ 1))<br>                    break;<br>                need ^= 1;<br>            }<br>        }<br>        cache[stage][at][have] = res;<br>        return res;<br>    }<br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>