<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;  <br>#include &lt;string&gt;  <br>#include &lt;set&gt;  <br>#include &lt;map&gt;  <br>#include &lt;vector&gt;  <br>#include &lt;queue&gt;   <br>#include &lt;iostream&gt;  <br>#include &lt;iterator&gt;  <br>#include &lt;math.h&gt;  <br>#include &lt;cstdio&gt;  <br>#include &lt;cstdlib&gt;  <br>#include &lt;sstream&gt;  <br><br>#pragma comment(linker, "/STACK:60777216")  <br><br>using namespace std;  <br><br>typedef pair&lt;int,int&gt; pii;  <br>typedef long long ll;  <br>typedef vector&lt;int&gt; vi;  <br><br>#define UN(v) SORT(v),v.erase(unique(v.begin(),v.end()),v.end())  <br>#define SORT(c) sort((c).begin(),(c).end())  <br>#define FOR(i,a,b) for (int  i=(a); i &lt; (b); i++)   <br>#define REP(i,n) FOR(i,0,n)   <br>#define CL(a,b) memset(a,b,sizeof(a))  <br>#define pb push_back  <br><br>const int mod = 1000000007;<br><br>int d[55][55][2][2];<br><br>bool canbe(string s,int n1,char c1,int n2,char c2){<br>  REP(i,s.size()){<br>    if(i&lt;n1){<br>      if(s[i]!='?' &amp;&amp; s[i]!=c1) return 0;<br>    }else{<br>      if(s[i]!='?' &amp;&amp; s[i]!=c2) return 0;<br>    }<br>  }<br>  return 1;<br>}<br><br>class TwoConvexShapes {<br>public:<br> int countWays(vector &lt;string&gt; grid) {<br>   int n = grid.size();<br>   int m = grid[0].size();<br>   int sum = 0;<br>   REP(type,2){<br>     CL(d,0);<br>     char fr = (type?'W':'B');<br>     char sc = (type?'B':'W');<br>     REP(i,m+1) if(canbe(grid[0],i,fr,m-i,sc))<br>       d[0][i][1][1] = 1;<br>     int t;<br>     REP(i,n-1)REP(j,m+1)REP(t1,2)REP(t2,2)if(t=d[i][j][t1][t2]){<br>       REP(j2,m+1)if(canbe(grid[i+1],j2,fr,m-j2,sc)){<br>         int nt1 = t1;<br>         int nt2 = t2;<br>         if(t1){<br>           if(j2&lt;j)nt1=0;<br>         }else{<br>           if(j2&gt;j) continue;<br>         }<br>         if(t2){<br>           if(m-j2&lt;m-j)nt2=0;<br>         }else{<br>           if(m-j2&gt;m-j) continue;<br>         }<br>         d[i+1][j2][nt1][nt2] =(d[i+1][j2][nt1][nt2]+t)%mod;<br>       }<br>     }<br>     REP(i,m+1)REP(t1,2)REP(t2,2) sum=(sum+d[n-1][i][t1][t2])%mod;<br><br>    REP(i,n+1){<br>      bool good = 1;<br>      REP(j,n){<br>        if(j&lt;i){<br>          if(!canbe(grid[j],m,fr,0,sc)) good=0;<br>        }else{<br>          if(!canbe(grid[j],m,sc,0,fr)) good=0;<br>        }<br>      }<br>      if(good) sum=(sum+mod-1)%mod;<br>    }<br>   }<br>   // subtract shit!!!<br>  bool good = 1;<br>  REP(i,n) if(!canbe(grid[i],m,'W',0,'B')) good=0;<br>  if(good) sum=(sum+1)%mod;<br>  good = 1;<br>  REP(i,n) if(!canbe(grid[i],m,'B',0,'W')) good=0;<br>  if(good) sum=(sum+1)%mod;<br>  <br>   return sum;<br> }<br> <br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>