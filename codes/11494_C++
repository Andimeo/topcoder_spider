<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cctype&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>using namespace std;<br> <br>typedef unsigned long long qword;<br>typedef long long int64;<br> <br>const int INF = 0x3f3f3f3f;<br>const int N = 300;<br> <br>int n, r, c;<br>int lRow[N], rRow[N], lCol[N], rCol[N];<br>int cntIn[N];<br>bool V[N];<br>bool haveEdge[N][N];<br>vector&lt;string&gt; mat;<br>vector&lt;int&gt; E[N];<br> <br>bool check(int x) {<br>  for (int i = lRow[x]; i &lt;= rRow[x]; ++i)<br>    for (int j = lCol[x]; j &lt;= rCol[x]; ++j) {<br>      if (mat[i][j] == '.')<br>        return false;<br>      if ((isdigit(mat[i][j]) || isalpha(mat[i][j])) &amp;&amp; !haveEdge[x][mat[i][j]] &amp;&amp; mat[i][j] != x) {<br>        haveEdge[x][mat[i][j]] = true;<br>        E[x].push_back(mat[i][j]);<br>        ++cntIn[mat[i][j]];<br>        //cout &lt;&lt; (char)x &lt;&lt; "-&gt;" &lt;&lt; mat[i][j] &lt;&lt; endl;<br>      }<br>    }<br>  return true;<br>}<br> <br>class TopView {<br>public:<br>  string findOrder(vector &lt;string&gt; grid) {<br>    mat = grid;<br>    n = 0;<br>    for (int i = 0; i &lt; N; ++i) {<br>      E[i].clear();<br>      lRow[i] = INF;<br>      rRow[i] = -INF;<br>      lCol[i] = INF;<br>      rCol[i] = -INF;<br>      cntIn[i] = 0;<br>      V[i] = false;<br>    }<br>    memset(haveEdge, 0, sizeof(haveEdge));<br>    r = grid.size();<br>    c = grid[0].size();<br> <br>    for (int i = 0; i &lt; r; ++i)<br>      for (int j = 0; j &lt; c; ++j)<br>        if (grid[i][j] != '.') {<br>          int x = grid[i][j];<br>          V[x] = true;<br>          lRow[x] = min(lRow[x], i);<br>          rRow[x] = max(rRow[x], i);<br>          lCol[x] = min(lCol[x], j);<br>          rCol[x] = max(rCol[x], j);<br>        }<br> <br>    for (int i = 0; i &lt; 300; ++i)<br>      if (V[i] &amp;&amp; !check(i)) {<br>        sort(E[i].begin(), E[i].end());<br>        return "ERROR!";<br>      }<br> <br>    priority_queue&lt;int&gt; que;<br>    int cnt = 0;<br>    for (int i = 0; i &lt; 300; ++i)<br>      if (V[i]) {<br>        ++cnt;<br>        if (!cntIn[i])<br>          que.push(-i);<br>      }<br>    string ret = "";<br>    while (!que.empty()) {<br>      int x = -que.top();<br>      que.pop();<br>      --cnt;<br>      char s[] = {(char)x};<br>      ret += string(s, s + 1);<br>      for (vector&lt;int&gt;::iterator y = E[x].begin(); y != E[x].end(); ++y)<br>        if (!--cntIn[*y])<br>          que.push(-*y);<br>    }<br>    return cnt ? "ERROR!" : ret;<br>  }<br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>