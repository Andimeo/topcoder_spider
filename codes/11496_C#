<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class SRMIntermissionPhase {<br>    long mod = 1000000007;<br>    int MAX = 200020;<br>    public int countWays(int[] points, string[] description)<br>    {<br>        long[] dp = new long[MAX];<br>        long[,] howtoget = new long[8, MAX];<br>        int i, j, k;<br><br>        howtoget[0, 0] = 1;<br>        for (i = 1; i &lt; 8; i++)<br>        {<br>            for (k = 0; k &lt; 3; k++)<br>            {<br>                if ((i &gt;&gt; k) % 2 == 0) continue;<br>                int pre = i - (1 &lt;&lt; k);<br>                long now = 0;<br>                for (j = 0; j &lt; MAX; j++)<br>                {<br>                    howtoget[i, j] = now;<br>                    now += howtoget[pre, j];<br>                    if (j &gt;= points[k]) now -= howtoget[pre, j - points[k]];<br>                    now = (now % mod) + mod;<br>                    now %= mod;<br>                }<br>                break;<br>            }<br>        }<br><br><br>        dp[MAX - 1] = 1;<br>        for (i = 0; i &lt; description.Length; i++)<br>        {<br>            int maxpoint = 0;<br>            int miniscore = 0;<br>            int now = 0;<br>            for (j = 0; j &lt; 3; j++)<br>            {<br>                if (description[i][j] == 'Y')<br>                {<br>                    maxpoint += points[j];<br>                    miniscore += 1;<br>                    now += (1 &lt;&lt; j);<br>                }<br>            }<br>            long[] nextdp = new long[MAX];<br>            long now2 = 0;<br>            for (j = MAX - 1; j &gt;= 0; j--)<br>            {<br>                if (j &lt;= maxpoint &amp;&amp; j &gt;= miniscore)<br>                {<br>                    nextdp[j] = (now2 * howtoget[now, j]) % mod;<br>                }<br>                now2 += dp[j];<br>                now2 %= mod;<br>            }<br>            dp = (long[])nextdp.Clone();<br>        }<br>        long ret = 0;<br>        foreach (long a in dp)<br>        {<br>            ret += a;<br>            ret %= mod;<br>        }<br>        return (int)ret;<br><br>    }<br><br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>