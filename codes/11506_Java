<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.TreeSet;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class PrimeCompositeGame {<br>   public int theOutcome(int N, int K) {<br>       boolean[] prime = new boolean[N + 1];<br>       boolean[] composite = new boolean[N + 1];<br>       for (int i = 2; i &lt;= N; ++i) {<br>           if (!composite[i]) {<br>               prime[i] = true;<br>               int max = N / i;<br>               for (int j = i; j &lt;= max; ++j)<br>                   composite[i * j] = true;<br>           }<br>       }<br>       boolean[] primeWins = new boolean[N + 1];<br>       boolean[] compositeWins = new boolean[N + 1];<br>       long[] primeMoves = new long[N + 1];<br>       long[] compositeMoves = new long[N + 1];<br>       TreeSet&lt;Long&gt; primeGoodMoves = new TreeSet&lt;Long&gt;();<br>       TreeSet&lt;Long&gt; compositeGoodMoves = new TreeSet&lt;Long&gt;();<br>       TreeSet&lt;Long&gt; primeBadMoves = new TreeSet&lt;Long&gt;();<br>       TreeSet&lt;Long&gt; compositeBadMoves = new TreeSet&lt;Long&gt;();<br>       for (int i = 1; i &lt;= N; ++i) {<br>           if (prime[i - 1]) {<br>               if (compositeWins[i - 1])<br>                   primeBadMoves.add(compositeMoves[i - 1]);<br>               else<br>                   primeGoodMoves.add(compositeMoves[i - 1]);<br>           }<br>           if (composite[i - 1]) {<br>               if (primeWins[i - 1])<br>                   compositeBadMoves.add(primeMoves[i - 1]);<br>               else<br>                   compositeGoodMoves.add(primeMoves[i - 1]);<br>           }<br>           if (i - K - 1 &gt;= 0) {<br>               if (prime[i - K - 1]) {<br>                   if (compositeWins[i - K - 1])<br>                       primeBadMoves.remove(compositeMoves[i - K - 1]);<br>                   else<br>                       primeGoodMoves.remove(compositeMoves[i - K - 1]);<br>               }<br>               if (composite[i - K - 1]) {<br>                   if (primeWins[i - K - 1])<br>                       compositeBadMoves.remove(primeMoves[i - K - 1]);<br>                   else<br>                       compositeGoodMoves.remove(primeMoves[i - K - 1]);<br>               }<br>           }<br>           if (!primeGoodMoves.isEmpty()) {<br>               primeWins[i] = true;<br>               primeMoves[i] = (((primeGoodMoves.first() &gt;&gt; 20) + 1) &lt;&lt; 20) + i;<br>           } else if (!primeBadMoves.isEmpty()) {<br>               primeMoves[i] = (((primeBadMoves.last() &gt;&gt; 20) + 1) &lt;&lt; 20) + i;<br>           } else {<br>               primeMoves[i] = i;<br>           }<br>           if (!compositeGoodMoves.isEmpty()) {<br>               compositeWins[i] = true;<br>               compositeMoves[i] = (((compositeGoodMoves.first() &gt;&gt; 20) + 1) &lt;&lt; 20) + i;<br>           } else if (!compositeBadMoves.isEmpty()) {<br>               compositeMoves[i] = (((compositeBadMoves.last() &gt;&gt; 20) + 1) &lt;&lt; 20) + i;<br>           } else {<br>               compositeMoves[i] = i;<br>           }<br>       }<br>       if (primeWins[N]) return (int) (primeMoves[N] &gt;&gt; 20); else return -(int) (primeMoves[N] &gt;&gt; 20);<br>   }<br>}<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>