<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;utility&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br><br>using namespace std;<br><br>#define REP(i,n) for((i)=0;(i)&lt;(int)(n);(i)++)<br><br>#define INF (1&lt;&lt;29)<br>typedef long long ll;<br><br>int X,Y;<br>int dx[]={1,-1,0,0},dy[]={0,0,1,-1};<br>vector &lt;string&gt; maze;<br>vector &lt;pair &lt;int, int&gt; &gt; L,F,R;<br><br>queue &lt;int&gt; q;<br>priority_queue &lt;pair &lt;int, pair &lt;int, int&gt; &gt; &gt; pq;<br>bool used[60][60];<br><br>int dist2[2][60][60];<br>int dist[60][60];<br><br>class MeetInTheMaze{<br>  public:<br>  <br>  ll gcd(ll x, ll y){<br>    return x ? gcd(y%x,x) : y;<br>  }<br>  <br>  void bfs(int id, int sx, int sy){<br>    int i,j;<br>    <br>    REP(i,X) REP(j,Y) dist2[id][i][j] = INF;<br>    q.push(sx); q.push(sy); dist2[id][sx][sy] = 0;<br>    <br>    while(!q.empty()){<br>      int x = q.front(); q.pop(); int y = q.front(); q.pop(); int d = dist2[id][x][y];<br>      REP(i,4){<br>        int x2 = x + dx[i], y2 = y + dy[i];<br>        if(x2 &gt;= 0 &amp;&amp; x2 &lt; X &amp;&amp; y2 &gt;= 0 &amp;&amp; y2 &lt; Y &amp;&amp; dist2[id][x2][y2] == INF &amp;&amp; maze[x2][y2] != '#'){<br>          dist2[id][x2][y2] = d + 1;<br>          q.push(x2); q.push(y2);<br>        }<br>      }<br>    }<br>  }<br>  <br>  void add(int x, int y, int d){<br>    if(x &gt;= 0 &amp;&amp; x &lt; X &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; Y &amp;&amp; d &lt; dist[x][y] &amp;&amp; maze[x][y] != '#'){<br>      dist[x][y] = d;<br>      pq.push(make_pair(-d,make_pair(x,y)));<br>    }<br>  }<br>  <br>  ll func(void){<br>    int i,j;<br>    <br>    REP(i,X) REP(j,Y) dist[i][j] = INF;<br>    REP(i,X) REP(j,Y) used[i][j] = false;<br>    <br>    REP(i,X) REP(j,Y) add(i,j,dist2[0][i][j]+dist2[1][i][j]);<br>    while(!pq.empty()){<br>      int x = pq.top().second.first, y = pq.top().second.second, d = -pq.top().first; pq.pop();<br>      if(used[x][y]) continue; used[x][y] = true;<br>      REP(i,4) add(x+dx[i],y+dy[i],d+1);<br>    }<br>    <br>    ll ans = 0;<br>    REP(i,L.size()){<br>      int x = L[i].first, y = L[i].second;<br>      if(dist[x][y] == INF) return -1;<br>      ans += dist[x][y];<br>    }<br>    <br>    return ans;<br>  }<br><br>  string getExpected(vector &lt;string&gt; _maze){<br>    int i,j;<br>    <br>    maze = _maze;<br>    X = maze.size(); Y = maze[0].length();<br>    REP(i,X) REP(j,Y){<br>      if(maze[i][j] == 'L') L.push_back(make_pair(i,j));<br>      if(maze[i][j] == 'F') F.push_back(make_pair(i,j));<br>      if(maze[i][j] == 'R') R.push_back(make_pair(i,j));<br>    }<br>    <br>    ll ans1 = 0;<br>    ll ans2 = L.size() * F.size() * R.size();<br>    <br>    REP(i,F.size()) REP(j,R.size()){<br>      bfs(0,F[i].first,F[i].second);<br>      bfs(1,R[j].first,R[j].second);<br>      ll tmp = func();<br>      if(tmp == -1) return "";<br>      ans1 += tmp;<br>    }<br>    <br>    ll g = gcd(ans1,ans2);<br>    ans1 /= g; ans2 /= g;<br>    stringstream ss;<br>    ss &lt;&lt; ans1 &lt;&lt; "/" &lt;&lt; ans2;<br>    <br>    string ans = ss.str();<br>    return ans;<br>  }<br><br>};<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>