<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class MeetInTheMaze {<br>  public String getExpected(String[] maze) {<br>        int height = maze.length + 2;<br>        int width = maze[0].length() + 2;<br>        int n = height * width;<br>        char[] data = new char[n];<br>        Arrays.fill(data, '#');<br>        for (int r = 0; r &lt; maze.length; ++r)<br>            for (int c = 0; c &lt; maze[0].length(); ++c) {<br>                data[(r + 1) * width + (c + 1)] = maze[r].charAt(c);<br>            }<br>        int[] first = new int[n];<br>        int nFirst = 0;<br>        int[] second = new int[n];<br>        int nSecond = 0;<br>        int[] third = new int[n];<br>        int nThird = 0;<br>        for (int i = 0; i &lt; n; ++i) {<br>            char ch = data[i];<br>            if (ch == 'F') {<br>                first[nFirst++] = i;<br>                data[i] = '.';<br>            } else if (ch == 'R') {<br>                second[nSecond++] = i;<br>                data[i] = '.';<br>            } else if (ch == 'L') {<br>                third[nThird++] = i;<br>                data[i] = '.';<br>            }<br>        }<br>        short[][] dist = new short[n][n];<br>        int[] q = new int[n];<br>        for (int i = 0; i &lt; n; ++i) {<br>            if (data[i] == '#') continue;<br>            Arrays.fill(dist[i], Short.MAX_VALUE);<br>            short[] cd = dist[i];<br>            cd[i] = 0;<br>            int qt = 0;<br>            int qh = 1;<br>            q[0] = i;<br>            while (qt &lt; qh) {<br>                int cur = q[qt++];<br>                if (data[cur + 1] != '#' &amp;&amp; cd[cur + 1] == Short.MAX_VALUE) {<br>                    cd[cur + 1] = (short) (cd[cur] + 1);<br>                    q[qh++] = cur + 1;<br>                }<br>                if (data[cur - 1] != '#' &amp;&amp; cd[cur - 1] == Short.MAX_VALUE) {<br>                    cd[cur - 1] = (short) (cd[cur] + 1);<br>                    q[qh++] = cur - 1;<br>                }<br>                if (data[cur + width] != '#' &amp;&amp; cd[cur + width] == Short.MAX_VALUE) {<br>                    cd[cur + width] = (short) (cd[cur] + 1);<br>                    q[qh++] = cur + width;<br>                }<br>                if (data[cur - width] != '#' &amp;&amp; cd[cur - width] == Short.MAX_VALUE) {<br>                    cd[cur - width] = (short) (cd[cur] + 1);<br>                    q[qh++] = cur - width;<br>                }<br>            }<br>        }<br>        int[] away = new int[n];<br>        final int MAX_DIST = 8000;<br>        int[] next = new int[n + MAX_DIST];<br>        int[] prev = new int[n + MAX_DIST];<br>        long total = 0;<br>        for (int iFirst = 0; iFirst &lt; nFirst; ++iFirst) {<br>            int f = first[iFirst];<br>            short[] df = dist[f];<br>            for (int iSecond = 0; iSecond &lt; nSecond; ++iSecond) {<br>                int s = second[iSecond];<br>                short[] ds = dist[s];<br>                Arrays.fill(away, Integer.MAX_VALUE);<br>                for (int i = 0; i &lt; n; ++i) {<br>                    if (df[i] &lt; Short.MAX_VALUE &amp;&amp; ds[i] &lt; Short.MAX_VALUE) {<br>                        away[i] = df[i] + ds[i];<br>                    }<br>                }<br>                Arrays.fill(next, -1);<br>                Arrays.fill(prev, -1);<br>                for (int d = 0; d &lt; MAX_DIST; ++d) {<br>                    next[d + n] = d + n;<br>                    prev[d + n] = d + n;<br>                }<br>                for (int i = 0; i &lt; n; ++i)<br>                    if (away[i] &lt; Integer.MAX_VALUE) {<br>                        next[i] = next[away[i] + n];<br>                        prev[i] = away[i] + n;<br>                        prev[next[i]] = i;<br>                        next[prev[i]] = i;<br>                    }<br>                for (int d = 0; d &lt; MAX_DIST; ++d) {<br>                    while (next[n + d] != n + d) {<br>                        int cur = next[n + d];<br>                        prev[next[cur]] = prev[cur];<br>                        next[prev[cur]] = next[cur];<br>                        next[cur] = -1;<br>                        prev[cur] = -1;<br>                        int newAway = away[cur] + 1;<br>                        int nxt = cur + 1;<br>                        if (data[nxt] != '#' &amp;&amp; away[nxt] &gt; newAway) {<br>                            if (next[nxt] &gt;= 0) {<br>                                prev[next[nxt]] = prev[nxt];<br>                                next[prev[nxt]] = next[nxt];<br>                            }<br>                            away[nxt] = newAway;<br>                            next[nxt] = next[newAway + n];<br>                            prev[nxt] = newAway + n;<br>                            next[prev[nxt]] = nxt;<br>                            prev[next[nxt]] = nxt;<br>                        }<br>                        nxt = cur - 1;<br>                        if (data[nxt] != '#' &amp;&amp; away[nxt] &gt; newAway) {<br>                            if (next[nxt] &gt;= 0) {<br>                                prev[next[nxt]] = prev[nxt];<br>                                next[prev[nxt]] = next[nxt];<br>                            }<br>                            away[nxt] = newAway;<br>                            next[nxt] = next[newAway + n];<br>                            prev[nxt] = newAway + n;<br>                            next[prev[nxt]] = nxt;<br>                            prev[next[nxt]] = nxt;<br>                        }<br>                        nxt = cur + width;<br>                        if (data[nxt] != '#' &amp;&amp; away[nxt] &gt; newAway) {<br>                            if (next[nxt] &gt;= 0) {<br>                                prev[next[nxt]] = prev[nxt];<br>                                next[prev[nxt]] = next[nxt];<br>                            }<br>                            away[nxt] = newAway;<br>                            next[nxt] = next[newAway + n];<br>                            prev[nxt] = newAway + n;<br>                            next[prev[nxt]] = nxt;<br>                            prev[next[nxt]] = nxt;<br>                        }<br>                        nxt = cur - width;<br>                        if (data[nxt] != '#' &amp;&amp; away[nxt] &gt; newAway) {<br>                            if (next[nxt] &gt;= 0) {<br>                                prev[next[nxt]] = prev[nxt];<br>                                next[prev[nxt]] = next[nxt];<br>                            }<br>                            away[nxt] = newAway;<br>                            next[nxt] = next[newAway + n];<br>                            prev[nxt] = newAway + n;<br>                            next[prev[nxt]] = nxt;<br>                            prev[next[nxt]] = nxt;<br>                        }<br>                    }<br>                }<br>                for (int iThird = 0; iThird &lt; nThird; ++iThird) {<br>                    int cur = away[third[iThird]];<br>                    if (cur == Integer.MAX_VALUE)<br>                        return "";<br>                    total += cur;<br>                }<br>            }<br>        }<br>        long denom = (long) nFirst * (long) nSecond * (long) nThird;<br>        long g = gcd(total, denom);<br>        return (total / g) + "/" + (denom / g);<br>  }<br> <br>    private long gcd(long a, long b) {<br>        while (b &gt; 0) {<br>            long t = a % b;<br>            a = b;<br>            b = t;<br>        }<br>        return a;<br>    }<br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>