<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;list&gt;<br>#include &lt;complex&gt;<br>#include &lt;cstdio&gt;<br> <br>using namespace std;<br> <br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef long long ll;<br>typedef complex&lt;double&gt; pnt;<br>typedef pair&lt;int, int&gt; pii;<br> <br>#define RA(x) (x).begin(), (x).end()<br>#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)<br>#define SZ(x) ((int) (x).size())<br> <br>template&lt;class T&gt;<br>void splitstr(const string &amp;s, vector&lt;T&gt; &amp;out)<br>{<br>    istringstream in(s);<br>    out.clear();<br>    copy(istream_iterator&lt;T&gt;(in), istream_iterator&lt;T&gt;(), back_inserter(out));<br>}<br> <br>class NewItemShop<br>{<br>public:<br>    double getMaximum(int swords, vector &lt;string&gt; customers);<br>};<br> <br>struct hour<br>{<br>    int cust;<br>    int next;<br>    int price;<br>    double prob;<br>    double tprob;<br> <br>    hour() : cust(-1), next(-1), price(0), prob(0.0), tprob(1.0) {}<br>};<br> <br>static int N;<br>static hour hours[24];<br>static map&lt;pair&lt;int, pii&gt;, double&gt; cache;<br> <br>static double recurse(int swords, int time, int mask)<br>{<br>    pair&lt;int, pii&gt; key(swords, pii(time, mask));<br>    if (cache.count(key))<br>        return cache[key];<br> <br>    double ans = 0.0;<br>    if (time == 24)<br>        ans = 0.0;<br>    else<br>    {<br>        hour &amp;h = hours[time];<br>        int cmask = 1 &lt;&lt; h.cust;<br>        if (h.cust == -1 || (mask &amp; cmask))<br>            ans = recurse(swords, time + 1, mask);<br>        else<br>        {<br>            double p = h.prob / h.tprob;<br>            int mask2 = mask;<br>            if (h.next != -1)<br>                mask2 |= cmask;<br>            double base = recurse(swords, time + 1, mask);<br>            double reject = recurse(swords, time + 1, mask2);<br>            double yes = reject;<br>            if (swords &gt; 0)<br>            {<br>                double accept = recurse(swords - 1, time + 1, mask2) + h.price;<br>                if (accept &gt; yes) yes = accept;<br>            }<br>            ans = base * (1.0 - p) + yes * p;<br>        }<br>    }<br>    return cache[key] = ans;<br>}<br> <br>double NewItemShop::getMaximum(int swords, vector &lt;string&gt; customers)<br>{<br>    cache.clear();<br>    fill(hours, hours + 24, hour());<br> <br>    N = SZ(customers);<br>    int cidx = 0;<br>    vector&lt;double&gt; rprob(24);<br>    FE(s, customers)<br>    {<br>        vector&lt;string&gt; parts;<br>        splitstr(*s, parts);<br>        reverse(RA(parts));<br> <br>        int t, c, p;<br>        int next = -1;<br>        int sprob = 0;<br>        FE(part, parts)<br>        {<br>            sscanf(part-&gt;c_str(), "%d,%d,%d", &amp;t, &amp;c, &amp;p);<br>            hours[t].cust = cidx;<br>            hours[t].prob = p / 100.0;<br>            hours[t].price = c;<br>            hours[t].next = next;<br>            next = t;<br>            sprob += p;<br>        }<br>        rprob[cidx] = (100 - sprob) / 100.0;<br>        cidx++;<br>    }<br>    for (int t = 23; t &gt;= 0; t--)<br>        if (hours[t].next != -1)<br>            hours[t].tprob = hours[t].prob + hours[hours[t].next].tprob;<br>        else if (hours[t].cust != -1)<br>            hours[t].tprob = hours[t].prob + rprob[hours[t].cust];<br>    return recurse(swords, 0, 0);<br>}<br> <br> <br>// Powered by FileEdit<br></td>