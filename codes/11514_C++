<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;numeric&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;list&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdarg&gt;<br>#include &lt;cstring&gt;<br>using namespace std;<br> <br>#define ALL(c) (c).begin(), (c).end()<br>#define FOR(i, n) for (int i = 0; i &lt; (int)(n); ++i)<br>#define FOREACH(i, n) for (typeof(n.begin()) i = n.begin(); i != n.end(); ++i)<br>#define MEMSET(p, c) memset(p, c, sizeof(p))<br>typedef long long llint;<br>typedef pair&lt;int, int&gt; PII;<br>#ifndef WATASHI_PC<br>#define errf(fmt, ...) do { } while (false)<br>#endif<br> <br>struct RequiredSubstrings {<br>  int solve(vector &lt;string&gt; words, int C, int L);<br>};<br> <br>struct AhoCorasick {<br>  static const int UNDEF = 0;<br>  static const int MAXN = 360;<br>  static const int CHARSET = 26;<br> <br>  int end;<br>  int tag[MAXN];<br>  int fail[MAXN];<br>  int trie[MAXN][CHARSET];<br> <br>  void init() {<br>    tag[0] = UNDEF;<br>    fill(trie[0], trie[0] + CHARSET, -1);<br>    end = 1;<br>  }<br> <br>  void add(int m, const int* s, int t) {<br>    int p = 0;<br>    for (int i = 0; i &lt; m; ++i) {<br>      if (trie[p][*s] == -1) {<br>        tag[end] = UNDEF;<br>        fill(trie[end], trie[end] + CHARSET, -1);<br>        trie[p][*s] = end++;<br>      }<br>      p = trie[p][*s];<br>      ++s;<br>    }<br>    tag[p] = t;<br>  }<br> <br>  void build() {<br>    queue&lt;int&gt; bfs;<br>    fail[0] = 0;<br>    for (int i = 0; i &lt; CHARSET; ++i) {<br>      if (trie[0][i] != -1) {<br>        fail[trie[0][i]] = 0;<br>        bfs.push(trie[0][i]);<br>      } else {<br>        trie[0][i] = 0;<br>      }<br>    }<br>    while (!bfs.empty()) {<br>      int p = bfs.front();<br>      tag[p] |= tag[fail[p]];<br>      bfs.pop();<br>      for (int i = 0; i &lt; CHARSET; ++i) {<br>        if (trie[p][i] != -1) {<br>          fail[trie[p][i]] = trie[fail[p]][i];<br>          bfs.push(trie[p][i]);<br>        } else {<br>          trie[p][i] = trie[fail[p]][i];<br>        }<br>      }<br>    }<br>  }<br>} ac;<br> <br>const int MAXN = 6;<br>const int MAXL = 60;<br>const int MOD = 1000000009;<br> <br>int a[MAXL];<br>int dp[MAXL][AhoCorasick::MAXN][1 &lt;&lt; MAXN];<br> <br>int RequiredSubstrings::solve(vector &lt;string&gt; words, int C, int L) {<br>  int n = words.size();<br>  ac.init();<br>  for (int i = 0; i &lt; n; ++i) {<br>    int m = words[i].length();<br>    for (int j = 0; j &lt; m; ++j) {<br>      a[j] = words[i][j] - 'a';<br>    }<br>    ac.add(m, a, 1 &lt;&lt; i);<br>  }<br>  ac.build();<br> <br>  fill(dp[0][0], dp[L + 1][0], 0);<br>  dp[0][0][ac.tag[0]] = 1;<br>  for (int i = 0; i &lt; L; ++i) {<br>    for (int j = 0; j &lt; ac.end; ++j) {<br>      for (int k = 0; k &lt; (1 &lt;&lt; n); ++k) {<br>        if (dp[i][j][k] != 0) {<br>          for (int t = 0; t &lt; AhoCorasick::CHARSET; ++t) {<br>            int jj = ac.trie[j][t];<br>            int kk = k | ac.tag[jj];<br>            dp[i + 1][jj][kk] = (dp[i + 1][jj][kk] + dp[i][j][k]) % MOD;<br>          }<br>        }<br>      }<br>    }<br>  }<br> <br>  int ans = 0;<br>  for (int j = 0; j &lt; ac.end; ++j) {<br>    for (int k = 0; k &lt; (1 &lt;&lt; n); ++k) {<br>      if (__builtin_popcount(k) == C) {<br>        ans = (ans + dp[L][j][k]) % MOD;<br>      }<br>    }<br>  }<br>  return ans;<br>}<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>