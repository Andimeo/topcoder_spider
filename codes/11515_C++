<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;utility&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cstring&gt;<br>#include &lt;queue&gt;<br>#include &lt;list&gt;<br>#include &lt;numeric&gt;<br>#include &lt;iterator&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cmath&gt;<br><br>using namespace std;<br><br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;VI&gt; VVI;<br>typedef pair&lt;int,int&gt; PII;<br>typedef vector&lt;PII&gt; VPII;<br>typedef long long LL;<br>typedef vector&lt;double&gt; VD;<br>typedef vector&lt;string&gt; VS;<br><br>#define REP(i,n) for (int i = 0; i &lt; (n); ++i)<br>#define FOR(i,a,b) for (int i = (a); i &lt;= (b); ++i)<br>#define FORD(i,a,b) for (int i = (a); i &gt;= (b); --i)<br>#define FOREACH(it,X) for (__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it)<br>#define PB push_back<br>#define MP make_pair<br>#define ST first<br>#define ND second<br>#define SIZE(X) ((int)(X).size())<br>#define ALL(X) (X).begin(),(X).end()<br><br>void wypiszVI(const VI&amp; v){<br>  printf("{");<br>  REP(i,SIZE(v)){<br>    if (i) printf(",");<br>    printf("%d",v[i]);<br>  }<br>  puts("}");<br>}<br><br>void wypiszVS(const VS&amp; v){<br>  puts("{");<br>  REP(i,SIZE(v)) printf("\"%s\",\n",v[i].c_str());<br>  puts("}");<br>}<br><br>const int MOD = 1000000009;<br><br>const int N = 2100;<br>int t[N][2*N];<br><br>class EventOrder {<br>  public:<br>  int getCount(int longEvents, int instantEvents) {<br>    int n = longEvents + instantEvents;<br>    if (longEvents &gt; 0) t[1][2] = 1;<br>    else t[1][1] = 1;<br><br>    FOR(i,1,n-1) FOR(j,0,2*i) if (t[i][j]) {<br>      if (i &lt; longEvents){<br>        //dwa nowe<br>        t[i+1][j+2] = (t[i+1][j+2] + (LL)t[i][j] * (j * (j+1) /2)) % MOD;<br>        //dwa nowe pomiedzy<br>        t[i+1][j+2] = (t[i+1][j+2] + (LL)t[i][j] * (j+1)) % MOD;<br>        //nic nowego<br>        t[i+1][j] = (t[i+1][j] + (LL)t[i][j] * (j * (j-1) / 2)) % MOD;<br>        //jeden nowy<br>        t[i+1][j+1] = (t[i+1][j+1] + (LL)t[i][j] * j * (j+1)) % MOD;<br>      } else {<br>        //nic nowego<br>        t[i+1][j] = (t[i+1][j] + (LL)t[i][j] * j) % MOD;<br>        //nowy<br>        t[i+1][j+1] = (t[i+1][j+1] + (LL)t[i][j] * (j+1)) % MOD;<br>      }<br>    }<br>    int res = 0;<br>    REP(i,2*N) res = (res + t[n][i]) % MOD;<br>    return res % MOD;<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>