<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class AdjacentSwaps {<br><br>    long mod = 1000000007;<br>    int len;<br>    int[] pr;<br>    long[,] dp;<br>    bool[,] used;<br>    long[,] C;<br><br><br>    public int theCount(int[] p)<br>    {<br>        len = p.Length;<br>        pr = p;<br>        dp = new long[len, len];<br>        C = new long[100, 100];<br>        int i, j;<br>        C[0, 0] = 1;<br>        for (i = 0; i &lt; 99; i++)<br>        {<br>            for (j = 0; j &lt; 99; j++)<br>            {<br>                C[i, j] %= mod;<br>                C[i + 1, j] += C[i, j];<br>                C[i + 1, j + 1] += C[i, j];<br>            }<br>        }<br><br><br>        used = new bool[len, len];<br>        return (int)saiki(0, len - 1);<br>    }<br><br>    long saiki(int a, int b)<br>    {<br>        if (a == b) return 1;<br>        if (used[a, b]) return dp[a, b];<br>        int i, j;<br>        int[] ar = new int[b - a + 1];<br>        for (i = a; i &lt;= b; i++) ar[i - a] = pr[i];<br>        Dictionary&lt;int, int &gt; dic = new Dictionary&lt;int,int&gt;();<br>        for (i = a; i &lt;= b; i++) dic[ar[i - a]] = i;<br>        Array.Sort(ar);<br>        long res = 0;<br>        used[a, b] = true;<br><br>        for (i = a; i &lt; b; i++)<br>        {<br>            //down<br>            for (j = a; j &lt; i; j++)<br>            {<br>                if (dic[ar[j - a]] &gt; i) break;<br>            }<br>            if (j != i) continue;<br>            if (dic[ar[i + 1 - a]] &gt; i) continue;<br><br>            //up<br>            for (j = i + 2; j &lt;= b; j++)<br>            {<br>                if (dic[ar[j - a]] &lt;= i) break;<br>            }<br>            if (j != b + 1) continue;<br>            if (dic[ar[i - a]] &lt;= i) continue;<br><br>            res += (((saiki(a, i) * saiki(i + 1, b)) % mod) * C[(i - a) + (b - (i+1)), i - a]) % mod;<br>            res %= mod;<br>        }<br><br>        return dp[a, b] = res;<br>    }<br><br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>