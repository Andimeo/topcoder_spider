<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br> <br>public class ColorfulBoard<br>{<br>    int N, M;<br>    public int theMin(string[] board)<br>    {<br>        N = board.Length;<br>        M = board[0].Length;<br>        int[,] target = new int[N, M];<br>        int[,] target2 = new int[M, N];<br>        for (int i = 0; i &lt; N; i++)<br>        {<br>            for (int j = 0; j &lt; M; j++)<br>            {<br>                target[i, j] = board[i][j] - '0';<br>                target2[j, i] = target[i, j];<br>            }<br>        }<br> <br>        int ans1 = minWays(target);<br> <br>        int temp = N;<br>        N = M;<br>        M = temp;<br> <br>        int ans2 = minWays(target2);<br> <br>        if (ans1 == -1) return ans2;<br>        if (ans2 == -1) return ans1;<br>        return Math.Min(ans1, ans2);<br>    }<br> <br>    private int minWays(int[,] target)<br>    {<br>        bool[] rowDone = new bool[N];<br>        bool[] colDone = new bool[M];<br> <br>        int steps = 0;<br>        int rowsDone = 0;<br>        do<br>        {<br>            bool painted = false;<br>            for (int i = 0; i &lt; N; i++)<br>            {<br>                if (rowcolcolour(target, i, -1, rowDone, colDone) &gt;= 0)<br>                {<br>                    steps++;<br>                    rowDone[i] = true;<br>                    rowsDone++;<br>                    if (rowsDone == N) return steps;<br>                    painted = true;<br>                    break;<br>                }<br>            }<br>            if (painted) continue;<br> <br>            bool[] readyCols = new bool[M];<br>            for (int j = 0; j &lt; M; j++)<br>            {<br>                if (rowcolcolour(target, -1, j, rowDone, colDone) &gt;= 0)<br>                {<br>                    readyCols[j] = true;<br>                }<br> <br>            }<br> <br>            int bestColCount = 999;<br>            List&lt;int&gt; bestColSet = null;<br>            for (int i = 0; i &lt; N; i++) if (!rowDone[i])<br>            {<br>                List&lt;int&gt; bestColSetForRow = minColSetToFixRow(target, rowDone, colDone, i, readyCols);<br>                if (bestColSetForRow != null &amp;&amp; bestColSetForRow.Count &lt; bestColCount)<br>                {<br>                    bestColSet = bestColSetForRow;<br>                    bestColCount = bestColSet.Count;<br>                }<br>            }<br> <br>            if (bestColSet == null) return -1;<br> <br>            foreach (int j in bestColSet)<br>            {<br>                colDone[j] = true;<br>                steps++;<br>            }<br> <br>        } while (true);<br>    }<br> <br>    private int rowcolcolour(int[,] target, int row, int col, bool[] rowdone, bool[] coldone)<br>    {<br>        int c = -1;<br>        if (row != -1)<br>        {<br>            if (rowdone[row]) return -1;<br>            for (int j = 0; j &lt; M; j++)<br>            {<br>                if (!coldone[j])<br>                {<br>                    if (c != -1 &amp;&amp; target[row, j] != c) return -1;<br>                    c = target[row, j];<br>                }<br>            }<br>            return c;<br>        }<br> <br>        if (col != -1)<br>        {<br>            if (coldone[col]) return -1;<br>            for (int i = 0; i &lt; N; i++)<br>            {<br>                if (!rowdone[i])<br>                {<br>                    if (c != -1 &amp;&amp; target[i, col] != c) return -1;<br>                    c = target[i, col];<br>                }<br>            }<br>            return c;<br>        }<br> <br>        return -1;<br>    }<br> <br>    private List&lt;int&gt; minColSetToFixRow(int[,] target, bool[] rowsdone, bool[] colsdone, int row, bool[] readycols)<br>    {<br>        int best = 999;<br>        int colTot = 0;<br>        Dictionary&lt;int, int&gt; colCount = new Dictionary&lt;int, int&gt;();<br>        for (int j = 0; j &lt; M; j++) if (!colsdone[j])<br>            {<br>                if (!colCount.ContainsKey(target[row, j])) colCount.Add(target[row, j], 0);<br>                colCount[target[row, j]]++;<br>                colTot++;<br>            }<br>        List&lt;int&gt; bestret = null;<br>        foreach (KeyValuePair&lt;int, int&gt; colour in colCount)<br>        {<br>            if (colTot - colour.Value &lt; best)<br>            {<br>                List&lt;int&gt; ret = new List&lt;int&gt;();<br>                bool possible = true;<br>                for (int j = 0; j &lt; M; j++) if (!colsdone[j])<br>                    {<br>                        if (target[row, j] != colour.Key)<br>                        {<br>                            if (!readycols[j]) possible = false;<br>                            ret.Add(j);<br>                        }<br>                    }<br>                if (possible)<br>                {<br>                    best = colTot - colour.Value;<br>                    bestret = ret;<br>                }<br>            }<br>        }<br> <br>        return bestret;<br>    }<br> <br> <br>}<br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>