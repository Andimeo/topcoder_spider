<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;functional&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;ctime&gt;<br><br>using namespace std;<br><br>#define REP(i,n) for((i)=0;(i)&lt;(int)(n);(i)++)<br>#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)<br><br>typedef long long ll;<br>#define MOD 1234567891ll<br><br>ll pathdp[2][1000010];<br><br>int leftmost;<br>int L,dl[20],R,dr[20];<br>vector &lt;int&gt; vl[200000],vr[200000];<br><br>class TheCards{<br>  public:<br>  <br>  void dfsl(int pos, int pos2, int big, int cur){ // cout &lt;&lt; "A " &lt;&lt; pos &lt;&lt; ' ' &lt;&lt; pos2 &lt;&lt; ' ' &lt;&lt; big &lt;&lt; ' ' &lt;&lt; cur &lt;&lt; endl;<br>    if(pos == L){<br>      vl[cur].push_back(big);<br>    } else {<br>      int pos3 = (pos2 + 1) % (L + R);<br>      int low = ((pos3 &lt; leftmost) ? 1 : 0);<br>      int next = cur + dl[pos];<br>      if(next &gt;= low) dfsl(pos+1, pos3, max(big, next), next);<br>      next = cur - dl[pos];<br>      if(next &gt;= low) dfsl(pos+1, pos3, max(big, next), next);<br>    }<br>  }<br>  <br>  void dfsr(int pos, int pos2, int big, int cur){<br>    if(pos == R){<br>      vr[cur].push_back(big);<br>    } else {<br>      int pos3 = (pos2 - 1 + L + R) % (L + R);<br>      int low = ((pos3 &lt; leftmost) ? 1 : 0);<br>      int next = cur + dr[pos];<br>      if(next &gt;= low) dfsr(pos+1, pos3, max(big, next), next);<br>      next = cur - dr[pos];<br>      if(next &gt;= low) dfsr(pos+1, pos3, max(big, next), next);<br>    }<br>  }<br>  <br>  ll calc(int x, int X){<br>    int A=vl[x].size(),B=vr[x].size(),i,j;<br>    ll ans = 0;<br>    <br>    sort(vl[x].begin(),vl[x].end());<br>    sort(vr[x].begin(),vr[x].end());<br>    <br>  //  cout &lt;&lt; leftmost &lt;&lt; ' ' &lt;&lt; x &lt;&lt; endl;<br>  //  REP(i,A) cout &lt;&lt; vl[x][i] &lt;&lt; ' '; cout &lt;&lt; endl;<br>  //  REP(i,B) cout &lt;&lt; vr[x][i] &lt;&lt; ' '; cout &lt;&lt; endl;<br>    <br>    // vl[x][i] &lt;= vr[x][j]<br>    i = 0;<br>    REP(j,B){<br>      while(i+1 &lt; A &amp;&amp; vl[x][i+1] &lt;= vr[x][j]) i++;<br>      if(vl[x][i] &lt;= vr[x][j]){<br>        int Y = vr[x][j];<br>        if(Y &lt; X) ans = (ans + (ll)(X-Y) * (i+1)) % MOD;<br>      }<br>    }<br>    <br>    // vl[x][i] &gt; vr[x][j]<br>    j = 0;<br>    REP(i,A){<br>      while(j+1 &lt; B &amp;&amp; vl[x][i] &gt; vr[x][j+1]) j++;<br>      if(vl[x][i] &gt; vr[x][j]){<br>        int Y = vl[x][i];<br>        if(Y &lt; X) ans = (ans + (ll)(X-Y) * (j+1)) % MOD;<br>      }<br>    }<br>    <br>  //  cout &lt;&lt; ans &lt;&lt; endl;<br>  //  cout &lt;&lt; endl;<br>    <br>    return ans;<br>  }<br>  <br>  ll cycle(vector &lt;int&gt; d, int X){ // N &gt;= 2<br>    int N=d.size(),i,j;<br>    ll ans = 0;<br>    <br>    L = N/2; R = N-L;<br>    REP(i,N){ // i is the first leftmost<br>      leftmost = i;<br>      REP(j,200000) vl[j].clear();<br>      REP(j,200000) vr[j].clear();<br>      REP(j,L) dl[j] = d[(i+j)%N];<br>      REP(j,R) dr[j] = d[(i-1-j+2*N)%N];<br>      dfsl(0,i,0,0); dfsr(0,i,0,0);<br>    //  cout &lt;&lt; leftmost &lt;&lt; ' ' &lt;&lt; vl[2].size() &lt;&lt; ' ' &lt;&lt; vr[2].size() &lt;&lt; endl &lt;&lt; endl;<br>      REP(j,200000) if(!vl[j].empty() &amp;&amp; !vr[j].empty()){<br>        ll tmp = calc(j,X);<br>        ans = (ans + tmp) % MOD;<br>      }<br>    }<br>    <br>    return ans;<br>  }<br>  <br>  ll path(vector &lt;int&gt; d, int X){<br>    int N=d.size(),i,j;<br>    <br>  //  cout &lt;&lt; 'A' &lt;&lt; endl;<br>  //  REP(i,N) cout &lt;&lt; d[i] &lt;&lt; ' ';<br>  //  cout &lt;&lt; endl;<br>    <br>    REP(i,X) pathdp[0][i] = 1;<br>    REP(i,N){<br>      int cur = i%2, next = (i+1)%2;<br>      REP(j,X) pathdp[next][j] = 0;<br>      REP(j,X){<br>        if(j &gt;= d[i]) pathdp[next][j-d[i]] = (pathdp[next][j-d[i]] + pathdp[cur][j]) % MOD;<br>        if(d[i] != 0 &amp;&amp; j+d[i] &lt; X) pathdp[next][j+d[i]] = (pathdp[next][j+d[i]] + pathdp[cur][j]) % MOD;<br>      }<br>    }<br>    <br>    ll ans = 0;<br>    REP(i,X) ans = (ans + pathdp[N%2][i]) % MOD;<br>  //  cout &lt;&lt; ans &lt;&lt; endl;<br>    return ans;<br>  }<br><br>  int find(vector &lt;int&gt; dist, int m){<br>    int N=dist.size(),i,j;<br>    <br>    // contain -1<br>    vector &lt;int&gt; minus;<br>    REP(i,N) if(dist[i] == -1) minus.push_back(i);<br>    <br>    if(!minus.empty()){<br>      ll ans = 1;<br>      int sz = minus.size();<br>      <br>      REP(i,sz-1){<br>        vector &lt;int&gt; d;<br>        for(j=minus[i]+1;j&lt;minus[i+1];j++) d.push_back(dist[j]);<br>        ll tmp = path(d,m);<br>        ans = ans * tmp % MOD;<br>      }<br>      <br>      {<br>        vector &lt;int&gt; d;<br>        for(j=minus[sz-1]+1;j&lt;N;j++) d.push_back(dist[j]);<br>        REP(j,minus[0]) d.push_back(dist[j]);<br>        ll tmp = path(d,m);<br>        ans = ans * tmp % MOD;<br>      }<br>      <br>      return ans;<br>    }<br>    <br>    vector &lt;int&gt; nonzero;<br>    REP(i,N) if(dist[i] != 0) nonzero.push_back(dist[i]);<br>    if(nonzero.size() == 0) return m;<br>    if(nonzero.size() == 1) return 0;<br>    <br>    ll ans2 = cycle(nonzero,m);<br>    return ans2;<br>  }<br><br>};<br><br><br>// Powered by FileEdit<br></td>