<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br> <br>using namespace std;<br> <br>#define LL long long<br>#define LLU unsigned long long<br>#define sz(s) s.size()<br>#define clr(f, t) memset(f, t, sizeof(f))<br>#define all(x) (x).begin(), (x).end()<br>#define X first<br>#define Y second<br>#define MP(x, y) make_pair(x, y)<br>#define PB(x) push_back(x)<br>#define FR(i, a, b) for (int i(a), _b(b); i &lt; _b; ++i)<br>#define FD(i, a, b) for (int i(a), _b(b); i &gt;= _b; --i)<br> <br>typedef pair &lt; int, int &gt; PII;<br> <br>int toInt(string s){ istringstream sin(s); int t; sin&gt;&gt;t; return t;}<br>template&lt;class T&gt; string toString(T x){ ostringstream sout; sout&lt;&lt;x; return sout.str(); }<br> <br>#define N 10<br>#define MOD 1000000007<br> <br>int dp[N + 1][1 &lt;&lt; N];<br> <br>class SmallBricks31 {<br>public:<br>  int w, h, m;<br>  void dfs(int i, int k, int ns, int ps) {<br>    if (k == w) {<br>      if (!ns) return;<br>      dp[i + 1][ns] += dp[i][ps];<br>      if (dp[i + 1][ns] &gt;= MOD) dp[i + 1][ns] -= MOD;<br>      return;<br>    }<br>    dfs(i, k + 1, ns, ps);<br>    if (ps &gt;&gt; k &amp; 1)<br>      dfs(i, k + 1, ns | (1 &lt;&lt; k), ps);<br>    if (k + 1 &lt; w &amp;&amp; (ps &gt;&gt; k &amp; 1) &amp;&amp; (ps &gt;&gt; (k + 1) &amp; 1))<br>      dfs(i, k + 2, ns | (1 &lt;&lt; k) | (1 &lt;&lt; (k + 1)), ps);<br>    if (k + 2 &lt; w &amp;&amp; (ps &gt;&gt; k &amp; 1) &amp;&amp; (ps &gt;&gt; (k + 2) &amp; 1))<br>      dfs(i, k + 3, ns | (1 &lt;&lt; k) | (1 &lt;&lt; (k + 1)) | (1 &lt;&lt; (k + 2)), ps);<br>  }<br>    int countWays(int _w, int _h) {<br>      w = _w; h = _h;<br>      m = 1 &lt;&lt; w;<br>      clr(dp, 0);<br>      dp[0][m - 1] = 1;<br>      FR(i, 0, h) FR(j, 0, m) if (dp[i][j])<br>        dfs(i, 0, 0, j);<br>      int ret = 0;<br>      FR(i, 0, h + 1) FR(j, 0, m) if (dp[i][j]) {<br>        ret += dp[i][j];<br>        if (ret &gt;= MOD) ret -= MOD;<br>      }<br>        return ret;<br>    }<br>    <br> <br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>