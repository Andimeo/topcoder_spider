<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;utility&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;complex&gt;<br><br>using namespace std;<br><br>typedef long long Int;<br>typedef vector&lt;int&gt; vint;<br>typedef pair&lt;int,int&gt; pint;<br>#define mp make_pair<br><br>template&lt;class T&gt; void pv(T a, T b) { for (T i = a; i != b; ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; endl; }<br>template&lt;class T&gt; void pvp(T a, T b) { for (T i = a; i != b; ++i) cout &lt;&lt; "(" &lt;&lt; i-&gt;first &lt;&lt; ", " &lt;&lt; i-&gt;second &lt;&lt; ") "; cout &lt;&lt; endl; }<br>template&lt;class T&gt; void chmin(T &amp;t, T f) { if (t &gt; f) t = f; }<br>template&lt;class T&gt; void chmax(T &amp;t, T f) { if (t &lt; f) t = f; }<br><br>const Int MO = 1000000007;<br><br>Int mod(Int x) { return (x % MO + MO) % MO; }<br><br>Int power(Int a, Int e) {<br>  Int x = a, y = 1;<br>  for (; e; e &gt;&gt;= 1, x = x * x % MO) if (e &amp; 1) y = y * x % MO;<br>  return y;<br>}<br>Int inv(Int x) {<br>  return power(x, MO - 2);<br>}<br><br>Int d, q, n;<br><br>struct Rabbit {<br>  Int A, B, C, D;<br>  Rabbit() {}<br>  Rabbit(Int A, Int B, Int C, Int D) : A(A), B(B), C(C), D(D) {}<br>  Int get(int i, int j) {<br>    Int qj = power(q, j);<br>    Int ret = 0;<br>    ret += A * 1;<br>    ret += B * i;<br>    ret += C * qj;<br>    ret += D * mod(i * qj);<br>    ret = mod(ret);<br>    return ret;<br>  }<br>  Rabbit operator*(const Rabbit &amp;r) const {<br>    Int s1, sk, s1qk, skqk;<br>    s1 = mod(n);<br>    sk = mod((n - 1) * n / 2);<br>    if (q == 1) {<br>      s1qk = s1;<br>      skqk = sk;<br>    } else {<br>      Int qn = power(q, n);<br>      s1qk = mod((qn - 1) * inv(q - 1));<br>      skqk = mod(mod(mod((n - 1) * qn) - (s1qk - 1)) * inv(q - 1));<br>    }<br>    Rabbit s(0, 0, 0, 0);<br>    s.A += mod(A*r.A)*s1  ; s.A += mod(A*r.B)*sk  ; s.C += mod(A*r.C)*s1  ; s.C += mod(A*r.D)*sk  ;<br>    s.B += mod(B*r.A)*s1  ; s.B += mod(B*r.B)*sk  ; s.D += mod(B*r.C)*s1  ; s.D += mod(B*r.D)*sk  ;<br>    s.A += mod(C*r.A)*s1qk; s.A += mod(C*r.B)*skqk; s.C += mod(C*r.C)*s1qk; s.C += mod(C*r.D)*skqk;<br>    s.B += mod(D*r.A)*s1qk; s.B += mod(D*r.B)*skqk; s.D += mod(D*r.C)*s1qk; s.D += mod(D*r.D)*skqk;<br>    s.A = mod(s.A);<br>    s.B = mod(s.B);<br>    s.C = mod(s.C);<br>    s.D = mod(s.D);<br>    return s;<br>  }<br>};<br>Rabbit power(Rabbit &amp;a, Int e) {<br>  if (e == 1) return a;<br>  Rabbit b = power(a, e / 2);<br>  b = b * b;<br>  if (e % 2 != 0) b = b * a;<br>  return b;<br>}<br>ostream &amp;operator&lt;&lt;(ostream &amp;os, const Rabbit &amp;r) {<br>  os &lt;&lt; "(" &lt;&lt; r.A &lt;&lt; ", " &lt;&lt; r.B &lt;&lt; ", " &lt;&lt; r.C &lt;&lt; ", " &lt;&lt; r.D &lt;&lt; ")";<br>  return os;<br>}<br><br><br>struct MatrixPower {<br>  <br>  vector &lt;int&gt; getElements(int inp_d, int inp_q, int inp_n, int k, vector &lt;int&gt; rows, vector &lt;int&gt; columns) {<br>    <br>    <br>    d = inp_d;<br>    q = inp_q;<br>    n = inp_n;<br>    <br>    Rabbit A(0, d, 1, 0);<br>    Rabbit B = power(A, k);<br>    <br>    int Q = rows.size(), i;<br>    vint ans(Q);<br>    for (i = 0; i &lt; Q; ++i) {<br>      ans[i] = (int)B.get(rows[i], columns[i]);<br>    }<br>    return ans;<br>    <br>  }<br>  <br>};<br></td>