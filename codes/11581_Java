<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Iterator;<br>import java.util.NoSuchElementException;<br>import java.util.Set;<br>import java.util.TreeSet;<br><br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class PointErasing {<br>  public int[] getOutcomes(int[] y) {<br>    WritableSequence&lt;Integer&gt; wrappedY = ArrayWrapper.wrap(y);<br>    int min = CollectionUtils.minElement(wrappedY);<br>    int max = CollectionUtils.maxElement(wrappedY);<br>    int first = Math.min(SequenceUtils.find(wrappedY, min), SequenceUtils.find(wrappedY, max));<br>    int last = Math.max(SequenceUtils.findLast(wrappedY, min), SequenceUtils.findLast(wrappedY, max));<br>    int minAnswer = CollectionUtils.count(wrappedY, min);<br>    if (min != max)<br>      minAnswer += CollectionUtils.count(wrappedY, max);<br>    if (first != 0)<br>      minAnswer++;<br>    if (last != y.length - 1)<br>      minAnswer++;<br>    int[] leftVariants = go(y, first);<br>    int[] yReverse = new int[y.length];<br>    for (int i = 0; i &lt; y.length; i++)<br>      yReverse[i] = y[y.length - 1 - i];<br>    int[] rightVariants = go(yReverse, y.length - 1 - last);<br>    Set&lt;Integer&gt; variants = new TreeSet&lt;Integer&gt;();<br>    for (int i : leftVariants) {<br>      for (int j : rightVariants)<br>        variants.add(i + j);<br>    }<br>    int[] result = new int[variants.size()];<br>    int index = 0;<br>    for (int i : variants)<br>      result[index++] = minAnswer + i;<br>    return result;<br>  }<br><br>  private int[] go(int[] array, int upTo) {<br>    if (upTo == 0)<br>      return new int[]{0};<br>    boolean[][] canBe = new boolean[upTo][upTo];<br>    canBe[0][0] = true;<br>    for (int i = 1; i &lt; upTo; i++) {<br>      for (int j = 0; j &lt; upTo; j++) {<br>        if (canBe[i - 1][j]) {<br>          if (array[i] == array[0])<br>            canBe[i][j + 1] = true;<br>          else {<br>            canBe[i][j] = true;<br>            canBe[upTo - 1][j] = true;<br>            for (int k = i + 1; k &lt; upTo; k++) {<br>              if (array[i] &lt; array[0] &amp;&amp; array[k] &gt; array[0] || array[i] &gt; array[0] &amp;&amp; array[k] &lt; array[0])<br>                canBe[k - 1][j] = true;<br>            }<br>          }<br>        }<br>      }<br>    }<br>    int size = CollectionUtils.count(ArrayWrapper.wrap(canBe[upTo - 1]), true);<br>    int[] result = new int[size];<br>    int index = 0;<br>    for (int i = 0; i &lt; upTo; i++) {<br>      if (canBe[upTo - 1][i])<br>        result[index++] = i;<br>    }<br>    return result;<br>  }<br><br><br>}<br><br>interface WritableSequence&lt;T&gt; extends Sequence&lt;T&gt; {<br>  }<br><br>abstract class ArrayWrapper&lt;T&gt; extends AbstractWritableSequence&lt;T&gt; {<br><br>  public static WritableSequence&lt;Integer&gt; wrap(int...array) {<br>    return new IntArrayWrapper(array);<br>  }<br><br>  public static WritableSequence&lt;Boolean&gt; wrap(boolean...array) {<br>    return new BooleanArrayWrapper(array);<br>  }<br><br>  protected static class IntArrayWrapper extends ArrayWrapper&lt;Integer&gt; {<br>    protected final int[] array;<br><br>    protected IntArrayWrapper(int[] array) {<br>      this.array = array;<br>    }<br><br>    public int size() {<br>      return array.length;<br>    }<br><br>    public Integer get(int index) {<br>      return array[index];<br>    }<br><br>    }<br><br>  protected static class BooleanArrayWrapper extends ArrayWrapper&lt;Boolean&gt; {<br>    protected final boolean[] array;<br><br>    protected BooleanArrayWrapper(boolean[] array) {<br>      this.array = array;<br>    }<br><br>    public int size() {<br>      return array.length;<br>    }<br><br>    public Boolean get(int index) {<br>      return array[index];<br>    }<br><br>    }<br><br>  }<br><br>class CollectionUtils {<br><br>  public static&lt;T extends Comparable&lt;T&gt;&gt; T minElement(Iterable&lt;T&gt; collection) {<br>    T result = null;<br>    for (T element : collection) {<br>      if (result == null || result.compareTo(element) &gt; 0)<br>        result = element;<br>    }<br>    return result;<br>  }<br><br>  public static&lt;T extends Comparable&lt;T&gt;&gt; T maxElement(Iterable&lt;T&gt; collection) {<br>    T result = null;<br>    for (T element : collection) {<br>      if (result == null || result.compareTo(element) &lt; 0)<br>        result = element;<br>    }<br>    return result;<br>  }<br><br>  public static&lt;T&gt; int count(Iterable&lt;T&gt; array, T sample) {<br>    int result = 0;<br>    for (T element : array) {<br>      if (element.equals(sample))<br>        result++;<br>    }<br>    return result;<br>  }<br><br>  }<br><br>class SequenceUtils {<br>  public static&lt;T&gt; int find(Sequence&lt;T&gt; sequence, T value) {<br>    int size = sequence.size();<br>    for (int i = 0; i &lt; size; i++) {<br>      if (MiscUtils.equals(sequence.get(i), value))<br>        return i;<br>    }<br>    return -1;<br>  }<br><br>  public static &lt;T&gt; int findLast(Sequence&lt;T&gt; sequence, T value) {<br>    int size = sequence.size();<br>    for (int i = size - 1; i &gt;= 0; i--) {<br>      if (MiscUtils.equals(sequence.get(i), value))<br>        return i;<br>    }<br>    return -1;<br>  }<br>}<br><br>interface Sequence&lt;T&gt; extends Iterable&lt;T&gt; {<br>  public int size();<br>  public T get(int index);<br>}<br><br>abstract class AbstractWritableSequence&lt;T&gt; extends AbstractSequence&lt;T&gt; implements WritableSequence&lt;T&gt; {<br><br>  }<br><br>class MiscUtils {<br><br>  public static&lt;T&gt; boolean equals(T first, T second) {<br>    return first == null &amp;&amp; second == null || first != null &amp;&amp; first.equals(second);<br>  }<br><br>  }<br><br>abstract class AbstractSequence&lt;T&gt; implements Sequence&lt;T&gt; {<br><br>  public Iterator&lt;T&gt; iterator() {<br>    return new ReadOnlyIterator&lt;T&gt;() {<br>      private int index = 0;<br><br>      public boolean hasNext() {<br>        return index != size();<br>      }<br><br>      public T next() {<br>        if (!hasNext())<br>          throw new NoSuchElementException();<br>        return get(index++);<br>      }<br>    };<br>  }<br><br>  }<br><br>abstract class ReadOnlyIterator&lt;T&gt; implements Iterator&lt;T&gt;  {<br>  public final void remove() {<br>    throw new UnsupportedOperationException();<br>  }<br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.15 [modified TZTester]<br>// Powered by CodeProcessor<br></td>