<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class SPartition {<br>   public long getCount(String s) {<br>       int n = s.length() / 2;<br>       long[][] best = new long[2 * n + 1][];<br>       for (int balance = -n; balance &lt;= n; ++balance) {<br>           best[balance + n] = new long[1 &lt;&lt; Math.abs(balance)];<br>       }<br>       best[0 + n][0] = 1;<br>       for (int i = 0; i &lt; s.length(); ++i) {<br>           for (int oldBalance = -n; oldBalance &lt;= n; ++oldBalance) {<br>               if ((i + oldBalance) % 2 != 0) Arrays.fill(best[oldBalance + n], 0);<br>           }<br>           int curBit = s.charAt(i) == 'x' ? 1 : 0;<br>           for (int oldBalance = -n; oldBalance &lt;= n; ++oldBalance) {<br>               if ((i + oldBalance) % 2 != 0) continue;<br>               int firstPos = (i + oldBalance) / 2;<br>               int secondPos = firstPos - oldBalance;<br>               if (firstPos &lt; 0 || secondPos &lt; 0 || firstPos &gt; n || secondPos &gt; n) continue;<br>               int numMasks = best[oldBalance + n].length;<br>               for (int oldMask = 0; oldMask &lt; numMasks; ++oldMask) {<br>                   long curWays = best[oldBalance + n][oldMask];<br>                   if (curWays == 0) continue;<br>                   if (oldBalance == 0) {<br>                       if (firstPos &lt; n) {<br>                           best[oldBalance + n + 1][curBit] += curWays;<br>                       }<br>                       if (secondPos &lt; n) {<br>                           best[oldBalance + n - 1][curBit] += curWays;<br>                       }<br>                   } else if (oldBalance &gt; 0) {<br>                       if (firstPos &lt; n) {<br>                           best[oldBalance + n + 1][oldMask + (curBit &lt;&lt; oldBalance)] += curWays;<br>                       }<br>                       if (secondPos &lt; n &amp;&amp; ((oldMask &amp; 1) == curBit)) {<br>                           best[oldBalance + n - 1][oldMask &gt;&gt; 1] += curWays;<br>                       }<br>                   } else {<br>                       if (secondPos &lt; n) {<br>                           best[oldBalance + n - 1][oldMask + (curBit &lt;&lt; -oldBalance)] += curWays;<br>                       }<br>                       if (firstPos &lt; n &amp;&amp; ((oldMask &amp; 1) == curBit)) {<br>                           best[oldBalance + n + 1][oldMask &gt;&gt; 1] += curWays;<br>                       }<br>                   }<br>               }<br>           }<br>       }<br>       return best[n][0];<br>   }<br> <br> <br>}<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>