<td class="problemText" colspan="8" valign="middle" align="left">
            // Authored by dolphinigle<br>// TopCoder<br> <br>#include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br> <br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;cstring&gt;<br>#include &lt;assert.h&gt;<br> <br>#define FORN(X,Y) for (int (X) = 0;(X) &lt; (Y);++(X))<br>#define DEBUG(x) cout &lt;&lt; '&gt;' &lt;&lt; #x &lt;&lt; ':' &lt;&lt; x &lt;&lt; '\n';<br> <br>#define REP(X,Y,Z) for (int (X) = (Y);(X) &lt; (Z);++(X))<br>#define RESET(Z,Y) memset(Z,Y,sizeof(Z))<br> <br>#define SZ(Z) ((int)(Z).size())<br>#define ALL(W) (W).begin(), (W).end()<br>#define PB push_back<br> <br>#define MP make_pair<br>#define A first<br>#define B second<br> <br>#define INF 1023123123<br>#define EPS 1e-11<br> <br>#define MX(Z,Y) Z = max((Z),(Y))<br>#define MN(X,Y) X = min((X),(Y))<br> <br>#define FORIT(X,Y) for(typeof((Y).begin()) X = (Y).begin();X!=(Y).end();X++)<br> <br>using namespace std;<br> <br>typedef long long ll;<br>typedef double db;<br>typedef vector&lt;int&gt; vint;<br>typedef vector&lt;ll&gt; vll;<br> <br>class DengklekCountingFormations {<br>public:<br>int numFormations(int, int, int);<br>};<br> <br>//(number**exponent) % ivalue;<br>ll Power(ll number,ll exponent,ll ivalue) {<br>  ll ret = 1;<br>  ll multiplier = number;<br>  while (exponent &gt; 0LL) {<br>    if (exponent % 2LL) {<br>      ret = (ret * multiplier) % ivalue;<br>    }<br>    exponent /= 2LL;<br>    multiplier = (multiplier * multiplier) % ivalue;<br>  }<br>  return ret;<br>}<br> <br>//works if modulo &gt;= 2<br>ll MultiplicativeInverse(ll number, ll ivalue) {<br>  return Power(number, ivalue - 2LL, ivalue);<br>}<br> <br>ll FastCombination(ll from, ll pick, ll ivalue, bool reset = false) {<br>  static vector&lt;ll&gt; fact, rfact;<br>  if (reset) fact = rfact = vector&lt;ll&gt;(0);<br>  if (SZ(fact) == 0LL) {<br>    fact.PB(1LL);<br>    rfact.PB(1LL);<br>  }<br>  if (pick &gt; from) return 0LL;<br>  ll table_size = max(from, max(pick, from-pick));<br>  while (SZ(fact) &lt;= table_size) {<br>    fact.PB((fact.back() * (ll)SZ(fact)) % ivalue);<br>    rfact.PB(MultiplicativeInverse(fact.back(), ivalue));<br>  }<br>  ll jahja = (fact[from] * rfact[pick]) % ivalue;<br>  return (jahja * rfact[from-pick]) % ivalue;<br>}<br>// O(max(from, pick)).<br>// Assumes that ivalue will always be the same. To reset, use the<br>// reset flag.<br> <br>ll modu = 1000000007LL;<br> <br>int combi[102][102][102];<br> <br>int n, m, k;<br> <br>int dp[12][52][102][52];<br> <br>int Solve(int row, int col, int types, int toput) {<br> <br>  int&amp; alias = dp[row][col][types][toput];<br>  if (alias != -1) return alias;<br>  <br>  if (row == 0) return alias = 1;<br>  if (col == 0) return alias = (row == 1);<br>  <br>  if (types == k) {<br>    // not allowed to put anymore<br>    return alias = 0;<br>  }<br>  <br>  if (toput &gt; col) {<br>    return alias = 0;<br>  }<br>  <br>  alias = 0;<br>  FORN(i, row+1) {<br>    ll val = (ll)Solve(i, col - toput, types+1, 0) *<br>             (ll)Solve(row - i, col, types, toput+1);<br>    val %= modu;<br>    val *= combi[row][i][1];<br>    val %= modu;<br>    val *= combi[col][toput][i];<br>    val %= modu;<br>    alias += val;<br>    alias %= modu;<br>  }<br>    //cout &lt;&lt; row &lt;&lt; " " &lt;&lt; col &lt;&lt; " " &lt;&lt; types &lt;&lt; " " &lt;&lt; toput &lt;&lt; " " &lt;&lt; alias &lt;&lt; endl;<br>  return alias;<br>}<br> <br>int DengklekCountingFormations::numFormations(int N, int M, int K) {<br>  n = N;<br>  m = M;<br>  k = K;<br>  FORN(i, 12) FORN(j, 52) FORN(k, 102) FORN(l, 52) dp[i][j][k][l] = -1;<br>  <br>  FORN(i, 102) FORN(j, 102) combi[i][j][0] = 1;<br>  <br>  FORN(i, 102) FORN(j, 102) {<br>    ll mult = FastCombination(i, j, modu);<br>    REP(k, 1, 102) combi[i][j][k] = (((ll)combi[i][j][k-1] * mult) % (ll)modu);<br>  }<br>  return Solve(n, m, 0, 0);<br>}<br> <br> <br>//Powered by [KawigiEdit] 2.0!<br> <br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>