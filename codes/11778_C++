<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br><br>using namespace std;<br><br>template&lt;class T&gt; inline T euclide(T a,T b,T &amp;x,T &amp;y)<br>  {if(a&lt;0){T d=euclide(-a,b,x,y);x=-x;return d;}<br>   if(b&lt;0){T d=euclide(a,-b,x,y);y=-y;return d;}<br>   if(b==0){x=1;y=0;return a;}else{T d=euclide(b,a%b,x,y);T t=x;x=y;y=t-(a/b)*y;return d;}}<br><br>const int MOD=10007;<br><br>#define MUL(a,b) ((a)*(b)%MOD)<br>#define ADD(a,b) (((a)+(b))%MOD)<br>#define SUB(a,b) (((a)-(b))%MOD)<br><br>inline void addto(int &amp;a,int b) { a+=b; if (a&gt;=MOD) a-=MOD; }<br><br>class FoxAndGreed<br>{<br>public:<br>  int factorial[10000],factorial_inv[10000];<br>  int f[6000][105],f1[6000][105],f2[6000][105];<br>  int ep[2600*2600];<br>  int get_inv(int a)<br>  {<br>    int x,y;<br>    euclide(a,MOD,x,y);<br>    x%=MOD;<br>    if (x&lt;0) x+=MOD;<br>    return x;<br>  }<br>  int get_c(int n,int m)<br>  {<br>    if (n&lt;0 || m&lt;0 || m&gt;n) return 0;<br>    return MUL(factorial[n],MUL(factorial_inv[m],factorial_inv[n-m]));<br>  }<br>  void preprocess(int n,int s)<br>  {<br>    memset(f,0,sizeof(f));<br>    memset(f1,0,sizeof(f1));<br>    memset(f2,0,sizeof(f2));<br>    f[0][0]=f1[0][0]=f2[0][0]=1;<br>    for (int i=0;i&lt;n;i++) for (int p=0;p&lt;=s;p++) <br>    {<br>      if (f[i][p]) for (int h=0;p+h&lt;=s;h++) addto(f[i+1][p+h],f[i][p]);<br>      if (f1[i][p]) for (int h=0;p+h&lt;=s;h++) addto(f1[i+1][p+h],MUL(h+1,f1[i][p]));<br>      if (f2[i][p]) for (int h=0;p+h&lt;=s;h++) addto(f2[i+1][p+h],MUL(h,f2[i][p]));<br>    }<br>  }<br>  int count(int n, int m, int s)<br>  {<br>    for (int i=0;i&lt;2600*2600;i++)<br>      ep[i]=(i==0)?1:MUL(ep[i-1],s+1);<br>    for (int i=0;i&lt;10000;i++)<br>    {<br>      factorial[i]=(i==0)?1:MUL(factorial[i-1],i);<br>      factorial_inv[i]=get_inv(factorial[i]);<br>    }<br>    preprocess(max(n,m)+2,s);<br>    if (n==1 || m==1) return f[n*m-1][s];<br>    int ret=0;<br>    for (int x=0;x&lt;n;x++) for (int y=0;y&lt;m;y++)<br>    {<br>      if (x==n-1 &amp;&amp; y==m-1) continue;<br>      if (x==n-1)<br>      {<br>        int ps=(y+n-1)*2+(m-1-y);<br>        int tmp[105];<br>        memset(tmp,0,sizeof(tmp));<br>        for (int s1=0;s1&lt;=s;s1++) for (int s2=0;s1+s2&lt;=s;s2++)<br>        {<br>          int t=MUL(f1[y][s1],f2[n-1][s2]);<br>          t=MUL(t,get_c(x+y-1,y));<br>          addto(tmp[s1+s2],t);<br>        }<br>        for (int s0=0;s0&lt;=s;s0++)<br>        {<br>          int t=MUL(tmp[s0],f[m-1-y][s-s0]);<br>          addto(ret,MUL(t,ep[n*m-1-ps]));<br>        }<br>      }<br>      if (y==m-1)<br>      {<br>        int ps=(m-1+x)*2+(n-1-x);<br>        int tmp[105];<br>        memset(tmp,0,sizeof(tmp));<br>        for (int s1=0;s1&lt;=s;s1++) for (int s2=0;s1+s2&lt;=s;s2++)<br>        {<br>          int t=MUL(f1[m-1][s1],f2[x][s2]);<br>          t=MUL(t,get_c(x+y-1,x));<br>          addto(tmp[s1+s2],t);<br>        }<br>        for (int s0=0;s0&lt;=s;s0++)<br>        {<br>          int t=MUL(tmp[s0],f[n-1-x][s-s0]);<br>          addto(ret,MUL(t,ep[n*m-1-ps]));<br>        }<br>      }<br>    }<br>    return ret;<br>  }<br>};<br></td>