<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;list&gt;<br>#include &lt;complex&gt;<br>#include &lt;climits&gt;<br> <br>using namespace std;<br> <br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef long long ll;<br>typedef complex&lt;double&gt; pnt;<br>typedef pair&lt;int, int&gt; pii;<br> <br>#define RA(x) (x).begin(), (x).end()<br>#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)<br>#define SZ(x) ((int) (x).size())<br> <br> <br>class Pikachu<br>{<br>public:<br>    vector &lt;int&gt; bestEncoding(vector &lt;int&gt; freq);<br>};<br> <br>struct state<br>{<br>    int freq[4];<br>    int used;<br> <br>    bool operator&lt;(const state &amp;s) const<br>    {<br>        if (used != s.used)<br>            return used &lt; s.used;<br>        else<br>        {<br>            for (int i = 0; i &lt; 4; i++)<br>                if (freq[i] != s.freq[i])<br>                    return freq[i] &lt; s.freq[i];<br>        }<br>        return false;<br>    }<br>};<br> <br>typedef pair&lt;int, ll&gt; result;<br>static ll choose[60][60];<br>static ll fact[60];<br>static map&lt;state, result&gt; cache;<br> <br>#define MOD 1000000009<br> <br>static result combine(const result &amp;a, const result &amp;b)<br>{<br>    if (a.first == b.first)<br>        return result(a.first, (a.second + b.second) % MOD);<br>    else<br>        return min(a, b);<br>}<br> <br>static result recurse(const state &amp;s, const vi &amp;freq_sum)<br>{<br>    int N = SZ(freq_sum) - 1;<br>    if (s.freq[0] == 0 &amp;&amp; s.freq[1] == 0 &amp;&amp; s.freq[2] == 0 &amp;&amp; s.freq[3] == 0)<br>    {<br>        if (s.used == SZ(freq_sum) - 1)<br>            return result(0, 1);<br>        else<br>            return result(INT_MAX, 0);<br>    }<br>    if (s.freq[0] + s.freq[1] + s.freq[2] + s.freq[3] &gt; N - s.used)<br>        return result(INT_MAX, 0);<br> <br>    if (s.freq[0] == 0)<br>    {<br>        state n = s;<br>        for (int i = 0; i &lt; 3; i++)<br>            n.freq[i] = n.freq[i + 1];<br>        n.freq[3] = 0;<br>        result r = recurse(n, freq_sum);<br>        r.first += (freq_sum.back() - freq_sum[s.used]);<br>        return r;<br>    }<br> <br>    if (cache.count(s))<br>        return cache[s];<br> <br>    result ans(INT_MAX, 0);<br>    for (int u = 0; u &lt;= min(N - s.used, s.freq[0]); u++)<br>    {<br>        int cut = freq_sum[s.used + u] - freq_sum[s.used + u - 1];<br>        int p = s.used + u - 1;<br>        while (p &gt; s.used &amp;&amp; freq_sum[p] - freq_sum[p - 1] == cut)<br>            p--;<br>        int q = s.used + u;<br>        while (q &lt; N &amp;&amp; freq_sum[q + 1] - freq_sum[q] == cut)<br>            q++;<br>        for (int i = 0; i &lt;= s.freq[0] - u; i++)<br>        {<br>            int j = s.freq[0] - u - i;<br>            state n = s;<br>            n.freq[0] = 0;<br>            n.freq[2] += 2 * (i + j);<br>            n.freq[3] += j;<br>            n.used += u;<br>            result r = recurse(n, freq_sum);<br>            r.second = (r.second * choose[s.freq[0]][u]) % MOD;<br>            r.second = (r.second * fact[u]) % MOD;<br>            r.second = (r.second * choose[q - p][s.used + u - p]) % MOD;<br>            r.second = (r.second * choose[s.freq[0] - u][i]) % MOD;<br>            ans = combine(ans, r);<br>        }<br>    }<br>    return cache[s] = ans;<br>}<br> <br>vector &lt;int&gt; Pikachu::bestEncoding(vector &lt;int&gt; freq)<br>{<br>    cache.clear();<br>    fact[0] = 1;<br>    for (int i = 0; i &lt; 60; i++)<br>    {<br>        choose[i][0] = choose[i][i] = 1;<br>        for (int j = 1; j &lt; i; j++)<br>            choose[i][j] = (choose[i - 1][j - 1] + choose[i - 1][j]) % MOD;<br>    }<br>    for (int i = 1; i &lt; 60; i++)<br>    {<br>        fact[i] = (fact[i - 1] * i) % MOD;<br>    }<br> <br>    int N = SZ(freq);<br>    vi freq_sum(N + 1, 0);<br>    sort(RA(freq), greater&lt;int&gt;());<br>    partial_sum(RA(freq), freq_sum.begin() + 1);<br>    state s;<br>    for (int i = 0; i &lt; 4; i++)<br>        s.freq[i] = 0;<br>    s.freq[0] = 1;<br>    s.used = 0;<br>    result ans = recurse(s, freq_sum);<br>    vi ans2(2);<br>    ans2[0] = ans.first;<br>    ans2[1] = ans.second;<br>    return ans2;<br>}<br> <br> <br>// Powered by FileEdit<br></td>