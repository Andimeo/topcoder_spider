<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class Pikachu {<br>   static final long MODULO = 1000000009;<br>    static final int INF = (int) 1e9;<br>    static class Answer {<br>        int best = INF;<br>        int ways = 0;<br>    }<br>    <br>   public int[] bestEncoding(int[] freq) {<br>       Arrays.sort(freq);<br>       int n = freq.length;<br>       n += 3;<br>       int[] extraPay = new int[n + 1];<br>       for (int i = n - 1; i &gt;= 0; --i)<br>           extraPay[i] = extraPay[i + 1] + (freq.length - 1 - i &lt; 0 ? 0 : freq[freq.length - 1 - i]);<br>       int[][] comb = new int[n + 1][n + 1];<br>       comb[0][0] = 1;<br>       for (int i = 1; i &lt;= n; ++i) {<br>           comb[i][0] = 1;<br>           for (int j = 1; j &lt;= n; ++j) {<br>               comb[i][j] = (int) ((comb[i - 1][j] + comb[i - 1][j - 1]) % MODULO);<br>           }<br>       }<br>       int[][] prod = new int[n + 1][n + 1];<br>       for (int done = 0; done &lt;= n - 3; ++done) {<br>           long pr = 1;<br>           for (int take0 = 0; done + take0 &lt;= n - 3; ++take0) {<br>               int numSame = 0;<br>               int numInside = 0;<br>               if (take0 &gt; 0) {<br>                   for (int i = done; i &lt; n - 3; ++i)<br>                       if (freq[freq.length - 1 - i] == freq[freq.length - 1 - done - take0 + 1]) {<br>                           ++numSame;<br>                           if (i &lt; done + take0)<br>                               ++numInside;<br>                       }<br>               }<br>               prod[done][take0] = (int) (pr * comb[numSame][numInside] % MODULO);<br>               pr = pr * (take0 + 1) % MODULO;<br>           }<br>       }<br>       Answer[][][][] res = new Answer[n + 1][][][];<br>       Answer[][][][] nres = new Answer[n + 1][][][];<br>       for (int done = 0; done &lt;= n - 3; ++done) {<br>           res[done] = new Answer[n + 1 - done][][];<br>           nres[done] = new Answer[n + 1 - done][][];<br>           for (int free0 = 0; done + free0 &lt;= n; ++free0) {<br>               res[done][free0] = new Answer[n + 1 - done - free0][];<br>               nres[done][free0] = new Answer[n + 1 - done - free0][];<br>               for (int free1 = 0; done + free0 + free1 &lt;= n; ++free1) {<br>                   res[done][free0][free1] = new Answer[n + 1 - done - free0 - free1];<br>                   nres[done][free0][free1] = new Answer[n + 1 - done - free0 - free1];<br>                   for (int free2 = 0; done + free0 + free1 + free2 &lt;= n; ++free2) {<br>                       res[done][free0][free1][free2] = new Answer();<br>                       nres[done][free0][free1][free2] = new Answer();<br>                   }<br>               }<br>           }<br>       }<br>       res[0][1][0][0].best = 0;<br>       res[0][1][0][0].ways = 1;<br>       Answer ret = new Answer();<br>       ret.best = INF - 1;<br>       for (int level = 0;; ++level) {<br>           for (int done = 0; done &lt;= n - 3; ++done) {<br>               for (int free0 = 0; done + free0 &lt;= n; ++free0) {<br>                   for (int free1 = 0; done + free0 + free1 &lt;= n; ++free1) {<br>                       for (int free2 = 0; done + free0 + free1 + free2 &lt;= n; ++free2) {<br>                           nres[done][free0][free1][free2].best = INF;<br>                           nres[done][free0][free1][free2].ways = 0;<br>                       }<br>                   }<br>               }<br>           }<br>           boolean any = false;<br>           for (int done = 0; done &lt;= n - 3; ++done) {<br>               for (int free0 = 0; done + free0 &lt;= n; ++free0) {<br>                   for (int free1 = 0; done + free0 + free1 &lt;= n; ++free1) {<br>                       for (int free2 = 0; done + free0 + free1 + free2 &lt;= n; ++free2) {<br>                           Answer r = res[done][free0][free1][free2];<br>                           if (r.best &gt; ret.best)<br>                               continue;<br>                           if (done &gt;= n - 3) {<br>                               update(ret, r, 0, 1);<br>                           } else {<br>                               any = true;<br>                               for (int take0 = 0; take0 &lt;= free0 &amp;&amp; done + take0 &lt;= n - 3; ++take0) {<br>                                   int ndone = done + take0;<br>                                   int nfree0 = Math.min(free1, n - ndone);<br>                                   int nfree1 = Math.min(free2 + 2 * (free0 - take0), n - ndone - nfree0);<br>                                   int nfree2 = Math.min(free0 - take0, n - ndone - nfree0 - nfree1);<br>                                   update(nres[ndone][nfree0][nfree1][nfree2], r, extraPay[ndone], prod[done][take0] * (long) comb[free0][take0] % MODULO);<br>                               }<br>                           }<br>                       }<br>                   }<br>               }<br>           }<br>           if (!any) break;<br>           Answer[][][][] tmp = res;<br>           res = nres;<br>           nres = tmp;<br>       }<br>       return new int[]{ret.best, ret.ways};<br>   }<br> <br>    private void update(Answer a, Answer b, int extra, long times) {<br>        if (b.best + extra &lt; a.best) {<br>            a.best = b.best + extra;<br>            a.ways = 0;<br>        }<br>        if (b.best + extra == a.best) {<br>            a.ways = (int) ((a.ways + times * b.ways) % MODULO);<br>        }<br>    }<br>}<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>