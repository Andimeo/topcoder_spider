<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.List;<br>import java.util.Arrays;<br>import java.util.ArrayList;<br>import java.util.Set;<br>import java.io.PrintStream;<br>import java.util.Comparator;<br>import java.util.HashSet;<br>import java.util.Collection;<br><br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class EllysNumbers {<br>  public long getSubsets(long n, String[] special) {<br>    String all = StringUtils.unite(special);<br>    String[] tokens = all.split(" ");<br>    int[] multipliers = new int[tokens.length];<br>    for (int i = 0; i &lt; multipliers.length; i++)<br>      multipliers[i] = Integer.parseInt(tokens[i]);<br>    boolean[] isGood = new boolean[multipliers.length];<br>    boolean containsOne = false;<br>    for (int i = 0; i &lt; multipliers.length; i++) {<br>      isGood[i] = n % multipliers[i] == 0 &amp;&amp; IntegerUtils.gcd(n / multipliers[i], multipliers[i]) == 1;<br>      containsOne |= multipliers[i] == 1;<br>    }<br>    long nCopy = n;<br>    for (int i = 0; i &lt; multipliers.length; i++) {<br>      if (isGood[i])<br>        nCopy /= IntegerUtils.gcd(nCopy, multipliers[i]);<br>    }<br>    if (nCopy != 1)<br>      return 0;<br>    Set&lt;Long&gt; primes = new HashSet&lt;Long&gt;();<br>    for (int i = 0; i &lt; multipliers.length; i++) {<br>      if (isGood[i]) {<br>        for (Pair&lt;Long, Integer&gt; pair : IntegerUtils.factorize(multipliers[i])) {<br>          primes.add(pair.first);<br>        }<br>      }<br>    }<br>    long[] aPrimes = new long[primes.size()];<br>    int index = 0;<br>    for (long prime : primes)<br>      aPrimes[index++] = prime;<br>    int[] mask = new int[multipliers.length];<br>    for (int i = 0; i &lt; multipliers.length; i++) {<br>      if (isGood[i] &amp;&amp; multipliers[i] != 1) {<br>        int curMask = 0;<br>        for (int j = 0; j &lt; aPrimes.length; j++) {<br>          if (multipliers[i] % aPrimes[j] == 0)<br>            curMask += 1 &lt;&lt; j;<br>        }<br>        mask[i] = curMask;<br>      }<br>    }<br>    long[] answer = new long[1 &lt;&lt; aPrimes.length];<br>    answer[0] = 1;<br>    for (int i = 0; i &lt; multipliers.length; i++) {<br>      if (!isGood[i] || multipliers[i] == 1)<br>        continue;<br>      for (int j = answer.length - 1; j &gt; 0; j--) {<br>        if ((j &amp; mask[i]) == mask[i])<br>          answer[j] += answer[j - mask[i]];<br>      }<br>    }<br>    return answer[answer.length - 1] * (containsOne ? 2 : 1);<br>  }<br><br>  }<br><br>class StringUtils {<br><br>  public static String unite(String[] array) {<br>    StringBuilder result = new StringBuilder();<br>    for (String s : array) {<br>      result.append(s);<br>    }<br>    return result.toString();<br>  }<br><br>  }<br><br>class IntegerUtils {<br>  public static long gcd(long a, long b) {<br>    while (b != 0) {<br>      long temp = a % b;<br>      a = b;<br>      b = temp;<br>    }<br>    return a;<br>  }<br><br>  public static List&lt;Pair&lt;Long, Integer&gt;&gt; factorize(long number) {<br>    List&lt;Pair&lt;Long, Integer&gt;&gt; result = new ArrayList&lt;Pair&lt;Long, Integer&gt;&gt;();<br>    for (long i = 2; i * i &lt;= number; i++) {<br>      if (number % i == 0) {<br>        int power = 0;<br>        do {<br>          power++;<br>          number /= i;<br>        } while (number % i == 0);<br>        result.add(Pair.makePair(i, power));<br>      }<br>    }<br>    if (number != 1)<br>      result.add(Pair.makePair(number, 1));<br>    return result;<br>  }<br><br>  }<br><br>class Pair&lt;U, V&gt; implements Comparable&lt;Pair&lt;U, V&gt;&gt; {<br>  public final U first;<br>  public final V second;<br><br>  public static&lt;U, V&gt; Pair&lt;U, V&gt; makePair(U first, V second) {<br>    return new Pair&lt;U, V&gt;(first, second);<br>  }<br><br>  private Pair(U first, V second) {<br>    this.first = first;<br>    this.second = second;<br>  }<br><br>  public boolean equals(Object o) {<br>    if (this == o) return true;<br>    if (o == null || getClass() != o.getClass()) return false;<br><br>    Pair pair = (Pair) o;<br><br>    return !(first != null ? !first.equals(pair.first) : pair.first != null) &amp;&amp; !(second != null ? !second.equals(pair.second) : pair.second != null);<br><br>  }<br><br>  public int hashCode() {<br>    int result = first != null ? first.hashCode() : 0;<br>    result = 31 * result + (second != null ? second.hashCode() : 0);<br>    return result;<br>  }<br><br>  public String toString() {<br>    return "(" + first + "," + second + ")";<br>  }<br><br>  public int compareTo(Pair&lt;U, V&gt; o) {<br>    int value = ((Comparable&lt;U&gt;)first).compareTo(o.first);<br>    if (value != 0)<br>      return value;<br>    return ((Comparable&lt;V&gt;)second).compareTo(o.second);<br>  }<br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.17 [modified TZTester]<br>// Powered by CodeProcessor<br></td>