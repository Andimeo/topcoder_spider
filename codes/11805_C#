<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br> <br>public class SafeReturn<br>{<br>  public int minRisk(int N, string[] streets)<br>  {<br>      int T = streets.Length;<br>        int[,] Dist = new int[T,T];<br>      for (int i = 0; i &lt; T; i++)<br>      {<br>          for (int j = 0; j &lt; T; j++)<br>          {<br>              if (j==i)<br>              {<br>                  Dist[i, j] = 0;<br>              }<br>                else if (streets[i][j] &gt;= '1' &amp;&amp; streets[i][j]&lt;='9')<br>                {<br>                    Dist[i, j] = streets[i][j] - '0';<br>                }<br>                else<br>                {<br>                    Dist[i, j] = 1000000;<br>                }<br> <br>          }<br>      }<br>      for (int i = 0; i &lt; T; i++)<br>      {<br>          for (int j = 0; j &lt; T; j++)<br>          {<br>              for (int k = 0; k &lt; T; k++)<br>              {<br>                  Dist[j, k] = Math.Min(Dist[j, k], Dist[j, i] + Dist[i, k]);<br>              }<br>          }<br>      }<br>        bool[,] Edge = new bool[N,N];<br>      for (int i = 0; i &lt; N; i++)<br>      {<br>          for (int j = 0; j &lt; N; j++)<br>          {<br>              if (j==i)<br>              {<br>                  continue;<br>              }<br>              int from = i + 1;<br>              int to = j + 1;<br>              if (Dist[0,from]==Dist[0,to]+Dist[to,from])<br>              {<br>                  Edge[i, j] = true;<br>              }<br>          }<br>      }<br>      return N-BipartiteMatching.Calc(Edge);<br>  }<br> <br> <br>    public class BipartiteMatching<br>    {<br>        private static int[] matchl;<br>        private static int[] matchr;<br>        private static int L;<br>        private static int R;<br>        private static bool[] visited;<br>        private static bool[,] Edge;<br> <br>        private static bool dfs(int cur)<br>        {<br>            if (visited[cur]) return false;<br>            visited[cur] = true;<br>            for (int i = 0; i &lt; R; ++i)<br>            {<br>                if (!Edge[cur, i]) continue;<br>                if (matchr[i] == -1 || dfs(matchr[i]))<br>                {<br>                    matchl[cur] = i;<br>                    matchr[i] = cur;<br>                    return true;<br>                }<br>            }<br>            return false;<br>        }<br> <br>        public static int Calc(bool[,] edge)<br>        {<br>            Edge = edge;<br>            L = edge.GetUpperBound(0) + 1;<br>            R = edge.GetUpperBound(1) + 1;<br>            matchl = new int[L];<br>            matchr = new int[R];<br>            for (int i = 0; i &lt; L; ++i)<br>            {<br>                matchl[i] = -1;<br>            }<br>            for (int i = 0; i &lt; R; ++i)<br>            {<br>                matchr[i] = -1;<br>            }<br>            int ret = 0;<br>            visited = new bool[L];<br>            for (int i = 0; i &lt; L; ++i)<br>            {<br>                if (matchl[i] != -1)<br>                {<br>                    continue;<br>                }<br>                for (int j = 0; j &lt; L; ++j)<br>                {<br>                    visited[j] = false;<br>                }<br>                if (dfs(i))<br>                {<br>                    ++ret;<br>                }<br>            }<br>            return ret;<br>        }<br>    } <br> <br> <br>}<br>//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!<br></td>