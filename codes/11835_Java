<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class Stamp {<br>    static final int INF = (int) 1e9;<br> <br>  public int getMinimumCost(String desiredColor, int stampCost, int pushCost) {<br>        int n = desiredColor.length();<br>        int[] colors = new int[n];<br>        for (int i = 0; i &lt; n; ++i) colors[i] = "RGB".indexOf(desiredColor.charAt(i));<br>        int res = Integer.MAX_VALUE;<br>        for (int len = 1; len &lt;= n; ++len) {<br>            int[][] best = new int[n + 1][3];<br>            for (int[] x : best) Arrays.fill(x, INF);<br>            for (int firstColor = 0; firstColor &lt; 3; ++firstColor) {<br>                boolean valid = true;<br>                for (int i = 0; i &lt; len; ++i)<br>                    if (colors[i] &gt;= 0 &amp;&amp; colors[i] != firstColor)<br>                        valid = false;<br>                if (valid)<br>                    best[len][firstColor] = 1;<br>            }<br>            for (int pos = len; pos &lt; n; ++pos)<br>                for (int lastColor = 0; lastColor &lt; 3; ++lastColor) {<br>                    int lastBest = best[pos][lastColor];<br>                    if (lastBest &gt;= INF) continue;<br>                    for (int protrude = 1; protrude &lt; len &amp;&amp; pos + protrude &lt;= n; ++protrude) {<br>                        if (colors[pos + protrude - 1] &gt;= 0 &amp;&amp; colors[pos + protrude - 1] != lastColor) {<br>                            break;<br>                        }<br>                        best[pos + protrude][lastColor] = Math.min(best[pos + protrude][lastColor], lastBest + 1);<br>                    }<br>                    if (pos + len &lt;= n) {<br>                        for (int firstColor = 0; firstColor &lt; 3; ++firstColor) {<br>                            boolean valid = true;<br>                            for (int i = 0; i &lt; len; ++i)<br>                                if (colors[pos + i] &gt;= 0 &amp;&amp; colors[pos + i] != firstColor)<br>                                    valid = false;<br>                            if (valid)<br>                                best[pos + len][firstColor] = Math.min(best[pos + len][firstColor], lastBest + 1);<br>                        }<br>                    }<br>                }<br>            for (int lastColor = 0; lastColor &lt; 3; ++lastColor) {<br>                if (best[n][lastColor] &lt; INF) {<br>                    res = Math.min(res, best[n][lastColor] * pushCost + len * stampCost);<br>                }<br>            }<br>        }<br>        return res;<br>  }<br>}<br></td>