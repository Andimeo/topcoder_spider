<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br> <br>using namespace std;<br> <br>double dp[42][52][52][52];<br> <br>double sum[52][52][52]; // R,G,B<br> <br>int maxR, maxG, maxB;<br> <br>int is(int l, int r, int L, int R) {<br>  l = max(l, L), r = min(r, R);<br>  if (l &lt;= r)<br>    return r - l + 1;<br>  else<br>    return 0;<br>}<br> <br>int count(int r, int g, int b, int d) {<br>  int ret = is(0, maxR - 1, r - d, r + d);<br>  ret *= is(0, maxG - 1, g - d, g + d);<br>  ret *= is(0, maxB - 1, b - d, b + d);<br>  return ret;<br>}<br> <br>double calc(int l1, int r1, int l2, int r2, int l3, int r3) { //r,g,b<br>  double ret = 0;<br> <br>  int MAX[] = { maxR, maxG, maxB };<br>  int L[] = { l1, l2, l3 }, R[] = { r1, r2, r3 };<br> <br>  for (int i = 0; i &lt; 3; ++i) {<br>    L[i] = max(L[i], 0);<br>    R[i] = min(R[i], MAX[i] - 1);<br>    if (L[i] &gt; R[i])<br>      return 0;<br>  }<br> <br>  for (int mask = 0; mask &lt; 8; ++mask) {<br>    int w[3], sign = 1;<br>    for (int i = 0; i &lt; 3; ++i) {<br>      if (mask &gt;&gt; i &amp; 1) {<br>        w[i] = R[i];<br>      } else {<br>        w[i] = L[i] - 1;<br>        sign *= -1;<br>      }<br>    }<br>    if (w[0] &gt;= 0 &amp;&amp; w[1] &gt;= 0 &amp;&amp; w[2] &gt;= 0)<br>      ret += sum[w[0]][w[1]][w[2]] * sign;<br>  }<br> <br>  return ret;<br>}<br> <br>class RandomColoring {<br>public:<br>  double getProbability(int N, int maxR, int maxG, int maxB, int startR, int startG, int startB, int d1, int d2) {<br>    memset(dp, 0, sizeof dp);<br>    ::maxR = maxR, ::maxB = maxB, ::maxG = maxG;<br> <br>    dp[0][startR][startG][startB] = 1;<br> <br>    --d1;<br> <br>    for (int i = 0; i &lt; N; ++i) {<br> <br>      if (i + 1 &lt; N) {<br>        for (int r = 0; r &lt; maxR; ++r) {<br>          for (int g = 0; g &lt; maxG; ++g) {<br>            for (int b = 0; b &lt; maxB; ++b) {<br>              int cnt = count(r, g, b, d2) - count(r, g, b, d1);<br>              if (cnt &gt; 0)<br>                dp[i][r][g][b] /= cnt;<br>              else<br>                dp[i][r][g][b] = 0;<br>            }<br>          }<br>        }<br>      }<br> <br>      //make sum<br> <br>      for (int r = 0; r &lt; maxR; ++r) {<br>        for (int g = 0; g &lt; maxG; ++g) {<br>          for (int b = 0; b &lt; maxB; ++b) {<br>            sum[r][g][b] = dp[i][r][g][b];<br>            for (int mask = 1; mask &lt; 8; ++mask) {<br>              int nr = r, ng = g, nb = b, sign = -1;<br>              if (mask &amp; 1)<br>                --nr, sign *= -1;<br>              if (mask &amp; 2)<br>                --ng, sign *= -1;<br>              if (mask &amp; 4)<br>                --nb, sign *= -1;<br>              if (nr &gt;= 0 &amp;&amp; ng &gt;= 0 &amp;&amp; nb &gt;= 0)<br>                sum[r][g][b] += sign * sum[nr][ng][nb];<br>            }<br>          }<br>        }<br>      }<br> <br>      //calc next<br>      for (int r = 0; r &lt; maxR; ++r) {<br>        for (int g = 0; g &lt; maxG; ++g) {<br>          for (int b = 0; b &lt; maxB; ++b) {<br>            dp[i + 1][r][g][b] = calc(r - d2, r + d2, g - d2, g + d2, b - d2, b + d2) - calc(r - d1, r + d1, g - d1, g + d1, b - d1, b + d1);<br>          }<br>        }<br>      }<br>    }<br> <br>    return 1 - dp[N][startR][startG][startB];<br>  }<br>};<br> <br> <br>//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!<br></td>