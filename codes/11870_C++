<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br><br>using namespace std;<br><br>#define SIZE(X) ((int)(X.size()))<br>#define MP(X,Y) make_pair(X,Y)<br>typedef long long int64;<br>template&lt;class T&gt; inline void checkmin(T &amp;a,T b){if(b&lt;a) a=b;}<br>typedef pair&lt;int,int&gt; ipair;<br><br>const int MOD=1000000007;<br><br>#define MUL(a,b) ((int)((int64)(a)*(int64)(b)%MOD))<br><br>const int maxsize=110;<br><br>int f[maxsize][maxsize];<br><br>class ProductQuery<br>{<br>public:<br>  inline void addto(int &amp;a,int b)<br>  {<br>    a+=b;<br>    if (a&gt;=MOD) a-=MOD;<br>  }<br>  int theInput(int n, vector &lt;int&gt; S, vector &lt;int&gt; T, vector &lt;int&gt; G,int M=-1)<br>  {<br>    if (M&lt;0) return MUL(theInput(n,S,T,G,2),theInput(n,S,T,G,5));<br>    int inv[10];<br>    for (int i=0;i&lt;M;i++) for (int j=0;j&lt;M;j++) if ((i*j)%M==1) inv[i]=j;<br>    int m=SIZE(S);<br>    int rs[maxsize],rt[maxsize],rg[maxsize];<br>    int h[maxsize],q[maxsize];<br>    for (int i=0;i&lt;m;i++) rs[i]=S[i],rt[i]=T[i],rg[i]=G[i]%M;<br>    bool can_zero[maxsize];<br>    memset(can_zero,true,sizeof(can_zero));<br>    for (int i=0;i&lt;m;i++) if (rg[i]&gt;0) <br>      for (int j=rs[i];j&lt;=rt[i];j++) <br>        can_zero[j]=false;<br>    for (int s=0;s&lt;=n;s++) for (int t=s;t&lt;=n;t++)<br>    {<br>      int R=1;<br>      for (int i=0;i&lt;m;i++) if (rs[i]&gt;=s &amp;&amp; rt[i]&lt;=t &amp;&amp; rg[i]==0) R=0;<br>      if (R&gt;0)<br>      {<br>        int size=t-s+2;<br>        vector&lt;ipair&gt; g[maxsize];<br>        for (int i=0;i&lt;m;i++) if (rs[i]&gt;=s &amp;&amp; rt[i]&lt;=t)<br>        {<br>          int a=rs[i]-s;<br>          int b=rt[i]+1-s;<br>          g[a].push_back(MP(b,rg[i]));<br>          g[b].push_back(MP(a,inv[rg[i]]));<br>        }<br>        memset(h,255,sizeof(h));<br>        for (int i=0;i&lt;size;i++) if (h[i]&lt;0)<br>        {<br>          if (i&gt;0) R=MUL(R,M-1);<br>          int sizeq=0;<br>          h[i]=1;<br>          q[sizeq++]=i;<br>          for (int cl=0;cl&lt;sizeq;cl++) for (int key=q[cl],i=SIZE(g[key])-1;i&gt;=0;i--)<br>          {<br>            int other=g[key][i].first;<br>            int new_val=(h[key]*g[key][i].second)%M;<br>            if (h[other]&lt;0)<br>            {<br>              h[other]=new_val;<br>              q[sizeq++]=other;<br>            }<br>            else if (new_val!=h[other]) R=0;<br>          }<br>        }<br>      }<br>      f[s][t]=R;<br>    }<br>    int g[maxsize];<br>    memset(g,0,sizeof(g));<br>    for (int s=-1;s&lt;n;s++) if (s&lt;0 || g[s]&gt;0)<br>    {<br>      int cnt=(s&lt;0)?1:g[s];<br>      int next=n;<br>      for (int i=0;i&lt;m;i++) if (rg[i]==0 &amp;&amp; rs[i]&gt;s) checkmin(next,rt[i]);<br>      for (int k=s+1;k&lt;=next;k++) if (can_zero[k])<br>      {<br>        int md=(s+1&gt;k-1)?1:f[s+1][k-1];<br>        addto(g[k],MUL(cnt,md));<br>      }<br>    }<br>    return g[n];<br>  }<br>};<br></td>