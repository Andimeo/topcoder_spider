<td class="problemText" colspan="8" valign="middle" align="left">
            import java.math.BigInteger;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class ProductQuery {<br>    static final long MODULO = (long) (1e9 + 7);<br> <br>    public int theInput(int N, int[] Qfrom, int[] Qto, int[] output) {<br>        return (int) (doit(N, Qfrom, Qto, output.clone(), 2) * doit(N, Qfrom, Qto, output.clone(), 5) % MODULO);<br>    }<br>    <br>    int[] qfrom;<br>    int[] qto;<br>    int[] output;<br>    int base;<br>    int i;<br>    int ii;<br>    int[] what;<br>    int[] inv;<br> <br>    private long doit(int n, int[] qfrom, int[] qto, int[] output, int base) {<br>        inv = new int[base];<br>        for (int i = 1; i &lt; base; ++i)<br>            inv[i] = BigInteger.valueOf(i).modInverse(BigInteger.valueOf(base)).intValue();<br>        this.qfrom = qfrom;<br>        this.qto = qto;<br>        this.output = output;<br>        this.base = base;<br>        for (int i = 0; i &lt; output.length; ++i) {<br>            output[i] %= base;<br>        }<br>        long[] ways = new long[n + 1];<br>        ways[0] = 1;<br>        for (int i = 0; i &lt; n;) {<br>            boolean anyNonZero = false;<br>            for (int j = 0; j &lt; qfrom.length; ++j) {<br>                if (qfrom[j] &lt;= i &amp;&amp; qto[j] &gt;= i &amp;&amp; output[j] != 0) {<br>                    anyNonZero = true;<br>                }<br>            }<br>            if (anyNonZero) {<br>                int ii;<br>                for (ii = i + 1; ii &lt; n; ++ii) {<br>                    boolean nowNonZero = false;<br>                    for (int j = 0; j &lt; qfrom.length; ++j) {<br>                        if (qfrom[j] &lt;= ii &amp;&amp; qto[j] &gt;= ii &amp;&amp; output[j] != 0) {<br>                            nowNonZero = true;<br>                        }<br>                    }<br>                    if (!nowNonZero) break;<br>                }<br>                int must = 0;<br>                for (int j = 0; j &lt; qfrom.length; ++j)<br>                    if (output[j] == 0 &amp;&amp; qto[j] &gt;= i &amp;&amp; qto[j] &lt; ii) {<br>                        must = Math.max(must, qfrom[j] + 1);<br>                    }<br>                for (int k = 0; k &lt; must; ++k) {<br>                    ways[k] = 0;<br>                }<br>                what = new int[ii - i + 1];<br>                int pw = 0;<br>                for (int k = i; k &lt;= ii; ++k) {<br>                    if (what[k - i] &gt; 0) continue;<br>                    ++pw;<br>                    this.i = i;<br>                    this.ii = ii;<br>                    if (!dfs(k, 1)) return 0;<br>                }<br>                long prod = 1;<br>                for (int k = 1; k &lt; pw; ++k) {<br>                    prod = prod * (base - 1) % MODULO;<br>                }<br>                for (int k = 0; k &lt; ways.length; ++k)<br>                    ways[k] = ways[k] * prod % MODULO;<br>                i = ii;<br>            } else {<br>                long sum = 0;<br>                for (int k = 0; k &lt; ways.length; ++k) {<br>                    sum = (sum + ways[k]) % MODULO;<br>                }<br>                for (int k = 0; k &lt; ways.length; ++k) {<br>                    ways[k] = (ways[k] * (base - 1)) % MODULO;<br>                }<br>                ways[i + 1] = (ways[i + 1] + sum) % MODULO;<br>                int must = 0;<br>                for (int j = 0; j &lt; qfrom.length; ++j)<br>                    if (output[j] == 0 &amp;&amp; qto[j] == i) {<br>                        must = Math.max(must, qfrom[j] + 1);<br>                    }<br>                for (int k = 0; k &lt; must; ++k) {<br>                    ways[k] = 0;<br>                }<br>                ++i;<br>            }<br>        }<br>        long res = 0;<br>        for (long x : ways)<br>            res = (res + x) % MODULO;<br>        return res;<br>    }<br> <br>    private boolean dfs(int at, int val) {<br>        if (what[at - i] &gt; 0) {<br>            if (what[at - i] != val) return false;<br>            return true;<br>        }<br>        what[at - i] = val;<br>        for (int j = 0; j &lt; qfrom.length; ++j) {<br>            if (output[j] == 0) continue;<br>            if (qfrom[j] == at) {<br>                if (!dfs(qto[j] + 1, val * output[j] % base)) return false;<br>            } else if (qto[j] + 1 == at) {<br>                if (!dfs(qfrom[j], val * inv[output[j]] % base)) return false;<br>            }<br>        }<br>        return true;<br>    }<br> <br>}<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>