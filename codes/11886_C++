<td class="problemText" colspan="8" valign="middle" align="left">
            //  SRM 541 (C)<br><br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;utility&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;complex&gt;<br><br>using namespace std;<br><br>typedef unsigned uint;<br>typedef long long Int;<br>typedef vector&lt;int&gt; vint;<br>typedef pair&lt;int,int&gt; pint;<br>#define mp make_pair<br><br>template&lt;class T&gt; void pv(T a, T b) { for (T i = a; i != b; ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; endl; }<br>template&lt;class T&gt; void chmin(T &amp;t, T f) { if (t &gt; f) t = f; }<br>template&lt;class T&gt; void chmax(T &amp;t, T f) { if (t &lt; f) t = f; }<br><br><br><br>struct XorLife {<br>  <br>  vector&lt;vint&gt; cut(vector&lt;vint&gt; a) {<br>    int m = a.size(), n = a[0].size();<br>    int x, y;<br>    int xMin = m, yMin = n, xMax = -1, yMax = -1;<br>    for (x = 0; x &lt; m; ++x) for (y = 0; y &lt; n; ++y) if (a[x][y]) {<br>      chmin(xMin, x);<br>      chmin(yMin, y);<br>      chmax(xMax, x);<br>      chmax(yMax, y);<br>    }<br>    if (xMin &gt; xMax || yMin &gt; yMax) return vector&lt;vint&gt;();<br>    vector&lt;vint&gt; b(xMax - xMin + 1, vint(yMax - yMin + 1));<br>    for (x = xMin; x &lt;= xMax; ++x) for (y = yMin; y &lt;= yMax; ++y) {<br>      b[x - xMin][y - yMin] = a[x][y];<br>    }<br>    return b;<br>  }<br>  <br>  map&lt;Int,Int&gt; mem;<br>  Int solve(vector&lt;vint&gt; a, int k) {<br>    a = cut(a);<br>    if (a.empty()) {<br>      return 0;<br>    }<br>    int m = a.size(), n = a[0].size();<br>// cout&lt;&lt;m&lt;&lt;" "&lt;&lt;n&lt;&lt;" "&lt;&lt;k&lt;&lt;endl;<br>    int x, y;<br>    if (m == 1 &amp;&amp; n == 1) {<br>      if (mem.count(k)) {<br>        return mem[k];<br>      }<br>    }<br>    Int ret = 0;<br>    if (k == 0) {<br>      for (x = 0; x &lt; m; ++x) for (y = 0; y &lt; n; ++y) if (a[x][y]) {<br>        ++ret;<br>      }<br>    } else {<br>      if (k % 2 != 0) {<br>        vector&lt;vint&gt; b(m + 2, vint(n + 2, 0));<br>        for (x = 0; x &lt; m; ++x) for (y = 0; y &lt; n; ++y) if (a[x][y]) {<br>          b[x + 0][y + 1] ^= 1;<br>          b[x + 1][y + 0] ^= 1;<br>          b[x + 1][y + 1] ^= 1;<br>          b[x + 1][y + 2] ^= 1;<br>          b[x + 2][y + 1] ^= 1;<br>        }<br>        ret += solve(b, k - 1);<br>      } else {<br>        int rx, ry;<br>        for (rx = 0; rx &lt; 2; ++rx) for (ry = 0; ry &lt; 2; ++ry) {<br>          vector&lt;vint&gt; b(m / 2 + 1, vint(n / 2 + 1));<br>          for (x = rx; x &lt; m; x += 2) for (y = ry; y &lt; n; y += 2) {<br>            b[x / 2][y / 2] = a[x][y];<br>          }<br>          ret += solve(b, k / 2);<br>        }<br>      }<br>    }<br>    if (m == 1 &amp;&amp; n == 1) {<br>      mem[k] = ret;<br>    }<br>    return ret;<br>  }<br>  <br>  long long countAliveCells(vector &lt;string&gt; field, int K) {<br>    int M = field.size(), N = field[0].size();<br>    int x, y;<br>    <br>    vector&lt;vint&gt; a(M, vint(N));<br>    for (x = 0; x &lt; M; ++x) for (y = 0; y &lt; N; ++y) {<br>      a[x][y] = (field[x][y] == 'o') ? 1 : 0;<br>    }<br>    <br>    mem.clear();<br>    Int res = solve(a, K);<br>    return res;<br>    <br>    <br>  }<br>  <br>};<br></td>