<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br> <br>using namespace std;<br> <br>typedef long long LL;<br>#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)<br>#define PB push_back<br>#define ZERO(x) memset(x,0,sizeof(x))<br> <br>map&lt;LL, LL&gt; dp[55];<br> <br>LL e[55];<br>int n;<br> <br>bool canBlock[55];<br> <br>LL go(int x, LL mask) {<br>    if (dp[x].find(mask) != dp[x].end()) {<br>        return dp[x][mask];<br>    }<br>    if (x == n - 1) {<br>        return dp[x][mask] = !((mask &gt;&gt; x) &amp; 1LL);<br>    } else {<br>        LL&amp; result = dp[x][mask] = 0;<br>        if (!canBlock[x]) {<br>            if ((mask &gt;&gt; x) &amp; 1LL) {<br>                return result = go(x + 1, mask ^ (1LL &lt;&lt; x) ^ e[x]);<br>            } else {<br>                return result = go(x + 1, mask);<br>            }<br>        } else {<br>            if (((mask &gt;&gt; x) &amp; 1LL) == 0) {<br>                return result = 2 * go(x + 1, mask);<br>            } else {<br>                return result = go(x + 1, mask ^ (1LL &lt;&lt; x) ^ e[x]) + go(x + 1, mask ^ (1LL &lt;&lt; x));<br>            }<br>        }<br>    }<br>}<br> <br>bool de[55][55];<br>bool vis[55];<br> <br>class EvenPaths {<br>public:<br>   long long theCount( vector &lt;string&gt; maze, string rooms ) {<br>       vector&lt;int&gt; seq;<br>       ZERO(de);<br>       n = maze.size();<br>       for (int i = 0; i &lt; n; ++i) {<br>           for (int j = 0; j &lt; n; ++j) {<br>               de[i][j] = (maze[i][j] == 'Y');<br>           }<br>       }<br>       for (int k = 0; k &lt; n; ++k) {<br>           for (int i = 0; i &lt; n; ++i) {<br>               for (int j = 0; j &lt; n; ++j) {<br>                   de[i][j] |= de[i][k] &amp; de[k][j];<br>               }<br>           }<br>       }<br>       int cnt = 0;<br>       FORE (it, rooms) {<br>           cnt += *it == '?';<br>       }<br>       seq.PB(0);<br>       ZERO(vis);<br>       vis[0] = true;<br>       while (true) {<br>           int nx = -1;<br>           for (int i = 0; i &lt; n; ++i) {<br>               if (!vis[i]) {<br>                   bool bad = false;<br>                   FORE (it, seq) {<br>                       if (de[i][*it]) {<br>                           bad = true;<br>                       }<br>                   }<br>                   for (int k = 0; k &lt; n; ++k) {<br>                       if (!vis[k] &amp;&amp; k != i &amp;&amp; de[k][i]) {<br>                           bool ok = true;<br>                           FORE (it, seq) {<br>                               if (de[k][*it]) {<br>                                   ok = false;<br>                                   break;<br>                               }<br>                           }<br>                           if (ok) {<br>                               bad = true;<br>                               break;<br>                           }<br>                       }<br>                   }<br>                   if (!bad) {<br>                       nx = i;<br>                       break;<br>                   }<br>               }<br>           }<br>           vis[nx] = true;<br>           seq.PB(nx);<br>           if (nx == -1) {<br>               return 1LL &lt;&lt; cnt;<br>           }<br>           if (nx == 1) {<br>               break;<br>           }<br>       }<br>       n = seq.size();<br>       for (int i = 0; i &lt; n; ++i) {<br>           canBlock[i] = (rooms[seq[i]] == '?');<br>           e[i] = 0;<br>           for (int j = 1; j &lt; n; ++j) {<br>               if (maze[seq[i]][seq[j]] == 'Y') {<br>                   e[i] |= 1LL &lt;&lt; j;<br>               }<br>           }<br>       }<br>       for (int i = 0; i &lt; n; ++i) {<br>           if (canBlock[i]) {<br>               --cnt;<br>           }<br>       }<br>       return (1LL &lt;&lt; cnt) * go(0, 1);<br>   }<br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br> <br>// Powered by CodeProcessor<br></td>