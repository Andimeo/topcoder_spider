<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;  <br>#include &lt;string&gt;  <br>#include &lt;set&gt;  <br>#include &lt;map&gt;  <br>#include &lt;vector&gt;  <br>#include &lt;queue&gt;   <br>#include &lt;iostream&gt;  <br>#include &lt;iterator&gt;  <br>#include &lt;math.h&gt;  <br>#include &lt;cstdio&gt;  <br>#include &lt;cstdlib&gt;  <br>#include &lt;sstream&gt;  <br><br>#pragma comment(linker, "/STACK:60777216")  <br><br>using namespace std;  <br><br>typedef pair&lt;int,int&gt; pii;  <br>typedef long long ll;  <br>typedef vector&lt;int&gt; vi;  <br><br>#define UN(v) SORT(v),v.erase(unique(v.begin(),v.end()),v.end())  <br>#define SORT(c) sort((c).begin(),(c).end())  <br>#define FOR(i,a,b) for (int  i=(a); i &lt; (b); i++)   <br>#define REP(i,n) FOR(i,0,n)   <br>#define CL(a,b) memset(a,b,sizeof(a))  <br>#define pb push_back  <br><br>class CrossingTheRiver {<br>public:<br> string isItEvenPossible(int waterWidth, int landWidth, vector &lt;int&gt; blockHeight, int depth) {<br>   blockHeight.pb(0);<br>   SORT(blockHeight);<br>   vi t;<br>   REP(i,blockHeight.size()) t.pb(blockHeight[i]);<br>   UN(t);<br>   REP(i,t.size())if(t[i]==depth || t[i]==depth+1) FOR(j,i,t.size()){<br>     int h = t[j] - depth;<br>//     cout&lt;&lt;h&lt;&lt;endl;<br>     REP(i2,t.size()) if(t[i2]==h || t[i2]==h+1)FOR(j2,i2,t.size()){<br>       bool good = 1;<br>       map&lt;int,int&gt; mm;<br>       REP(w,blockHeight.size()) mm[blockHeight[w]]++;<br>       mm[0] += 100;<br>       FOR(w,t[i],t[j]+1){<br>         mm[w]--;<br>         if(mm[w]&lt;0) {good=0;break;}<br>         <br>       }<br>       //cout&lt;&lt;good&lt;&lt;' '&lt;&lt;t[i2]&lt;&lt;' '&lt;&lt;mm[0]&lt;&lt;' '&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;<br>       FOR(w,t[i2],t[j2]+1){<br>         mm[w]--;<br>         if(mm[w]&lt;0) {good=0;break;}<br>       }<br>       int n1=0,n2=0,n3=0;<br>       FOR(w,t[i],t[j]+1){<br>         if(w&gt;=t[i2]&amp;&amp;w&lt;=t[j2]) n2+=mm[w];<br>         else n1+=mm[w];         <br>       }<br>       FOR(w,t[i2],t[j2]+1){<br>         if(w&gt;=t[i]&amp;&amp;w&lt;=t[j]) ;//n2+=mm[w];<br>         else n3+=mm[w];         <br>       }<br><br>       int need1 = waterWidth - ( t[j]-t[i]+1);<br>       int need2 = landWidth - (t[j2]-t[i2]+1);<br>       //cout&lt;&lt;good&lt;&lt;" : "&lt;&lt;need1&lt;&lt;' '&lt;&lt;need2&lt;&lt;' '&lt;&lt;n1&lt;&lt;' '&lt;&lt;n2&lt;&lt;' '&lt;&lt;n3&lt;&lt;' '&lt;&lt;t[i]&lt;&lt;' '&lt;&lt;t[j]&lt;&lt;' '&lt;&lt;t[i2]&lt;&lt;' '&lt;&lt;t[j2]&lt;&lt;endl;<br>       need1 = max(need1 - n1, 0);<br>       need2 = max(need2 - n3, 0);<br>       if(good &amp;&amp; need1+need2&lt;=n2) return "POSSIBLE";<br>     }<br>   } <br>  return "IMPOSSIBLE";<br> }<br> <br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>