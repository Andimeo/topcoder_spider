<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br> <br>public class CucumberWatering<br>{<br>    long[] x;<br>    long[] sortedX;<br>    int K;<br>    long[,] mem;<br>    public long theMin(int[] x, int K)<br>    {<br>        this.x = new long[x.Length];<br>        for (int i = 0; i &lt; x.Length; i++)<br>        {<br>            this.x[i] = x[i];<br>        }<br>        this.sortedX = new long[x.Length];<br>        Array.Copy(this.x, this.sortedX, this.x.Length);<br>        Array.Sort(sortedX);<br>        this.K = K;<br>        mem = new long[55, 55];<br>        for (int i = 0; i &lt; 55; i++)<br>        {<br>            for (int j = 0; j &lt; 55; j++)<br>            {<br>                mem[i, j] = -1;<br>            }<br>        }<br> <br>        if (K &gt;= x.Length) return 0;<br>        return bestAll();<br>    }<br> <br>    private long bestAll()<br>    {<br>        long best = long.MaxValue;<br>        for (int last = K - 1; last &lt; x.Length; last++)<br>        {<br>            long ret = 0;<br>            for (int i = 0; i &lt; x.Length - 1; i++)<br>            {<br>                long x1 = x[i];<br>                long x2 = x[i + 1];<br>                if (x1 &lt; sortedX[last]) x1 = sortedX[last];<br>                if (x2 &lt; sortedX[last]) x2 = sortedX[last];<br>                ret += Math.Abs(x1 - x2);<br>            }<br>            ret += bestLeftK(last, 0);<br>            best = Math.Min(best, ret);<br>        }<br>        return best;<br>    }<br> <br> <br>    private long bestLeftK(int lastTeleportIdx, int KRem)<br>    {<br>        long m = mem[lastTeleportIdx, KRem];<br>        if (m != -1) return m;<br> <br>        long best = long.MaxValue / 50;<br>        if (KRem &lt;= K - 2)<br>        {<br>            for (int last = 0; last &lt; lastTeleportIdx; last++)<br>            {<br>                long ret = 0;<br>                for (int i = 0; i &lt; x.Length - 1; i++)<br>                {<br>                    long x1 = x[i];<br>                    long x2 = x[i + 1];<br>                    if (x1 &gt; sortedX[lastTeleportIdx]) x1 = sortedX[lastTeleportIdx];<br>                    if (x2 &gt; sortedX[lastTeleportIdx]) x2 = sortedX[lastTeleportIdx];<br>                    if (x1 &lt; sortedX[last]) x1 = sortedX[last];<br>                    if (x2 &lt; sortedX[last]) x2 = sortedX[last];<br>                    long shortest = Math.Abs(x2 - x1);<br>                    long x1Tel = Math.Min(Math.Abs(x1 - sortedX[lastTeleportIdx]), Math.Abs(x1 - sortedX[last]));<br>                    long x2Tel = Math.Min(Math.Abs(x2 - sortedX[lastTeleportIdx]), Math.Abs(x2 - sortedX[last]));<br>                    shortest = Math.Min(shortest, x1Tel + x2Tel);<br>                    ret += Math.Abs(shortest);<br>                }<br>                ret += bestLeftK(last, KRem + 1);<br>                best = Math.Min(best, ret);<br>            }<br>        }<br>        else<br>        {<br>            long ret = 0;<br>            // KRem&gt;=K-1, this is the first teleport<br>            for (int i = 0; i &lt; x.Length - 1; i++)<br>            {<br>                long x1 = x[i];<br>                long x2 = x[i + 1];<br>                if (x1 &gt; sortedX[lastTeleportIdx]) x1 = sortedX[lastTeleportIdx];<br>                if (x2 &gt; sortedX[lastTeleportIdx]) x2 = sortedX[lastTeleportIdx];<br>                ret += Math.Abs(x2 - x1);<br>            }<br>            best = Math.Min(best, ret);<br>        }<br> <br>        mem[lastTeleportIdx, KRem] = best;<br>        return best;<br>    }<br> <br>    private long walkLen(long[] teleportSorted)<br>    {<br>        long ret = 0;<br>        for (int i = 0; i &lt; x.Length - 1; i++)<br>        {<br>            ret += spanDis(x[i], x[i + 1], teleportSorted);<br>        }<br>        return ret;<br>    }<br> <br>    private long spanDis(long x1, long x2, long[] teleportSorted)<br>    {<br>        long ret = Math.Abs(x1 - x2);<br>        if (teleportSorted.Length &gt; 0)<br>        {<br>            long x1NearestTeleport = int.MaxValue;<br>            long x2NearestTeleport = int.MaxValue;<br>            for (int i = 0; i &lt; teleportSorted.Length; i++)<br>            {<br>                x1NearestTeleport = Math.Min(x1NearestTeleport, Math.Abs(x1 - teleportSorted[i]));<br>                x2NearestTeleport = Math.Min(x2NearestTeleport, Math.Abs(x2 - teleportSorted[i]));<br>            }<br>            ret = Math.Min(ret, x1NearestTeleport + x2NearestTeleport);<br>        }<br>        return ret;<br>    }<br> <br> <br>}<br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>