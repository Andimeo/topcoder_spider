<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class CucumberWatering {<br>    static final long INF = (long) 1e18;<br>    <br>    public long theMin(int[] _x, int K) {<br>        long[] x = new long[_x.length + 2];<br>        for (int i = 0; i &lt; _x.length; ++i) x[i + 1] = _x[i];<br>        x[0] = (long) (-1e12);<br>        x[_x.length + 1] = (long) (1e12);<br>        Arrays.sort(x);<br>        int n = x.length;<br>        ++K;<br>        long[][] best = new long[n][K + 1];<br>        for (long[] tmp : best) Arrays.fill(tmp, INF);<br>        Arrays.fill(best[0], 0);<br>        for (int last = 1; last &lt; n; ++last) {<br>            for (int numRemaining = 0; numRemaining + 1 &lt;= K; ++numRemaining) {<br>                for (int preLast = 0; preLast &lt; last; ++preLast) {<br>                    long old = best[preLast][numRemaining + 1];<br>                    if (old &gt;= INF) continue;<br>                    for (int i = 0; i + 1 &lt; _x.length; ++i) {<br>                        long left = _x[i];<br>                        long right = _x[i + 1];<br>                        if (left &gt; right) {<br>                            long tt = left;<br>                            left = right;<br>                            right = tt;<br>                        }<br>                        if (left &gt; x[preLast] &amp;&amp; left &lt;= x[last]) {<br>                            if (right &lt;= x[last]) {<br>                                long b = Math.abs(right - left);<br>                                b = Math.min(b, Math.abs(left - x[preLast]) + Math.abs(right - x[last]));<br>                                old += b;<br>                            } else {<br>                                old += Math.min(Math.abs(left - x[preLast]), Math.abs(left - x[last]));<br>                            }<br>                        } else if (left &lt;= x[last]) {<br>                            if (right &gt; x[preLast] &amp;&amp; right &lt;= x[last]) {<br>                                old += Math.min(Math.abs(right - x[preLast]), Math.abs(right - x[last]));<br>                            }<br>                        }<br>                    }<br>                    best[last][numRemaining] = Math.min(best[last][numRemaining], old);<br>                }<br>            }<br>        }<br>        return best[x.length - 1][0];<br>    }<br>}<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>