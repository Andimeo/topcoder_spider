<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;stack&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;climits&gt;<br>#include &lt;numeric&gt;<br>#include &lt;complex&gt;<br>using namespace std;<br> <br>#define all(c) (c).begin(), (c).end()<br>#define iter(c) __typeof((c).begin())<br>#define cpresent(c, e) (find(all(c), (e)) != (c).end())<br>#define rep(i, n) for (int i = 0; i &lt; (int)(n); i++)<br>#define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)<br>#define pb push_back<br>#define mp make_pair<br> <br>struct EllysDeathStars {<br>  double getMax(vector &lt;string&gt; stars, vector &lt;string&gt; ships);<br>};<br> <br>typedef complex&lt;double&gt; p_t;<br>const double EPS = 1e-10;<br> <br> <br>namespace mf {<br>const int MAX_V = 100010;<br> <br>struct e_t {<br>  int to;<br>  double cap;<br>  int rev;<br>};<br> <br>int V, S, T;<br>vector&lt;e_t&gt; adj[MAX_V];<br> <br>int lev[MAX_V], done[MAX_V];<br> <br>void add_edge(int i, int j, double c) {<br>  adj[i].push_back((e_t){j, c, adj[j].size()});<br>  adj[j].push_back((e_t){i, 0, adj[i].size() - 1});<br>}<br> <br>bool levelize() {<br>  memset(lev, -1, sizeof(lev));<br>  queue&lt;int&gt; que;<br>  lev[S] = 0;<br>  que.push(S);<br>  while (!que.empty()) {<br>    int v = que.front(); que.pop();<br>    rep (i, adj[v].size()) {<br>      e_t &amp;e = adj[v][i];<br>      if (e.cap &lt; EPS || lev[e.to] != -1) continue;<br>      lev[e.to] = lev[v] + 1;<br>      que.push(e.to);<br>    }<br>  }<br>  return lev[T] != -1;<br>}<br> <br>double augment(int v, double f) {<br>  if (v == T || f &lt; EPS) return f;<br>  for (; done[v] &lt; (int)adj[v].size(); done[v]++) {<br>    e_t &amp;e = adj[v][done[v]];<br>    if (lev[e.to] &lt;= lev[v]) continue;<br>    double t = augment(e.to, min(f, e.cap));<br>    if (t &gt; EPS) {<br>      e.cap -= t;<br>      adj[e.to][e.rev].cap += t;<br>      return t;<br>    }<br>  }<br>  return 0;<br>}<br> <br>double max_flow() {<br>  double f = 0, t;<br>  while (levelize()) {<br>    memset(done, 0, sizeof(done));<br>    while (EPS &lt; (t = augment(S, 1E30))) f += t;<br>  }<br>  return f;<br>}<br>}<br> <br> <br> <br> <br>double dot(const p_t &amp;p, const p_t &amp;q) { return real(conj(p) * q); }<br>double det(const p_t &amp;p, const p_t &amp;q) { return imag(conj(p) * q); }<br> <br>double dist_l_p(const p_t &amp;p, const p_t &amp;a, const p_t &amp;u) {<br>  return abs(det(p - a, u)) / abs(u);<br>}<br> <br>pair&lt;double, double&gt; cross_l_c(p_t a, const p_t &amp;u, const p_t &amp;c, double r) {<br>  a -= c;<br>  double b = real(u * conj(a)), d = b * b - norm(u) * (norm(a) - r * r);<br>  d = max(d, 0.0);<br>  return make_pair((-b + sqrt(d)) / norm(u), (-b - sqrt(d)) / norm(u));<br>}<br> <br> <br> <br>int NSTAR, NSHIP;<br>p_t S[60];<br>p_t F[60], T[60], move[60];<br>double speed[60], range[60], energy[60], end[60];<br> <br>double EllysDeathStars::getMax(vector &lt;string&gt; stars, vector &lt;string&gt; ships) {<br>  NSTAR = stars.size();<br>  rep (i, NSTAR) sscanf(stars[i].c_str(), "%lf %lf", &amp;S[i].real(), &amp;S[i].imag());<br> <br>  NSHIP = ships.size();<br>  rep (i, NSHIP) sscanf(ships[i].c_str(), "%lf %lf %lf %lf %lf %lf %lf",<br>                         &amp;F[i].real(), &amp;F[i].imag(), &amp;T[i].real(), &amp;T[i].imag(),<br>                         speed + i, range + i, energy + i);<br> <br>  mf::V = NSHIP + 2;<br>  mf::S = NSHIP + 0;<br>  mf::T = NSHIP + 1;<br>  rep (v, mf::V) mf::adj[v].clear();<br>  rep (j, NSHIP) mf::add_edge(mf::S, j, energy[j]);<br> <br>  rep (i, NSTAR) {<br>    vector&lt;double&gt; evt;<br> <br>    rep (j, NSHIP) {<br>      if (T[j] == F[j]) continue;<br>      if (dist_l_p(S[i], F[j], T[j] - F[j]) &gt; range[j] - EPS) continue;<br> <br>      p_t m = (T[j] - F[j]);<br>      m /= abs(m);<br>      m *= speed[j];<br>      double e = abs(T[j] - F[j]) / speed[j];<br> <br>      pair&lt;double, double&gt; c = cross_l_c(F[j], m, S[i], range[j]);<br>      evt.pb(max(0.0, min(e, c.first)));<br>      evt.pb(max(0.0, min(e, c.second)));<br> <br>      move[j] = m;<br>      end[j] = e;<br>    }<br> <br>    sort(all(evt));<br> <br>    for (int k = 0; k + 1 &lt; (int)evt.size(); ++k) {<br>      double time = (evt[k + 1] + evt[k]) / 2.0;<br>      double span = evt[k + 1] - evt[k];<br>      if (span &lt; EPS) continue;<br> <br>      int v = mf::V++;<br>      mf::adj[v].clear();<br> <br>      rep (j, NSHIP) {<br>        if (time &gt; end[j] + EPS) continue;<br>        p_t p = F[j] + move[j] * time;<br>        if (abs(S[i] - p) &lt; range[j]) mf::add_edge(j, v, span);<br>      }<br> <br>      mf::add_edge(v, mf::T, span);<br>    }<br>  }<br> <br>  return mf::max_flow();<br>}<br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.17pre2 [modified TZTester]<br>// Powered by CodeProcessor<br></td>