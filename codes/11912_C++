<td class="problemText" colspan="8" valign="middle" align="left">
            // Another ugly solution by Olexiy <br>#include &lt;map&gt; <br>#include &lt;set&gt; <br>#include &lt;iostream&gt; <br>#include &lt;sstream&gt; <br>#include &lt;queue&gt; <br>#include &lt;vector&gt; <br>#include &lt;string&gt; <br>#include &lt;math.h&gt; <br>#include &lt;algorithm&gt; <br>#include &lt;numeric&gt; <br><br>#ifdef __GNUC__ <br>typedef long long lint; <br>typedef unsigned long long ulint; <br>#else <br>typedef __int64 lint; <br>typedef unsigned __int64 ulint; <br>#endif <br><br>using namespace std; <br><br>#define FOR(i, b) for(int i=0; i &lt; b;i++) <br>#define SFOR(i, i1, b) for(int i=i1; i &lt; b;i++) <br>#define ALL(C) C.begin(), C.end() <br><br>typedef vector&lt;string&gt; VS; <br>typedef vector&lt;int&gt; VI; <br>typedef vector&lt;double&gt; VD; <br><br><br>class EllysRivers  { <br>public: <br>  int N, L, walk;<br>  VD speed, width;<br>  double getMin(int length, int walk1, vector &lt;int&gt; width1, vector &lt;int&gt; speed1) { <br>   <br>    N = width1.size();<br>    walk = walk1;<br>    L = length;<br>    double res = 0;<br>    speed = VD(N);<br>    width = VD(N, 0);<br>    FOR(i, N) speed[i] = speed1[i];<br>    FOR(i, N) width[i] = width1[i];<br>    FOR(i, N) res += width[i] / speed1[i];<br>    VI have(N, 0);<br>    FOR(q, L) {<br>      int bi = -1;<br>      double T = 1. / walk;<br>      FOR(i, N) {<br>        double delta = hypot(width[i], have[i] + 1) - hypot(width[i], have[i]);<br>        delta /= speed[i];<br>        if (delta &lt; T) {<br>          bi = i;<br>          T = delta;<br>        }<br><br>      }<br>      if (bi != -1) {<br>        have[bi]++;<br>      }<br>      res += T;<br>    }<br>    return res;<br>  } <br><br> <br>}; <br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>