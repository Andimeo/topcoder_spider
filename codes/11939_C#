<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class HeavyBooks {<br>    public int[] findWeight(int[] books, int[] moves)<br>    {<br>        Array.Sort(books);<br>        Heap&lt;int&gt; t = new Heap&lt;int&gt;();<br>        Heap&lt;int&gt; w = new Heap&lt;int&gt;();<br>        t.push(-1); w.push(-1);<br>        for (int i = 0; i &lt; moves[0]; i++)<br>        {<br>            t.push(i);<br>        }<br>        bool[] check = new bool[moves[0]];<br>        for (int i = 1; i &lt; moves.Length; i++)<br>        {<br>            if (i % 2 != 0)<br>            {<br>                for (int j = 0; j &lt; moves[i] &amp;&amp; t.top.val != -1; j++)<br>                {<br>                    w.push(t.pop());<br>                }<br>            }<br>            else<br>            {<br>                for (int j = 0; j &lt; moves[i] &amp;&amp; w.top.val != -1; j++)<br>                {<br>                    t.push(w.pop());<br>                }<br>            }<br>        }<br><br>        while (t.top.val != -1)<br>        {<br>            int a = t.pop();<br>            check[a] = true;<br>        }<br>        for (int i = 0; i &lt; moves[0]; i++)<br>        {<br>            if (check[i]) Console.Write("T");<br>            else Console.Write("F");<br>        }<br>        Console.WriteLine();<br><br>        long[][] dp = new long[moves[0] + 1][];<br>        for (int i = 0; i &lt; moves[0] + 1; i++)<br>        {<br>            dp[i] = new long[3];<br>            dp[i][0] = dp[i][1] = (long)-1e10;<br>            dp[i][2] = 0;<br>        }<br>        dp[0][0] = dp[0][1] = dp[0][2] = 0;<br>        for (int j = 0; j &lt; books.Length; j++)<br>        {<br>            for (int i = moves[0] - 1; i &gt;= 0; i--)<br>            {<br>                if (dp[i][0] == (long)-1e10) continue;<br>                long[] next = new long[3];<br>                next[1] = dp[i][1];<br>                next[2] = dp[i][2];<br>                if (check[i]) next[1] += books[j];<br>                else next[2] += books[j];<br>                next[0] = next[1] - next[2];<br>                if (compare(next, dp[i + 1]))<br>                {<br>                    dp[i + 1] = next;<br>                }<br>            }<br>        }<br><br>        return new int[2] { (int)dp[moves[0]][2], (int)dp[moves[0]][1] };<br>    }<br><br>    bool compare(long[] a, long[] b)<br>    {<br>        if (a[0] != b[0])<br>        {<br>            if (a[0] &gt; b[0]) return true;<br>            else return false;<br>        }<br>        else<br>        {<br>            if (a[1] &gt; b[1]) return true;<br>            else return false;<br>        }<br>    }<br><br>    class Heap&lt;T&gt; where T : IComparable<br>    {<br>        public HeapNode&lt;T&gt; top;<br><br>        public Heap() { }<br><br>        public void push(T val)<br>        {<br>            top = HeapNode&lt;T&gt;.meld(top, new HeapNode&lt;T&gt;(val));<br>        }<br><br>        public T pop()<br>        {<br>            T ret = top.val;<br>            top = HeapNode&lt;T&gt;.meld(top.r, top.l);<br>            return ret;<br>        }<br><br>        public void merge(Heap&lt;T&gt; h2)<br>        {<br>            top = HeapNode&lt;T&gt;.meld(top, h2.top);<br>        }<br><br>        public class HeapNode&lt;NT&gt; where NT : IComparable<br>        {<br>            public HeapNode&lt;NT&gt; l, r;<br>            public NT val;<br><br>            public HeapNode(NT _val)<br>            {<br>                val = _val;<br>            }<br><br>            public static HeapNode&lt;NT&gt; meld(HeapNode&lt;NT&gt; a, HeapNode&lt;NT&gt; b)<br>            {<br>                if (a == null) return b;<br>                if (b == null) return a;<br>                if (a.val.CompareTo(b.val) &lt; 0)<br>                {<br>                    HeapNode&lt;NT&gt; temp = a;<br>                    a = b;<br>                    b = temp;<br>                }<br>                a.r = meld(a.r, b);<br>                HeapNode&lt;NT&gt; temph = a.l;<br>                a.l = a.r;<br>                a.r = temph;<br>                return a;<br>            }<br>        }<br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>