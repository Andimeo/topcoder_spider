<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class MagicalHats {<br>    public int findMaximumReward(String[] board, int[] coins, int numGuesses) {<br>        int numCoins = coins.length;<br>        numHats = 0;<br>        int height = board.length;<br>        int width = board[0].length();<br>        for (int row = 0; row &lt; height; ++row)<br>            for (int col = 0; col &lt; width; ++col)<br>                if (board[row].charAt(col) == 'H') {<br>                    ++numHats;<br>                }<br>        int[] hatRow = new int[numHats];<br>        int[] hatCol = new int[numHats];<br>        numHats = 0;<br>        for (int row = 0; row &lt; height; ++row)<br>            for (int col = 0; col &lt; width; ++col)<br>                if (board[row].charAt(col) == 'H') {<br>                    hatRow[numHats] = row;<br>                    hatCol[numHats] = col;<br>                    ++numHats;<br>                }<br>        int[] validSets = new int[1 &lt;&lt; numHats];<br>        int numValid = 0;<br>        int[] countRow = new int[height];<br>        int[] countCol = new int[width];<br>        for (int set = 0; set &lt; (1 &lt;&lt; numHats); ++set) {<br>            if (Integer.bitCount(set) != numCoins) continue;<br>            Arrays.fill(countRow, 0);<br>            Arrays.fill(countCol, 0);<br>            for (int i = 0; i &lt; numHats; ++i)<br>                if ((set &amp; (1 &lt;&lt; i)) == 0) {<br>                    countRow[hatRow[i]] ^= 1;<br>                    countCol[hatCol[i]] ^= 1;<br>                }<br>            boolean ok = true;<br>            for (int x : countRow) if (x != 0) ok = false;<br>            for (int x : countCol) if (x != 0) ok = false;<br>            if (!ok) continue;<br>            validSets[numValid++] = set;<br>        }<br>        if (numValid == 0) return -1;<br>        validByLayer = new int[numGuesses + 1][numValid];<br>        p3 = new int[numHats + 1];<br>        p3[0] = 1;<br>        for (int i = 1; i &lt;= numHats; ++i) p3[i] = p3[i - 1] * 3;<br>        cache = new int[p3[numHats]];<br>        Arrays.fill(cache, -1);<br>        System.arraycopy(validSets, 0, validByLayer[numGuesses], 0, numValid);<br>        numValidByLayer = new int[numGuesses + 1];<br>        numValidByLayer[numGuesses] = numValid;<br>        int maxFound = doit(numGuesses, 0);<br>        Arrays.sort(coins);<br>        int res = 0;<br>        for (int i = 0; i &lt; maxFound; ++i)<br>            res += coins[i];<br>        return res;<br>    }<br> <br>    private int doit(int numGuesses, int state) {<br>        if (cache[state] &gt;= 0) return cache[state];<br>        int res = 0;<br>        if (numGuesses == 0) {<br>            for (int i = 0; i &lt; numHats; ++i)<br>                if ((state / p3[i]) % 3 == 2) {<br>                    ++res;<br>                }<br>        } else {<br>            for (int i = 0; i &lt; numHats; ++i) {<br>                if ((state / p3[i]) % 3 == 0) {<br>                    int best = numHats + 1;<br>                    {<br>                        int newState = state + p3[i];<br>                        numValidByLayer[numGuesses - 1] = 0;<br>                        for (int j = 0; j &lt; numValidByLayer[numGuesses]; ++j) {<br>                            int cur = validByLayer[numGuesses][j];<br>                            if ((cur &amp; (1 &lt;&lt; i)) == 0) {<br>                                validByLayer[numGuesses - 1][numValidByLayer[numGuesses - 1]++] = cur;<br>                            }<br>                        }<br>                        if (numValidByLayer[numGuesses - 1] != 0)<br>                            best = Math.min(best, doit(numGuesses - 1, newState));<br>                    }<br>                    {<br>                        int newState = state + 2 * p3[i];<br>                        numValidByLayer[numGuesses - 1] = 0;<br>                        for (int j = 0; j &lt; numValidByLayer[numGuesses]; ++j) {<br>                            int cur = validByLayer[numGuesses][j];<br>                            if ((cur &amp; (1 &lt;&lt; i)) != 0) {<br>                                validByLayer[numGuesses - 1][numValidByLayer[numGuesses - 1]++] = cur;<br>                            }<br>                        }<br>                        if (numValidByLayer[numGuesses - 1] != 0)<br>                            best = Math.min(best, doit(numGuesses - 1, newState));<br>                    }<br>                    if (best == numHats + 1) throw new RuntimeException();<br>                    res = Math.max(res, best);<br>                }<br>            }<br>        }<br>        cache[state] = res;<br>        return res;<br>    }<br> <br>    int numHats;<br>    int[][] validByLayer;<br>    int[] numValidByLayer;<br>    int[] p3;<br>    int[] cache;<br> <br> <br>}<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>