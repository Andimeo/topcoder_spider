<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt; <br>#include &lt;list&gt; <br>#include &lt;map&gt; <br>#include &lt;set&gt; <br>#include &lt;deque&gt; <br>#include &lt;queue&gt; <br>#include &lt;stack&gt; <br>#include &lt;bitset&gt; <br>#include &lt;algorithm&gt; <br>#include &lt;functional&gt; <br>#include &lt;numeric&gt; <br>#include &lt;utility&gt; <br>#include &lt;complex&gt; <br>#include &lt;sstream&gt; <br>#include &lt;iostream&gt; <br>#include &lt;iomanip&gt; <br>#include &lt;cstdio&gt; <br>#include &lt;cmath&gt; <br>#include &lt;cstdlib&gt; <br>#include &lt;cstring&gt; <br>#include &lt;ctime&gt; <br>#include &lt;cassert&gt; <br>using namespace std;<br><br>#define ME(s) memset((s), 0, sizeof((s)))<br>#define MM(s,a) memset((s),(a),sizeof((s)))<br>#define MCP(s,a) memcpy((s), (a), sizeof(s))<br>#define LL long long<br>#define LD long double<br>#define PII pair&lt;int, int&gt;<br>#define mkp(a,b) make_pair((a),(b))<br>#define x first<br>#define y second<br>#define sqr(a) ((a)*(a))<br>#define CPX complex&lt;double&gt;<br><br>const int MaxN = 300010;<br>int N;<br>int X[MaxN], Y[MaxN];<br>PII P[MaxN];<br><br>struct BIT<br>{<br>  LL tar[MaxN];<br>  int n;<br>  int init(int _n)<br>  {<br>    n = _n;<br>    fill(tar, tar + 1 + n, 0);<br>  }<br>  int add(int x, LL d)<br>  {<br>    for(; x &lt;= n; x += x&amp;-x)<br>      tar[x] += d;<br>  }<br>  LL count(int x)<br>  {<br>    LL ret = 0;<br>    for(; x &gt; 0; x -= x&amp;-x)<br>      ret+= tar[x];<br>    return ret;<br>  }<br>  LL count(int x, int y)<br>  {<br>    return count(y) - count(x-1);<br>  }<br>}T;<br><br>LL Choose(LL n)<br>{<br>  return n * (n - 1) / 2;<br>}<br><br>LL dp[MaxN];<br><br>class ThreePoints{<br>public:<br>  long long countColoring(int _N, int xzero, int xmul, int xadd, int xmod, int yzero, int ymul, int yadd, int ymod){<br>    N = _N;<br>    X[0] = xzero;<br>    vector&lt;int&gt; xx, yy;<br>    for(int i=1;i&lt;N;++i) {<br>      X[i] = ((LL)X[i-1] * xmul + xadd) % xmod;<br>    }<br>    Y[0] = yzero;<br>    for(int i=1;i&lt;N;++i) {<br>      Y[i] = ((LL)Y[i-1] * ymul + yadd) % ymod;<br>    }<br>    for(int i=0;i&lt;N;++i)<br>    {<br>      xx.push_back(X[i]);<br>      yy.push_back(Y[i]);<br>    }<br>    sort(xx.begin(), xx.end());<br>    sort(yy.begin(), yy.end());<br>    for(int i=0;i&lt;N;++i)<br>    {<br>      Y[i] = lower_bound(yy.begin(), yy.end(), Y[i]) - yy.begin()+1;<br>      P[i]=mkp(X[i], Y[i]);<br>    }<br>    sort(P, P + N);<br>    LL res = 0;<br>    T.init(N);<br>    <br>    for(int i=N-1;i&gt;=0;--i)<br>    {<br>      LL tmp = T.count(P[i].y, N);<br>      dp[i] = tmp;<br>      res += Choose(tmp);<br>      T.add(P[i].y, 1);<br>    }<br>    T.init(N);<br>    for(int i=N-1;i&gt;=0;--i)<br>    {<br>      LL tmp = T.count(P[i].y, N);<br>      res -= tmp;<br>      T.add(P[i].y, dp[i]);<br>    }<br>    return res;<br>  }<br><br>};<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>