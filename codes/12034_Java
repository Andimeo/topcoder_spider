<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>import static java.lang.Math.*;<br>import static java.util.Arrays.*;<br> <br>public class CosmicBlocks {<br>  <br>  int n;<br>  int[] num;<br>  int min, max;<br>  TreeMap&lt;Long, Integer&gt; count = new TreeMap&lt;Long, Integer&gt;();<br>  int count(long g, int used) {<br>    Integer r = count.get(g &lt;&lt; n | used);<br>    if (r != null) return r;<br>    if (used == (1 &lt;&lt; n) - 1) return 1;<br>    int res = 0;<br>    loop : for (int i = 0; i &lt; n; i++) if ((used &gt;&gt; i &amp; 1) == 0) {<br>      for (int j = 0; j &lt; n; j++) if ((used &gt;&gt; j &amp; 1) == 0 &amp;&amp; (g &gt;&gt; (j * n + i) &amp; 1) != 0) continue loop;<br>      res += count(g &amp; ~(((1L &lt;&lt; n) - 1) &lt;&lt; (i * n)), used | 1 &lt;&lt; i);<br>    }<br>    count.put(g &lt;&lt; n | used, res);<br>    return res;<br>  }<br>  <br>  boolean can2(long g, long b1, long b2) {<br>    int[] num = this.num.clone();<br>    V[] vs = new V[n];<br>    V s = new V(), t = new V();<br>    for (int i = 0; i &lt; n; i++) vs[i] = new V();<br>    for (int i = 0; i &lt; n; i++) if ((b2 &gt;&gt; i &amp; 1) != 0) {<br>      for (int j = 0; j &lt; n; j++) if ((g &gt;&gt; (i * n + j) &amp; 1) != 0) {<br>        if (--num[i] &lt; 0) return false;<br>        if (--num[j] &lt; 0) return false;<br>        vs[i].add(vs[j], INF);<br>      }<br>    }<br>    int total = 0;<br>    for (int i = 0; i &lt; n; i++) {<br>      if ((b2 &gt;&gt; i &amp; 1) != 0) {<br>        s.add(vs[i], num[i]);<br>        total += num[i];<br>      } else if ((b1 &gt;&gt; i &amp; 1) != 0) {<br>        vs[i].add(t, num[i]);<br>      }<br>    }<br>    if (dinic(s, t) != total) return false;<br>    return true;<br>  }<br>  <br>  TreeMap&lt;Long, Boolean&gt; can = new TreeMap&lt;Long, Boolean&gt;();<br>  boolean can(long g, long b1, long b2) {<br>    Boolean r = can.get(g &lt;&lt; (n * 2) | b1 &lt;&lt; n | b2);<br>    if (r != null) return r;<br>    r = can2(g, b1, b2);<br>    can.put(g &lt;&lt; (n * 2) | b1 &lt;&lt; n | b2, r);<br>    return r;<br>  }<br>  <br>  boolean can(int[] hs, long g) {<br>    for (int h = 0; h + 1 &lt; n; h++) {<br>      long b1 = 0, b2 = 0, g2 = 0;<br>      for (int i = 0; i &lt; n; i++) {<br>        if (hs[i] == h) b1 |= 1 &lt;&lt; i;<br>        if (hs[i] == h + 1) {<br>          b2 |= 1 &lt;&lt; i;<br>          for (int j = 0; j &lt; n; j++) if ((g &gt;&gt; (i * n + j) &amp; 1) != 0) g2 |= 1L &lt;&lt; (i * n + j);<br>        }<br>      }<br>      if (!can(g2, b1, b2)) return false;<br>    }<br>    return true;<br>  }<br>  <br>  int rec(int[] hs, long g, int i, int j) {<br>    if (i == n) {<br>      int c = count(g, 0);<br>      if (min &lt;= c &amp;&amp; c &lt;= max &amp;&amp; can(hs, g)) {<br>        return 1;<br>      } else {<br>        return 0;<br>      }<br>    }<br>    while (j &lt; n &amp;&amp; (i == j || hs[j] + 1 != hs[i])) j++;<br>    if (j == n) return rec(hs, g, i + 1, 0);<br>    int res = rec(hs, g, i, j + 1) + rec(hs, g | 1L &lt;&lt; (n * i + j), i, j + 1);<br>    return res;<br>  }<br>  <br>  int rec(int[] hs, int i) {<br>    if (i == n) {<br>      int[] ns = new int[n];<br>      for (int j = 0; j &lt; n; j++) ns[hs[j]]++;<br>      for (int j = 0; j &lt; n - 1; j++) if (ns[j] == 0 &amp;&amp; ns[j + 1] &gt; 0) return 0;<br>      return rec(hs, 0, 0, 0);<br>    } else {<br>      int res = 0;<br>      for (int j = 0; j &lt; n; j++) {<br>        hs[i] = j;<br>        res += rec(hs, i + 1);<br>      }<br>      return res;<br>    }<br>  }<br>  <br>  public int getNumOrders(int[] blockTypes, int minWays, int maxWays) {<br>    n = blockTypes.length;<br>    num = blockTypes;<br>    min = minWays;<br>    max = maxWays;<br>    int res = rec(new int[n], 0);<br>    debug(res);<br>    return res;<br>  }<br>  <br>  int INF = 1 &lt;&lt; 29;<br>  <br>  int dinic(V s, V t) {<br>    int flow = 0;<br>    for (int p = 1; ; p++) {<br>      Queue&lt;V&gt; que = new LinkedList&lt;V&gt;();<br>      s.level = 0;<br>      s.p = p;<br>      que.offer(s);<br>      while (!que.isEmpty()) {<br>        V v = que.poll();<br>        v.iter = v.es.size() - 1;<br>        for (E e : v.es) if (e.to.p &lt; p &amp;&amp; e.cap &gt; 0) {<br>          e.to.level = v.level + 1;<br>          e.to.p = p;<br>          que.offer(e.to);<br>        }<br>      }<br>      if (t.p &lt; p) return flow;<br>      for (int f; (f = dfs(s, t, INF)) &gt; 0; ) flow += f;<br>    }<br>  }<br>  int dfs(V v, V t, int f) {<br>    if (v == t) return f;<br>    for (; v.iter &gt;= 0; v.iter--) {<br>      E e = v.es.get(v.iter);<br>      if (v.level &lt; e.to.level &amp;&amp; e.cap &gt; 0) {<br>          int d = dfs(e.to, t, min(f, e.cap));<br>          if (d &gt; 0) {<br>            e.cap -= d;<br>            e.rev.cap += d;<br>            return d;<br>          }<br>      }<br>    }<br>    return 0;<br>  }<br>  class V {<br>    ArrayList&lt;E&gt; es = new ArrayList&lt;E&gt;();<br>    int level, p, iter;<br>    void add(V to, int cap) {<br>      E e = new E(to, cap), rev = new E(this, 0);<br>      e.rev = rev; rev.rev = e;<br>      es.add(e); to.es.add(rev);<br>    }<br>  }<br>  class E {<br>    V to;<br>    E rev;<br>    int cap;<br>    E(V to, int cap) {<br>      this.to = to;<br>      this.cap = cap;<br>    }<br>  }<br>  <br>  void debug(Object...os) {<br>    System.err.println(deepToString(os));<br>  }<br>  <br>}<br></td>