<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br> <br>public class Incubator<br>{<br>  public int maxMagicalGirls(string[] love)<br>  {<br>      int N = love.Length;<br>        bool[,] edge = new bool[N,N];<br>      for (int i = 0; i &lt; N; i++)<br>      {<br>          for (int j = 0; j &lt; N; j++)<br>          {<br>              if (love[i][j]=='Y')<br>              {<br>                  edge[i, j] = true;<br>              }<br>          }<br>      }<br>      for (int i = 0; i &lt; N; i++)<br>      {<br>          for (int j = 0; j &lt; N; j++)<br>          {<br>              for (int k = 0; k &lt; N; k++)<br>              {<br>                  if (edge[j,i]&amp;&amp;edge[i,k])<br>                  {<br>                      edge[j, k] = true;<br>                  }<br>              }<br>          }<br>      }<br>        List&lt;int&gt; l = new List&lt;int&gt;();<br>      for (int i = 0; i &lt; N; i++)<br>      {<br>          if (!edge[i,i])<br>          {<br>              l.Add(i);<br>          }<br>      }<br>      int M = l.Count;<br>        bool[,] E1 = new bool[M,M];<br>      for (int i = 0; i &lt; M; i++)<br>      {<br>          for (int j = 0; j &lt; M; j++)<br>          {<br>              if (edge[l[i],l[j]])<br>              {<br>                  E1[i, j] = true;<br>              }<br>          }<br>      }<br>      return M - BipartiteMatching.Calc(E1);<br>  }<br> <br>    public class BipartiteMatching<br>    {<br>        private static int[] matchl;<br>        private static int[] matchr;<br>        private static int L;<br>        private static int R;<br>        private static bool[] visited;<br>        private static bool[,] Edge;<br> <br>        private static bool dfs(int cur)<br>        {<br>            if (visited[cur]) return false;<br>            visited[cur] = true;<br>            for (int i = 0; i &lt; R; ++i)<br>            {<br>                if (!Edge[cur, i]) continue;<br>                if (matchr[i] == -1 || dfs(matchr[i]))<br>                {<br>                    matchl[cur] = i;<br>                    matchr[i] = cur;<br>                    return true;<br>                }<br>            }<br>            return false;<br>        }<br> <br>        public static int Calc(bool[,] edge)<br>        {<br>            Edge = edge;<br>            L = edge.GetUpperBound(0) + 1;<br>            R = edge.GetUpperBound(1) + 1;<br>            matchl = new int[L];<br>            matchr = new int[R];<br>            for (int i = 0; i &lt; L; ++i)<br>            {<br>                matchl[i] = -1;<br>            }<br>            for (int i = 0; i &lt; R; ++i)<br>            {<br>                matchr[i] = -1;<br>            }<br>            int ret = 0;<br>            visited = new bool[L];<br>            for (int i = 0; i &lt; L; ++i)<br>            {<br>                if (matchl[i] != -1)<br>                {<br>                    continue;<br>                }<br>                for (int j = 0; j &lt; L; ++j)<br>                {<br>                    visited[j] = false;<br>                }<br>                if (dfs(i))<br>                {<br>                    ++ret;<br>                }<br>            }<br>            return ret;<br>        }<br>    }<br> <br> <br>}<br>//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!<br></td>