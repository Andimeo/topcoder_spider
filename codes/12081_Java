<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class FoxAndCake {<br>    class Edge {<br>        int s;<br>        int t;<br>        int c;<br>        int f;<br>        Edge r;<br>        EdgeDesc desc;<br> <br>        public Edge(int s, int t, int c, EdgeDesc desc) {<br>            this.s = s;<br>            this.t = t;<br>            this.c = c;<br>            this.f = 0;<br>            this.desc = desc;<br>        }<br>    }<br> <br>    class EdgeDesc {<br>        int s;<br>        int t;<br> <br>        public EdgeDesc(int s, int t) {<br>            this.s = s;<br>            this.t = t;<br>        }<br>    }<br> <br>    class Graph {<br>        int n;<br>        ArrayList&lt;Edge&gt; edges[];<br> <br>        public Graph(int n) {<br>            this.n = n;<br>            edges = new ArrayList[n];<br>            for (int i = 0; i &lt; n; i++) {<br>                edges[i] = new ArrayList&lt;Edge&gt;();<br>            }<br>        }<br> <br>        void addEdge(int s, int t, int c) {<br>            Edge ef = new Edge(s, t, c, null);<br>            Edge er = new Edge(t, s, 0, null);<br>            ef.r = er;<br>            er.r = ef;<br>            edges[s].add(ef);<br>            edges[t].add(er);<br>        }<br> <br>        void addEdge(int s, int t, int c, EdgeDesc desc) {<br>            Edge ef = new Edge(s, t, c, desc);<br>            Edge er = new Edge(t, s, 0, null);<br>            ef.r = er;<br>            er.r = ef;<br>            edges[s].add(ef);<br>            edges[t].add(er);<br>        }<br> <br>        boolean[] u;<br> <br>        int dfs(int i, int t, int c) {<br>            if (i == t) {<br>                return c;<br>            }<br>            u[i] = true;<br> <br>            for (Edge e : edges[i]) {<br>                if (e.f &lt; e.c &amp;&amp; !u[e.t]) {<br>                    int cap = dfs(e.t, t, Math.min(c, e.c - e.f));<br>                    if (cap &gt; 0) {<br>                        e.f += cap;<br>                        e.r.f -= cap;<br>                        return cap;<br>                    }<br>                }<br>            }<br> <br>            return 0;<br>        }<br> <br>        int maxFlow(int s, int t) {<br>            u = new boolean[n];<br> <br>            int flow = 0;<br>            while (true) {<br>                Arrays.fill(u, false);<br>                int df = dfs(s, t, Integer.MAX_VALUE);<br>                if (df == 0) {<br>                    break;<br>                }<br>                flow += df;<br>            }<br> <br>            return flow;<br>        }<br>    }<br> <br> <br>    public String ableToDivide(int n, int m, int[] x, int[] y) {<br>        Set&lt;Integer&gt; xx = new TreeSet&lt;Integer&gt;();<br>        Set&lt;Integer&gt; yy = new TreeSet&lt;Integer&gt;();<br>        for (int i = 0; i &lt; 7; i++) {<br>            for (int dx = -3; dx &lt;= 3; dx++) {<br>                int p = x[i] + dx;<br>                if (p &gt;= 1 &amp;&amp; p &lt;= n) {<br>                    xx.add(p);<br>                }<br>                p = y[i] + dx;<br>                if (p &gt;= 1 &amp;&amp; p &lt;= m) {<br>                    yy.add(p);<br>                }<br>            }<br>        }<br>        <br>        int xs = xx.size();<br>        int[] xxa = new int[xs];<br>        xs = 0;<br>        for (int xv : xx) {<br>            xxa[xs++] = xv;<br>        }<br> <br>        int ys = yy.size();<br>        int[] yya = new int[ys];<br>        ys = 0;<br>        for (int yv : yy) {<br>            yya[ys++] = yv;<br>        }<br>        <br>        int[] dx = new int[]{-1, 0, 1, 0};<br>        int[] dy = new int[]{0, 1, 0, -1};<br>        <br>        Graph g = new Graph(2 * xs * ys + 2);<br>        for (int i = 0; i &lt; xs; i++) {<br>            for (int j = 0; j &lt; ys; j++) {<br>                int xv = xxa[i];<br>                int yv = yya[j];<br>                if (xv == x[0] &amp;&amp; yv == y[0]) {<br>                    continue;<br>                }<br>                <br>                g.addEdge(i * ys + j, xs * ys + i * ys + j, 1);<br>                <br>                boolean isS = false;<br>                for (int k = 1; k &lt; 4; k++) {<br>                    if (xv == x[k] &amp;&amp; yv == y[k]) {<br>                        isS = true;<br>                    }<br>                }<br>                boolean isT = false;<br>                for (int k = 4; k &lt; 7; k++) {<br>                    if (xv == x[k] &amp;&amp; yv == y[k]) {<br>                        isT = true;<br>                    }<br>                }<br>                <br>                if (isS) {<br>                    g.addEdge(2 * xs * ys, i * ys + j, 1);<br>                } else if (isT) {<br>                    g.addEdge(xs * ys + i * ys + j, 2 * xs * ys + 1, 1);<br>                }<br>                <br>                for (int k = 0; k &lt; 4; k++) {<br>                    int nx = i + dx[k];<br>                    int ny = j + dy[k];<br>                    if (nx &gt;= 0 &amp;&amp; nx &lt; xs &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; ys) {<br>                        g.addEdge(xs * ys + i * ys + j, nx * ys + ny, 1);<br>                    }<br>                }<br>            }<br>        }<br>        <br>        int v = g.maxFlow(2 * xs * ys, 2 * xs * ys + 1);<br>        if (v == 3) {<br>            return "Yes";<br>        } else {<br>            return "No";<br>        }<br>    }<br> <br>}<br> <br> <br>// Powered by PopsEdit<br> <br>// Powered by CodeProcessor<br></td>