<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.List;<br>import java.util.Arrays;<br>import java.util.ArrayList;<br>import java.util.Comparator;<br>import java.util.Collection;<br><br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class KingdomAndCities {<br>  final static long MOD = (long) (1e9 + 7);<br><br>  long[][] connected;<br>  long[] factorial;<br>  long[] reverseFactorial;<br><br>  public int howMany(int N, int M, int K) {<br>    if (N == M)<br>      return 0;<br>    if (M == 1)<br>      return (int) (((long) howMany(N - 1, M - 1, K - 1) * (K - 1) +<br>        (long) howMany(N - 1, M - 1, K - 2) * (K - 2)) % MOD);<br>    if (M == 2) {<br>      return (int) (((long) howMany(N - 1, M - 1, K - 1) * (K - 1) +<br>        (long) howMany(N - 1, M - 1, K - 2) * (K - 4) +<br>        (long) howMany(N - 2, 0, K - 3) * (N - 2)) % MOD);<br>    }<br>    if (N == 0 || K &lt; N - 1 || K &gt; N * (N - 1) / 2)<br>      return 0;<br>    connected = new long[N + 1][K + 1];<br>    ArrayUtils.fill(connected, -1);<br>    factorial = IntegerUtils.generateFactorial(N * (N - 1) / 2 + 1, MOD);<br>    reverseFactorial = IntegerUtils.generateReverseFactorials(N * (N - 1) / 2 + 1, MOD);<br>    return (int) countConnected(N, K);<br>  }<br><br>  private long countConnected(int n, int k) {<br>    if (connected[n][k] != -1)<br>      return connected[n][k];<br>    connected[n][k] = countAny(n, k);<br>    for (int i = 1; i &lt; n; i++) {<br>      for (int j = 0; j &lt;= k; j++) {<br>        connected[n][k] -= countConnected(i, j) * countAny(n - i, k - j) % MOD * c(n - 1, i - 1) % MOD;<br>      }<br>    }<br>    connected[n][k] %= MOD;<br>    connected[n][k] += MOD;<br>    connected[n][k] %= MOD;<br>    return connected[n][k];<br>  }<br><br>  private long countAny(int n, int k) {<br>    return c(n * (n - 1) / 2, k);<br>  }<br><br>  private long c(int n, int k) {<br>    if (k &lt; 0 || k &gt; n)<br>      return 0;<br>    return factorial[n] * reverseFactorial[k] % MOD * reverseFactorial[n - k] % MOD;<br>  }<br><br><br>}<br><br>class ArrayUtils {<br><br>  public static void fill(long[][] array, long value) {<br>    for (long[] row : array)<br>      Arrays.fill(row, value);<br>  }<br><br>  }<br><br>class IntegerUtils {<br><br>  public static long[] generateFactorial(int count, long module) {<br>    long[] result = new long[count];<br>    if (module == -1) {<br>      if (count != 0)<br>        result[0] = 1;<br>      for (int i = 1; i &lt; count; i++)<br>        result[i] = result[i - 1] * i;<br>    } else {<br>      if (count != 0)<br>        result[0] = 1 % module;<br>      for (int i = 1; i &lt; count; i++)<br>        result[i] = (result[i - 1] * i) % module;<br>    }<br>    return result;<br>  }<br><br>  public static long[] generateReverse(int upTo, long module) {<br>    long[] result = new long[upTo];<br>    if (upTo &gt; 1)<br>      result[1] = 1;<br>    for (int i = 2; i &lt; upTo; i++)<br>      result[i] = (module - module / i * result[((int) (module % i))] % module) % module;<br>    return result;<br>  }<br><br>  public static long[] generateReverseFactorials(int upTo, long module) {<br>    long[] result = generateReverse(upTo, module);<br>    if (upTo &gt; 0)<br>      result[0] = 1;<br>    for (int i = 1; i &lt; upTo; i++)<br>      result[i] = result[i] * result[i - 1] % module;<br>    return result;<br>  }<br><br>  }<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.17 [modified TZTester]<br>// Powered by CodeProcessor<br></td>