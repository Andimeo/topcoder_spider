<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;  <br>#include &lt;string&gt;  <br>#include &lt;set&gt;  <br>#include &lt;map&gt;  <br>#include &lt;vector&gt;  <br>#include &lt;queue&gt;   <br>#include &lt;iostream&gt;  <br>#include &lt;iterator&gt;  <br>#include &lt;math.h&gt;  <br>#include &lt;cstdio&gt;  <br>#include &lt;cstdlib&gt;  <br>#include &lt;sstream&gt;  <br><br>#pragma comment(linker, "/STACK:60777216")  <br><br>using namespace std;  <br><br>typedef pair&lt;int,int&gt; pii;  <br>typedef long long ll;  <br>typedef vector&lt;int&gt; vi;  <br><br>#define UN(v) SORT(v),v.erase(unique(v.begin(),v.end()),v.end())  <br>#define SORT(c) sort((c).begin(),(c).end())  <br>#define FOR(i,a,b) for (int  i=(a); i &lt; (b); i++)   <br>#define REP(i,n) FOR(i,0,n)   <br>#define CL(a,b) memset(a,b,sizeof(a))  <br>#define pb push_back  <br><br>const int mod = 1000000007;<br><br>ll c[55][55];<br>ll f[55];<br><br>ll u[55][55];<br><br>ll solve(int num,int pos){<br>  if(pos==0){<br>    if(num) return 0;<br>    return 1;<br>  }<br>  if(u[num][pos]!=-1) return u[num][pos];<br>  ll val = 0;<br>  REP(i,num+1){<br>    ll t = solve(num-i,pos-1);<br>    t *= c[num][i]; t %= mod;<br>    t *= f[i]; t%=mod;<br>    val+=t;<br>    val%=mod;<br>  }<br>  return u[num][pos] = val;<br><br>}<br><br>ll d[55][55][11];<br>void add(ll &amp;x,ll val){<br>  x+=val;<br>  x%=mod;<br>}<br>vi solve_odd(vi odd){<br>  if(odd.size()==0){<br>    vi v(11);<br>    v[0]=1;<br>    return v;<br>  }<br><br>  int tot_even = (odd.size() + 1)/2;<br>  int tot_odd = odd.size() / 2;<br><br>  CL(d,0);<br>  d[0][0][0] = 1;<br><br>  REP(i,odd.size()){<br>    for(int j = tot_even;j&gt;=0;j--)<br>      for(int k = tot_odd;k&gt;=0;k--)<br>        for(int md = 10;md&gt;=0;md--)if(d[j][k][md]){<br>          add(d[j+1][k][(md+odd[i])%11] , (tot_even - j) * d[j][k][md]);<br>          add(d[j][k+1][(md-odd[i]+11)%11], (tot_odd - k) * d[j][k][md]);<br>        }<br>  }<br><br>  vi res(11);<br>  REP(i,11) res[i] = d[tot_even][tot_odd][i];<br>  return res;<br>}<br><br>ll  r[55][55][11];<br>int solve_even(vi res, vi even, int even_pos, int odd_pos){<br>  CL(r,0);<br>  REP(i,11) r[0][0][i] = res[i];<br>  REP(i,even.size()){<br>    for(int j = 50;j&gt;=0;j--)<br>      for(int k = 50;k&gt;=0;k--)<br>        for(int md = 10;md&gt;=0;md--)if(r[j][k][md]){<br>          add(r[j+1][k][(md+even[i])%11] , r[j][k][md]);<br>          add(r[j][k+1][(md-even[i]+11)%11], r[j][k][md]);<br>        }<br>  }<br>  ll ans = 0;<br>  REP(i,55)REP(j,55)if(r[i][j][0] &amp;&amp; i+j==even.size()){<br>    ll t =  r[i][j][0] ;<br>    t *= solve(i,even_pos); t%= mod;<br>    t *= solve(j,odd_pos); t%=mod;<br>    ans += t;<br>    ans%=mod;<br>  }<br>  return ans;<br><br>}<br><br>class ElevenMultiples {<br>public:<br> int countMultiples(vector &lt;string&gt; pieces) {<br>   f[0] = 1;<br>   FOR(i,1,55) f[i]=(f[i-1]*i)%mod;<br>   CL(c,0);<br>   REP(i,55){<br>     c[i][i]=c[i][0]=1;<br>     FOR(j,1,i) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;<br>   }<br>   vi odd;CL(u,-1);<br>   vi even;<br>   REP(i,pieces.size()){<br>     int sum = 0;<br>     REP(j,pieces[i].size()) sum += (j%2?-1:1)*(pieces[i][j]-'0');<br>     sum %= 11;<br>     if(sum&lt;0) sum += 11;<br>     if(pieces[i].size()%2) odd.pb(sum);<br>     else even.pb(sum);<br>   }<br>   vi v = solve_odd(odd);<br>   return solve_even(v, even, 1 + odd.size()/2, (odd.size()+1)/2);<br> }<br> <br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>