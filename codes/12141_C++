<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br> <br>using namespace std;<br> <br>class SweetFruits {<br>public:<br>  int countTrees(vector &lt;int&gt;, int);<br>};<br> <br>const int md = 1000000007;<br> <br>int c[2222222], d[2222222];<br> <br>void Sort(int l, int r) {<br>  int i = l, j = r, x = c[(l+r) &gt;&gt; 1], tmp;<br>  do {<br>    while (c[i] &lt; x) i++;<br>    while (x &lt; c[j]) j--;<br>    if (i &lt;= j) {<br>      tmp = c[i]; c[i] = c[j]; c[j] = tmp;<br>      tmp = d[i]; d[i] = d[j]; d[j] = tmp;<br>      i++; j--;<br>    }<br>  } while (i &lt;= j);<br>  if (l &lt; j) Sort(l,j);<br>  if (i &lt; r) Sort(i,r);<br>}<br> <br>int inv(int a) {<br>  int x = 1, step = 1 &lt;&lt; 30;<br>  while (step &gt; 0) {<br>    x = (long long)x*x % md;<br>    if (step &amp; (md-2)) x = (long long)x*a % md;<br>    step &gt;&gt;= 1;<br>  }<br>  return x;<br>}<br> <br>int C[55][55];<br>int ans, r[55];<br>int a[55][55];<br>int trees[55];<br> <br>void go(int v,int w,int id,int bit,int sw,int cc,int q) {<br>  if (v == 0) {<br>    int n = q+bit+sw, i, j;<br>    for (i=0;i&lt;n;i++)<br>      for (j=0;j&lt;n;j++) a[i][j] = 0;<br>    for (i=0;i&lt;q;i++)<br>      for (j=q;j&lt;q+bit;j++) a[i][j] = a[j][i] = r[i];<br>    for (i=q;i&lt;q+bit;i++)<br>      for (j=q;j&lt;q+bit;j++)<br>        if (i != j) a[i][j] = 1;<br>    for (i=q;i&lt;q+bit;i++)<br>      for (j=q+bit;j&lt;n;j++) a[i][j] = a[j][i] = 1;<br>    for (i=0;i&lt;n;i++)<br>      for (j=0;j&lt;n;j++)<br>        if (i != j) a[i][i] -= a[i][j];<br>    for (i=0;i&lt;n;i++)<br>      if (a[i][i] &lt; 0) a[i][i] += md;<br>    n--;<br>    int e, co, res = 1, tmp;<br>    for (e=0;e&lt;n;e++) {<br>      for (j=e;j&lt;n;j++)<br>        if (a[e][j] != 0) {<br>          for (i=0;i&lt;n;i++) {<br>            tmp = a[i][e]; a[i][e] = a[i][j]; a[i][j] = tmp;<br>          }<br>          break;<br>        }<br>      if (a[e][e] == 0) return;<br>      res = (long long)res*a[e][e] % md;<br>      co = inv(a[e][e]);<br>      for (i=e+1;i&lt;n;i++) {<br>        if (a[i][e] == 0) continue;<br>        int coeff = (long long)a[i][e]*co % md;<br>        for (j=e;j&lt;n;j++) {<br>          a[i][j] = (a[i][j]-(long long)coeff*a[e][j]) % md;<br>          if (a[i][j] &lt; 0) a[i][j] += md;<br>        }<br>      }<br>    }<br>    if (n &amp; 1) res = (md-res) % md;<br>    ans = (ans+(long long)cc*res) % md;<br>    return;<br>  }<br>  if (v &gt;= w) {<br>    int ft = (long long)cc*C[v][w] % md;<br>    ft = (long long)ft*inv(id) % md;<br>    ft = (long long)ft*trees[w] % md;<br>    r[q] = w;<br>    go(v-w,w,id+1,bit,sw,ft,q+1);<br>  }<br>  if (w &gt; 2) go(v,w-1,1,bit,sw,cc,q);<br>}<br> <br>int SweetFruits::countTrees(vector &lt;int&gt; a, int maxs) {<br>  memset(C,0,sizeof(C));<br>  for (int i=0;i&lt;50;i++) C[i][0] = 1;<br>  for (int i=1;i&lt;50;i++)<br>    for (int j=1;j&lt;=i;j++) C[i][j] = (C[i-1][j-1]+C[i-1][j]) % md;<br>  int n = a.size(), i, m = 0, b[99];<br>  for (i=0;i&lt;n;i++)<br>    if (a[i] &gt;= 0) b[m++] = a[i];<br>  int mm = m/2, t;<br>  for (t=0;t&lt;(1&lt;&lt;mm);t++) {<br>    c[t] = 0; d[t] = 0;<br>    for (i=0;i&lt;mm;i++)<br>      if (t &amp; (1 &lt;&lt; i)) {<br>        c[t] += b[i];<br>        d[t]++;<br>      }<br>  }<br>  for (t=0;t&lt;(1&lt;&lt;(m-mm));t++) {<br>    int p = t+(1&lt;&lt;mm);<br>    c[p] = 0; d[p] = 10000;<br>    for (i=mm;i&lt;m;i++)<br>      if (t &amp; (1 &lt;&lt; (i-mm))) {<br>        c[p] += b[i];<br>        d[p]++;<br>      }<br>  }<br>  int sz = (1&lt;&lt;mm)+(1&lt;&lt;(m-mm));<br>  if (sz &gt; 0) Sort(0,sz-1);<br>  int cur[99], j, comb[99];<br>  for (j=0;j&lt;=m;j++) cur[j] = 0;<br>  for (j=0;j&lt;=m;j++) comb[j] = 0;<br>  for (i=0;i&lt;sz;i++)<br>    if (d[i] &lt; 1000) cur[d[i]]++;<br>  j = sz-1;<br>  for (i=0;i&lt;sz;i++) {<br>    if (d[i] &lt; 1000) continue;<br>    while (j &gt;= 0 &amp;&amp; c[i]+c[j] &gt; maxs) {<br>      if (d[j] &lt; 1000) cur[d[j]]--;<br>      j--;<br>    }<br>    for (int k=0;k&lt;=m;k++) {<br>      int z = k+(d[i]-10000);<br>      comb[z] += cur[k];<br>      if (comb[z] &gt;= md) comb[z] -= md;<br>    }<br>  }<br>  trees[2] = 1;<br>  for (i=3;i&lt;=40;i++) {<br>    trees[i] = 1;<br>    for (j=0;j&lt;i-2;j++) trees[i] = (long long)trees[i]*i % md;<br>  }<br>  ans = 0;<br>  for (int sweet=0;sweet&lt;=m;sweet++) {<br>    if (sweet == 1 || comb[sweet] == 0) continue;<br>    go(sweet,sweet,1,n-m,m-sweet,comb[sweet],0);<br>  }<br>  return ans;<br>}<br> <br> <br>//Powered by [KawigiEdit] 2.0!<br></td>