<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>import static java.lang.Math.*;<br>import static java.util.Arrays.*;<br> <br>public class SweetFruits {<br>  <br>  long M = 1000000007;<br>  <br>  long[][] comb = new long[50 + 1][50 + 1];<br>  {<br>    comb[0][0] = 1;<br>    for (int i = 1; i &lt;= 50; i++) {<br>      comb[i][0] = 1;<br>      for (int j = 1; j &lt;= 50; j++) {<br>        comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % M;<br>      }<br>    }<br>  }<br>  <br>  public int countTrees(int[] sweetness, int maxSweetness) {<br>    int n = sweetness.length;<br>    int bitter = 0;<br>    for (int i = 0; i &lt; n; i++) if (sweetness[i] &lt; 0) {<br>      bitter++;<br>      sweetness[i] = Integer.MAX_VALUE;<br>    }<br>    sort(sweetness);<br>    n -= bitter;<br>    int N = n / 2;<br>    long[] list1 = new long[1 &lt;&lt; N];<br>    for (int i = 0; i &lt; 1 &lt;&lt; N; i++) {<br>      int num = Integer.bitCount(i);<br>      int sum = 0;<br>      for (int j = 0; j &lt; N; j++) if ((i &gt;&gt; j &amp; 1) != 0) sum += sweetness[j];<br>      list1[i] = (long)sum &lt;&lt; 32 | num;<br>    }<br>    sort(list1);<br>    long[] list2 = new long[1 &lt;&lt; (n - N)];<br>    for (int i = 0; i &lt; 1 &lt;&lt; (n - N); i++) {<br>      int num = Integer.bitCount(i);<br>      int sum = 0;<br>      for (int j = 0; j &lt; n - N; j++) if ((i &gt;&gt; j &amp; 1) != 0) sum += sweetness[N + j];<br>      list2[i] = (long)sum &lt;&lt; 32 | num;<br>    }<br>    sort(list2);<br>    long[] total = new long[n + 1];<br>    int[] count = new int[n - N + 1];<br>    for (int i = 0; i &lt; list2.length; i++) count[(int)list2[i]]++;<br>    int p = 0, q = list2.length - 1;<br>    for (; p &lt; list1.length; p++) {<br>      while (q &gt;= 0 &amp;&amp; (int)(list1[p] &gt;&gt; 32) + (int)(list2[q] &gt;&gt; 32) &gt; maxSweetness) {<br>        count[(int)list2[q]]--;<br>        q--;<br>      }<br>      for (int i = 0; i &lt; count.length; i++) total[(int)list1[p] + i] += count[i];<br>    }<br>    for (int i = 0; i &lt; total.length; i++) total[i] %= M;<br>    long[] tree = new long[n + 1];<br>    for (int i = 0; i &lt;= n; i++) {<br>      boolean[][] g = new boolean[n + bitter][n + bitter];<br>      for (int j = 0; j &lt; n - i; j++) {<br>        for (int k = n; k &lt; n + bitter; k++) {<br>          g[j][k] = g[k][j] = true;<br>        }<br>      }<br>      for (int j = n - i; j &lt; n + bitter; j++) {<br>        for (int k = j + 1; k &lt; n + bitter; k++) {<br>          g[j][k] = g[k][j] = true;<br>        }<br>      }<br>      tree[i] = tree(g);<br>      for (int j = 1; j &lt;= i; j++) {<br>        tree[i] -= tree[i - j] * comb[i][j];<br>        tree[i] %= M;<br>        if (tree[i] &lt; 0) tree[i] += M;<br>      }<br>    }<br>    long res = 0;<br>    for (int i = 0; i &lt;= n; i++) {<br>      res += tree[i] * total[i];<br>      res %= M;<br>    }<br>    return (int)res;<br>  }<br>  <br>  long tree(boolean[][] g) {<br>    int n = g.length;<br>    long[][] a = new long[n][n];<br>    for (int i = 0; i &lt; n; i++) {<br>      for (int j = 0; j &lt; n; j++) if (g[i][j]) {<br>        a[i][i]++;<br>        a[i][j]--;<br>      }<br>    }<br>    for (int i = 0; i &lt; n; i++) {<br>      for (int j = 0; j &lt; n; j++) if (a[i][j] &lt; 0) a[i][j] += M;<br>    }<br>    return det(a);<br>  }<br>  <br>  long det(long[][] a) {<br>    int n = a.length - 1;<br>    long[][] c = new long[n][n];<br>    long res = 1;<br>    for (int i = 0; i &lt; n; i++) c[i] = a[i].clone();<br>    for (int p = 0; p &lt; n; p++) {<br>      int pi = p;<br>      for (int i = p + 1; i &lt; n; i++) {<br>        if (abs(c[i][p]) &gt; abs(c[pi][p])) pi = i;<br>      }<br>      if (p != pi) {<br>        res = -res;<br>        if (res &lt; 0) res += M;<br>      }<br>      long[] t1 = c[pi]; c[pi] = c[p]; c[p] = t1;<br>      if (c[p][p] == 0) return 0;<br>      res *= c[p][p];<br>      res %= M;<br>      long inv = pow(c[p][p], M - 2);<br>      for (int i = p + 1; i &lt; n; i++) {<br>        c[i][p] *= inv;<br>        c[i][p] %= M;<br>        for (int j = p + 1; j &lt; n; j++) {<br>          c[i][j] -= c[p][j] * c[i][p];<br>          c[i][j] %= M;<br>          if (c[i][j] &lt; 0) c[i][j] += M;<br>        }<br>      }<br>    }<br>    return res;<br>  }<br>  <br>  long pow(long a, long b) {<br>    long res = 1;<br>    while (b &gt; 0) {<br>      if ((b &amp; 1) != 0) res = (res * a) % M;<br>      a = (a * a) % M;<br>      b &gt;&gt;&gt;= 1;<br>    }<br>    return res;<br>  }<br>  <br>  class Entry implements Comparable&lt;Entry&gt; {<br>    int num;<br>    int val;<br>    Entry(int num, int val) {<br>      this.num = num;<br>      this.val = val;<br>    }<br>    public int compareTo(Entry o) {<br>      return val - o.val;<br>    }<br>  }<br>  <br>  void debug(Object...os) {<br>    System.err.println(deepToString(os));<br>  }<br>  <br>}<br></td>