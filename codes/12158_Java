<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.List;<br>import java.util.Arrays;<br>import java.util.LinkedList;<br>import java.util.Queue;<br>import java.util.ArrayList;<br>import java.util.Collection;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Crash<br> */<br>public class SurroundingGame {<br>  private static final int[][] u = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};<br>  private int get(char ch) {<br>    if ('0' &lt;= ch &amp;&amp; ch &lt;= '9') return ch - '0';<br>    if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z') return ch - 'a' + 10;<br>    if ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z') return ch - 'A' + 36;<br>    return -1;<br>  }<br>  public int maxScore(String[] cost, String[] benefit) {<br>    int n = cost.length;<br>    int m = cost[0].length();<br>    IntMaxFlow net = new IntMaxFlow(n * m * 2 + 2);<br>    int sum = 0;<br>    for (int i = 0; i &lt; n; i ++)<br>      for (int j = 0; j &lt; m; j ++)<br>        sum += get(benefit[i].charAt(j));<br>    for (int i = 0; i &lt; n; i ++)<br>      for (int j = 0; j &lt; m; j ++)<br>        if ((i + j) % 2 == 0) {<br>          int tmp = get(benefit[i].charAt(j)) - get(cost[i].charAt(j));<br>          if (tmp &lt; 0) {<br>            net.insertEdge(i * m + j + 1, n * m * 2 + 1, -tmp);<br>          } else {<br>            net.insertEdge(0, i * m + j + 1, tmp);<br>            sum += tmp;<br>          }<br>          net.insertEdge(i * m + j + n * m + 1, n * m * 2 + 1, get(benefit[i].charAt(j)));<br>          for (int k = 0; k &lt; 4; k ++) {<br>            int t1 = i + u[k][0], t2 = j + u[k][1];<br>            if (0 &lt;= t1 &amp;&amp; t1 &lt; n &amp;&amp; 0 &lt;= t2 &amp;&amp; t2 &lt; m) {<br>              net.insertEdge(t1 * m + t2 + 1, i * m + j + n * m + 1, Integer.MAX_VALUE);<br>            }<br>          }<br>          net.insertEdge(i * m + j + 1, i * m + j + n * m + 1, Integer.MAX_VALUE);<br>        } else {<br>          int tmp = get(benefit[i].charAt(j)) - get(cost[i].charAt(j));<br>          if (tmp &lt; 0) {<br>            net.insertEdge(0, i * m + j + 1, -tmp);<br>          } else {<br>            net.insertEdge(i * m + j + 1, n * m * 2 + 1, tmp);<br>            sum += tmp;<br>          }<br>          net.insertEdge(0, i * m + j + n * m + 1, get(benefit[i].charAt(j)));<br>          for (int k = 0; k &lt; 4; k ++) {<br>            int t1 = i + u[k][0], t2 = j + u[k][1];<br>            if (0 &lt;= t1 &amp;&amp; t1 &lt; n &amp;&amp; 0 &lt;= t2 &amp;&amp; t2 &lt; m) {<br>              net.insertEdge(i * m + j + n * m + 1, t1 * m + t2 + 1, Integer.MAX_VALUE);<br>            }<br>          }<br>          net.insertEdge(i * m + j + n * m + 1, i * m + j + 1, Integer.MAX_VALUE);<br>        }<br>    return sum - (int)net.maxFlow(0, n * m * 2 + 1);<br>  }<br>}<br> <br>class IntMaxFlow {<br>  public List&lt;IntMaxFlowEdge&gt;[] ge;<br>  public int n;<br> <br>  public IntMaxFlow(int n) {<br>    this.n = n;<br>    ge = new List[n];<br>    for (int i = 0; i &lt; n; i ++)<br>      ge[i] = new ArrayList&lt;IntMaxFlowEdge&gt;();<br>  }<br> <br>  public void insertEdge(int a, int b, int w) {<br>    if (0 &gt; a || a &gt;= n) throw new RuntimeException();<br>    if (0 &gt; b || b &gt;= n) throw new RuntimeException();<br>    IntMaxFlowEdge x = new IntMaxFlowEdge(a, 0);<br>    IntMaxFlowEdge y = new IntMaxFlowEdge(b, w);<br>    x.anti = y;<br>    y.anti = x;<br>    ge[a].add(y);<br>    ge[b].add(x);<br>  }<br> <br>  public long maxFlow(int s, int t) {<br>    if (0 &gt; s || s &gt;= n) throw new RuntimeException();<br>    if (0 &gt; t || t &gt;= n) throw new RuntimeException();<br>    long tot = 0;<br>    while (true) {<br>      int[] dist = new int[n];<br>      Arrays.fill(dist, -1);<br>      Queue&lt;Integer&gt; Q = new LinkedList&lt;Integer&gt;();<br>      Q.offer(s);<br>      dist[s] = 0;<br>      while (! Q.isEmpty()) {<br>        int now = Q.remove();<br>        for (IntMaxFlowEdge e : ge[now])<br>          if (e.weight &gt; 0 &amp;&amp; dist[e.data] == -1) {<br>            dist[e.data] = dist[now] + 1;<br>            Q.offer(e.data);<br>          }<br>      }<br>      if (dist[t] == -1) break;<br> <br>      int[] cur = new int[n];<br>      int[] pre = new int[n];<br>      IntMaxFlowEdge[] path = new IntMaxFlowEdge[n];<br>      int now = s;<br>      while (dist[s] != -1) {<br>        if (now == t) {<br>          int flow = Integer.MAX_VALUE;<br>          for (now = t; now != s; now = pre[now])<br>            flow = Math.min(flow, path[now].weight);<br>          tot += flow;<br>          for (now = t; now != s; now = pre[now]) {<br>            path[now].weight -= flow;<br>            path[now].anti.weight += flow;<br>          }<br>        }<br>        boolean flag = false;<br>        for (int i = cur[now]; i &lt; ge[now].size(); i ++) {<br>          IntMaxFlowEdge e = ge[now].get(i);<br>          if (e.weight &gt; 0 &amp;&amp; dist[e.data] == dist[now] + 1) {<br>            pre[e.data] = now;<br>            cur[now] = i;<br>            path[e.data] = e;<br>            now = e.data;<br>            flag = true;<br>            break;<br>          }<br>        }<br>        if (! flag) {<br>          dist[now] = -1;<br>          now = pre[now];<br>        }<br>      }<br>    }<br>    return tot;<br>  }<br>}<br> <br>class IntMaxFlowEdge {<br>  public int data;<br>  public int weight;<br>  public IntMaxFlowEdge anti;<br>  public IntMaxFlowEdge(int data, int weight) {<br>    this.data = data;<br>    this.weight = weight;<br>  }<br>}<br></td>