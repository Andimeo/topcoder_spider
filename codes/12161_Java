<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Comparator;<br>import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class TheBrickTowerMediumDivOne {<br>  public int[] find(final int[] heights) {<br>    int[] answer = new int[heights.length];<br>    int max = Integer.MAX_VALUE;<br>    boolean[] used = new boolean[heights.length];<br>    for (int i = 0; i &lt; answer.length; i++) {<br>      int current = -1;<br>      for (int j = 0; j &lt; answer.length; j++) {<br>        if (!used[j] &amp;&amp; heights[j] &lt;= max) {<br>          current = j;<br>          break;<br>        }<br>      }<br>      if (current == -1) {<br>        int[] remaining = new int[answer.length - i];<br>        int index = 0;<br>        for (int j = 0; j &lt; answer.length; j++) {<br>          if (!used[j])<br>            remaining[index++] = j;<br>        }<br>        ArrayUtils.sort(remaining, new IntComparator() {<br>          public int compare(int first, int second) {<br>            if (heights[first] != heights[second])<br>              return heights[first] - heights[second];<br>            return first - second;<br>          }<br>        });<br>        System.arraycopy(remaining, 0,answer, i, answer.length - i);<br>        break;<br>      }<br>      max = heights[current];<br>      used[current] = true;<br>      answer[i] = current;<br>    }<br>    return answer;<br>  }<br>}<br> <br>class ArrayUtils {<br>    private static int[] tempInt = new int[0];<br> <br>  public static int[] sort(int[] array, IntComparator comparator) {<br>        return sort(array, 0, array.length, comparator);<br>    }<br> <br>    public static int[] sort(int[] array, int from, int to, IntComparator comparator) {<br>        ensureCapacityInt(to - from);<br>        System.arraycopy(array, from, tempInt, 0, to - from);<br>        sortImpl(array, from, to, tempInt, 0, to - from, comparator);<br>        return array;<br>    }<br> <br>    private static void ensureCapacityInt(int size) {<br>        if (tempInt.length &gt;= size)<br>            return;<br>        size = Math.max(size, tempInt.length &lt;&lt; 1);<br>        tempInt = new int[size];<br>    }<br> <br>    private static void sortImpl(int[] array, int from, int to, int[] temp, int fromTemp, int toTemp, IntComparator comparator) {<br>        if (to - from &lt;= 1)<br>            return;<br>        int middle = (to - from) &gt;&gt; 1;<br>        int tempMiddle = fromTemp + middle;<br>        sortImpl(temp, fromTemp, tempMiddle, array, from, from + middle, comparator);<br>        sortImpl(temp, tempMiddle, toTemp, array, from + middle, to, comparator);<br>        int index = from;<br>        int index1 = fromTemp;<br>        int index2 = tempMiddle;<br>        while (index1 &lt; tempMiddle &amp;&amp; index2 &lt; toTemp) {<br>            if (comparator.compare(temp[index1], temp[index2]) &lt;= 0)<br>                array[index++] = temp[index1++];<br>            else<br>                array[index++] = temp[index2++];<br>        }<br>        if (index1 != tempMiddle)<br>            System.arraycopy(temp, index1, array, index, tempMiddle - index1);<br>        if (index2 != toTemp)<br>            System.arraycopy(temp, index2, array, index, toTemp - index2);<br>    }<br> <br>    }<br> <br>interface IntComparator {<br> <br>    public int compare(int first, int second);<br>}<br></td>