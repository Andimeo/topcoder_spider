<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cmath&gt;<br>#include &lt;stack&gt;<br>#include &lt;queue&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;bitset&gt;<br>#include &lt;fstream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br>#define li        long long int<br>#define rep(i,to) for(li i=0;i&lt;((li)(to));++i)<br>#define pb        push_back<br>#define sz(v)     ((li)(v).size())<br>#define bit(n)    (1ll&lt;&lt;(li)(n))<br>#define all(vec)  (vec).begin(),(vec).end()<br>#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)<br>#define MP        make_pair<br>#define F         first<br>#define S         second<br> <br> <br> <br> <br> <br>//  p.180<br>//<br>#define MAT_MOD  1234567891<br>//check mod is not long long int<br>//<br>li mod = MAT_MOD;<br> <br>template &lt;class T&gt; class MAT<br>{<br>public:<br>  int n,m;<br>  int mod;<br>  long long int mod2;<br>  vector&lt;vector&lt;T&gt; &gt; a;<br>  <br>  MAT();<br>  MAT(int N,int M,long long int num);<br>  void print();<br>  void setMod(long long int next_mod);<br>  long long int size();<br>  MAT&lt;T&gt; operator+(MAT&lt;T&gt; mat);<br>  MAT&lt;T&gt; operator-(MAT&lt;T&gt; mat);<br>  MAT&lt;T&gt; operator*(MAT&lt;T&gt; mat);<br>  MAT&lt;T&gt; operator*(T num);<br>  vector&lt;T&gt;&amp; operator[](int num){ return a[num]; }<br>  MAT&lt;T&gt; transpose();<br>  MAT&lt;T&gt; pow(long long int m);<br>};<br> <br>template &lt;class T&gt; long long int MAT&lt;T&gt;::size(){ return n; }<br> <br> <br>template &lt;class T&gt; void MAT&lt;T&gt;::print()<br>{<br>  for(int i=0;i&lt;n;i++){<br>    for(int j=0;j&lt;m;j++) printf("%d ",a[i][j]);<br>    printf("\n");<br>  }<br>}<br> <br>template &lt;&gt; void MAT&lt;double&gt;::print()<br>{<br>  for(int i=0;i&lt;n;i++){<br>    for(int j=0;j&lt;m;j++) printf("%0.6lf ",(double)a[i][j]);<br>    printf("\n");<br>  }<br>}<br> <br>template &lt;class T&gt; void MAT&lt;T&gt;::setMod(long long int next_mod)<br>{<br>  mod=next_mod;<br>  mod2=(long long int)mod*mod;<br>}<br> <br>template &lt;class T&gt; MAT&lt;T&gt; MAT&lt;T&gt;::transpose()<br>{<br>  MAT res(m,n,0);<br>  for(int i=0;i&lt;n;i++)for(int j=0;j&lt;m;j++) res[j][i]=a[i][j];<br>  return res;<br>}<br> <br> <br>template &lt;class T&gt; MAT&lt;T&gt; MAT&lt;T&gt;::pow(long long int a)<br>{<br>  MAT&lt;T&gt; res(n,n,0);<br>  for(int i=0;i&lt;n;i++) res[i][i]=1;<br>  MAT&lt;T&gt; base=*this;<br>  for(;a;a&gt;&gt;=1){<br>    if(a&amp;1) res=res*base;<br>    base=base*base;<br>  }<br>  return res;<br>}<br> <br>template &lt;class T&gt; MAT&lt;T&gt;::MAT()<br>{<br>  n=m=0;<br>  setMod(MAT_MOD);<br>}<br> <br>template &lt;class T&gt; MAT&lt;T&gt;::MAT(int N,int M,long long int num)<br>{<br>  n=N; m=M;<br>  setMod(MAT_MOD);<br>  if(mod&lt;=abs(num)) num%=mod;<br>  if(num&lt;0) num+=mod;<br>  a=vector&lt;vector&lt;T&gt; &gt;(n,vector&lt;T&gt;(m,num));<br>}<br> <br>template &lt;class T&gt; MAT&lt;T&gt; MAT&lt;T&gt;::operator+(MAT&lt;T&gt; mat)<br>{<br>  MAT&lt;T&gt; res=*this;<br>  for(int i=0;i&lt;n;i++)for(int j=0;j&lt;m;j++){<br>    res[i][j]=res[i][j]+mat[i][j];<br>    if(mod&lt;=res[i][j]) res[i][j]-=mod;<br>  }<br>  return res;<br>}<br> <br>template &lt;&gt; MAT&lt;double&gt; MAT&lt;double&gt;::operator+(MAT&lt;double&gt; mat)<br>{<br>  MAT&lt;double&gt; res=*this;<br>  for(int i=0;i&lt;n;i++)for(int j=0;j&lt;m;j++) res[i][j]=res[i][j]+mat[i][j];<br>  return res;<br>}<br> <br>template &lt;class T&gt; MAT&lt;T&gt; MAT&lt;T&gt;::operator-(MAT&lt;T&gt; mat)<br>{<br>  MAT&lt;T&gt; res=*this;<br>  for(int i=0;i&lt;n;i++)for(int j=0;j&lt;m;j++){<br>    res[i][j]=res[i][j]-mat[i][j];<br>    if(res[i][j]&lt;0) res[i][j]+=mod;<br>  }<br>  return res;<br>}<br> <br>template &lt;&gt; MAT&lt;double&gt; MAT&lt;double&gt;::operator-(MAT&lt;double&gt; mat)<br>{<br>  MAT&lt;double&gt; res=*this;<br>  for(int i=0;i&lt;n;i++)for(int j=0;j&lt;m;j++) res[i][j]=res[i][j]-mat[i][j];<br>  return res;<br>}<br> <br>template &lt;class T&gt; MAT&lt;T&gt; MAT&lt;T&gt;::operator*(MAT&lt;T&gt; mat)<br>{<br>  MAT&lt;T&gt; res=MAT&lt;T&gt;(n,mat.m,0);<br>  vector&lt;long long int&gt; b(mat.m);<br>  for(int i=0;i&lt;n;i++){<br>    for(int j=0;j&lt;mat.m;j++) b[j]=0;<br>    for(int j=0;j&lt;m;j++){<br>      if(a[i][j]==0) continue;<br>      for(int k=0;k&lt;mat.m;k++){<br>        b[k]+=(long long int)a[i][j]*mat[j][k];<br>        if(mod2&lt;=b[k]) b[k]-=mod2;<br>      }<br>    }<br>    for(int j=0;j&lt;mat.m;j++) res[i][j]=b[j]%mod;<br>  }<br>  return res;<br>}<br> <br>template &lt;&gt; MAT&lt;double&gt; MAT&lt;double&gt;::operator*(MAT&lt;double&gt; mat)<br>{<br>  MAT&lt;double&gt; res=MAT&lt;double&gt;(n,mat.m,0);<br>  for(int i=0;i&lt;n;i++)for(int j=0;j&lt;m;j++){<br>    if(a[i][j]==0) continue;<br>    for(int k=0;k&lt;mat.m;k++) res[i][k]+=a[i][j]*mat[j][k];<br>  }<br>  return res;<br>}<br> <br> <br> <br> <br> <br>class TheBrickTowerHardDivOne {<br>public:<br> <br>  #define MAX 24<br>  li N;<br>  li C, K, H;<br>  vector&lt;li&gt; state[MAX];<br>  li INDEX[4][4][4][4];<br> <br>  void reform(vector&lt;li&gt; &amp;v)<br>  {<br>    if(sz(v) != 4) cout &lt;&lt; "Erorr : " &lt;&lt; __LINE__ &lt;&lt; endl;<br>    map&lt;li, li&gt; mp;<br>    rep(i, 4){<br>      if(mp.find(v[i]) == mp.end()){<br>        li t = sz(mp);<br>        mp[v[i]] = t;<br>      }<br>      v[i] = mp[v[i]];<br>    }<br>  }<br>  <br>  void make(vector&lt;li&gt; v)<br>  {<br>    if(sz(v) == 4){<br>      INDEX[v[0]][v[1]][v[2]][v[3]] = N;<br>      state[N++] = v;<br>      return;<br>    }<br> <br>    li maxi = 0;<br>    rep(i, sz(v)) maxi = max(maxi, v[i]);<br>    <br>    for(li i = 0; i &lt;= maxi + 1; i++){<br>      v.pb(i);<br>      make(v);<br>      v.pop_back();<br>    }<br> <br>  }<br>  <br>  li cnt[MAX][10];<br>  vector&lt;li&gt; base;<br>  bool debug;<br>  <br>  void recur(vector&lt;li&gt; v, li maxi, li way)<br>  {<br>    if(debug){<br>      rep(i, sz(v)) cout &lt;&lt; v[i] &lt;&lt; " "; cout &lt;&lt; endl;<br>      cout &lt;&lt; maxi &lt;&lt; " " &lt;&lt; way &lt;&lt; endl;<br>      cout &lt;&lt; endl;<br>    }<br>    <br>    if(sz(v) == 4){<br>      li sum = 0;<br>      rep(i, 4)if(v[i] == base[i]) sum++;<br>      if(v[0] == v[1]) sum++;<br>      if(v[0] == v[2]) sum++;<br>      if(v[1] == v[3]) sum++;<br>      if(v[2] == v[3]) sum++;<br>      reform(v);<br>      if(debug){<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>      }<br>      li &amp;t = cnt[INDEX[v[0]][v[1]][v[2]][v[3]]][sum];<br>      t = (t + way) % mod;<br>      return;<br>    }<br> <br>    for(li i = 0; i &lt;= maxi + 1; i++){<br>      v.pb(i);<br>      if(i == maxi + 1) recur(v, maxi + 1, way * (C - maxi - 1) % mod);<br>      else recur(v, maxi, way);<br>      v.pop_back();<br>    }<br>  }<br>  <br>  int find(int _C, int _K, long long _H){<br>    N = 0;<br>    C = _C;<br>    K = _K;<br>    H = _H;<br>    <br>    make(vector&lt;li&gt;(1, 0));<br>    MAT&lt;li&gt; left(N * 8 + 1, N * 8 + 1, 0); <br>    MAT&lt;li&gt; right(N * 8 + 1, 1, 0);<br>    rep(i, N)rep(j, K + 1) left[N * 8][i + j * N] = 1;<br>    left[N * 8][N * 8] = 1;<br>    <br>    debug = false;<br>    rep(i, N){<br>      memset(cnt, 0, sizeof(cnt));<br>      base = state[i];<br>      li maxi = 0;<br>      rep(j, 4) maxi = max(maxi, base[j]);<br>      recur(vector&lt;li&gt;(), maxi, 1);<br>      rep(j, 8)rep(k, N){<br>        for(li l = 0; l + j &lt; 8; l++){<br>          left[k + (j + l) * N][i + j * N] = cnt[k][l];<br>        }<br>      }<br>    }<br>    <br>//    debug = true;<br>//    left.print();<br>    memset(cnt, 0, sizeof(cnt));<br>    base = vector&lt;li&gt;(4, -1);<br>    recur(vector&lt;li&gt;(), -1, 1);<br>    rep(i, N)rep(j, 8) right[i + j * N][0] = cnt[i][j];<br>//    right.print();<br>    <br>//    cout &lt;&lt; "  " &lt;&lt; H &lt;&lt; endl;<br>    left = left.pow(H);<br>    <br>    <br>    right = left * right;<br>    return right[8 * N][0];<br>  }<br>  <br> <br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>