<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class CirclesGame {<br>    boolean[][] contains;<br>    int[] nimber;<br>    int n;<br> <br>  public String whoCanWin(int[] x, int[] y, int[] r) {<br>        n = x.length;<br>        contains = new boolean[n][n];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j) if (r[i] &gt; r[j]) {<br>                int dx = x[i] - x[j];<br>                int dy = y[i] - y[j];<br>                int d2 = dx * dx + dy * dy;<br>                int diff = r[i] - r[j];<br>                if (d2 &lt; diff * diff) {<br>                    contains[i][j] = true;<br>                }<br>            }<br>        boolean[][] indirect = new boolean[n][n];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>                for (int k = 0; k &lt; n; ++k)<br>                    if (contains[i][k] &amp;&amp; contains[k][j]) indirect[i][j] = true;<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>                contains[i][j] &amp;= !indirect[i][j];<br>        nimber = new int[n];<br>        Arrays.fill(nimber, -1);<br>        int res = 0;<br>        for (int i = 0; i &lt; n; ++i) {<br>            boolean hasCover = false;<br>            for (int j = 0; j &lt; n; ++j) if (contains[j][i]) hasCover = true;<br>            if (!hasCover) {<br>                doit(i);<br>                res ^= nimber[i];<br>            }<br>        }<br>        if (res == 0) return "Bob"; else return "Alice";<br>  }<br> <br>    private void doit(int root) {<br>        for (int i = 0; i &lt; n; ++i) if (contains[root][i]) doit(i);<br>        boolean[] seen = new boolean[n + 10];<br>        dfs(root, 0, seen);<br>        for (int i = 0; i &lt; seen.length; ++i) if (!seen[i]) {<br>            nimber[root] = i;<br>            break;<br>        }<br>    }<br> <br>    private void dfs(int root, int already, boolean[] seen) {<br>        int childXor = 0;<br>        for (int i = 0; i &lt; n; ++i) if (contains[root][i]) childXor ^= nimber[i];<br>        seen[already ^ childXor] = true;<br>        for (int i = 0; i &lt; n; ++i) if (contains[root][i]) dfs(i, already ^ childXor ^ nimber[i], seen);<br>    }<br>}<br></td>