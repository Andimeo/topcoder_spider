<td class="problemText" colspan="8" valign="middle" align="left">
            /**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class HatRack {<br>    int[] knob1;<br>    int[] knob2;<br> <br>  public long countWays(int[] _knob1, int[] _knob2) {<br>        knob1 = _knob1.clone();<br>        knob2 = _knob2.clone();<br>        int n = knob1.length + 1;<br>        for (int i = 0; i &lt; knob1.length; ++i) {<br>            --knob1[i];<br>            --knob2[i];<br>        }<br>        long res = 0;<br>        for (int root = 0; root &lt; n; ++root) {<br>            res += solveForRoot(root);<br>        }<br>        return res;<br>  }<br> <br>    int[] subtreeSize;<br>    int[] childSizes;<br>    int[] child;<br> <br>    private long solveForRoot(int root) {<br>        subtreeSize = new int[knob1.length + 1];<br>        childSizes = new int[knob1.length + 1];<br>        child = new int[knob1.length + 1];<br>        dfs(root, -1);<br>        return doit(root, -1);<br>    }<br> <br>    private long doit(int root, int parent) {<br>        int size = subtreeSize[root];<br>        if (size == 1)<br>            return 1;<br>        int height = 1;<br>        while ((1 &lt;&lt; height) - 1 &lt; size)<br>            ++height;<br>        int numChildren = 0;<br>        for (int i = 0; i &lt; knob1.length; ++i)<br>            if (knob1[i] == root || knob2[i] == root) {<br>                int other = knob1[i] + knob2[i] - root;<br>                if (other != parent) {<br>                    childSizes[numChildren] = subtreeSize[other];<br>                    child[numChildren] = other;<br>                    ++numChildren;<br>                }<br>            }<br>        if (size == 2) {<br>            if (numChildren != 1) return 0;<br>            return doit(child[0], root);<br>        } else {<br>            if (numChildren != 2) return 0;<br>            int expectLeft = (1 &lt;&lt; (height - 1)) - 1;<br>            int expectRight = (1 &lt;&lt; (height - 1)) - 1;<br>            for (int i = 0; i &lt; (1 &lt;&lt; (height - 2)) &amp;&amp; 1 + expectLeft + expectRight &gt; size; ++i)<br>                --expectRight;<br>            for (int i = 0; i &lt; (1 &lt;&lt; (height - 2)) &amp;&amp; 1 + expectLeft + expectRight &gt; size; ++i)<br>                --expectLeft;<br>            int c0 = child[0];<br>            int c1 = child[1];<br>            if (expectLeft == expectRight) {<br>                if (childSizes[0] != expectLeft || childSizes[1] != expectLeft)<br>                    return 0;<br>                return 2 * doit(c0, root) * doit(c1, root);<br>            } else {<br>                if ((childSizes[0] == expectLeft &amp;&amp; childSizes[1] == expectRight) || (childSizes[0] == expectRight &amp;&amp; childSizes[1] == expectLeft)) {<br>                    return doit(c0, root) * doit(c1, root);<br>                } else {<br>                    return 0;<br>                }<br>            }<br>        }<br>    }<br> <br>    private void dfs(int root, int parent) {<br>        subtreeSize[root] = 1;<br>        for (int i = 0; i &lt; knob1.length; ++i)<br>            if (knob1[i] == root || knob2[i] == root) {<br>                int other = knob1[i] + knob2[i] - root;<br>                if (other != parent) {<br>                    dfs(other, root);<br>                    subtreeSize[root] += subtreeSize[other];<br>                }<br>            }<br>    }<br>}<br></td>