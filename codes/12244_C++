<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;ctime&gt;<br>#include &lt;string&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;cassert&gt;<br>#include &lt;stack&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br> <br>using namespace std;<br> <br>#define pb               push_back<br>#define mp              make_pair<br>#define fill(a,v)           memset(a, v, sizeof a)<br>#define INF              (int)1e9<br>#define EPS 1e-9<br>typedef vector&lt;int&gt; VI;<br>typedef long long LL;<br>typedef pair&lt;int, int &gt; PII;<br> <br> <br> <br>#define debug(args...)      {dbg,args; cout&lt;&lt;endl;}<br>struct debugger<br>{<br>  template&lt;typename T&gt; debugger&amp; operator , (const T&amp; v)<br>  {  <br>    cout&lt;&lt;v&lt;&lt;" ";  <br>    return *this;  <br>  }<br>} dbg;<br> <br> <br> <br>struct Point<br>{<br>  double x,y;<br>  Point( double a = 0, double b = 0)<br>  {<br>     x = a; <br>     y = b;<br>  }<br>  <br>  double operator ^ (Point P)<br>  {<br>    return x * P.y - y * P.x;<br>  }<br>  <br>  Point operator * (double c)<br>  {<br>    return Point ( c * x, c * y);<br>  }<br>  <br>  Point operator + ( Point P)<br>  {<br>    return Point( x + P.x, y + P.y);<br>  }<br>  <br>  Point operator - ( Point P)<br>  {<br>    return Point( x - P.x, y - P.y);<br>  }<br>};<br> <br>double dist(Point a, Point b)<br>{<br>  double dx = a.x - b.x;<br>  double dy = a.y - b.y;<br>  return sqrt(dx*dx + dy*dy);<br>}<br> <br>double cx,cy,cr;<br>Point C;<br>double besta[55];<br>double bestb[55];<br>double bestd[55];<br>double bestopp[55];<br>const double PI = 4*atan(1);<br>int n;<br> <br>VI x,y,r;<br> <br>void getTangent(int u,double x,double y,double r)<br>{<br>  Point O = Point(x,y);<br>  double dev = acos(cr/dist(O,C));<br>  double base = atan2(y-cy, x-cx);   <br>  besta[u] = base+dev;<br>  bestb[u] = base-dev;<br>  bestopp[u] = atan2(cy-y, cx-x);<br>  <br>  Point P = Point(cx + cr * cos(besta[u]), cy + cr * sin(besta[u]));<br>  bestd[u] = dist(O, P) - r;<br>}<br> <br>double delta(double u,double v)<br>{<br>  double ans = v-u;<br>  while(ans&gt;0) ans -= 2*PI;<br>  while(ans&lt;-EPS) ans += 2*PI;<br>  return min(ans, 2*PI-ans);<br>}<br> <br>double getf(int u, double x,double y,double r,double theta)<br>{<br>    Point dev = Point(cr * cos(theta), cr * sin(theta));<br>    Point P = C+dev;<br>    Point O = Point(x,y);<br>    double d = dist(P, O) - r;<br>    //debug("d",d);<br>    if(d&gt;bestd[u])<br>    {<br>      d = bestd[u] + cr * min(delta(theta, besta[u]), delta(theta, bestb[u]));<br>    }<br>    return d;<br>}  <br>  <br>double getf(int u,double theta)<br>{<br>  return getf(u,x[u],y[u],r[u],theta);<br>}  <br>    <br>    <br>double eval(double theta)<br>{<br>  double ans = 1e9;<br>  for(int i=1;i&lt;n;i++)<br>  {<br>    ans = min(ans, getf(i, x[i], y[i], r[i], theta));<br>  }<br>  return ans;<br>}<br>    <br>const int steps = 1000;<br>double temp[steps+5];<br> <br> <br>double ans;<br>void dostuff(int u,int v, double lo,double hi)<br>{<br>  for(int i=0;i&lt;50;i++)<br>  {<br>    double mid = (lo+hi)/2;<br>    double z = getf(u,mid) - getf(v,mid);<br>    if(z&lt;0)<br>      lo=mid;<br>    else<br>      hi=mid;<br>  }<br>  <br>  ans = max(ans, eval(lo));<br>}<br>    <br> <br>class CircusTents <br>{<br>public:<br> <br> <br>double findMaximumDistance(vector &lt;int&gt; qx, vector &lt;int&gt; qy, vector &lt;int&gt; qr) <br>{<br>  x=qx;<br>  y=qy;<br>  r=qr;<br>  n=qx.size();<br>  <br>  cx = x[0];<br>  cy = y[0];<br>  cr = r[0];<br>  C = Point(cx,cy);<br>  for(int i=1;i&lt;x.size();i++)<br>  {<br>    getTangent(i,x[i],y[i],r[i]);<br>  }<br>  <br>  ans = 0;<br>  for(int i=1;i&lt;n;i++)<br>  {<br>    //debug(besta[1],bestb[1],bestd[1],bestopp[1]);<br>    //debug(getf(1, x[1], y[1], r[1], bestopp[1]));<br>    ans = max(ans, eval(bestopp[i]));<br>  }<br>  <br>  double iter = (2 * PI)/steps;<br>  <br>  for(int i=1;i&lt;n;i++)<br>    for(int j=1;j&lt;n;j++)<br>    {<br>      if(j==i) continue;<br>      for(int k=0;k&lt;steps;k++)<br>      {<br>        double angle = k*iter;<br>        temp[k] = getf(i,angle) - getf(j,angle);<br>      }<br>      <br>      for(int k=0;k&lt;steps;k++)<br>        if(temp[k]==0)<br>          ans = max(ans, eval(k*iter));<br>    <br>      <br>      for(int k=0;k&lt;steps;k++)<br>      {<br>        int nk = (k+1)%steps;<br>        <br>        if(temp[k]&lt;0 &amp;&amp; temp[nk]&gt;0)<br>          dostuff(i,j,k*iter, (k+1)*iter);<br>          <br>        if(temp[k]&gt;0 &amp;&amp; temp[nk]&lt;0)<br>          dostuff(i,j,(k+1)*iter, k*iter);<br>      }<br>    }<br>  return ans;<br>    <br>  <br>  <br>}<br> <br> <br> <br>};<br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!<br></td>