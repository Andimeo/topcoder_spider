<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class CircusTents {<br>    int[] x;<br>    int[] y;<br>    int[] r;<br>    double[] alp;<br>    double[] dist;<br>    double[] inside;<br>    int n;<br>    double result;<br> <br>  public double findMaximumDistance(int[] x, int[] y, int[] r) {<br>        n = r.length;<br>        this.x = x;<br>        this.y = y;<br>        this.r = r;<br>        result = 0;<br>        alp = new double[n];<br>        dist = new double[n];<br>        inside = new double[n];<br>        double[] interestingAlphas = new double[2 * n - 2];<br>        for (int i = 1; i &lt; n; ++i) {<br>            interestingAlphas[2 * i - 2] = alp[i] = norm(Math.atan2(y[i] - y[0], x[i] - x[0]));<br>            interestingAlphas[2 * i - 1] = norm(Math.atan2(y[i] - y[0], x[i] - x[0]) + Math.PI);<br>            dist[i] = Math.sqrt((x[i] - x[0]) * (double) (x[i] - x[0]) + (y[i] - y[0]) * (double) (y[i] - y[0]));<br>            inside[i] = Math.acos(r[0] / dist[i]);<br>        }<br>        Arrays.sort(interestingAlphas);<br>        for (int i = -1; i &lt; interestingAlphas.length; ++i) {<br>            double left;<br>            if (i &lt; 0) left = -Math.PI; else left = interestingAlphas[i];<br>            double right;<br>            if (i + 1 &gt;= interestingAlphas.length) right = Math.PI; else right = interestingAlphas[i + 1];<br>            if (right - left &lt; 1e-14) continue;<br>            checkPoint(left);<br>            checkPoint(right);<br>            for (int first = 1; first &lt; n; ++first) {<br>                for (int second = first + 1; second &lt; n; ++second) {<br>                    boolean atLeft = getDistance(left, first) &gt; getDistance(left, second);<br>                    boolean atRight = getDistance(right, first) &gt; getDistance(right, second);<br>                    if (atLeft != atRight) {<br>                        double al = left;<br>                        double ar = right;<br>                        while (ar - al &gt; 1e-14) {<br>                            double am = (al + ar) / 2;<br>                            if ((getDistance(am, first) &gt; getDistance(am, second)) == atLeft)<br>                                al = am;<br>                            else<br>                                ar = am;<br>                        }<br>                        checkPoint((al + ar) / 2.0);<br>                    }<br>                }<br>            }<br>        }<br>        return result;<br>  }<br> <br>    private void checkPoint(double alpha) {<br>        double res = Double.MAX_VALUE;<br>        for (int i = 1; i &lt; n; ++i)<br>            res = Math.min(res, getDistance(alpha, i));<br>        result = Math.max(result, res);<br>    }<br> <br>    private double getDistance(double alpha, int who) {<br>        double delta = Math.abs(alpha - alp[who]);<br>        if (delta &gt; Math.PI)<br>            delta = 2 * Math.PI - delta;<br>        if (delta &lt; inside[who]) {<br>            double dx = Math.cos(alpha) * r[0] + x[0] - x[who];<br>            double dy = Math.sin(alpha) * r[0] + y[0] - y[who];<br>            return Math.sqrt(dx * dx + dy * dy) - r[who];<br>        } else {<br>            return Math.sqrt(dist[who] * dist[who] - r[0] * (double) r[0]) - r[who] + r[0] * (delta - inside[who]);<br>        }<br>    }<br> <br>    private double norm(double x) {<br>        while (x &lt;= -Math.PI)<br>            x += 2 * Math.PI;<br>        while (x &gt; Math.PI)<br>            x -= 2 * Math.PI;<br>        return x;<br>    }<br>}<br></td>