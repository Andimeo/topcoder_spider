<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.List;<br>import java.util.ArrayList;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class Orienteering {<br>    static class Edge {<br>        Vertex dest;<br>        int[] checkpointDistMap;<br>        int count;<br>        int savedCount;<br> <br>        Edge(Vertex dest) {<br>            this.dest = dest;<br>        }<br>    }<br> <br>    static class Vertex {<br>        int generation = 0;<br>        int distance;<br>        int index;<br>        boolean checkpoint;<br>        List&lt;Edge&gt; adj = new ArrayList&lt;Edge&gt;();<br>    }<br> <br>    int totalVertices;<br> <br>  public double expectedLength(String[] field, int K) {<br>        int height = field.length;<br>        int width = field[0].length();<br>        Vertex[][] v = new Vertex[height][width];<br>        int totalCheckpoints = 0;<br>        totalVertices = 0;<br>        List&lt;Vertex&gt; all = new ArrayList&lt;Vertex&gt;();<br>        for (int r = 0; r &lt; height; ++r)<br>            for (int c = 0; c &lt; width; ++c)<br>                if (field[r].charAt(c) != '#') {<br>                    v[r][c] = new Vertex();<br>                    v[r][c].index = totalVertices;<br>                    v[r][c].checkpoint = field[r].charAt(c) == '*';<br>                    if (v[r][c].checkpoint) ++totalCheckpoints;<br>                    ++totalVertices;<br>                    all.add(v[r][c]);<br>                }<br>        for (int r = 0; r &lt; height; ++r)<br>            for (int c = 0; c &lt; width; ++c) if (v[r][c] != null) {<br>                if (r + 1 &lt; height &amp;&amp; v[r + 1][c] != null) {<br>                    v[r][c].adj.add(new Edge(v[r + 1][c]));<br>                    v[r + 1][c].adj.add(new Edge(v[r][c]));<br>                }<br>                if (c + 1 &lt; width &amp;&amp; v[r][c + 1] != null) {<br>                    v[r][c].adj.add(new Edge(v[r][c + 1]));<br>                    v[r][c + 1].adj.add(new Edge(v[r][c]));<br>                }<br>            }<br>        double[][] c = new double[totalCheckpoints + 1][totalCheckpoints + 1];<br>        c[0][0] = 1.0;<br>        for (int i = 1; i &lt;= totalCheckpoints; ++i) {<br>            c[i][0] = 1.0;<br>            for (int j = 1; j &lt;= totalCheckpoints; ++j) {<br>                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];<br>            }<br>        }<br>        double res = 2.0 * (totalVertices - 1);<br>        for (Vertex a : all)<br>            for (Edge e : a.adj) {<br>                int[] cntHereByDist = countCheckpoints(e.dest, a);<br>                int cntHere = 0;<br>                for (int x : cntHereByDist) cntHere += x;<br>                res -= 2.0 * c[cntHere][K] / c[totalCheckpoints][K];<br>                e.checkpointDistMap = cntHereByDist;<br>            }<br>        // Odd diameter.<br>        for (Vertex a : all)<br>            for (Edge ab : a.adj) {<br>                Vertex b = ab.dest;<br>                if (a.index &gt; b.index) continue;<br>                Edge ba = null;<br>                for (Edge ee : ab.dest.adj) if (ee.dest == a) ba = ee;<br>                int countAb = 0;<br>                int countBa = 0;<br>                for (int dist = 0; dist &lt; totalVertices; ++dist) {<br>                    int savedCountab = countAb;<br>                    int savedCountba = countBa;<br>                    countAb += ab.checkpointDistMap[dist];<br>                    countBa += ba.checkpointDistMap[dist];<br>                    double cur = (c[countAb + countBa][K] - c[savedCountab + countBa][K] - c[countAb + savedCountba][K] + c[savedCountab + savedCountba][K]) / c[totalCheckpoints][K];<br>                    res -= cur * (dist * 2 + 1);<br>                }<br>            }<br>        // Even diameter<br>        for (Vertex a : all) {<br>            for (Edge b : a.adj) {<br>                b.count = 0;<br>            }<br>            for (int dist = 0; dist &lt; totalVertices; ++dist) {<br>                int totalCount = 0;<br>                int totalSavedCount = 0;<br>                for (Edge b : a.adj) {<br>                    b.savedCount = b.count;<br>                    b.count += b.checkpointDistMap[dist];<br>                    totalCount += b.count;<br>                    totalSavedCount += b.savedCount;<br>                }<br>                double cur = 0;<br>                if (a.checkpoint) ++totalCount;<br>                cur += c[totalCount][K];<br>                if (a.checkpoint) ++totalSavedCount;<br>                for (Edge b : a.adj) {<br>                    cur -= c[totalSavedCount - b.savedCount + b.count][K];<br>                }<br>                cur += c[totalSavedCount][K] * (a.adj.size() - 1);<br>                cur /= c[totalCheckpoints][K];<br>                res -= cur * (2 * dist + 2);<br>            }<br>        }<br> <br>        return res;<br>    }<br> <br>    int lastGen = 0;<br> <br>    private int[] countCheckpoints(Vertex root, Vertex forbidden) {<br>        List&lt;Vertex&gt; queue = new ArrayList&lt;Vertex&gt;();<br>        int qt = 0;<br>        queue.add(root);<br>        int[] res = new int[totalVertices];<br>        ++lastGen;<br>        forbidden.generation = lastGen;<br>        root.generation = lastGen;<br>        root.distance = 0;<br>        while (qt &lt; queue.size()) {<br>            Vertex cur = queue.get(qt++);<br>            if (cur.checkpoint) ++res[cur.distance];<br>            for (Edge e : cur.adj) {<br>                Vertex a = e.dest;<br>                if (a.generation &lt; lastGen) {<br>                    a.generation = lastGen;<br>                    a.distance = cur.distance + 1;<br>                    queue.add(a);<br>                }<br>            }<br>        }<br>        return res;<br>    }<br>}<br></td>