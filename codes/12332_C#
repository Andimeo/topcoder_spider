<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br>public class CoinsGameEasy<br>{<br>  struct pos<br>    {<br>        public int[] coinX, coinY;<br>        public int depth;<br>        <br>        public pos(int[] _x, int[] _y, int _depth) {<br>            coinX = new int[2];<br>            coinY = new int[2];<br>            coinX[0] = _x[0];<br>            coinX[1] = _x[1];<br>            coinY[0] = _y[0];<br>            coinY[1] = _y[1];<br>            depth = _depth; <br>        }        <br>    };<br> <br>    struct move<br>    {<br>        public int x, y;<br>    };<br> <br>    public int minimalSteps(string[] board)<br>    {<br>        int i, j, ctr = 0, maxX, maxY;<br>        int[] coinX, coinY;<br>        coinX = new int[2];<br>        coinY = new int[2];<br> <br>        move[] movement = new move[4];<br>        movement[0].x = -1;<br>        movement[0].y = 0;<br>        movement[1].x = 1;<br>        movement[1].y = 0;<br>        movement[2].x = 0;<br>        movement[2].y = -1;<br>        movement[3].x = 0;<br>        movement[3].y = 1;<br> <br>        for (i = 0; i &lt; board.Length; i++)<br>        {<br>            for (j = 0; j &lt; board[i].Length; j++)<br>            {<br>                if (board[i][j] == 'o')<br>                {<br>                    coinX[ctr] = j;<br>                    coinY[ctr] = i;<br>                    ctr++;<br>                }<br>            }<br>        }<br>        maxX = board[0].Length;<br>        maxY = board.Length;<br> <br>        bool coin1Fall, coin2Fall, coin1Moved, coin2Moved;<br>        int[] newX, newY;<br>        newX = new int[2];<br>        newY = new int[2];<br>        Queue&lt;pos&gt; bfs = new Queue&lt;pos&gt;();<br>        pos curPos;<br>        bfs.Enqueue(new pos(coinX, coinY, 0));<br>        while (bfs.Count &gt; 0)<br>        {<br>            curPos = bfs.Dequeue();<br>            for (i = 0; i &lt; 4; i++)<br>            {<br>                coin1Fall = false;<br>                coin2Fall = false;<br>                coin1Moved = false;<br>                coin2Moved = false;<br> <br>                if (curPos.coinX[0] + movement[i].x &lt; 0 ||<br>                    curPos.coinX[0] + movement[i].x &gt;= maxX ||<br>                    curPos.coinY[0] + movement[i].y &lt; 0 ||<br>                    curPos.coinY[0] + movement[i].y &gt;= maxY)<br>                    coin1Fall = true;<br>                if (curPos.coinX[1] + movement[i].x &lt; 0 ||<br>                    curPos.coinX[1] + movement[i].x &gt;= maxX ||<br>                    curPos.coinY[1] + movement[i].y &lt; 0 ||<br>                    curPos.coinY[1] + movement[i].y &gt;= maxY)<br>                    coin2Fall = true;<br> <br>                if ((coin1Fall == true || coin2Fall == true) &amp;&amp; (coin1Fall != coin2Fall))<br>                    return curPos.depth + 1;<br> <br>                if (curPos.coinX[0] + movement[i].x &gt;= 0 &amp;&amp; curPos.coinX[0] + movement[i].x &lt; maxX &amp;&amp;<br>                    curPos.coinY[0] + movement[i].y &gt;= 0 &amp;&amp; curPos.coinY[0] + movement[i].y &lt; maxY &amp;&amp;<br>                    board[curPos.coinY[0] + movement[i].y][curPos.coinX[0] + movement[i].x] != '#')<br>                {<br>                    newX[0] = curPos.coinX[0] + movement[i].x;<br>                    newY[0] = curPos.coinY[0] + movement[i].y;<br>                    coin1Moved = true;<br>                }<br>                else<br>                {<br>                    newX[0] = curPos.coinX[0];<br>                    newY[0] = curPos.coinY[0];<br>                }<br> <br>                if (curPos.coinX[1] + movement[i].x &gt;= 0 &amp;&amp; curPos.coinX[1] + movement[i].x &lt; maxX &amp;&amp;<br>                    curPos.coinY[1] + movement[i].y &gt;= 0 &amp;&amp; curPos.coinY[1] + movement[i].y &lt; maxY &amp;&amp;<br>                    board[curPos.coinY[1] + movement[i].y][curPos.coinX[1] + movement[i].x] != '#')<br>                {<br>                    newX[1] = curPos.coinX[1] + movement[i].x;<br>                    newY[1] = curPos.coinY[1] + movement[i].y;<br>                    coin2Moved = true;<br>                }<br>                else<br>                {<br>                    newX[1] = curPos.coinX[1];<br>                    newY[1] = curPos.coinY[1];<br>                }<br>                if ((coin1Moved || coin2Moved ) &amp;&amp; !(newX[0] == newX[1] &amp;&amp; newY[0] == newY[1]) &amp;&amp; curPos.depth &lt; 9)<br>                {<br>                    bfs.Enqueue(new pos(newX, newY, curPos.depth + 1));<br>                }<br>            }<br>        }<br>        return -1;<br>    }<br> <br> <br> <br>}<br>//Powered by [KawigiEdit] 2.0!<br></td>