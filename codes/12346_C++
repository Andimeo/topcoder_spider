<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cassert&gt;<br>using namespace std;<br>typedef long long ll;<br><br>#define REP(i,n) for (int i=0; i&lt;(int)(n); ++i)<br>#define FOR(i,k,n) for (int i=(k); i&lt;(int)(n); ++i)<br>#define FOREQ(i,k,n) for (int i=(k); i&lt;=(int)(n); ++i)<br>#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)<br>#define SZ(v) (int)((v).size())<br>#define MEMSET(v,h) memset((v),(h),sizeof(v))<br><br><br>const ll MOD = 1000000007;<br>ll mul(ll x, ll y) {<br>  x%=MOD;<br>  y%=MOD;<br>  return (x*y)%MOD;<br>}<br>int N;<br><br>int acc(ll x, int pos) {<br>  return (x&gt;&gt;pos)&amp;1;<br>}<br>ll solve(ll a[], ll K) {<br>  sort(a, a+N);<br>  reverse(a, a+N);<br><br>  /*<br>  cout&lt;&lt;"!"&lt;&lt;K&lt;&lt;" ";<br>  REP(i, N) cout&lt;&lt;a[i]&lt;&lt;" ";<br>  cout&lt;&lt;endl;<br>  */<br><br>  if (a[0] == 0) {<br>    // oh<br>    if (K==0) return 1;<br>    else return 0;<br>  }<br><br>  int bpos = 0;<br>  for (; a[0] &gt;= (1LL&lt;&lt;(bpos+1)); bpos++);<br><br>  assert(a[0] &lt; (1LL&lt;&lt;(bpos+1)) &amp;&amp; a[0] &gt;= (1LL&lt;&lt;bpos));<br>  if (K &gt;= 1LL&lt;&lt;(bpos+1)) return 0LL;<br><br>  ll ret = 0;<br><br>  // when a[0][bpos] == 0;<br>  // K=hogehoge<br>  // -&gt;<br>  // K=ho******<br>  // we can choose freely<br>  // the only constraint is that K[bpos].<br><br>  ll x[N], y[N]; // +1, +0<br>  FOR(i, 1, N) {<br>    if (acc(a[i], bpos)) {<br>      x[i] = 1&lt;&lt;bpos;<br>      y[i] = a[i]+1-(1&lt;&lt;bpos);<br>      assert(y[i]&gt;=0);<br>    } else {<br>      x[i] = a[i]+1;<br>      y[i] = 0;<br>    }<br>  }<br>  ll dp[2][N];<br>  MEMSET(dp, 0);<br>  dp[0][0] = 1;<br><br>  FOR(i, 1, N) {<br>    dp[0][i] = (mul(dp[0][i-1],x[i]) + mul(dp[1][i-1],y[i])) % MOD;<br>    dp[1][i] = (mul(dp[0][i-1],y[i]) + mul(dp[1][i-1],x[i])) % MOD;<br><br>     //cout&lt;&lt;dp[0][i]&lt;&lt; " "&lt;&lt;dp[1][i]&lt;&lt;endl;<br>  }<br><br>  ret += dp[acc(K, bpos)][N-1];<br><br>  // when a[0][bpos] == 1;<br>  ll b[N];<br>  REP(i, N) b[i] = a[i];<br>  b[0] ^= 1LL&lt;&lt;bpos;<br>  K ^= 1LL&lt;&lt;bpos;<br><br>  ret += solve(b, K);<br>  // cout&lt;&lt;"#"&lt;&lt;ret&lt;&lt;endl;<br><br>  return ret % MOD;<br>}<br><br>/*<br>int main() {<br>  ll K;<br>  while (cin&gt;&gt;N&gt;&gt;K, N|K) {<br>    ll a[N];<br>    REP(i, N) cin &gt;&gt; a[i];<br>    if (N==2) {<br>      // int ho=0;<br>      // FOREQ(x, 0, a[0]) FOREQ(y, 0, a[1]) if ((x^y)==K) ho++;<br>      // cout&lt;&lt;"!"&lt;&lt;ho&lt;&lt;endl;<br>    }<br>    cout&lt;&lt;solve(a, K)&lt;&lt;endl;<br>  }<br>}<br>*/<br><br>class DefectiveAddition {<br>public:<br>  int count(vector &lt;int&gt; v, int K) {<br>    N=SZ(v);<br>    ll a[N];<br>    REP(i, N) a[i] = v[i];<br>    return solve(a, K);<br>  }<br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] : &lt;cafelier&amp;naoya_t&gt;-custom<br>// Powered by CodeProcessor<br></td>