<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;list&gt;<br>#include &lt;complex&gt;<br>#include &lt;queue&gt;<br>#include &lt;climits&gt;<br> <br>using namespace std;<br> <br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef long long ll;<br>typedef complex&lt;double&gt; pnt;<br>typedef pair&lt;int, int&gt; pii;<br> <br>#define RA(x) (x).begin(), (x).end()<br>#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)<br>#define SZ(x) ((int) (x).size())<br> <br> <br>class RockPaperScissors<br>{<br>public:<br>    double bestScore(vector &lt;int&gt; rockProb, vector &lt;int&gt; paperProb, vector &lt;int&gt; scissorsProb);<br>};<br> <br>static double dp[51][51][51], dp2[51][51][51], ex[51][51][51];<br> <br>double RockPaperScissors::bestScore(vector &lt;int&gt; P1, vector &lt;int&gt; P2, vector &lt;int&gt; P3)<br>{<br>    int N = P1.size();<br>    memset(dp, 0, sizeof(dp));<br>    dp[0][0][0] = 1.0;<br>    for (int i = 1; i &lt;= N; i++)<br>    {<br>        memset(dp2, 0, sizeof(dp2));<br>        dp2[0][0][0] = 1.0;<br>        for (int a = 0; a &lt;= i; a++)<br>            for (int b = 0; a + b &lt;= i; b++)<br>                for (int c = 0; a + b + c &lt;= i; c++)<br>                {<br>                    int r = a + b + c;<br>                    if (r == 0)<br>                        continue;<br>                    dp2[a][b][c] = dp[a][b][c] * (i - r) / i;<br>                    double scl = r / (i * 300.0);<br>                    if (a &gt; 0)<br>                        dp2[a][b][c] += dp[a - 1][b][c] * P1[i - 1] * scl;<br>                    if (b &gt; 0)<br>                        dp2[a][b][c] += dp[a][b - 1][c] * P2[i - 1] * scl;<br>                    if (c &gt; 0)<br>                        dp2[a][b][c] += dp[a][b][c - 1] * P3[i - 1] * scl;<br>                }<br>        memcpy(dp, dp2, sizeof(dp));<br>    }<br> <br>    memset(ex, 0, sizeof(ex));<br>    for (int a = N; a &gt;= 0; a--)<br>        for (int b = N - a; b &gt;= 0; b--)<br>            for (int c = N - a - b; c &gt;= 0; c--)<br>            {<br>                int r = a + b + c;<br>                if (r == N)<br>                    ex[a][b][c] = 0.0;<br>                else<br>                {<br>                    double v[3];<br>                    double f[3];<br>                    v[0] = dp[a + 1][b][c] * (a + 1) / (r + 1); f[0] = ex[a + 1][b][c];<br>                    v[1] = dp[a][b + 1][c] * (b + 1) / (r + 1); f[1] = ex[a][b + 1][c];<br>                    v[2] = dp[a][b][c + 1] * (c + 1) / (r + 1); f[2] = ex[a][b][c + 1];<br>                    double best = 0.0;<br>                    for (int s = 0; s &lt; 3; s++)<br>                        if (v[s] == 0)<br>                            f[s] = 0.0; // avoid NaN trouble<br>                    for (int s = 0; s &lt; 3; s++)<br>                    {<br>                        double e = v[0] * (f[0] + 1.0) + v[1] * f[1] + v[2] * (f[2] + 3.0);<br>                        best = max(best, e);<br>                        rotate(v, v + 1, v + 3);<br>                        rotate(f, f + 1, f + 3);<br>                    }<br>                    best /= (v[0] + v[1] + v[2]);<br>                    ex[a][b][c] = best;<br>                }<br>            }<br>    return ex[0][0][0];<br>}<br> <br> <br>// Powered by FileEdit<br></td>