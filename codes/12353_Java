<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class UnknownTree {<br>    static final long MODULO = (long) (1e9 + 9);<br> <br>    public int getCount(int[] distancesA, int[] distancesB, int[] distancesC) {<br>        int n = distancesA.length;<br>        int[][] d = new int[3][n + 3];<br>        System.arraycopy(distancesA, 0, d[0], 0, n);<br>        System.arraycopy(distancesB, 0, d[1], 0, n);<br>        System.arraycopy(distancesC, 0, d[2], 0, n);<br>        for (int i = 0; i &lt; 3; ++i)<br>            for (int j = 0; j &lt; 3; ++j)<br>                if (i != j) {<br>                    d[i][n + j] = (int) 1e9;<br>                    for (int k = 0; k &lt; n; ++k)<br>                        d[i][n + j] = Math.min(d[i][n + j], d[i][k] + d[j][k]);<br>                }<br>        int[][] have = new int[3][3];<br>        long res = 0;<br>        int[][][] seenD = new int[10][3][];<br>        int nseen = 0;<br>        for (have[0][1] = 0; have[0][1] &lt; 2; ++have[0][1])<br>            for (have[1][2] = 0; have[1][2] &lt; 2; ++have[1][2])<br>                outer: for (have[0][2] = 0; have[0][2] &lt; 2; ++have[0][2]) {<br>                    int s = 0;<br>                    for (int i = 0; i &lt; 3; ++i)<br>                        for (int j = 0; j &lt; i; ++j) {<br>                            have[i][j] = have[j][i];<br>                            s += have[i][j];<br>                        }<br>                    if (s &gt;= 3) continue;<br>                    int[][] nd = new int[3][];<br>                    for (int i = 0; i &lt; 3; ++i) nd[i] = d[i].clone();<br>                    for (int i = 0; i &lt; 3; ++i)<br>                        for (int j = 0; j &lt; 3; ++j)<br>                            if (have[i][j] &gt; 0) {<br>                                nd[i][n + j] = Math.abs(d[i][0] - d[j][0]);<br>                            }<br>                    for (int i = 0; i &lt; 3; ++i)<br>                        for (int j = 0; j &lt; 3; ++j)<br>                            for (int k = 0; k &lt; 3; ++k)<br>                                if (have[i][j] &gt; 0 &amp;&amp; have[j][k] &gt; 0 &amp;&amp; i != k)<br>                                    nd[i][n + k] = nd[i][n + j] + nd[j][n + k];<br>                    for (int a = 0; a &lt; nseen; ++a) {<br>                        boolean allSame = true;<br>                        for (int i = 0; i &lt; 3; ++i)<br>                            for (int j = 0; j &lt; nd[i].length; ++j)<br>                                if (nd[i][j] != seenD[a][i][j])<br>                                    allSame = false;<br>                        if (allSame) continue outer;<br>                    }<br>                    ++nseen;<br>                    for (int i = 0; i &lt; 3; ++i) {<br>                        seenD[nseen - 1][i] = nd[i].clone();<br>                    }<br>                    int cur = getCountKnowAll(nd[0], nd[1], nd[2]);<br>                    res = (res + cur) % MODULO;<br>                }<br>        return (int) res;<br>    }<br> <br>    public int getCountKnowAll(int[] distancesA, int[] distancesB, int[] distancesC) {<br>        int n = distancesA.length;<br>        int[] toCore = new int[n];<br>        Arrays.fill(toCore, -1);<br>        for (int i = 0; i &lt; n; ++i) {<br>            toCore[i] = -1;<br>            for (int j = 0; j &lt; n; ++j) {<br>                if (distancesA[i] - distancesA[j] == distancesB[i] - distancesB[j] &amp;&amp; distancesA[i] - distancesA[j] == distancesC[i] - distancesC[j]) {<br>                    if (toCore[i] &lt; 0 || distancesA[j] &lt; distancesA[toCore[i]])<br>                        toCore[i] = j;<br>                }<br>            }<br>        }<br>        return (int) (countCore(distancesA, distancesB, distancesC, n, toCore) * countBranches(distancesA, distancesB, distancesC, n, toCore) % MODULO);<br>  }<br> <br>    private long countCore(int[] distancesA, int[] distancesB, int[] distancesC, int n, int[] toCore) {<br>        long res = 0;<br>        int[][] d = new int[][]{distancesA, distancesB, distancesC};<br>        outer: for (int root = 0; root &lt; n; ++root) {<br>            if (toCore[root] != root) continue;<br>            int[] which = new int[n];<br>            for (int i = 0; i &lt; n; ++i) {<br>                if (toCore[i] != i) continue;<br>                if (i == root) {<br>                    which[i] = -1;<br>                } else {<br>                    which[i] = -1;<br>                    for (int j = 0; j &lt; 3; ++j)<br>                        if (d[j][i] &lt; d[j][root]) {<br>                            if (which[i] &gt;= 0)<br>                                continue outer;<br>                            which[i] = j;<br>                        }<br>                    if (which[i] &lt; 0) continue outer;<br>                }<br>            }<br>            long[] tmp = new long[n];<br>            for (int who = 0; who &lt; 3; ++who) {<br>                int cnt = 0;<br>                for (int i = 0; i &lt; n; ++i) {<br>                    if (toCore[i] != i) continue;<br>                    if (which[i] != who) continue;<br>                    tmp[cnt++] = d[who][i] * (long) n + i;<br>                }<br>                Arrays.sort(tmp, 0, cnt);<br>                int pd = -1;<br>                for (int i = 0; i &lt; cnt; ++i) {<br>                    int at = (int) (tmp[i] % n);<br>                    int cd = (int) (tmp[i] / n);<br>                    if (cd &lt;= pd) continue outer;<br>                    pd = cd;<br>                    for (int j = 0; j &lt; 3; ++j) if (j != who) {<br>                        if (d[j][at] != d[j][root] + d[who][root] - d[who][at]) continue outer;<br>                    }<br>                }<br>            }<br>            res = (res + 1) % MODULO;<br>        }<br>        return res;<br>    }<br> <br>    private long countBranches(int[] distancesA, int[] distancesB, int[] distancesC, int n, int[] toCore) {<br>        long res = 1;<br>        for (int i = 0; i &lt; n; ++i) {<br>            if (toCore[i] == i)<br>                res = res * countBranch(distancesA, distancesB, distancesC, n, toCore, i) % MODULO;<br>        }<br>        return res;<br>    }<br> <br>    private long countBranch(int[] distancesA, int[] distancesB, int[] distancesC, int n, int[] toCore, int root) {<br>        int cnt = 0;<br>        for (int i = 0; i &lt; n; ++i)<br>            if (toCore[i] == root)<br>                ++cnt;<br>        int[] dst = new int[cnt];<br>        cnt = 0;<br>        for (int i = 0; i &lt; n; ++i)<br>            if (toCore[i] == root)<br>                dst[cnt++] = distancesA[i];<br>        Arrays.sort(dst);<br>        long res = 1;<br>        for (int i = 1; i &lt; cnt; ++i) {<br>            int by = 0;<br>            for (int j = 0; j &lt; i; ++j)<br>                if (dst[j] &lt; dst[i]) ++by;<br>            res = res * by % MODULO;<br>        }<br>        return res;<br>    }<br>}<br></td>