<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Text;<br>using System.Linq;<br>using System.Collections;<br>using System.Diagnostics;<br>using System.Collections.Generic;<br>public class SpecialCells<br>{<br>    public int guess(int[] x, int[] y)<br>    {<br>        var nx = x.Distinct();<br>        var ny = y.Distinct();<br>        int v = nx.Count() + ny.Count() + 2;<br>        int s = v - 2;<br>        int t = v - 1;<br>        MinCostFlow mcf = new MinCostFlow(v);<br>        for (int i = 0; i &lt; nx.Count(); i++)<br>        {<br>            mcf.AddEdge(s, i, x.Where(p =&gt; p == nx.ElementAt(i)).Count(), 0);<br>        }//for i<br>        for (int i = 0; i &lt; ny.Count(); i++)<br>        {<br>            mcf.AddEdge(i + nx.Count(), t, y.Where(p =&gt; p == ny.ElementAt(i)).Count(), 0);<br>        }//for i<br>        for (int i = 0; i &lt; nx.Count(); i++)<br>        {<br>            for (int j = 0; j &lt; ny.Count(); j++)<br>            {<br>                int xx = nx.ElementAt(i);<br>                int yy = ny.ElementAt(j);<br>                bool found = false;<br>                for (int k = 0; k &lt; x.Length; k++)<br>                {<br>                    if (x[k] == xx &amp;&amp; y[k] == yy)<br>                    {<br>                        found = true;<br>                    }//if<br>                }//for k<br>                if (found)<br>                {<br>                    mcf.AddEdge(i, nx.Count() + j, 1, 1);<br>                }//if<br>                else<br>                {<br>                    mcf.AddEdge(i, nx.Count() + j, 1, 0);<br>                }//else<br>            }//for j<br>        }//for i<br>        int res = mcf.CalcMinCostFlow(s, t, x.Length, false);<br>        return res;<br>    }<br><br><br>    /// &lt;summary&gt;<br>    /// varified by SRM371 DIV1 Medium ChessMatchup([\u65298][\u37096][\u12464][\u12521][\u12501][\u12387][\u12413][\u12356][\u65289]<br>    /// INF [\u12395][\u27880][\u24847]<br>    /// 0 : [\u38914][\u28857][\u25968][\u12434][\u25351][\u23450][\u12375][\u12390][\u21021][\u26399][\u21270]<br>    /// 1 : [\u36794][\u12434][\u21152][\u12360][\u12427]<br>    /// 2 : [\u12477][\u12540][\u12473][\u12289][\u12471][\u12531][\u12463][\u12434][\u25351][\u23450][\u12375][\u12390][\u26368][\u23567][\u36027][\u29992][\u27969][\u12434][\u35336][\u31639]<br>    /// PrimalDual [\u12395][\u12424][\u12427][\u26368][\u23567][\u36027][\u29992][\u27969]<br>    /// F : [\u27969][\u12375][\u12383][\u12356][\u27969][\u37327][\u12392][\u12375][\u12390][\u12289]O( F E log V )<br>    /// &lt;/summary&gt;<br>    public class MinCostFlow<br>    {<br>        const int INF = (int)(int.MaxValue / 2.1);  //careful<br>        int V;  //[\u38914][\u28857][\u25968]<br>        List&lt;Edge&gt;[] G;<br>        int[] potential;<br>        int[] dist;<br>        int[] prevVertex;<br>        int[] prevEdge;<br><br>        /// &lt;summary&gt;<br>        /// [\u38914][\u28857][\u25968][\u12434][\u27770][\u12417][\u12390][\u21021][\u26399][\u21270]<br>        /// O( V )<br>        /// &lt;/summary&gt;<br>        /// &lt;param name="V"&gt;[\u38914][\u28857][\u25968]&lt;/param&gt;<br>        public MinCostFlow(int V)<br>        {<br>            this.V = V;<br>            potential = new int[V];<br>            dist = new int[V];<br>            prevVertex = new int[V];<br>            prevEdge = new int[V];<br>            G = new List&lt;Edge&gt;[V];<br>            for (int i = 0; i &lt; V; i++)<br>                G[i] = new List&lt;Edge&gt;();<br>        }//Constractor        <br><br>        /// &lt;summary&gt;<br>        /// [\u36794][\u12434][\u12354][\u12425][\u12431][\u12377][\u12463][\u12521][\u12473]<br>        /// &lt;/summary&gt;<br>        public class Edge<br>        {<br>            public int to;<br>            public int capacity;<br>            public int cost;<br>            public int reverse;<br>            public Edge(int to, int capacity, int cost, int reverse)<br>            {<br>                this.to = to;<br>                this.capacity = capacity;<br>                this.cost = cost;<br>                this.reverse = reverse;<br>            }//Constractor<br>        }//Edge<br><br>        /// &lt;summary&gt;<br>        /// [\u36794][\u12434][\u21152][\u12360][\u12427]<br>        /// O( 1 )<br>        /// &lt;/summary&gt;<br>        /// &lt;param name="from"&gt;[\u20837][\u21147][\u28857]&lt;/param&gt;<br>        /// &lt;param name="to"&gt;[\u20986][\u21147][\u28857]&lt;/param&gt;<br>        /// &lt;param name="capacity"&gt;[\u23481][\u37327]&lt;/param&gt;<br>        /// &lt;param name="cost"&gt;[\u36027][\u29992]&lt;/param&gt;<br>        public void AddEdge(int from, int to, int capacity, int cost)<br>        {<br>            G[from].Add(new Edge(to, capacity, cost, G[to].Count));<br>            G[to].Add(new Edge(from, 0, -cost, G[from].Count - 1));<br>        }//AddEdge<br><br>        /// &lt;summary&gt;<br>        /// [\u27969][\u37327] f [\u12398][\u26368][\u23567][\u36027][\u29992][\u27969][\u12434][\u27714][\u12417][\u12427]<br>        /// [\u23384][\u22312][\u12375][\u12394][\u12369][\u12428][\u12400][\u12289]int.MinValue [\u12434][\u36820][\u12377]<br>        /// O( F E log V )<br>        /// &lt;/summary&gt;<br>        /// &lt;param name="s"&gt;[\u12477][\u12540][\u12473]&lt;/param&gt;<br>        /// &lt;param name="t"&gt;[\u12471][\u12531][\u12463]&lt;/param&gt;<br>        /// &lt;param name="f"&gt;[\u27969][\u37327]&lt;/param&gt;<br>        /// &lt;param name="negativeEdge"&gt;true : [\u36000][\u12398][\u36794][\u12364][\u23384][\u22312][\u12377][\u12427][\u12392][\u12365]&lt;/param&gt;<br>        /// &lt;returns&gt;[\u26368][\u23567][\u36027][\u29992]&lt;/returns&gt;<br>        public int CalcMinCostFlow(int s, int t, int f, bool negativeEdge)<br>        {<br>            int res = 0;<br>            if (negativeEdge)<br>            {<br>                BellmanFord(s);<br>                Renew(s, t, ref f, ref res);<br>            }//if<br><br>            while (f &gt; 0)<br>            {<br>                Dijkstra(s);<br>                if (dist[t] == INF)<br>                    return int.MinValue;<br>                Renew(s, t, ref f, ref res);<br>            }//while f<br>            return res;<br>        }//MinCostFlow<br><br>        /// &lt;summary&gt;<br>        /// [\u12464][\u12521][\u12501][\u12434][\u26356][\u26032][\u12377][\u12427]<br>        /// O( Math.Min( V , E) )<br>        /// &lt;/summary&gt;<br>        /// &lt;param name="s"&gt;[\u12477][\u12540][\u12473]&lt;/param&gt;<br>        /// &lt;param name="t"&gt;[\u12471][\u12531][\u12463]&lt;/param&gt;<br>        /// &lt;param name="f"&gt;[\u27969][\u37327]&lt;/param&gt;<br>        /// &lt;param name="res"&gt;[\u36027][\u29992]&lt;/param&gt;<br>        private void Renew(int s, int t, ref int f, ref int res)<br>        {<br>            for (int i = 0; i &lt; V; i++)<br>                potential[i] += dist[i];<br><br>            int d = f;<br>            for (int v = t; v != s; v = prevVertex[v])<br>                d = Math.Min(d, G[prevVertex[v]][prevEdge[v]].capacity);<br><br>            f -= d;<br>            res += d * potential[t];<br><br>            for (int v = t; v != s; v = prevVertex[v])<br>            {<br>                Edge e = G[prevVertex[v]][prevEdge[v]];<br>                e.capacity -= d;<br>                G[v][e.reverse].capacity += d;<br>            }//for v<br>        }//Renew<br><br>        /// &lt;summary&gt;<br>        /// Dijkstra [\u12450][\u12523][\u12468][\u12522][\u12474][\u12512][\u12391]([\u36027][\u29992][\u12398][\u24847][\u21619][\u12391][\u12398][\u65289][\u26368][\u30701][\u32076][\u36335][\u12434][\u27714][\u12417][\u12427]<br>        /// O( E log V )<br>        /// &lt;/summary&gt;<br>        /// &lt;param name="s"&gt;[\u12477][\u12540][\u12473]&lt;/param&gt;<br>        private void Dijkstra(int s)<br>        {<br>            PriorityQueueMin&lt;Pair&gt; que = new PriorityQueueMin&lt;Pair&gt;();<br>            for (int i = 0; i &lt; V; i++)<br>                dist[i] = INF;<br>            dist[s] = 0;<br>            que.Enqueue(new Pair(0, s));<br>            while (que.Count != 0)<br>            {<br>                Pair deq = que.Dequeue();<br>                int v = deq.second;<br>                if (dist[v] &lt; deq.first)<br>                    continue;<br>                for (int i = 0; i &lt; G[v].Count; i++)<br>                {<br>                    Edge e = G[v][i];<br>                    if (e.capacity &gt; 0 &amp;&amp; dist[e.to] &gt; dist[v] + e.cost + potential[v] - potential[e.to])<br>                    {<br>                        dist[e.to] = dist[v] + e.cost + potential[v] - potential[e.to];<br>                        prevVertex[e.to] = v;<br>                        prevEdge[e.to] = i;<br>                        que.Enqueue(new Pair(dist[e.to], e.to));<br>                    }//if<br>                }//for i<br>            }//while que<br>        }//Dijkstra<br><br>        /// &lt;summary&gt;<br>        /// BellmanFord [\u12450][\u12523][\u12468][\u12522][\u12474][\u12512][\u12391]([\u36027][\u29992][\u12398][\u24847][\u21619][\u12391][\u12398][\u65289][\u26368][\u30701][\u32076][\u36335][\u12434][\u27714][\u12417][\u12427]<br>        /// O( E V )<br>        /// &lt;/summary&gt;<br>        /// &lt;param name="s"&gt;[\u12477][\u12540][\u12473]&lt;/param&gt;<br>        private void BellmanFord(int s)<br>        {<br>            for (int i = 0; i &lt; V; i++)<br>                dist[i] = INF;<br>            dist[s] = 0;<br>            bool update = true;<br>            while (update)<br>            {<br>                update = false;<br>                for (int v = 0; v &lt; V; v++)<br>                {<br>                    if (dist[v] == INF)<br>                        continue;<br>                    for (int i = 0; i &lt; G[v].Count; i++)<br>                    {<br>                        Edge e = G[v][i];<br>                        if (e.capacity &gt; 0 &amp;&amp; dist[e.to] &gt; dist[v] + e.cost)<br>                        {<br>                            dist[e.to] = dist[v] + e.cost;<br>                            prevVertex[e.to] = v;<br>                            prevEdge[e.to] = i;<br>                            update = true;<br>                        }//if<br>                    }//for i<br>                }//for v<br>            }//while update<br>        }//BellmanFord<br><br><br>        /// &lt;summary&gt;<br>        /// varified by SRM 337 DIV1 Medium BuildingAdvertise<br>        /// varified by SRM 529 DIV1 easy KingSort<br>        /// varified by SRM404 DIV1 Medium KSubstring<br>        /// Pair [\u12463][\u12521][\u12473]<br>        /// &lt;/summary&gt;<br>        /// &lt;typeparam name="int"&gt;[\u65296][\u30058][\u30446][\u12398][\u35201][\u32032][\u12398][\u22411]&lt;/typeparam&gt;<br>        /// &lt;typeparam name="int"&gt;[\u65297][\u30058][\u30446][\u12398][\u35201][\u32032][\u12398][\u22411]&lt;/typeparam&gt;<br>        public struct Pair : IComparable&lt;Pair&gt;<br>        {<br>            public int first;  //[\u26368][\u21021][\u12395][\u27604][\u36611][\u12373][\u12428][\u12427][\u35201][\u32032]<br>            public int second;   //[\u27425][\u12395][\u27604][\u36611][\u12373][\u12428][\u12427][\u35201][\u32032]<br><br>            /// &lt;summary&gt;<br>            /// [\u12467][\u12531][\u12473][\u12488][\u12521][\u12463][\u12479][\u12540]<br>            /// &lt;/summary&gt;<br>            /// &lt;param name="int"&gt;&lt;/param&gt;<br>            /// &lt;param name="int"&gt;&lt;/param&gt;<br>            public Pair(int first, int second)<br>            {<br>                this.first = first;<br>                this.second = second;<br>            }//Constractor<br><br>            /// &lt;summary&gt;<br>            /// [\u65296][\u30058][\u30446][\u12398][\u35201][\u32032][\u12434][\u27604][\u36611][\u12375][\u12390][\u12289][\u27425][\u12395][\u65297][\u30058][\u30446][\u12398][\u35201][\u32032][\u12434][\u27604][\u36611][\u12377][\u12427]<br>            /// &lt;/summary&gt;<br>            /// &lt;param name="other"&gt;[\u27604][\u36611][\u12377][\u12427][\u12463][\u12521][\u12473]&lt;/param&gt;<br>            /// &lt;returns&gt;[\u27604][\u36611][\u12375][\u12383][\u24046]&lt;/returns&gt;<br>            public int CompareTo(Pair other)<br>            {<br>                int res = this.first.CompareTo(other.first);<br>                if (res != 0)<br>                    return res;<br>                return this.second.CompareTo(other.second);<br>            }//CompareTo<br><br>        }//Pair<br><br>        /// &lt;summary&gt;<br>        /// varified by SRM 461 DIV1 Medium BuildingCities<br>        /// [\u20516][\u12398][\u23567][\u12373][\u12356][\u12418][\u12398][\u12363][\u12425][\u21462][\u12426][\u20986][\u12377][\u12498][\u12540][\u12503][\u12290]<br>        /// &lt;/summary&gt;<br>        /// &lt;typeparam name="T"&gt;[\u38918][\u24207][\u12398][\u23450][\u32681][\u12373][\u12428][\u12390][\u12356][\u12427][\u12463][\u12521][\u12473]&lt;/typeparam&gt;<br>        public class PriorityQueueMin&lt;T&gt; where T : IComparable&lt;T&gt;<br>        {<br>            public List&lt;T&gt; priorityQueue;<br>            int count;<br><br>            /// &lt;summary&gt;<br>            /// [\u21021][\u26399][\u21270]<br>            /// &lt;/summary&gt;<br>            public PriorityQueueMin()<br>            {<br>                priorityQueue = new List&lt;T&gt;();<br>                count = 0;<br>            }//Constractor<br><br>            /// &lt;summary&gt;<br>            ///  [\u27425][\u12398][\u20516][\u12398][\u36861][\u21152][\u12290]<br>            ///  O ( log n )<br>            /// &lt;/summary&gt;<br>            /// &lt;param name="enqueueKey"&gt;[\u12461][\u12517][\u12540][\u12395][\u21152][\u12360][\u12427]&lt;/param&gt;<br>            public void Enqueue(T enqueueKey)<br>            {<br>                if (count == priorityQueue.Count) //count [\u12392][\u35201][\u32032][\u25968][\u12364][\u31561][\u12375][\u12356]<br>                    priorityQueue.Add(enqueueKey);<br>                int child = count++;<br>                for (; child != 0; )   //[\u19978][\u12387][\u12390][\u12356][\u12367]<br>                {<br>                    int parent = child - 1 &gt;&gt; 1;<br>                    if (enqueueKey.CompareTo(priorityQueue[parent]) &gt;= 0)<br>                        break;<br>                    priorityQueue[child] = priorityQueue[parent];<br>                    child = parent;<br>                }<br>                priorityQueue[child] = enqueueKey;<br>            }//Enqueue<br><br>            /// &lt;summary&gt;<br>            /// [\u26368][\u23567][\u20516][\u12398][\u21462][\u12426][\u20986][\u12375][\u12290]<br>            /// O(log n)<br>            /// &lt;/summary&gt;<br>            public T Dequeue()<br>            {<br>                if (count == 0)<br>                    throw new IndexOutOfRangeException();<br>                T dequeueKey = priorityQueue[0];<br>                T parentKey = priorityQueue[--count];<br><br>                int parent = 0;<br>                for (int child = 1; child &lt; count; )  //[\u19979][\u12364][\u12387][\u12390][\u12356][\u12367]<br>                {<br>                    if ((child != count - 1) &amp;&amp; (priorityQueue[child].CompareTo(priorityQueue[child + 1]) &gt; 0)) //[\u24038][\u21491][\u12393][\u12385][\u12425][\u12398][\u23376][\u12398][\u26041][\u12364][\u23567][\u12373][\u12356][\u12363]<br>                        child++;<br>                    if (parentKey.CompareTo(priorityQueue[child]) &lt;= 0)<br>                        break;<br>                    priorityQueue[parent] = priorityQueue[child]; //[\u35242][\u12392][\u23376][\u12398][\u20837][\u12428][\u26367][\u12360]<br>                    parent = child;  //[\u23376][\u12398][\u26356][\u26032]<br>                    child = parent &lt;&lt; 1 | 1;   //[\u35242][\u12398][\u26356][\u26032]<br>                }//for child<br>                priorityQueue[parent] = parentKey;<br>                return dequeueKey;<br>            }//Dequeue<br><br>            /// &lt;summary&gt;<br>            /// [\u35201][\u32032][\u25968][\u12434][\u36820][\u12377]<br>            /// &lt;/summary&gt;<br>            public int Count<br>            {<br>                get { return count; }<br>            }//Count<br><br>        }//PriorityQueueMin<br><br>    }//MinCostFlow<br><br>}//SpecialCells<br><br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] modified for C# by onigiri[25-Feb-2013]<br>// Powered by CodeProcessor<br></td>