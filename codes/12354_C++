<td class="problemText" colspan="8" valign="middle" align="left">
            //  SRM 612 (B)<br><br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;utility&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;complex&gt;<br><br>using namespace std;<br><br>typedef unsigned uint;<br>typedef long long Int;<br>typedef vector&lt;int&gt; vint;<br>typedef pair&lt;int,int&gt; pint;<br>#define mp make_pair<br><br>template&lt;class T&gt; void pv(T a, T b) { for (T i = a; i != b; ++i) cout &lt;&lt; *i &lt;&lt; " "; cout &lt;&lt; endl; }<br>template&lt;class T&gt; void chmin(T &amp;t, const T &amp;f) { if (t &gt; f) t = f; }<br>template&lt;class T&gt; void chmax(T &amp;t, const T &amp;f) { if (t &lt; f) t = f; }<br><br>namespace MCF {<br>  #define MAXN 1000010<br>  #define MAXM 1000010<br>  #define wint int<br>  #define cint int<br>  const wint wEPS = 0;<br>  const wint wINF = 1001001001;<br>  const cint cEPS = 0;<br>  const cint cINF = 1001001001;<br>  int n, m, ptr[MAXN], next[MAXM], zu[MAXM];<br>  wint capa[MAXM], tof;<br>  cint cost[MAXM], toc, d[MAXN], pot[MAXN];<br>  int vis[MAXN], pree[MAXN];<br>  void init(int _n) {<br>    n = _n; m = 0; memset(ptr, ~0, n &lt;&lt; 2);<br>  }<br>  void ae(int u, int v, wint w, cint c) {<br>    next[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;<br>    next[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;<br>  }<br>  bool solve(int src, int ink, wint flo = wINF) {<br>    wint f;<br>    cint c, cc;<br>    int i, u, v;<br>    memset(pot, 0, n * sizeof(cint));<br>  //*<br>    for (bool cont = 1; cont; ) {<br>      cont = 0;<br>      for (u = 0; u &lt; n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] &gt; wEPS) {<br>        if (pot[zu[i]] &gt; pot[u] + cost[i] + cEPS) {<br>          pot[zu[i]] = pot[u] + cost[i]; cont = 1;<br>        }<br>      }<br>    }<br>  //*/<br>    for (toc = 0, tof = 0; tof + wEPS &lt; flo; ) {<br>      typedef pair&lt;cint,int&gt; node;<br>      priority_queue&lt; node,vector&lt;node&gt;,greater&lt;node&gt; &gt; q;<br>      for (u = 0; u &lt; n; ++u) { d[u] = cINF; vis[u] = 0; }<br>      for (q.push(mp(d[src] = 0, src)); !q.empty(); ) {<br>        c = q.top().first; u = q.top().second; q.pop();<br>        if (vis[u]++) continue;<br>        for (i = ptr[u]; ~i; i = next[i]) if (capa[i] &gt; wEPS) {<br>          cc = c + cost[i] + pot[u] - pot[v = zu[i]];<br>          if (d[v] &gt; cc) { q.push(mp(d[v] = cc, v)); pree[v] = i; }<br>        }<br>      }<br>      if (!vis[ink]) return 0;<br>      f = flo - tof;<br>      for (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; chmin(f, capa[i]); }<br>      for (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }<br>      tof += f;<br>      toc += f * (d[ink] - pot[src] + pot[ink]);<br>      for (u = 0; u &lt; n; ++u) pot[u] += d[u];<br>    }<br>    return 1;<br>  }<br>}<br><br>int xsLen, ysLen;<br>int xs[110], ys[110];<br><br>int X[110], Y[110];<br>int cntX[110], cntY[110], cnt[110][110];<br><br>struct SpecialCells {<br>  <br>  int guess(vector &lt;int&gt; x, vector &lt;int&gt; y) {<br>    int N = x.size();<br>    int i;<br>    int u, v;<br>    <br>    for (i = 0; i &lt; N; ++i) {<br>      xs[i] = x[i];<br>      ys[i] = y[i];<br>    }<br>    sort(xs, xs + N);<br>    sort(ys, ys + N);<br>    xsLen = unique(xs, xs + N) - xs;<br>    ysLen = unique(ys, ys + N) - ys;<br>    for (i = 0; i &lt; N; ++i) {<br>      X[i] = lower_bound(xs, xs + xsLen, x[i]) - xs;<br>      Y[i] = lower_bound(ys, ys + ysLen, y[i]) - ys;<br>    }<br>    <br>    memset(cntX, 0, sizeof(cntX));<br>    memset(cntY, 0, sizeof(cntY));<br>    memset(cnt, 0, sizeof(cnt));<br>    for (i = 0; i &lt; N; ++i) {<br>      ++cntX[X[i]];<br>      ++cntY[Y[i]];<br>      ++cnt[X[i]][Y[i]];<br>    }<br>    <br>    MCF::init(2 + xsLen + ysLen);<br>    for (u = 0; u &lt; xsLen; ++u) {<br>      MCF::ae(0, 2 + u, cntX[u], 0);<br>    }<br>    for (v = 0; v &lt; ysLen; ++v) {<br>      MCF::ae(2 + xsLen + v, 1, cntY[v], 0);<br>    }<br>    for (u = 0; u &lt; xsLen; ++u) for (v = 0; v &lt; ysLen; ++v) {<br>      MCF::ae(2 + u, 2 + xsLen + v, 1, cnt[u][v]);<br>    }<br>    bool res = MCF::solve(0, 1, N);<br>    cerr &lt;&lt; res &lt;&lt; endl;<br>    return MCF::toc;<br>    <br>  }<br>  <br>};<br></td>