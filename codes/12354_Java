<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class SpecialCells {<br>    public int guess(int[] x, int[] y) {<br>        int[] ux = norm(x);<br>        int[] uy = norm(y);<br>        int n = 2 + ux.length + uy.length;<br>        int s = n - 2;<br>        int t = n - 1;<br>        int[][] cap = new int[n][n];<br>        for (int a = 0; a &lt; ux.length; ++a)<br>            for (int b = 0; b &lt; uy.length; ++b)<br>                ++cap[a][ux.length + b];<br>        int[][] cost = new int[n][n];<br>        for (int i = 0; i &lt; x.length; ++i) {<br>            int ix = Arrays.binarySearch(ux, x[i]);<br>            int iy = Arrays.binarySearch(uy, y[i]);<br>            ++cap[s][ix];<br>            ++cap[ux.length + iy][t];<br>            ++cost[ix][ux.length + iy];<br>            --cost[ux.length + iy][ix];<br>        }<br>        return minCostMaxFlow(n, s, t, cap, cost);<br>    }<br>    <br>    static final int INF = (int) 1e9;<br> <br>    private int minCostMaxFlow(int n, int s, int t, int[][] cap, int[][] cost) {<br>        int[] pri = new int[n];<br>        int res = 0;<br>        while (true) {<br>            int[] dist = new int[n];<br>            int[] prev = new int[n];<br>            Arrays.fill(prev, -1);<br>            Arrays.fill(dist, INF);<br>            dist[s] = 0;<br>            boolean[] mark = new boolean[n];<br>            int mxd = 0;<br>            while (true) {<br>                int bi = -1;<br>                for (int i = 0; i &lt; n; ++i) if (dist[i] &lt; INF / 2 &amp;&amp; !mark[i]) {<br>                    if (bi &lt; 0 || dist[i] &lt; dist[bi])<br>                        bi = i;<br>                }<br>                if (bi &lt; 0) break;<br>                mark[bi] = true;<br>                mxd = dist[bi];<br>                for (int i = 0; i &lt; n; ++i) if (!mark[i] &amp;&amp; cap[bi][i] &gt; 0) {<br>                    int edge = pri[bi] - pri[i] + cost[bi][i];<br>                    if (dist[i] &gt; dist[bi] + edge) {<br>                        dist[i] = dist[bi] + edge;<br>                        prev[i] = bi;<br>                    }<br>                }<br>            }<br>            if (!mark[t]) break;<br>            res += dist[t] - pri[s] + pri[t];<br>            int at = t;<br>            while (at != s) {<br>                int pat = prev[at];<br>                --cap[pat][at];<br>                ++cap[at][pat];<br>                at = pat;<br>            }<br>            for (int i = 0; i &lt; n; ++i) {<br>                if (dist[i] &gt; INF / 2) pri[i] += mxd; else pri[i] += dist[i];<br>            }<br>        }<br>        return res;<br>    }<br> <br>    private int[] norm(int[] a) {<br>        a = a.clone();<br>        Arrays.sort(a);<br>        int cnt = 0;<br>        for (int i = 0; i &lt; a.length; ++i)<br>            if (i == 0 || a[i] &gt; a[i - 1]) {<br>                a[cnt++] = a[i];<br>            }<br>        return Arrays.copyOf(a, cnt);<br>    }<br>}<br></td>