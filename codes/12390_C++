<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br><br>using namespace std;<br><br>#define SIZE(X) ((int)(X.size()))<br>#define LENGTH(X) ((int)(X.length()))<br><br>const int maxn=100000+5;<br>const int maxm=100000+5;<br>const int oo=1000000000;<br><br>int node,nedge,src,dest;<br>int head[maxn],point[maxm],next[maxm],flow[maxm],capa[maxm],cost[maxm];<br>int dist[maxn],expand[maxn],prev[maxn],edge[maxn];<br>bool changed[maxn];<br><br>void init(int _node,int _src,int _dest)<br>{<br>  node=_node;<br>  src=_src;<br>  dest=_dest;<br>  nedge=0;<br>  for (int i=0;i&lt;node;i++) head[i]=-1;<br>}<br>void addedge(int u,int v,int c,int w)<br>{<br>  point[nedge]=v,capa[nedge]=c,cost[nedge]=+w,flow[nedge]=0,next[nedge]=head[u],head[u]=(nedge++);<br>  point[nedge]=u,capa[nedge]=0,cost[nedge]=-w,flow[nedge]=0,next[nedge]=head[v],head[v]=(nedge++);<br>}<br>void ford(int &amp;mflow,int &amp;mcost)<br>{<br>  mflow=mcost=0;<br>  while (1)<br>  {<br>    for (int i=0;i&lt;node;i++) dist[i]=oo,prev[i]=-1,changed[i]=false;<br>    dist[src]=0;<br>    changed[src]=true;<br>    expand[src]=oo;<br>    while (1)<br>    {<br>      bool ok=true;<br>      for (int i=0;i&lt;node;i++) if (changed[i])<br>      {<br>        changed[i]=false;<br>        for (int k=head[i];k&gt;=0;k=next[k])<br>          if (flow[k]&lt;capa[k] &amp;&amp; dist[i]+cost[k]&lt;dist[point[k]])<br>          {<br>            dist[point[k]]=dist[i]+cost[k];<br>            changed[point[k]]=true;<br>            prev[point[k]]=i;<br>            edge[point[k]]=k;<br>            expand[point[k]]=min(expand[i],capa[k]-flow[k]);<br>            ok=false;<br>          }<br>      }<br>      if (ok) break;<br>    }<br>    if (prev[dest]&lt;0) break;<br>    int d=expand[dest];<br>    mflow+=d;<br>    mcost+=d*dist[dest];<br>    for (int k=dest;k!=src;k=prev[k])<br>    {<br>      flow[edge[k]]+=d;<br>      flow[edge[k]^1]-=d;<br>    }<br>  }<br>}<br><br>class DirectionBoard<br>{<br>public:<br>  int getMinimum(vector &lt;string&gt; a)<br>  {<br>    int n=SIZE(a);<br>    int m=LENGTH(a[0]);<br>    int size=n*m;<br>    init(size*2+2,size*2,size*2+1);<br>    for (int i=0;i&lt;n*m;i++)<br>    {<br>      addedge(src,i,1,0);<br>      addedge(i+size,dest,1,0);<br>    }<br>    int dx[]={-1,1,0,0};<br>    int dy[]={0,0,-1,1};<br>    char dc[]={'U','D','L','R'};<br>    for (int x=0;x&lt;n;x++) for (int y=0;y&lt;m;y++) for (int d=0;d&lt;4;d++)<br>    {<br>      int x2=(x+dx[d]+n)%n;<br>      int y2=(y+dy[d]+m)%m;<br>      addedge(x*m+y,x2*m+y2+size,1,((dc[d]==a[x][y])?0:1));<br>    }<br>    int c1,c2;<br>    ford(c1,c2);<br>    return c2;<br>  }<br>};<br></td>