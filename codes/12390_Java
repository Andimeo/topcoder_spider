<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.math.*;<br> <br>public class DirectionBoard {<br>  int n,m;<br>  String dir = "DRUL";<br>  int[] dx = {1,0,-1,0};<br>  int[] dy = {0,1,0,-1};<br>  public int getMinimum(String[] board) {<br>    n = board.length;<br>    m = board[0].length();<br>    MinCostFlow mcf = new MinCostFlow(2*n*m);<br>    for(int i=0; i&lt;n; i++)<br>      for(int j=0; j&lt;m; j++) {<br>        mcf.add(mcf.s,node(i,j),1,0);<br>        mcf.add(n*m+node(i,j),mcf.t,1,0);<br>        int d = dir.indexOf(board[i].charAt(j));<br>        for(int k=0; k&lt;dx.length; k++) {<br>          int nx = (i+dx[k]+n)%n;<br>          int ny = (j+dy[k]+m)%m;<br>          mcf.add(node(i,j),n*m+node(nx,ny),1,k==d?0:1);<br>        }<br>      }<br>    return (int)(mcf.getFlow()[1]);<br>  }<br>  int node(int x, int y) {<br>    return x*m+y;<br>  }<br>  class MinCostFlow {<br>    int N, s, ss, t, tt;<br>    long oo =(long)1e15;<br>    long[] ex;<br>    ArrayList&lt;Edge&gt;[] adjj;<br>    Edge[][] adj;<br>    <br>    MinCostFlow(int NN) {<br>      N=(tt=(ss=(t=(s=NN)+1)+1)+1)+1;<br>      adj = new Edge[N][0];<br>      adjj = new ArrayList[N];<br>      for(int i=0; i&lt;N; adjj[i++] = new ArrayList&lt;Edge&gt;());<br>      ex = new long[N];<br>      ex[t] = -(ex[s] = oo);<br>    }<br>    void add(int i, int j, long cap, long cost) {<br>      Edge fwd = new Edge(i,j,cap,0,cost);<br>      Edge rev = new Edge(j,i,0,0,-cost);<br>      adjj[i].add(rev.rev=fwd); adjj[j].add(fwd.rev=rev);<br>    }<br>    long[] getFlow() {<br>      preFlow();<br>      for(int i=0; i&lt;N; i++) adj[i] = adjj[i].toArray(adj[i]);<br>      boolean[] canU = new boolean[N], hasU = new boolean[N];<br>      long[] dist = new long[N], width = new long[N];<br>      Edge[] prev = new Edge[N];<br>      while(true) {<br>        Arrays.fill(dist,oo);<br>        dist[ss] = 0; width[ss] = oo;<br>        boolean updated = hasU[ss] = true;<br>        while(updated) {<br>          updated = false;<br>          for(int i=0; i&lt;N; hasU[i++] = false)<br>            canU[i] = hasU[i];<br>          for(int i=0; i&lt;N; i++) if(canU[i])<br>            for(Edge e : adj[i])<br>              if(e.flow != e.cap &amp;&amp; dist[e.j] &gt; dist[e.i] + e.cost) {<br>                dist[e.j] = dist[e.i] + (prev[e.j]=e).cost;<br>                width[e.j] = Math.min(width[e.i],e.cap-e.flow);<br>                hasU[e.j] = updated = true;<br>              }<br>        }<br>        if(dist[tt] &gt;= oo) break;<br>        for(Edge e = prev[tt]; e != null; e = prev[e.i])<br>          e.rev.flow = -(e.flow += width[tt]);<br>      }<br>      long flow = 0, cost = 0;;<br>      for(Edge e : adj[s]) if(e.flow &gt; 0) flow += e.flow;<br>      for(int i=0; i&lt;N; i++) for(Edge e : adj[i]) if(e.flow &gt; 0) cost += e.flow*e.cost;<br>      return new long[]{flow,cost};<br>    }<br>    void preFlow() {<br>      for(int i=0; i&lt;N; i++) for(Edge e : adjj[i])<br>          if(e.cost &lt; 0 &amp;&amp; e.cap &gt; 0) {<br>            ex[e.i] -= e.cap-e.flow;<br>            ex[e.j] += e.cap-e.flow;<br>            e.rev.flow = -(e.flow=e.cap);<br>          }<br>      for(int i=0; i&lt;N; i++)<br>        if(ex[i] &gt; 0) add(ss,i,ex[i],0);<br>        else if(ex[i] &lt; 0) add(i,tt,-ex[i],0);<br>      Arrays.fill(ex,0);<br>    }<br>    class Edge {<br>      int i,j;<br>      long cap,flow,cost;<br>      Edge rev;<br>      Edge(int ii, int jj ,long cc, long ff, long C) {<br>        i=ii;j=jj;cap=cc;flow=ff;cost=C;;<br>      }<br>    }<br>  }<br>  <br>}<br> <br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>