<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.List;<br>import java.util.Arrays;<br>import java.util.LinkedList;<br>import java.util.Queue;<br>import java.util.ArrayList;<br>import java.util.Collection;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Zhipeng Jia<br> */<br>public class BoardPainting {<br>  private boolean check(String[] target, int x, int y) {<br>    return target[x].charAt(y) == '#';<br>  }<br>  public int minimalSteps(String[] target) {<br>    int n = target.length;<br>    int m = target[0].length();<br>    IntMaxFlow net = new IntMaxFlow(n * m + 2);<br>    int cnt = 0;<br>    int[][] a = new int[n][m];<br>    int[][] b = new int[n][m];<br>    for (int i = 0; i &lt; n; i ++)<br>      for (int j = 0; j &lt; m; j ++) {<br>        if (check(target, i, j)) {<br>          cnt ++;<br>          int x = i * m + j + 1;<br>          if (i + 1 &lt; n &amp;&amp; check(target, i + 1, j)) {<br>            cnt --;<br>            int y = (i + 1) * m + j + 1;<br>            a[i][j] ++;<br>            a[i + 1][j] ++;<br>            net.insertEdge(x, y, 1);<br>            net.insertEdge(y, x, 1);<br>          }<br>          if (j + 1 &lt; m &amp;&amp; check(target, i, j + 1)) {<br>            cnt --;<br>            b[i][j] ++;<br>            b[i][j + 1] ++;<br>            int y = i * m + (j + 1) + 1;<br>            net.insertEdge(x, y, 1);<br>            net.insertEdge(y, x, 1);<br>          }<br>        }<br>      }<br>    for (int i = 0; i &lt; n; i ++)<br>      for (int j = 0; j &lt; m; j ++) {<br>        int x = i * m + j + 1;<br>        net.insertEdge(0, x, a[i][j]);<br>        net.insertEdge(x, n * m + 1, b[i][j]);<br>      }<br>    return cnt + (int)net.maxFlow(0, n * m + 1) / 2;<br>  }<br>}<br> <br>class IntMaxFlow {<br>  public List&lt;IntMaxFlowEdge&gt;[] ge;<br>  public int n;<br> <br>  public IntMaxFlow(int n) {<br>    this.n = n;<br>    ge = new List[n];<br>    for (int i = 0; i &lt; n; i ++)<br>      ge[i] = new ArrayList&lt;IntMaxFlowEdge&gt;();<br>  }<br> <br>  public void insertEdge(int a, int b, int w) {<br>    if (0 &gt; a || a &gt;= n) throw new RuntimeException();<br>    if (0 &gt; b || b &gt;= n) throw new RuntimeException();<br>    IntMaxFlowEdge x = new IntMaxFlowEdge(a, 0);<br>    IntMaxFlowEdge y = new IntMaxFlowEdge(b, w);<br>    x.anti = y;<br>    y.anti = x;<br>    ge[a].add(y);<br>    ge[b].add(x);<br>  }<br> <br>  public long maxFlow(int s, int t) {<br>    if (0 &gt; s || s &gt;= n) throw new RuntimeException();<br>    if (0 &gt; t || t &gt;= n) throw new RuntimeException();<br>    long tot = 0;<br>    while (true) {<br>      int[] dist = new int[n];<br>      Arrays.fill(dist, -1);<br>      Queue&lt;Integer&gt; Q = new LinkedList&lt;Integer&gt;();<br>      Q.offer(s);<br>      dist[s] = 0;<br>      while (! Q.isEmpty()) {<br>        int now = Q.remove();<br>        for (IntMaxFlowEdge e : ge[now])<br>          if (e.weight &gt; 0 &amp;&amp; dist[e.data] == -1) {<br>            dist[e.data] = dist[now] + 1;<br>            Q.offer(e.data);<br>          }<br>      }<br>      if (dist[t] == -1) break;<br> <br>      int[] cur = new int[n];<br>      int[] pre = new int[n];<br>      IntMaxFlowEdge[] path = new IntMaxFlowEdge[n];<br>      int now = s;<br>      while (dist[s] != -1) {<br>        if (now == t) {<br>          int flow = Integer.MAX_VALUE;<br>          for (now = t; now != s; now = pre[now])<br>            flow = Math.min(flow, path[now].weight);<br>          tot += flow;<br>          for (now = t; now != s; now = pre[now]) {<br>            path[now].weight -= flow;<br>            path[now].anti.weight += flow;<br>          }<br>        }<br>        boolean flag = false;<br>        for (int i = cur[now]; i &lt; ge[now].size(); i ++) {<br>          IntMaxFlowEdge e = ge[now].get(i);<br>          if (e.weight &gt; 0 &amp;&amp; dist[e.data] == dist[now] + 1) {<br>            pre[e.data] = now;<br>            cur[now] = i;<br>            path[e.data] = e;<br>            now = e.data;<br>            flag = true;<br>            break;<br>          }<br>        }<br>        if (! flag) {<br>          dist[now] = -1;<br>          now = pre[now];<br>        }<br>      }<br>    }<br>    return tot;<br>  }<br>}<br> <br>class IntMaxFlowEdge {<br>  public int data;<br>  public int weight;<br>  public IntMaxFlowEdge anti;<br>  public IntMaxFlowEdge(int data, int weight) {<br>    this.data = data;<br>    this.weight = weight;<br>  }<br>}<br></td>