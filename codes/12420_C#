<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class EllysBulls {<br><br>    string[] g;<br>    int[] b;<br>    int len;<br><br>    int[,] num;<br>    int n;<br><br>    public string getNumber(string[] guesses, int[] bulls)<br>    {<br>        n = guesses.Length;<br>        len = guesses[0].Length;<br>        int[] ok = new int[len];<br>        int[] ng = new int[len];<br>        bool[,] flag = new bool[len, 10];<br>        bool[,] point = new bool[len, 10];<br><br>        g = guesses;<br>        b = bulls;<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            for (int j = 0; j &lt; n - 1; j++)<br>            {<br>                if (b[j] &lt; b[j + 1])<br>                {<br>                    swap(ref b[j], ref b[j + 1]);<br>                    swap(ref g[j], ref g[j + 1]);<br>                }<br>            }<br>        }<br><br>        num = new int[n, len];<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            for (int j = 0; j &lt; len; j++)<br>            {<br>                num[i, j] = g[i][j] - '0';<br>            }<br>        }<br>        <br>        res = "";<br>        retcount = 0;<br><br>        dfs(0, ok, ng, flag, point);<br><br>        if (retcount &gt; 1) return "Ambiguity";<br>        if (retcount == 0) return "Liar";<br>        return res;<br>    }<br><br>    void dfs(int now, int[] ok, int[] ng, bool[,] flag, bool[,] point)<br>    {<br>        /*<br>        Console.WriteLine(now);<br>        for (int i = 0; i &lt; len; i++)<br>        {<br>            Console.WriteLine(ok[i] + " " + ng[i]);<br>        }<br>         */<br>        if (retcount &gt; 1) return;<br>        if (now == n)<br>        {<br>            string r = "";<br>            for (int i = 0; i &lt; len; i++)<br>            {<br>                if (ok[i] == 0)<br>                {<br>                    retcount += 2;<br>                    return;<br>                }<br>                for (int j = 0; j &lt; 10; j++)<br>                {<br>                    if (flag[i, j] &amp;&amp; point[i, j]) r += j;<br>                }<br>            }<br>            res = r;<br>            retcount++;<br>            return;<br>        }<br>        int need = b[now];<br>        List&lt;int&gt; l = new List&lt;int&gt;();<br>        for (int i = 0; i &lt; len; i++)<br>        {<br>            if (flag[i, num[now, i]])<br>            {<br>                if (point[i, num[now, i]]) need--;<br>            }<br>            else<br>            {<br>                l.Add(i);<br>            }<br>        }<br><br>        if (need &lt; 0) return;<br>        if (need &gt; l.Count) return;<br>        int[] ar = firstArray(l.Count, need);<br><br>        if (l.Count == 0)<br>        {<br>            dfs(now + 1, ok, ng, flag, point);<br>        }<br>        else<br>        {<br>            do<br>            {<br>                int[] nok = (int[])ok.Clone();<br>                int[] nng = (int[])ng.Clone();<br>                bool[,] nflag = (bool[,])flag.Clone();<br>                bool[,] npoint = (bool[,])point.Clone();<br>                for (int i = 0; i &lt; l.Count; i++)<br>                {<br>                    int p = l[i];<br>                    int nn = num[now, p];<br>                    if (ar[i] == 1)<br>                    {<br>                        //ok<br>                        nok[p] = 1;<br>                        nng[p] = 9;<br>                        for (int j = 0; j &lt; 10; j++)<br>                        {<br>                            nflag[p, j] = true;<br>                            if (j == nn) npoint[p, j] = true;<br>                            else npoint[p, j] = false;<br>                        }<br>                    }<br>                    else<br>                    {<br>                        //ng<br>                        nng[p]++;<br>                        nflag[p, nn] = true;<br>                        npoint[p, nn] = false;<br>                        if (nng[p] == 9)<br>                        {<br>                            nok[p] = 1;<br>                            for (int j = 0; j &lt; 10; j++)<br>                            {<br>                                if (!nflag[p, j])<br>                                {<br>                                    nflag[p, j] = npoint[p, j] = true;<br>                                }<br>                            }<br>                        }<br>                    }<br>                }<br>                dfs(now + 1, nok, nng, nflag, npoint);<br><br>            } while (next_permutation(ar));<br>        }<br>    }<br><br><br>    int retcount;<br>    string res;<br><br>    //swap<br>    void swap&lt;T&gt;(ref T a, ref T b)<br>    {<br>        T c = a;<br>        a = b;<br>        b = c;<br>    } <br><br>    int[] firstArray(int a, int b)<br>    {<br>        int[] ret = new int[a];<br>        for (int i = 0; i &lt; b; i++)<br>        {<br>            ret[a - 1 - i] = 1;<br>        }<br>        return ret;<br>    }<br><br>    public static bool next_permutation&lt;T&gt;(T[] array) where T : IComparable&lt;T&gt;<br>    {<br>        return next_permutation(array, 0, array.Length);<br>    }<br><br>    public static bool next_permutation&lt;T&gt;(T[] array, int start, int length) where T : IComparable&lt;T&gt;<br>    {<br>        int end = start + length - 1;<br>        if (end &lt;= start) return false;<br>        int last = end;<br>        while (true)<br>        {<br>            int pos = last--;<br>            if (array[last].CompareTo(array[pos]) &lt; 0)<br>            {<br>                int i;<br>                for (i = end + 1; array[last].CompareTo(array[--i]) &gt;= 0; ) { }<br>                T tmp = array[last]; array[last] = array[i]; array[i] = tmp;<br>                Array.Reverse(array, pos, end - pos + 1);<br>                return true;<br>            }<br>            if (last == start)<br>            {<br>                //Array.Reverse(array, start, end - start);<br>                return false;<br>            }<br>        }<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] Modified for C# by ysn<br>// Powered by CodeProcessor<br></td>