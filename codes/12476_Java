<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class Tunnels {<br>    boolean[][] mark;<br>    int height;<br>    int width;<br>    String[] frame;<br>    int minRow;<br>    int maxRow;<br>    int minCol;<br>    int maxCol;<br>    int vMoveR1;<br>    int vMoveC1;<br>    int vMoveR2;<br>    int vMoveC2;<br>    int r1;<br>    int c1;<br>    int r2;<br>    int c2;<br> <br>    public int minimumTunnels(String[] frame) {<br>        this.frame = frame;<br>        height = frame.length;<br>        width = frame[0].length();<br>        if (width == 1) {<br>            for (int row = 0; row &lt; height; ++row)<br>                if (frame[row].charAt(0) == 'X')<br>                    return 1;<br>            return 0;<br>        }<br>        mark = new boolean[height][width];<br>        boolean[] haveEndRight = new boolean[height];<br>        boolean[] haveEndLeft = new boolean[height];<br>        boolean[] haveStartRight = new boolean[height];<br>        boolean[] haveStartLeft = new boolean[height];<br>        boolean[] haveCrossover = new boolean[height];<br>        int res = 0;<br> <br>        for (int row = 0; row &lt; height; ++row)<br>            for (int col = 0; col &lt; width; ++col)<br>                if (!mark[row][col] &amp;&amp; frame[row].charAt(col) == 'X') {<br>                    ++res;<br>                    minRow = (int) 1e9;<br>                    maxRow = (int) -1e9;<br>                    minCol = (int) 1e9;<br>                    maxCol = (int) -1e9;<br>                    vMoveR1 = -1;<br>                    vMoveC1 = -1;<br>                    vMoveR2 = -1;<br>                    vMoveC2 = -1;<br>                    dfs(row, col);<br>                    if (minRow &lt; maxRow) {<br>                        if (vMoveR1 &lt; 0) throw new RuntimeException();<br>                        r1 = Math.min(vMoveR1, vMoveR2);<br>                        c1 = vMoveC1;<br>                        r2 = Math.max(vMoveR1, vMoveR2);<br>                        c2 = vMoveC1;<br>                        traverse();<br>                        int er = r2;<br>                        int ec = c2;<br>                        r1 = Math.max(vMoveR1, vMoveR2);<br>                        c1 = vMoveC1;<br>                        r2 = Math.min(vMoveR1, vMoveR2);<br>                        c2 = vMoveC1;<br>                        traverse();<br>                        int sr = r2;<br>                        int sc = c2;<br>                        if (sr != minRow) throw new RuntimeException();<br>                        if (er != maxRow) throw new RuntimeException();<br>                        if (sr &gt; 0) {<br>                            if (sc == 0) haveStartLeft[sr] = true; else if (sc == width - 1) haveStartRight[sr] = true; else throw new RuntimeException();<br>                        }<br>                        if (ec == 0 &amp;&amp; !haveStartLeft[er - 1]) haveEndLeft[er] = true;<br>                        if (ec == width - 1 &amp;&amp; !haveStartRight[er - 1]) haveEndRight[er] = true;<br>                    } else {<br>                        if (vMoveR1 &gt;= 0) throw new RuntimeException();<br>                        if (minCol == 0 &amp;&amp; maxCol == width - 1) haveCrossover[minRow] = true; else {<br>                            if (minRow &gt; 0) {<br>                                if (minCol == 0) haveStartLeft[minRow] = true;<br>                                else if (maxCol == width - 1) haveStartRight[minRow] = true;<br>                                else throw new RuntimeException();<br>                            } else {<br>                                if (minCol == 0) haveEndLeft[minRow] = true;<br>                                if (maxCol == width - 1) haveEndRight[minRow] = true;<br>                            }<br>                        }<br>                    }<br>                }<br> <br>        int[][] best = new int[height + 1][height + 1];<br>        for (int[] x : best) Arrays.fill(x, (int) (-1e9));<br>        best[0][0] = 0;<br>        for (int row = 0; row &lt; height; ++row) {<br>            if (haveCrossover[row]) {<br>                int[][] nbest = new int[height + 1][height + 1];<br>                for (int[] x : nbest) Arrays.fill(x, (int) (-1e9));<br>                for (int bleft = 0; bleft &lt;= height; ++bleft)<br>                    for (int bright = 0; bright &lt;= height; ++bright)<br>                        if (best[bleft][bright] &gt;= 0) {<br>                            nbest[bleft][bright] = Math.max(nbest[bleft][bright], best[bleft][bright]);<br>                            if (bleft &gt; 0) {<br>                                nbest[bleft - 1][bright + 1] = Math.max(nbest[bleft - 1][bright + 1], best[bleft][bright] + 1);<br>                            }<br>                            nbest[bleft][bright + 1] = Math.max(nbest[bleft][bright + 1], best[bleft][bright]);<br>                            if (bright &gt; 0) {<br>                                nbest[bleft + 1][bright - 1] = Math.max(nbest[bleft + 1][bright - 1], best[bleft][bright] + 1);<br>                            }<br>                            nbest[bleft + 1][bright] = Math.max(nbest[bleft + 1][bright], best[bleft][bright]);<br>                        }<br>                best = nbest;<br>            }<br>            if (haveStartLeft[row]) {<br>                int[][] nbest = new int[height + 1][height + 1];<br>                for (int[] x : nbest) Arrays.fill(x, (int) (-1e9));<br>                for (int bleft = 0; bleft &lt;= height; ++bleft)<br>                    for (int bright = 0; bright &lt;= height; ++bright)<br>                        if (best[bleft][bright] &gt;= 0) {<br>                            nbest[bleft][bright] = Math.max(nbest[bleft][bright], best[bleft][bright]);<br>                            if (bleft &gt; 0) {<br>                                nbest[bleft - 1][bright] = Math.max(nbest[bleft - 1][bright], best[bleft][bright] + 1);<br>                            }<br>                        }<br>                best = nbest;<br>            }<br>            if (haveStartRight[row]) {<br>                int[][] nbest = new int[height + 1][height + 1];<br>                for (int[] x : nbest) Arrays.fill(x, (int) (-1e9));<br>                for (int bleft = 0; bleft &lt;= height; ++bleft)<br>                    for (int bright = 0; bright &lt;= height; ++bright)<br>                        if (best[bleft][bright] &gt;= 0) {<br>                            nbest[bleft][bright] = Math.max(nbest[bleft][bright], best[bleft][bright]);<br>                            if (bright &gt; 0) {<br>                                nbest[bleft][bright - 1] = Math.max(nbest[bleft][bright - 1], best[bleft][bright] + 1);<br>                            }<br>                        }<br>                best = nbest;<br>            }<br>            if (haveEndLeft[row]) {<br>                int[][] nbest = new int[height + 1][height + 1];<br>                for (int[] x : nbest) Arrays.fill(x, (int) (-1e9));<br>                for (int bleft = 0; bleft &lt;= height; ++bleft)<br>                    for (int bright = 0; bright &lt;= height; ++bright)<br>                        if (best[bleft][bright] &gt;= 0) {<br>                            nbest[bleft][bright] = Math.max(nbest[bleft][bright], best[bleft][bright]);<br>                            nbest[bleft + 1][bright] = Math.max(nbest[bleft + 1][bright], best[bleft][bright]);<br>                        }<br>                best = nbest;<br>            }<br>            if (haveEndRight[row]) {<br>                int[][] nbest = new int[height + 1][height + 1];<br>                for (int[] x : nbest) Arrays.fill(x, (int) (-1e9));<br>                for (int bleft = 0; bleft &lt;= height; ++bleft)<br>                    for (int bright = 0; bright &lt;= height; ++bright)<br>                        if (best[bleft][bright] &gt;= 0) {<br>                            nbest[bleft][bright] = Math.max(nbest[bleft][bright], best[bleft][bright]);<br>                            nbest[bleft][bright + 1] = Math.max(nbest[bleft][bright + 1], best[bleft][bright]);<br>                        }<br>                best = nbest;<br>            }<br>        }<br>        int sub = 0;<br>        for (int[] x : best) for (int y : x) sub = Math.max(sub, y);<br>        return res - sub;<br>    }<br> <br>    private void traverse() {<br>        outer: while (true) {<br>            for (int dr = -1; dr &lt;= 1; ++dr)<br>                for (int dc = -1; dc &lt;= 1; ++dc)<br>                    if (Math.abs(dr) + Math.abs(dc) == 1) {<br>                        int nr = r2 + dr;<br>                        int nc = c2 + dc;<br>                        if (nr &gt;= 0 &amp;&amp; nr &lt; height &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; width &amp;&amp; frame[nr].charAt(nc) == 'X' &amp;&amp; ((nr != r1) || (nc != c1))) {<br>                            r1 = r2;<br>                            c1 = c2;<br>                            r2 = nr;<br>                            c2 = nc;<br>                            continue outer;<br>                        }<br>                    }<br>            break;<br>        }<br>    }<br> <br>    private void dfs(int row, int col) {<br>        mark[row][col] = true;<br>        minRow = Math.min(minRow, row);<br>        minCol = Math.min(minCol, col);<br>        maxRow = Math.max(maxRow, row);<br>        maxCol = Math.max(maxCol, col);<br>        for (int dr = -1; dr &lt;= 1; ++dr)<br>            for (int dc = -1; dc &lt;= 1; ++dc)<br>                if (Math.abs(dr) + Math.abs(dc) == 1) {<br>                    int nr = row + dr;<br>                    int nc = col + dc;<br>                    if (nr &gt;= 0 &amp;&amp; nr &lt; height &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; width &amp;&amp; frame[nr].charAt(nc) == 'X' &amp;&amp; !mark[nr][nc]) {<br>                        dfs(nr, nc);<br>                        if (dr != 0) {<br>                            vMoveR1 = row;<br>                            vMoveC1 = col;<br>                            vMoveR2 = nr;<br>                            vMoveC2 = nc;<br>                        }<br>                    }<br>                }<br>    }<br>}<br></td>