<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br> <br>using namespace std;<br> <br>class TheMagicMatrix {<br>public:<br>  int find(int, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;);<br>};<br> <br>const long long P = 1234567891LL;<br>const int maxN = 500;<br> <br>long long powmod(long long a, long long n) {<br>  if (n == 0) {<br>    return 1LL % P;<br>  }<br> <br>  long long b = powmod(a, n / 2LL);<br>  b = (b * b) % P;<br> <br>  if (n % 2LL == 0LL) {<br>    return b;<br>  } else {<br>    return (a * b) % P;<br>  }<br>}<br> <br>long long inverse(long long a, long long P) {<br>  a = ((a % P) + P) % P;<br>  long long x1 = 1, b1 = a;<br>  long long x2 = 0, b2 = P;<br> <br>  while (b1) {<br>    long long q = b1 / b2;<br>    b1 -= q * b2;<br>    x1 -= q * x2;<br>    swap(x1, x2);<br>    swap(b1, b2);<br>  }<br> <br>  x1 = ((x1 % P) + P) % P;<br>  return x1;<br>}<br> <br>long long solve(int n, int m, int h, long long a[maxN][maxN], long long b[maxN], long long Q) {<br>  for (int i = 0; i &lt; m; ++i) {<br>    for (int j = 0; j &lt; n; ++j) {<br>      a[i][j] = ((a[i][j] % Q) + Q) % Q;<br>    }<br>    b[i] = ((b[i] % Q) + Q) % Q;<br>  }<br> <br>  int zeroes = 0;<br>  for (int i = 0; i &lt; m; ++i) {<br>    int v = -1;<br>    for (int j = 0; j &lt; n; ++j) {<br>      if (a[i][j] != 0) {<br>        v = j;<br>        break;<br>      }<br>    }<br> <br>    if (v == -1 &amp;&amp; b[i] != 0) {<br>      return 0;<br>    }<br> <br>    if (v == -1) {<br>      ++zeroes;<br>      continue;<br>    }<br> <br>    for (int j = 0; j &lt; m; ++j) {<br>      if (i == j) {<br>        continue;<br>      }<br>      if (a[j][v] == 0) {<br>        continue;<br>      }<br> <br>      long long A = a[j][v], B = a[i][v];<br>      for (int k = 0; k &lt; n; ++k) {<br>        a[j][k] = (a[j][k] * B - a[i][k] * A);<br>        a[j][k] = ((a[j][k] % Q) + Q) % Q;<br>      }<br>      b[j] = (b[j] * B - b[i] * A);<br>      b[j] = ((b[j] % Q) + Q) % Q;<br>    }<br>  }<br> <br>  return powmod(Q, (n - h) - (m - zeroes));<br>}<br> <br>long long a[maxN][maxN], c[maxN][maxN];<br>long long b[maxN], d[maxN];<br> <br>int p[maxN][maxN];<br> <br>int TheMagicMatrix::find(int n, vector &lt;int&gt; rows, vector &lt;int&gt; columns, vector &lt;int&gt; values) {<br>  if (n &gt; 10) {<br>    return powmod(10LL, n * n - rows.size() - 2 * n + 2);<br>  }<br> <br>  memset(p, -1, sizeof(p));<br>  for (int i = 0; i &lt; rows.size(); ++i) {<br>    p[rows[i]][columns[i]] = values[i];<br>  }<br> <br>  long long res = 0;<br>  for (int sum = 0; sum &lt; 10; ++sum) {<br>    memset(a, 0, sizeof(a));<br>    memset(b, 0, sizeof(b));<br>    memset(c, 0, sizeof(c));<br>    memset(d, 0, sizeof(d));<br> <br>    for (int i = 0; i &lt; n; ++i) {<br>      for (int j = 0; j &lt; n; ++j) {<br>        if (p[i][j] == -1) {<br>          a[i][i * n + j] = c[i][i * n + j] = 1;<br>        } else {<br>          b[i] -= p[i][j];<br>          d[i] -= p[i][j];<br>        }<br>      }<br>    }<br> <br>    for (int j = 0; j &lt; n; ++j) {<br>      for (int i = 0; i &lt; n; ++i) {<br>        if (p[i][j] == -1) {<br>          a[n + j][i * n + j] = c[n + j][i * n + j] = 1;<br>        } else {<br>          b[n + j] -= p[i][j];<br>          d[n + j] -= p[i][j];<br>        }<br>      }<br>    }<br> <br>    for (int i = 0; i &lt; n + n; ++i) {<br>      b[i] += sum;<br>      d[i] += sum;<br>    }<br> <br>    long long current = solve(n * n, n + n, rows.size(), a, b, 2LL) * solve(n * n, n + n, rows.size(), c, d, 5LL);<br>    current %= P;<br>    res += current;<br>    res %= P;<br>  }<br> <br>  res = ((res % P) + P) % P;<br>  return res;<br>}<br> <br> <br>//Powered by [KawigiEdit] 2.0!<br></td>