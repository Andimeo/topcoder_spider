<td class="problemText" colspan="8" valign="middle" align="left">
            import java.math.MathContext;<br>import java.math.BigDecimal;<br>import java.math.BigInteger;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author ilyakor<br> */<br>public class TheMagicMatrix {<br>    static final long mod = 1234567891L;<br> <br>    public int find(int n, int[] rows, int[] columns, int[] values) {<br>        if (n &gt; rows.length) {<br>            long res = IntegerUtlis.pow(10L, n * n - rows.length + 2 - 2 * n, mod);<br>            return (int) (res % mod);<br>        }<br>        int[][] a = new int[n][n];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>                a[i][j] = -1;<br>        for (int i = 0; i &lt; rows.length; ++i) {<br>            a[rows[i]][columns[i]] = values[i];<br>        }<br>        long res = 0;<br>        for (int dig = 0; dig &lt; 10; ++dig) {<br>            long cur = solve(a, dig);<br>            if (cur == -1) continue;<br>            res += IntegerUtlis.pow(10L, cur, mod);<br>            res %= mod;<br>        }<br>        return (int)(res % mod);<br>    }<br> <br>    private long solve(int[][] ma, int dig) {<br>        int m = ma.length;<br>        int cnt = 0;<br>        for (int i = 0; i &lt; m; ++i)<br>            for (int j = 0; j &lt; m; ++j)<br>                if (ma[i][j] != -1) ++cnt;<br>        int n = m * m;<br>        int[][] a = new int[2 * m + cnt][n + 1];<br>        int cur = 0;<br>        for (int i = 0; i &lt; m; ++i) {<br>            for (int j = 0; j &lt; m; ++j) {<br>                a[cur][i * m + j] = 1;<br>                a[cur + 1][j * m + i] = 1;<br>            }<br>            a[cur][n] = dig;<br>            a[cur + 1][n] = dig;<br>            cur += 2;<br>        }<br>        for (int i = 0; i &lt; m; ++i)<br>            for (int j = 0; j &lt; m; ++j)<br>                if (ma[i][j] != -1) {<br>                    a[cur][i * m + j] = 1;<br>                    a[cur][n] = ma[i][j];<br>                    ++cur;<br>                }<br>        Assert.assertTrue(cur == 2 * m + cnt);<br>        int M = 2 * m + cnt;<br>        cur = 0;<br>        for (int i = 0; i &lt;= n; ++i) {<br>            int ind = -1;<br>            for (int j = cur; j &lt; M; ++j)<br>                if (a[j][i] != 0) {<br>                    ind = j;<br>                    break;<br>                }<br>            if (ind == -1) continue;<br>            if (i == n)<br>                return -1;<br>            for (int j = 0; j &lt; n + 1; ++j) {<br>                int t = a[cur][j];<br>                a[cur][j] = a[ind][j];<br>                a[ind][j] = t;<br>            }<br>            for (int j = cur + 1; j &lt; M; ++j) {<br>                int k1 = (10 - a[cur][i]) % 10;<br>                int k2 = a[j][i];<br>                for (int t = 0; t &lt; n + 1; ++t) {<br>                    a[j][t] = (a[j][t] * k1 + a[cur][t] * k2) % 10;<br>                }<br>                Assert.assertTrue(a[j][i] == 0);<br>            }<br>            ++cur;<br>        }<br>        return m * m - cur;<br>    }<br>}<br> <br>class IntegerUtlis {<br> <br>    public static long pow(long x, long y, long mod) {<br>        x %= mod;<br>        long res = 1;<br>        while (y &gt; 0) {<br>            if (y % 2 == 1) {<br>                --y;<br>                res = BigInteger.valueOf(res).multiply(BigInteger.valueOf(x)).mod(BigInteger.valueOf(mod)).longValue();<br>            } else {<br>                y /= 2;<br>                x = BigInteger.valueOf(x).multiply(BigInteger.valueOf(x)).mod(BigInteger.valueOf(mod)).longValue();<br>            }<br>        }<br>        return res % mod;<br>    }<br> <br>    }<br> <br>class Assert {<br> <br>    public static void assertTrue(boolean flag) {<br>        if (!flag)<br>            throw new AssertionError();<br>    }<br> <br>    }<br></td>