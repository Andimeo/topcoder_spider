<td class="problemText" colspan="8" valign="middle" align="left">
            // headers from WishingBone's parser<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br> <br>//#define USE_MAP<br>#ifdef USE_MAP<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#endif<br> <br>#define USE_STREAM<br>#ifdef USE_STREAM<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;sstream&gt;<br>#endif<br> <br>#define USE_ALGORITHM<br>#ifdef USE_ALGORITHM<br>#include &lt;algorithm&gt;<br>#endif<br> <br>//#include &lt;functional&gt;<br>//#include &lt;numeric&gt;<br>//#include &lt;utility&gt;<br> <br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br> <br>using namespace std;<br> <br>typedef signed long long i64;<br>typedef unsigned long long u64;<br> <br>#define abs(a) ((a)&gt;0?(a):-(a))<br>#define max(a,b) ((a)&gt;(b)?(a):(b))<br>#define min(a,b) ((a)&lt;(b)?(a):(b))<br> <br>int gcd(int a,int b){for(int c;b;c=a,a=b,b=c%b);return a;}<br>int lcm(int a,int b){return a/gcd(a,b)*b;}<br> <br>#ifdef USE_ALGORITHM<br>#define ALL(a) (a).begin(),(a).end()<br>#define SORT(a) sort(a.begin(),a.end())<br>#define REVERSE(a) reverse(a.begin(),a.end())<br>#define UNIQUE(a) a.resize(unique(a.begin(),a.end())-a.begin())<br>#define REMOVE(a,b) a.resize(remove(a.begin(),a.end(),e)-a.begin())<br>#define FIND(a,b) find(a.begin(),a.end(),b)<br> <br>template &lt;class T&gt; void remove(vector&lt;T&gt;&amp; v,const T&amp;e){<br>  v.resize(remove(v.begin(),v.end(),e)-v.begin());<br>}<br>template &lt;class T&gt; vector&lt;T&gt; remove_copy(vector&lt;T&gt;&amp; v,const T&amp;e){<br>  vector&lt;T&gt; result;<br>  remove_copy(v.begin(),v.end(),back_inserter(result),e);<br>  return result;<br>}<br>#endif<br> <br>string upper(const string&amp; a) {<br>  string r(a);<br>  for(int i=0;i&lt;r.size();i++) r[i] = toupper(r[i]);    <br>  return r;<br>}<br>string lower(const string&amp; a) {<br>  string r(a);<br>  for(int i=0;i&lt;r.size();i++) r[i] = tolower(r[i]);    <br>  return r;<br>}<br> <br> <br>//parsing routine<br>template &lt;class T&gt;<br>vector&lt;basic_string&lt;T&gt; &gt; parse(const basic_string&lt;T&gt; &amp;s,const basic_string&lt;T&gt; &amp;delim){<br>  vector&lt;basic_string&lt;T&gt; &gt; ret(0);<br>  for (int b,e=0;;ret.push_back(s.substr(b,e-b)))<br>    if ((b=s.find_first_not_of(delim,e))==(e=s.find_first_of(delim,b)))<br>      return ret;<br>}<br>vector&lt;string&gt; parse(const string&amp; s, const char* c) {<br>  return parse(s,string(c));<br>}<br>vector&lt;int&gt; intparse(const string &amp;s,const string &amp;delim=" \t\n"){<br>  vector&lt;string&gt; tmp=parse(s,delim);<br>  vector&lt;int&gt; ret(0);<br>  int t;<br>  for (vector&lt;string&gt;::iterator i=tmp.begin();i!=tmp.end();i++)<br>    sscanf(i-&gt;c_str(),"%d",&amp;t),ret.push_back(t);<br>  return ret;<br>}<br> <br>#ifdef USE_MAP<br>//name mapper<br>class mapper{<br>public:<br>  map&lt;string,int&gt; m;<br>  vector&lt;string&gt; v;<br>  void reset(){<br>    v.clear();<br>    m.clear();<br>  }<br>  int size(){<br>    return v.size();<br>  }<br>  int get(const string str){<br>    if (m.find(str)==m.end()){<br>      m[str]=v.size();<br>      v.push_back(str);<br>    }<br>    return m[str];<br>  }<br>  string get(int i){<br>    return v[i];<br>  }<br>  vector&lt;int&gt; get(const vector&lt;string&gt;&amp; strs){<br>    vector&lt;int&gt; result;<br>    result.reserve(strs.size()+2);<br>    for(int i=0;i&lt;strs.size();i++)<br>      result.push_back(get(strs[i]));<br>    return result;<br>  }<br>  vector&lt;string&gt; get(const vector&lt;int&gt;&amp; is){<br>    vector&lt;string&gt; result;<br>    result.reserve(is.size()+2);<br>    for(int i=0;i&lt;is.size();i++)<br>      result.push_back(get(is[i]));<br>    return result;<br>  }<br>};<br>#endif<br> <br>//array index <br>bool valid_index(int index, int size) {<br>    return index&gt;=0 &amp;&amp; index&lt;size;<br>}<br> <br>bool valid_index(int index, int size, int index2, int size2) {<br>    return index&gt;=0 &amp;&amp; index&lt;size &amp;&amp; index2&gt;=0 &amp;&amp; index2&lt;size2;<br>}<br> <br>bool valid_index(const pair&lt;int,int&gt;&amp; index, const pair&lt;int,int&gt;&amp; size) {<br>    return index.first&gt;=0 &amp;&amp; index.first&lt;size.first &amp;&amp; index.second&gt;=0 &amp;&amp; index.second&lt;size.second;<br>}<br> <br>pair&lt;int, int&gt; add(const pair&lt;int,int&gt; &amp;a, const pair&lt;int,int&gt; &amp;b) {<br>    return pair&lt;int,int&gt;(a.first+b.first, a.second+b.second);<br>}<br> <br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt;vector&lt;int&gt; &gt; VII;<br>typedef vector&lt;vector&lt;string&gt; &gt; VSS;<br>typedef pair&lt;int,int&gt; PII;<br>typedef pair&lt;string,int&gt; PSI;<br>typedef pair&lt;int,string&gt; PIS;<br>typedef pair&lt;string,string&gt; PSS;<br>typedef pair&lt;int,pair&lt;int,int&gt; &gt; PIII;<br>//==========================================================<br>//header ends, please begin challenging here :)<br> <br>class UniqueTriangles {<br>  public:<br>  vector&lt;vector&lt;int&gt; &gt; a;<br>  int sqr(int a){<br>    return a*a;<br>  }<br>  int howMany(vector &lt;int&gt; x, vector &lt;int&gt; y) {<br>    a.clear();<br>    for(int i1=0;i1&lt;x.size();i1++)<br>    for(int i2=i1+1;i2&lt;x.size();i2++)<br>    for(int i3=i2+1;i3&lt;x.size();i3++) {<br>      vector&lt;int&gt; temp;<br>      temp.push_back( sqr(x[i1]-x[i2])+sqr(y[i1]-y[i2]));<br>      temp.push_back( sqr(x[i3]-x[i2])+sqr(y[i3]-y[i2]));<br>      temp.push_back( sqr(x[i1]-x[i3])+sqr(y[i1]-y[i3]));<br>      sort(temp.begin(),temp.end());<br>      if((x[i3]-x[i1])*(y[i2]-y[i1])!=(y[i3]-y[i1])*(x[i2]-x[i1])) {<br>        int g = gcd(temp[0],temp[1]);<br>        g=gcd(g,temp[2]);<br>        temp[0]/=g;<br>        temp[1]/=g;<br>        temp[2]/=g;<br>        a.push_back(temp);        <br>      }<br>    }<br>    sort(a.begin(),a.end());<br>    cout&lt;&lt;a.size()&lt;&lt;endl;<br>    UNIQUE(a);<br>    return a.size();<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>