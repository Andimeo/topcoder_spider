<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;functional&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;stdexcept&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;fstream&gt;<br>#include &lt;numeric&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;utility&gt;<br>#include &lt;cctype&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;bitset&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stack&gt;<br>#include &lt;ctime&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;assert.h&gt;<br>#define REP(i,n) for(int i=0;i&lt;n;i++)<br>#define TR(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++)<br>#define ALL(x) x.begin(),x.end()<br>#define SORT(x) sort(ALL(x))<br>#define CLEAR(x) memset(x,0,sizeof(x))<br>#define FILL(x,c) memset(x,c,sizeof(x))<br> <br>using namespace std;<br> <br>const double eps = 1e-8;<br> <br>#define PB push_back<br>#define MP make_pair<br> <br>typedef map&lt;int,int&gt; MII;<br>typedef map&lt;string,int&gt; MSI;<br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt;long double&gt; VD;<br>typedef pair&lt;int,int&gt; PII;<br>typedef long long int64;<br>typedef long long ll;<br>typedef unsigned int UI;<br>typedef long double LD;<br>typedef unsigned long long ULL;<br> <br>class TheTilesDivOne {<br>public:<br>  int find(vector &lt;string&gt;);<br>};<br> <br>const int max_edge = 100007,<br>          max_vertex = 50*107*4,<br>          inf = 0x3f3f3f3f;<br> <br>struct EDGE  {<br>    int next,u,w,v,r,idx;<br>    bool reversed;<br>} edge[max_edge];<br> <br>int last = 0,V[max_vertex],n,m,s,t;<br>int height[max_vertex],nheight[max_vertex];<br> <br>void insert(int u,int v,int w) {<br>    edge[last].u = u;<br>    edge[last].v = v;<br>    edge[last].w = w;<br>    edge[last].r = last + 1;<br>    edge[last].next = V[u];<br>    edge[last].reversed = false;<br>    V[u] = last++;<br> <br>    edge[last].v = u;<br>    edge[last].u = v;<br>    edge[last].w = 0;<br>    edge[last].r = last - 1;<br>    edge[last].next = V[v];<br>    edge[last].reversed = true;<br>    V[v] = last++;<br>}<br> <br>//AugPath(n,s,s,t,0xfffffff,edge);<br>long AugPath(int n,int u,int s,int t,int push,EDGE edge[]) {<br>   // cout &lt;&lt; s &lt;&lt; " " &lt;&lt; t &lt;&lt; endl;<br>    if (u == t)<br>        return push;<br>    int flow = push,minheight = n-1;<br>    for (int i = V[u];i != -1;i = edge[i].next)<br>        if (edge[i].w) {<br>            if (height[edge[i].v] + 1 == height[u]) {<br>                int delta = flow &lt; edge[i].w ? flow : edge[i].w,f;<br>                if (delta) delta = AugPath(n,edge[i].v,s,t,delta,edge);<br>                edge[i].w -= delta;<br>                edge[edge[i].r].w += delta;<br>                flow -= delta;<br>                if (0 == flow || height[s] &gt;= n) return push - flow;<br>            }<br>            if (height[edge[i].v] &lt; minheight) minheight = height[edge[i].v];<br>        }<br>    if (!(push - flow)) {<br>        nheight[height[u]]--;<br>        if (!nheight[height[u]]) height[s] = n;<br>        height[u] = ++minheight;<br>        nheight[height[u]]++;<br>    }<br>    return push - flow;<br>}<br> <br>int idx[501][501],<br>    mat[501][501];<br>int L[501][501], R[501][501];<br> <br>int dx[4] = {1, 1, -1, -1},<br>    dy[4] = {1, -1, 1, -1};<br>int N, M;<br> <br>inline bool ok(int x, int y)<br>{<br>    return x &gt;= 0 &amp;&amp; x &lt; N &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; M;<br>}<br> <br>int dir[4][4];<br> <br>int connL[501][501][4],<br>    connR[501][501][4];<br> <br>inline int next_int() {<br>    int c; c = getchar();<br>    while (c &lt; '0' || c &gt; '9') c = getchar();<br>    int n = 0;<br>    while (c &gt;= '0' &amp;&amp; c &lt;= '9') n *= 10, n += c - '0', c = getchar();<br>    return n;<br>}<br> <br>int ddx[4] = {0, 0, -1, 1},<br>    ddy[4] = {-1, 1, 0, 0};<br> <br>int go(int n, int m) {<br>  N = n; M = m;<br>    dir[0][1] = 0;<br>    dir[1][0] = 1;<br>    dir[1][2] = 2;<br>    dir[2][1] = 3;<br>/*<br>    last = 0;<br>    for (int i = 0;i &lt;= m*2;++i)<br>        V[i] = -1;<br>    t = n-1; s = 0;<br>    memset(height,0,sizeof(height));<br>    memset(nheight,0,sizeof(nheight));<br>    nheight[0] = VERTEXS; int flow = 0;<br>    while (height[s] &lt; VERTEXS)<br>        flow += AugPath(n,s,s,t,inf,edge);<br>    printf("%d\n",flow);<br>*/<br>   // while (EOF != scanf("%d%d", &amp;N, &amp;M))<br>    {<br>        last = 0;<br>        for (int i = 0; i &lt; N*M*2+10; ++i)<br>            V[i] = -1;<br> <br>       // REP(i, N) REP(j, M) mat[i][j] = next_int();<br>        int cnt = 0;<br>        REP(i, N) REP(j, M) idx[i][j] = -1;<br>        REP(i, N) REP(j, M) if (mat[i][j] == 2)<br>        {<br>            bool OK = false;<br>            REP(k, 4)<br>            {<br>                int nx = i + ddx[k],<br>                    ny = j + ddy[k];<br>                if (ok(nx, ny) &amp;&amp; mat[nx][ny] == 1)<br>                {<br>                    OK = true;<br>                    break;<br>                }<br>            }<br>            if (OK) idx[i][j] = cnt++;<br>        }<br>        else if (mat[i][j]  == 1)<br>        {<br>            int OK = 0;<br>            REP(k, 4)<br>            {<br>                int nx = i + ddx[k],<br>                    ny = j + ddy[k];<br>                if (ok(nx, ny) &amp;&amp; mat[nx][ny] == 2)<br>                {<br>                    OK++;<br>                    if (OK &gt;= 2) break;<br>                }<br>            }<br>            if (OK &gt;= 2)<br>            {<br>                L[i][j] = cnt++;<br>                R[i][j] = cnt++;<br>                insert(L[i][j], R[i][j], 1);<br>            }<br>        }<br>        s = cnt++, t = cnt++;<br> <br>        REP(i, N) REP(j, M) REP(k, 4) connL[i][j][k] = connR[i][j][k] = false;<br> <br>       // cout &lt;&lt; " cnt = " &lt;&lt; cnt &lt;&lt; endl;<br> <br>        for (int i = 0; i &lt; N; ++i)<br>            REP(j, M) if (idx[i][j] != -1)<br>        {<br>            if ((i&amp;1))<br>            {<br>                insert(idx[i][j], t, 1);<br>                continue;<br>            }<br>            insert(s, idx[i][j], 1);<br>            //map&lt;int, map&lt;int, int &gt; &gt; M;<br>            for (int d = 0; d &lt; 4; ++d)<br>            {<br>                int nx = i + dx[d],<br>                    ny = j + dy[d];<br>                if (!ok(nx, ny)) continue;<br>                if (idx[nx][ny] == -1) continue;<br>             //   int dir<br>            //    if (d<br>                if (mat[i+dx[d]][j] == 1)<br>                {<br>                  //  cout &lt;&lt; "src = " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " mid = " &lt;&lt; i+dx[d] &lt;&lt; " " &lt;&lt; j &lt;&lt; " dest = " &lt;&lt; nx &lt;&lt; " " &lt;&lt; ny &lt;&lt; endl;<br>                  //  M[dx[d]][0] = 1;<br>                    if (!connL[i+dx[d]][j][dir[-dx[d]+1][1]])<br>                    {<br>                        connL[i+dx[d]][j][dir[-dx[d]+1][1]] = true;<br>                        insert(idx[i][j], L[i+dx[d]][j], 1);<br>                    }<br>                    if (!connR[i+dx[d]][j][dir[1][-dy[d]+1]])<br>                    {<br>                        connR[i+dx[d]][j][dir[1][-dy[d]+1]] = true;<br>                        insert(R[i+dx[d]][j], idx[nx][ny], 1);<br>                    }<br>                }<br> <br>                if (mat[i][j+dy[d]] == 1)<br>                {<br>                  //  cout &lt;&lt; "src = " &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " mid = " &lt;&lt; i+dx[d] &lt;&lt; " " &lt;&lt; j &lt;&lt; " dest = " &lt;&lt; nx &lt;&lt; " " &lt;&lt; ny &lt;&lt; endl;<br>                  //  M[0][dy[d]] = 1;<br>                    if (!connL[i][j+dy[d]][dir[1][1-dy[d]]])<br>                    {<br>                        connL[i][j+dy[d]][dir[1][1-dy[d]]] = true;<br>                        insert(idx[i][j], L[i][j+dy[d]], 1);<br>                    }<br>                    if (!connR[i][j+dy[d]][dir[1-dx[d]][1]])<br>                    {<br>                        connR[i][j+dy[d]][dir[1-dx[d]][1]] = true;<br>                        insert(R[i][j+dy[d]], idx[nx][ny], 1);<br>                    }<br>                }<br>            }<br>        }<br> <br>        n = cnt;<br>        //memset(height,0,sizeof(height));<br>       // memset(nheight,0,sizeof(nheight));<br>        REP(i, cnt+1) height[i] = nheight[i] = 0;<br>        nheight[0] = n; int flow = 0;<br>        while (height[s] &lt; n)<br>            flow += AugPath(n,s,s,t,inf,edge);<br>        return flow;<br>    }<br>    return 0;<br>}<br> <br>int TheTilesDivOne::find(vector &lt;string&gt; board) {<br>  int n = board.size(), m = board[0].size();<br>  REP(i, n) REP(j, m) {<br>    mat[i][j] = 0;<br>    if (board[i][j] != 'X') {<br>      if ((i + j) &amp; 1) {<br>        mat[i][j] = 2;<br>      } else mat[i][j] = 1;<br>    }<br>  }<br>  return go(n, m);<br>}<br> <br> <br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>