<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.List;<br>import java.util.ArrayList;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class TheTilesDivOne {<br>    static class Edge {<br>        int cap;<br>        Vertex dest;<br>        Edge rev;<br>    }<br>    <br>    static class Vertex {<br>        int generation = 0;<br>        List&lt;Edge&gt; adj = new ArrayList&lt;Edge&gt;();<br>    }<br>    <br>    public int find(String[] board) {<br>        int height = board.length;<br>        int width = board[0].length();<br>        Vertex[][] v = new Vertex[height][width];<br>        Vertex[][] vout = new Vertex[height][width];<br>        for (int r = 0; r &lt; height; ++r)<br>            for (int c = 0; c &lt; width; ++c) {<br>                if (board[r].charAt(c) == 'X') continue;<br>                v[r][c] = new Vertex();<br>                if ((r + c) % 2 == 0) vout[r][c] = new Vertex();<br>            }<br>        Vertex s = new Vertex();<br>        Vertex t = new Vertex();<br>        for (int r = 0; r &lt; height; ++r)<br>            for (int c = 0; c &lt; width; ++c) {<br>                if (v[r][c] == null) continue;<br>                if ((r + c) % 2 == 0) {<br>                    addEdge(v[r][c], vout[r][c]);<br>                    for (int dr = -1; dr &lt;= 1; ++dr)<br>                        for (int dc = -1; dc &lt;= 1; ++dc)<br>                            if (Math.abs(dr) + Math.abs(dc) == 1) {<br>                                int nr = r + dr;<br>                                int nc = c + dc;<br>                                if (nr &gt;= 0 &amp;&amp; nr &lt; height &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; width &amp;&amp; v[nr][nc] != null)<br>                                    if (nr % 2 == 0)<br>                                        addEdge(v[nr][nc], v[r][c]);<br>                                    else<br>                                        addEdge(vout[r][c], v[nr][nc]);<br>                            }<br>                } else {<br>                    if (r % 2 == 0) {<br>                        addEdge(s, v[r][c]);<br>                    } else {<br>                        addEdge(v[r][c], t);<br>                    }<br>                }<br>            }<br>        return maxFlow(s, t);<br>    }<br>    <br>    int curGen;<br>    Vertex t;<br> <br>    private int maxFlow(Vertex s, Vertex t) {<br>        this.t = t;<br>        curGen = 0;<br>        int res = 0;<br>        while (true) {<br>            ++curGen;<br>            if (dfs(s)) {<br>                ++res;<br>            } else break;<br>        }<br>        return res;<br>    }<br> <br>    private boolean dfs(Vertex at) {<br>        if (at == t) return true;<br>        if (at.generation == curGen) return false;<br>        at.generation = curGen;<br>        for (Edge e : at.adj) {<br>            if (e.cap &gt; 0) {<br>                if (dfs(e.dest)) {<br>                    --e.cap;<br>                    ++e.rev.cap;<br>                    return true;<br>                }<br>            }<br>        }<br>        return false;<br>    }<br> <br>    private void addEdge(Vertex a, Vertex b) {<br>        Edge ab = new Edge();<br>        Edge ba = new Edge();<br>        ab.dest = b;<br>        ab.cap = 1;<br>        ab.rev = ba;<br>        ba.dest = a;<br>        ba.cap = 0;<br>        ba.rev = ab;<br>        a.adj.add(ab);<br>        b.adj.add(ba);<br>    }<br>}<br></td>