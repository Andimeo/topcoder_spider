<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;  <br>#include &lt;string&gt;  <br>#include &lt;set&gt;  <br>#include &lt;map&gt;  <br>#include &lt;vector&gt;  <br>#include &lt;queue&gt;   <br>#include &lt;iostream&gt;  <br>#include &lt;iterator&gt;  <br>#include &lt;math.h&gt;  <br>#include &lt;cstdio&gt;  <br>#include &lt;cstdlib&gt;  <br>#include &lt;sstream&gt;  <br>#include &lt;ctime&gt;<br>#include &lt;cfloat&gt;<br><br>#pragma comment(linker, "/STACK:60777216")  <br><br>using namespace std;  <br><br>typedef pair&lt;int,int&gt; pii;  <br>typedef long long ll;  <br>typedef vector&lt;int&gt; vi;  <br>typedef pair&lt;double,double&gt; pdd;<br><br>#define UN(v) SORT(v),v.erase(unique(v.begin(),v.end()),v.end())  <br>#define SORT(c) sort((c).begin(),(c).end())  <br>#define FOR(i,a,b) for (int  i=(a); i &lt; (b); i++)   <br>#define REP(i,n) FOR(i,0,n)   <br>#define CL(a,b) memset(a,b,sizeof(a))  <br>#define pb push_back  <br><br><br>const int mod = 1000000009;<br><br>ll qp(ll c,ll st){<br>  ll r = 1;<br>  while(st){<br>    if(st&amp;1)r*=c,r%=mod;<br>    c*=c,c%=mod;<br>    st&gt;&gt;=1;<br>  }<br>  return r;<br>}<br><br>set&lt;int&gt; possible_w;<br><br>int incommon(vector &lt;string&gt; fragment, ll W, ll i0, ll j0){<br>  set&lt;ll&gt; pre_w;<br>  int n = fragment.size();<br>  int m = fragment[0].size();<br>  REP(i,n)REP(j,m){<br>    ll pos1 = (i+i0) * W + (j0+j);<br>    REP(i1,n)REP(j1,m){<br>      ll pos2 = (i1+i0) * W + (j0+j1);<br>      ll diff = pos2 - pos1;<br>      if(diff&gt;0){<br>        pre_w.insert(diff);<br>      }<br>    }<br>  }<br>  for(set&lt;ll&gt;::iterator it = pre_w.begin();it!=pre_w.end();it++){<br>    ll val = *it;<br>    for(ll i=1;i*i&lt;=val;i++)if(val%i==0){<br>      if(i&lt;=W) possible_w.insert(i);<br>      if(val/i&lt;=W &amp;&amp; i*i!=val) possible_w.insert(val/i);<br>    }<br>  }<br>  int res = 0;<br>  for(set&lt;int&gt;::iterator it = possible_w.begin();it!=possible_w.end();it++){<br>    int s = *it;<br>    map&lt;int,char&gt; ps;<br>    bool good = 1;<br>    REP(i,n)REP(j,m){<br>      ll _pos = (i+i0) * W + (j0+j);<br>      int pos = _pos % s;<br>      if(ps.count(pos)){<br>        if(ps[pos]!=fragment[i][j]) good=0;<br>      }else ps[pos] = fragment[i][j];<br>    }<br>    if(good){<br>      int diff = s - ps.size();<br>      res += qp(26, diff);<br>      if(res&gt;=mod) res-=mod;<br>    }<br>  }<br>  return res;<br>}<br><br>ll getSum(int n){<br>  if(n==0) return 1;<br>  ll res = 0;<br>  if(n%2==1){<br>    ll t = getSum(n/2);<br>    return t*(1+qp(26,n/2+1))%mod;<br>  }else{<br>    return (1 + 26 * getSum(n-1))%mod;<br>  }<br><br>  return res;<br>}<br><br>int disjoint(vector &lt;string&gt; fragment, ll W, ll i0, ll j0){<br>  vector&lt;pii&gt; seg;<br>  if(possible_w.size()==0) seg.pb(pii(1,W));<br>  else{<br>    int beg = *possible_w.begin();<br>    if(beg&gt;1) seg.pb(pii(1,beg-1));<br>    set&lt;int&gt;::iterator it = possible_w.end();<br>    it--;<br>    int end = *it;<br>    if(end&lt;W) seg.pb(pii(end+1,W));<br><br>    for(set&lt;int&gt;::iterator it = possible_w.begin();it!=possible_w.end();it++){<br>      set&lt;int&gt;::iterator it2 = it;<br>      it2++;<br>      if(it2==possible_w.end()) break;<br>      int v1 = *it;<br>      int v2 = *it2;<br>      if(v1+1&lt;=v2-1) seg.pb(pii(v1+1,v2-1));<br>    }<br>  }<br>  int res = 0;<br>  REP(i,seg.size()){<br>    //cout&lt;&lt;seg[i].first&lt;&lt;' '&lt;&lt;seg[i].second&lt;&lt;endl;<br>    int from = seg[i].first;<br>    int to = seg[i].second;<br>    int mn = fragment.size() * fragment[0].size();<br>    from=max(from,mn);<br>    if(from&lt;=to){<br>      from-=mn;<br>      to-=mn;<br><br>      ll t = qp(26,from);<br>      t *= getSum(to-from);<br>      t%=mod;<br>      res+=t;<br>      if(res&gt;=mod)res-=mod;<br>    }<br>  }<br>  return res;<br>}<br><br>class CharacterBoard {<br>public:<br>  int countGenerators(vector &lt;string&gt; fragment, int W, int i0, int j0) {<br>    int res = 0;possible_w.clear();<br>    res += incommon(fragment,W,i0,j0);<br>    res += disjoint(fragment,W,i0,j0);<br>    if(res&gt;=mod)res-=mod;    <br>    return res;<br>  }<br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.17 [modified TZTester]<br>// Powered by CodeProcessor<br></td>