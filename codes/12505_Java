<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Random;<br>import java.util.AbstractCollection;<br>import java.util.Collection;<br>import java.util.List;<br>import java.util.Map;<br>import java.util.Arrays;<br>import java.util.ArrayList;<br>import java.util.AbstractSet;<br>import java.util.Set;<br>import java.util.Iterator;<br>import java.util.AbstractMap;<br>import java.util.NoSuchElementException;<br>import java.math.BigInteger;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class CharacterBoard {<br>  static final long MOD = (long) (1e9 + 9);<br> <br>    public int countGenerators(String[] fragment, int W, int i0, int j0) {<br>    int rowCount = fragment.length;<br>    int columnCount = fragment[0].length();<br>    long answer = 0;<br>    if (W &gt;= rowCount * columnCount)<br>      answer = (IntegerUtils.power(26, W - rowCount * columnCount + 1, MOD) - 1) * BigInteger.valueOf(25).modInverse(BigInteger.valueOf(MOD)).longValue() % MOD;<br>    Set&lt;Long&gt; bad = new EHashSet&lt;Long&gt;();<br>    Set&lt;Long&gt; good = new EHashSet&lt;Long&gt;();<br>    for (int i = 0; i &lt; rowCount; i++) {<br>      for (int j = 0; j &lt; columnCount; j++) {<br>        long first = (long)i * W + j;<br>        for (int k = i; k &lt; rowCount; k++) {<br>          for (int l = (k == i ? j + 1 : 0); l &lt; columnCount; l++) {<br>            long second = (long) k * W + l;<br>            long delta = second - first;<br>            if (fragment[i].charAt(j) == fragment[k].charAt(l))<br>              good.add(delta);<br>            else<br>              bad.add(delta);<br>          }<br>        }<br>      }<br>    }<br>    Set&lt;Long&gt; allBad = new EHashSet&lt;Long&gt;();<br>    for (long i : bad) {<br>      for (long j = 1; j * j &lt;= i; j++) {<br>        if (i % j == 0) {<br>          allBad.add(j);<br>          allBad.add(i / j);<br>        }<br>      }<br>    }<br>    Set&lt;Long&gt; allGood = new EHashSet&lt;Long&gt;();<br>    for (long i : good) {<br>      if (allBad.contains(i))<br>        continue;<br>      for (long j = 1; j * j &lt;= i; j++) {<br>        if (i % j == 0) {<br>          if (!allBad.contains(j))<br>            allGood.add(j);<br>          if (!allBad.contains(i / j))<br>            allGood.add(i / j);<br>        }<br>      }<br>    }<br>    for (long i : allBad) {<br>      if (i &lt;= W &amp;&amp; i &gt;= rowCount * columnCount)<br>        answer -= IntegerUtils.power(26, i - rowCount * columnCount, MOD);<br>    }<br>    for (long i : allGood) {<br>      if (i &gt; W)<br>        continue;<br>      Set&lt;Long&gt; set = new EHashSet&lt;Long&gt;();<br>      for (int j = 0; j &lt; rowCount; j++) {<br>        for (int k = 0; k &lt; columnCount; k++)<br>          set.add(((long)j * W + k) % i);<br>      }<br>      answer += IntegerUtils.power(26, i - set.size(), MOD);<br>      if (i &gt;= rowCount * columnCount)<br>        answer -= IntegerUtils.power(26, i - rowCount * columnCount, MOD);<br>    }<br>    answer %= MOD;<br>    answer += MOD;<br>    answer %= MOD;<br>    return (int) answer;<br>    }<br>}<br> <br>class IntegerUtils {<br> <br>    public static long power(long base, long exponent, long mod) {<br>    if (base &gt;= mod)<br>      base %= mod;<br>    if (exponent == 0)<br>      return 1 % mod;<br>    long result = power(base, exponent &gt;&gt; 1, mod);<br>    result = result * result % mod;<br>    if ((exponent &amp; 1) != 0)<br>      result = result * base % mod;<br>    return result;<br>  }<br> <br>  }<br> <br>class EHashSet&lt;E&gt; extends AbstractSet&lt;E&gt; {<br>    private static final Object VALUE = new Object();<br>    private final Map&lt;E, Object&gt; map;<br> <br>  public EHashSet() {<br>    this(4);<br>  }<br> <br>  public EHashSet(int maxSize) {<br>    map = new EHashMap&lt;E, Object&gt;(maxSize);<br>  }<br> <br>  public EHashSet(Collection&lt;E&gt; collection) {<br>    this(collection.size());<br>    addAll(collection);<br>  }<br> <br>  public boolean contains(Object o) {<br>        return map.containsKey(o);<br>  }<br> <br>  public boolean add(E e) {<br>    if (e == null)<br>      return false;<br>    return map.put(e, VALUE) == null;<br>  }<br> <br>  public boolean remove(Object o) {<br>    if (o == null)<br>      return false;<br>    return map.remove(o) != null;<br>  }<br> <br>  public void clear() {<br>        map.clear();<br>  }<br> <br>  public Iterator&lt;E&gt; iterator() {<br>        return map.keySet().iterator();<br>  }<br> <br>  public int size() {<br>    return map.size();<br>  }<br>}<br> <br>abstract class IntList extends IntCollection {<br>  private static final int INSERTION_THRESHOLD = 8;<br> <br>  public abstract int get(int index);<br>  public abstract void set(int index, int value);<br> <br>  public IntIterator iterator() {<br>    return new IntIterator() {<br>      private int size = size();<br>      private int index = 0;<br> <br>      public int value() throws NoSuchElementException {<br>        if (!isValid())<br>          throw new NoSuchElementException();<br>        return get(index);<br>      }<br> <br>      public void advance() throws NoSuchElementException {<br>        if (!isValid())<br>          throw new NoSuchElementException();<br>        index++;<br>      }<br> <br>      public boolean isValid() {<br>        return index &lt; size;<br>      }<br>    };<br>  }<br> <br>  private void swap(int first, int second) {<br>    if (first == second)<br>      return;<br>    int temp = get(first);<br>    set(first, get(second));<br>    set(second, temp);<br>  }<br> <br>  public IntSortedList inPlaceSort(IntComparator comparator) {<br>    quickSort(0, size() - 1, size(), comparator);<br>    return new IntSortedArray(this, comparator);<br>  }<br> <br>  private void quickSort(int from, int to, int remaining, IntComparator comparator) {<br>    if (to - from &lt; INSERTION_THRESHOLD) {<br>      insertionSort(from, to, comparator);<br>      return;<br>    }<br>    if (remaining == 0) {<br>      heapSort(from, to, comparator);<br>      return;<br>    }<br>    remaining &gt;&gt;= 1;<br>    int pivotIndex = (from + to) &gt;&gt; 1;<br>    int pivot = get(pivotIndex);<br>    swap(pivotIndex, to);<br>    int storeIndex = from;<br>    int equalIndex = to;<br>    for (int i = from; i &lt; equalIndex; i++) {<br>      int value = comparator.compare(get(i), pivot);<br>      if (value &lt; 0)<br>        swap(storeIndex++, i);<br>      else if (value == 0)<br>        swap(--equalIndex, i--);<br>    }<br>    quickSort(from, storeIndex - 1, remaining, comparator);<br>    for (int i = equalIndex; i &lt;= to; i++)<br>      swap(storeIndex++, i);<br>    quickSort(storeIndex, to, remaining, comparator);<br>  }<br> <br>  private void heapSort(int from, int to, IntComparator comparator) {<br>    for (int i = (to + from - 1) &gt;&gt; 1; i &gt;= from; i--)<br>      siftDown(i, to, comparator, from);<br>    for (int i = to; i &gt; from; i--) {<br>      swap(from, i);<br>      siftDown(from, i - 1, comparator, from);<br>    }<br>  }<br> <br>  private void siftDown(int start, int end, IntComparator comparator, int delta) {<br>    int value = get(start);<br>    while (true) {<br>      int child = ((start - delta) &lt;&lt; 1) + 1 + delta;<br>      if (child &gt; end)<br>        return;<br>      int childValue = get(child);<br>      if (child + 1 &lt;= end) {<br>        int otherValue = get(child + 1);<br>        if (comparator.compare(otherValue, childValue) &gt; 0) {<br>          child++;<br>          childValue = otherValue;<br>        }<br>      }<br>      if (comparator.compare(value, childValue) &gt;= 0)<br>        return;<br>      swap(start, child);<br>      start = child;<br>    }<br>  }<br> <br>  private void insertionSort(int from, int to, IntComparator comparator) {<br>    for (int i = from + 1; i &lt;= to; i++) {<br>      int value = get(i);<br>      for (int j = i - 1; j &gt;= from; j--) {<br>        if (comparator.compare(get(j), value) &lt;= 0)<br>          break;<br>        swap(j, j + 1);<br>      }<br>    }<br>  }<br> <br>  public IntSortedList sort(IntComparator comparator) {<br>    return new IntArray(this).inPlaceSort(comparator);<br>  }<br> <br>  }<br> <br>abstract class IntCollection {<br>  public abstract IntIterator iterator();<br>  public abstract int size();<br> <br>  }<br> <br>class EHashMap&lt;E, V&gt; extends AbstractMap&lt;E, V&gt; {<br>  private static final int[] shifts = new int[10];<br> <br>  private int size;<br>  private HashEntry&lt;E, V&gt;[] data;<br>  private int capacity;<br>  private Set&lt;Entry&lt;E, V&gt;&gt; entrySet;<br> <br>  static {<br>    Random random = new Random(System.currentTimeMillis());<br>    for (int i = 0; i &lt; 10; i++)<br>      shifts[i] = 1 + 3 * i + random.nextInt(3);<br>  }<br> <br>  public EHashMap() {<br>    this(4);<br>  }<br> <br>  private void setCapacity(int size) {<br>    capacity = Integer.highestOneBit(4 * size);<br>        //noinspection unchecked<br>        data = new HashEntry[capacity];<br>  }<br> <br>  public EHashMap(int maxSize) {<br>    setCapacity(maxSize);<br>    entrySet = new AbstractSet&lt;Entry&lt;E, V&gt;&gt;() {<br>      @Override<br>      public Iterator&lt;Entry&lt;E, V&gt;&gt; iterator() {<br>        return new Iterator&lt;Entry&lt;E, V&gt;&gt;() {<br>          private HashEntry&lt;E, V&gt; last = null;<br>                    private HashEntry&lt;E, V&gt; current = null;<br>                    private HashEntry&lt;E, V&gt; base = null;<br>                    private int lastIndex = -1;<br>          private int index = -1;<br> <br>          public boolean hasNext() {<br>                        if (current == null) {<br>                            for (index++; index &lt; capacity; index++) {<br>                                if (data[index] != null) {<br>                                    base = current = data[index];<br>                                    break;<br>                                }<br>                            }<br>                        }<br>                        return current != null;<br>          }<br> <br>          public Entry&lt;E, V&gt; next() {<br>            if (!hasNext())<br>              throw new NoSuchElementException();<br>                        last = current;<br>                        lastIndex = index;<br>                        current = current.next;<br>                        if (base.next != last)<br>                            base = base.next;<br>            return last;<br>          }<br> <br>          public void remove() {<br>            if (last == null)<br>              throw new IllegalStateException();<br>                        size--;<br>                        if (base == last)<br>                            data[lastIndex] = last.next;<br>                        else<br>                            base.next = last.next;<br>          }<br>        };<br>      }<br> <br>      @Override<br>      public int size() {<br>        return size;<br>      }<br>    };<br>  }<br> <br>  public EHashMap(Map&lt;E, V&gt; map) {<br>    this(map.size());<br>    putAll(map);<br>  }<br> <br>  public Set&lt;Entry&lt;E, V&gt;&gt; entrySet() {<br>    return entrySet;<br>  }<br> <br>  public void clear() {<br>    Arrays.fill(data, null);<br>    size = 0;<br>  }<br> <br>  private int index(Object o) {<br>    return getHash(o.hashCode()) &amp; (capacity - 1);<br>  }<br> <br>  private int getHash(int h) {<br>    int result = h;<br>    for (int i : shifts)<br>      result ^= h &gt;&gt;&gt; i;<br>    return result;<br>  }<br> <br>  public V remove(Object o) {<br>    if (o == null)<br>      return null;<br>    int index = index(o);<br>        HashEntry&lt;E, V&gt; current = data[index];<br>        HashEntry&lt;E, V&gt; last = null;<br>        while (current != null) {<br>            if (current.key.equals(o)) {<br>                if (last == null)<br>                    data[index] = current.next;<br>                else<br>                    last.next = current.next;<br>                size--;<br>                return current.value;<br>            }<br>            last = current;<br>            current = current.next;<br>        }<br>        return null;<br>  }<br> <br>  public V put(E e, V value) {<br>    if (e == null)<br>      return null;<br>    int index = index(e);<br>        HashEntry&lt;E, V&gt; current = data[index];<br>        if (current != null) {<br>            while (true) {<br>                if (current.key.equals(e)) {<br>                    V oldValue = current.value;<br>                    current.value = value;<br>                    return oldValue;<br>                }<br>                if (current.next == null)<br>                    break;<br>                current = current.next;<br>            }<br>        }<br>        if (current == null)<br>            data[index] = new HashEntry&lt;E, V&gt;(e, value);<br>        else<br>            current.next = new HashEntry&lt;E, V&gt;(e, value);<br>        size++;<br>        if (2 * size &gt; capacity) {<br>            HashEntry&lt;E, V&gt;[] oldData = data;<br>            setCapacity(size);<br>            for (HashEntry&lt;E, V&gt; entry : oldData) {<br>                while (entry != null) {<br>                    HashEntry&lt;E, V&gt; next = entry.next;<br>                    index = index(entry.key);<br>                    entry.next = data[index];<br>                    data[index] = entry;<br>                    entry = next;<br>                }<br>            }<br>        }<br>    return null;<br>  }<br> <br>  public V get(Object o) {<br>    if (o == null)<br>      return null;<br>    int index = index(o);<br>        HashEntry&lt;E, V&gt; current = data[index];<br>    while (current != null) {<br>      if (current.key.equals(o))<br>                return current.value;<br>            current = current.next;<br>        }<br>    return null;<br>  }<br> <br>  public boolean containsKey(Object o) {<br>        if (o == null)<br>            return false;<br>        int index = index(o);<br>        HashEntry&lt;E, V&gt; current = data[index];<br>        while (current != null) {<br>            if (current.key.equals(o))<br>                return true;<br>            current = current.next;<br>        }<br>        return false;<br>  }<br> <br>  public int size() {<br>    return size;<br>  }<br> <br>  private static class HashEntry&lt;E, V&gt; implements Entry&lt;E, V&gt; {<br>    private final E key;<br>    private V value;<br>        private HashEntry&lt;E, V&gt; next;<br> <br>        private HashEntry(E key, V value) {<br>            this.key = key;<br>            this.value = value;<br>        }<br> <br> <br>        public E getKey() {<br>            return key;<br>        }<br> <br>        public V getValue() {<br>            return value;<br>        }<br> <br>        public V setValue(V value) {<br>            V oldValue = this.value;<br>            this.value = value;<br>            return oldValue;<br>        }<br>    }<br>}<br> <br>interface IntIterator {<br>  public int value() throws NoSuchElementException;<br>  /*<br>   * @throws NoSuchElementException only if iterator already invalid<br>   */<br>  public void advance() throws NoSuchElementException;<br>  public boolean isValid();<br>}<br> <br>interface IntComparator {<br>    public static final IntComparator DEFAULT = new IntComparator() {<br>        public int compare(int first, int second) {<br>            if (first &lt; second)<br>                return -1;<br>            if (first &gt; second)<br>                return 1;<br>            return 0;<br>        }<br>    };<br> <br>  public int compare(int first, int second);<br>}<br> <br>abstract class IntSortedList extends IntList {<br>  protected final IntComparator comparator;<br> <br>  protected IntSortedList(IntComparator comparator) {<br>    this.comparator = comparator;<br>  }<br> <br>  public void set(int index, int value) {<br>    throw new UnsupportedOperationException();<br>  }<br> <br>  public IntSortedList inPlaceSort(IntComparator comparator) {<br>    if (comparator == this.comparator)<br>      return this;<br>    throw new UnsupportedOperationException();<br>  }<br> <br>  public IntSortedList sort(IntComparator comparator) {<br>    if (comparator == this.comparator)<br>      return this;<br>    return super.sort(comparator);<br>  }<br> <br>  protected void ensureSorted() {<br>    int size = size();<br>    if (size == 0)<br>      return;<br>    int last = get(0);<br>    for (int i = 1; i &lt; size; i++) {<br>      int current = get(i);<br>      if (comparator.compare(last, current) &gt; 0)<br>        throw new IllegalArgumentException();<br>      last = current;<br>    }<br>  }<br> <br>  }<br> <br>class IntSortedArray extends IntSortedList {<br>  private final int[] array;<br> <br>  public IntSortedArray(int[] array) {<br>    this(array, IntComparator.DEFAULT);<br>  }<br> <br>  public IntSortedArray(IntCollection collection) {<br>    this(collection, IntComparator.DEFAULT);<br>  }<br> <br>  public IntSortedArray(int[] array, IntComparator comparator) {<br>    super(comparator);<br>    this.array = array;<br>    ensureSorted();<br>  }<br> <br>  public IntSortedArray(IntCollection collection, IntComparator comparator) {<br>    super(comparator);<br>    array = new int[collection.size()];<br>    int i = 0;<br>    for (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator.advance())<br>      array[i++] = iterator.value();<br>    ensureSorted();<br>  }<br> <br>  public int get(int index) {<br>    return array[index];<br>  }<br> <br>  public int size() {<br>    return array.length;<br>  }<br>}<br> <br>class IntArray extends IntList {<br>  private final int[] array;<br> <br>  public IntArray(int[] array) {<br>    this.array = array;<br>  }<br> <br>  public IntArray(IntCollection collection) {<br>    array = new int[collection.size()];<br>    int i = 0;<br>    for (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator.advance())<br>      array[i++] = iterator.value();<br>  }<br> <br>  public int get(int index) {<br>    return array[index];<br>  }<br> <br>  public void set(int index, int value) {<br>    array[index] = value;<br>  }<br> <br>  public int size() {<br>    return array.length;<br>  }<br> <br>  }<br></td>