<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br> <br>using namespace std;<br> <br>#define ZERO(x) memset(x,0,sizeof(x))<br> <br>bool can[2505][2505];<br> <br>int n;<br> <br>bool ok[55];<br> <br>void populate(vector&lt;string&gt; v) {<br>    for (int i = 0; i &lt; n; ++i) {<br>        for (int j = i + 1; j &lt; n; ++j) {<br> <br>            ZERO(ok);<br>            for (int k = 0; k &lt; n; ++k) {<br>                if (v[i][k] == 'Y' || v[j][k] == 'Y') {<br>                    ok[k] = true;<br>                }<br>            }<br>            for (int k = 0; k &lt; n; ++k) {<br>                for (int l = k; l &lt; n; ++l) {<br>                    if (ok[k] &amp;&amp; ok[l]) {<br>                        can[i * n + j][k * n + l] = true;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}<br> <br>int odeg[2505];<br> <br>int dp[2505];<br> <br>class ScotlandYard {<br>public:<br>    int maxMoves( vector &lt;string&gt; taxi, vector &lt;string&gt; bus, vector &lt;string&gt; metro ) {<br>        n = taxi.size();<br>        ZERO(can);<br>        populate(taxi);<br>        populate(bus);<br>        populate(metro);<br>        ZERO(odeg);<br>        ZERO(dp);<br>        for (int i = 0; i &lt; n * n; ++i) {<br>            for (int j = 0; j &lt; n * n; ++j) {<br>                odeg[i] += can[i][j];<br>            }<br>        }<br>        queue&lt;int&gt; q;<br>        for (int i = 0; i &lt; n; ++i) {<br>            for (int j = i; j &lt; n; ++j) {<br>                if (odeg[i * n + j] == 0) {<br>                    q.push(i * n + j);<br>                }<br>            }<br>        }<br>        while (!q.empty()) {<br>            int c = q.front();<br>            q.pop();<br>            for (int i = 0; i &lt; n * n; ++i) {<br>                if (can[i][c]) {<br>                    dp[i] = max(dp[i], dp[c] + 1);<br>                    if (--odeg[i] == 0) {<br>                        q.push(i);<br>                    }<br>                }<br>            }<br>        }<br>        int result = 0;<br>        for (int i = 0; i &lt; n; ++i) {<br>            for (int j = i + 1; j &lt; n; ++j) {<br>                if (odeg[i * n + j]) {<br>                    return -1;<br>                }<br>                result = max(result, dp[i * n + j]);<br>            }<br>        }<br>        return result;<br>    }<br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.17 [modified TZTester]<br> <br>// Powered by CodeProcessor<br></td>