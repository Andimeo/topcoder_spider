<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cassert&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdarg&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;numeric&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>using namespace std;<br> <br>#define ALL(c) (c).begin(), (c).end()<br>#define FOR(i, n) for (int i = 0; i &lt; (int)(n); ++i)<br>#define FOREACH(i, n) for (__typeof(n.begin()) i = n.begin(); i != n.end(); ++i)<br>#define MEMSET(p, c) memset(p, c, sizeof(p))<br>typedef long long llint;<br>typedef pair&lt;int, int&gt; PII;<br>#ifndef __WATASHI__<br>#define errf(fmt, ...) do { } while (false)<br>#endif<br> <br>struct DeerInZooDivOne {<br>  int getmax(vector &lt;int&gt; a, vector &lt;int&gt; b);<br>};<br> <br>const int MAXN = 54;<br> <br>vector&lt;int&gt; e[MAXN];<br>int dp[MAXN][MAXN];<br> <br>int parent[MAXN];<br>vector&lt;int&gt; child[MAXN];<br>vector&lt;int&gt; treea, treeb;<br> <br>template&lt;int MAXN, typename S&gt;<br>struct MinCostMaxFlow {<br>  struct NegativeCostCircuitExistsException {<br>  };<br> <br>  struct Edge {<br>    int v;<br>    bool c;<br>    S w;<br>    int b;<br>    Edge(int v, bool c, S w, int b) : v(v), c(c), w(w), b(b) { }<br>  };<br> <br>  int n, source, sink;<br>  vector&lt;Edge&gt; e[MAXN];<br> <br>  void init(int n, int source, int sink) {<br>    this-&gt;n = n;<br>    this-&gt;source = source;<br>    this-&gt;sink = sink;<br>    for (int i = 0; i &lt; n; ++i) {<br>      e[i].clear();<br>    }<br>  }<br> <br>  void addEdge(int a, int b, S w) {<br>    e[a].push_back(Edge(b, true, w, e[b].size()));<br>    e[b].push_back(Edge(a, false, -w, e[a].size() - 1));  // TODO<br>  }<br> <br>  bool mark[MAXN];<br>  S minw[MAXN];<br>  int dist[MAXN];<br>  Edge* prev[MAXN];<br> <br>  bool _spfa() {<br>    queue&lt;int&gt; q;<br>    fill(mark, mark + n, false);<br>    fill(minw, minw + n, numeric_limits&lt;S&gt;::max());<br>    fill(dist, dist + n, 0);<br>    fill(prev, prev + n, (Edge*)NULL);<br>    mark[source] = true;<br>    minw[source] = 0;<br> <br>    q.push(source);<br>    while (!q.empty()) {<br>      int cur = q.front();<br>      mark[cur] = false;<br>      q.pop();<br>      for (typename vector&lt;Edge&gt;::iterator it = e[cur].begin(); it != e[cur].end(); ++it) {<br>        if (!it-&gt;c) {<br>          continue;<br>        }<br>        int v = it-&gt;v;<br>        S w = minw[cur] + it-&gt;w;<br>        if (minw[v] &gt; w) { // TODO<br>          minw[v] = w;<br>          dist[v] = dist[cur] + 1;<br>          if (dist[v] &gt;= n) {<br>            return false;<br>          }<br>          prev[v] = &amp;*it;<br>          if (!mark[v]) {<br>            mark[v] = true;<br>            q.push(v);<br>          }<br>        }<br>      }<br>    }<br>    return true;<br>  }<br> <br>  pair&lt;int, S&gt; gao() {<br>    int sumc = 0;<br>    S sumw = 0;<br>    while (true) {<br>      if (!_spfa()) {<br>        throw NegativeCostCircuitExistsException();<br>      } else if (minw[sink] == numeric_limits&lt;S&gt;::max()) {<br>        break;<br>      } else {<br>        ++sumc;<br>        sumw += minw[sink];<br> <br>        int cur = sink;<br>        while (cur != source) {<br>          Edge* e1 = prev[cur];<br>          e1-&gt;c = false;<br>          Edge* e2 = &amp;e[e1-&gt;v][e1-&gt;b];<br>          e2-&gt;c = true;<br>          cur = e2-&gt;v;<br>        }<br>      }<br>    }<br>    return make_pair(sumc, sumw);<br>  }<br>};<br> <br>MinCostMaxFlow&lt;MAXN, int&gt; mcmf;<br> <br>int gao(int a, int b) {<br>  int&amp; ret = dp[a][b];<br>  if (ret == -1) {<br>    if (child[a].empty() || child[b].empty()) {<br>      ret = 1;<br>    } else {<br>      int na = child[a].size();<br>      int nb = child[b].size();<br>      vector&lt;vector&lt;int&gt; &gt; w(na, vector&lt;int&gt;(nb));<br>      FOR (i, na) {<br>        FOR (j, nb) {<br>          w[i][j] = gao(child[a][i], child[b][j]);<br>        }<br>      }<br>      int s = na + nb;<br>      int t = s + 1;<br>      mcmf.init(t + 1, s, t);<br>      FOR (i, na) {<br>        mcmf.addEdge(s, i, 0);<br>      }<br>      FOR (i, nb) {<br>        mcmf.addEdge(na + i, t, 0);<br>      }<br>      FOR (i, na) {<br>        FOR (j, nb) {<br>          mcmf.addEdge(i, na + j, -w[i][j]);<br>        }<br>      }<br>      ret = 1 - mcmf.gao().second;<br>    }<br>  }<br>  return ret;<br>}<br> <br>void dfs(int v, int p, vector&lt;int&gt;&amp; tree) {<br>  parent[v] = p;<br>  child[v].clear();<br>  tree.push_back(v);<br>  FOREACH (w, e[v]) {<br>    if (*w != p) {<br>      child[v].push_back(*w);<br>      dfs(*w, v, tree);<br>    }<br>  }<br>}<br> <br>int DeerInZooDivOne::getmax(vector &lt;int&gt; a, vector &lt;int&gt; b) {<br>  int n = a.size() + 1;<br>  int ans = 1;<br> <br>  // 50<br>  FOR (i, a.size()) {<br>    FOR (j, n) {<br>      e[j].clear();<br>    }<br>    FOR (j, a.size()) {<br>      if (i != j) {<br>        e[a[j]].push_back(b[j]);<br>        e[b[j]].push_back(a[j]);<br>      }<br>    }<br>    treea.clear();<br>    dfs(a[i], -1, treea);<br>    treeb.clear();<br>    dfs(b[i], -1, treeb);<br>    if (treea.size() &lt; treeb.size()) {<br>      treea.swap(treeb);<br>    }<br>    if ((int)treeb.size() &lt;= ans) {<br>      continue;<br>    }<br> <br>    // 25<br>    FOR (j, treeb.size()) {<br>      vector&lt;int&gt; dummy;<br>      dfs(treeb[j], -1, dummy);<br>      MEMSET(dp, 0xff);<br>      FOREACH (u, treea) {<br>        FOREACH (v, treeb) {<br>          ans = max(ans, gao(*u, *v));<br>        }<br>      }<br>    }<br>  }<br> <br>  return ans;<br>}<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>