<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cassert&gt;<br>using namespace std;<br>typedef long long ll;<br><br>#define REP(i,n) for (int i=0; i&lt;(int)(n); ++i)<br>#define FOR(i,k,n) for (int i=(k); i&lt;(int)(n); ++i)<br>#define FOREQ(i,k,n) for (int i=(k); i&lt;=(int)(n); ++i)<br>#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)<br>#define SZ(v) (int)((v).size())<br>#define MEMSET(v,h) memset((v),(h),sizeof(v))<br><br>int N;<br>int ord(int y, int x) { return y*N+x; }<br><br>int d[404][404];<br><br>class Block3Checkers {<br>public:<br>  int blockThem(vector &lt;string&gt; f) {<br>    N=SZ(f);<br>    vector&lt;int&gt; border;<br>    REP(i, N)   border.push_back(ord(0, i));<br>    REP(i, N-2) border.push_back(ord(i+1, N-1));<br>    REP(i, N)   border.push_back(ord(N-1, N-1-i));<br>    REP(i, N-2) border.push_back(ord(N-2-i, 0));<br><br>    int z = 0;<br>    REP(i, SZ(border)) if (f[border[i]/N][border[i]%N] == 'A') { z = i+1; break; }<br>    vector&lt;int&gt; bet[3];<br>    int bu = 0;<br>    REP(j, SZ(border)) {<br>      int i = (z+j)%SZ(border);<br>      //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;border[i]/N&lt;&lt;" "&lt;&lt;border[i]%N&lt;&lt;endl;<br>      if (f[border[i]/N][border[i]%N] == 'A') {<br>        ++bu;<br>        continue;<br>      }<br>      bet[bu].push_back(border[i]);<br>    }<br><br>    MEMSET(d, 0x0f);<br>    REP(i, N*N) d[i][i] = 0;<br>    REP(i, N*N) REP(j, N*N) if (i!=j &amp;&amp; abs(i/N - j/N)&lt;=1 &amp;&amp; abs(i%N - j%N)&lt;=1) {<br>      if (f[j/N][j%N]=='A') d[i][j] = 99999;<br>      if (f[j/N][j%N]=='N') d[i][j] = 0;<br>      if (f[j/N][j%N]=='.') d[i][j] = 1;<br>    }<br><br>    REP(k, N*N) REP(i, N*N) REP(j, N*N) {<br>      d[i][j] = min(d[i][j], d[i][k]+d[k][j]);<br>    }<br>    cout&lt;&lt;"!"&lt;&lt;d[ord(7,1)][ord(6,0)]&lt;&lt;endl;<br><br>    int ret = 100;<br><br>    // center<br>    REP(c, N*N) if (f[c/N][c%N]!='A') {<br>      int tmp = f[c/N][c%N]=='N' ? 0 : 1;<br>      REP(k, 3) {<br>        int t2 = 9999;<br>        FORIT(it, bet[k]) t2 = min(t2, d[c][*it]);<br>        tmp += t2;<br>      }<br>      ret = min(tmp, ret);<br>    }<br><br>    // cut<br><br>    // min dist between i and i+1<br>    int mm[3];<br>    MEMSET(mm, 0x0f);<br>    REP(i, 3) {<br>      int j = (i+1)%3;<br>      FORIT(it, bet[i])<br>      FORIT(jt, bet[j]) {<br>        int first = f[*it/N][*it%N]=='N' ? 0 : 1;<br>        mm[i] = min(mm[i], d[*it][*jt] + first);<br>      }<br>    }<br>    cout&lt;&lt;"mm:";<br>    REP(i, 3) cout&lt;&lt;mm[i]&lt;&lt;" ";<br>    cout&lt;&lt;endl;<br><br>    sort(mm, mm+3);<br>    ret = min(ret, mm[0]+mm[1]);<br><br>    return ret;<br>  }<br>};<br><br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] : &lt;cafelier&amp;naoya_t&gt;-custom<br>// Powered by CodeProcessor<br></td>