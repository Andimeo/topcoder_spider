<td class="problemText" colspan="8" valign="middle" align="left">
            /*<br> * SRM 580 Div2 Hard<br> * Author: Andy Y.F. Huang<br> */<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;cassert&gt;<br>#include &lt;cctype&gt;<br>#include &lt;climits&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;ctime&gt;<br>#include &lt;complex&gt;<br>#include &lt;deque&gt;<br>#include &lt;fstream&gt;<br>#include &lt;functional&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br>#include &lt;limits&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;numeric&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;valarray&gt;<br>#include &lt;vector&gt;<br> <br>#ifdef AZN<br>#include "Azn.cpp"<br>#endif<br> <br>using namespace std;<br> <br>struct WallGameDiv2 {<br>  int play(vector &lt;string&gt; costs);<br>} ;<br> <br>int cost[55][55];<br>int dp[55][55];//-1 not possible<br>int rows, cols;<br> <br>int WallGameDiv2::play(vector &lt;string&gt; costs) {<br>  memset(cost, -1, sizeof (cost));<br>  rows = costs.size();<br>  cols = costs[0].size();<br>  for (int r = 1; r &lt;= rows; r++)<br>    for (int c = 1; c &lt;= cols; c++)<br>      if (costs[r - 1][c - 1] != 'x')<br>        cost[r][c] = costs[r - 1][c - 1] - '0';<br>  memset(dp, -1, sizeof (dp));<br>  dp[1][1] = 0;<br>  for (int c = 2; c &lt;= cols &amp;&amp; cost[1][c] != -1; c++)<br>    dp[1][c] = dp[1][c - 1] + cost[1][c];<br>  for (int r = 2; r &lt; rows; r++) {<br>    for (int c = 1; c &lt;= cols; c++) {<br>      if (dp[r - 1][c] == -1) continue;<br>      int sum = dp[r - 1][c];<br>      //go left<br>      for (int cc = c; cc &gt;= 1 &amp;&amp; cost[r][cc] != -1; cc--) {<br>        sum += cost[r][cc];<br>        dp[r][cc] = max(dp[r][cc], sum);<br>      }<br>      //go right<br>      sum = dp[r - 1][c];<br>      for (int cc = c; cc &lt;= cols &amp;&amp; cost[r][cc] != -1; cc++) {<br>        sum += cost[r][cc];<br>        dp[r][cc] = max(dp[r][cc], sum);<br>      }<br>    }<br>  }<br>  int res = 0;<br>  for (int c = 1; c &lt;= cols; c++)<br>    if (cost[rows][c] != -1)<br>      res = max(res, dp[rows - 1][c] + cost[rows][c]);<br>  return res;<br>}<br> <br> <br> <br>//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!<br></td>