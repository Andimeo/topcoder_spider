<td class="problemText" colspan="8" valign="middle" align="left">
            #define NDEBUG<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;cassert&gt;<br>#include &lt;cctype&gt;<br>#include &lt;climits&gt;<br>#include &lt;cmath&gt;<br>#include &lt;complex&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;ctime&gt;<br>#include &lt;deque&gt;<br>#include &lt;fstream&gt;<br>#include &lt;functional&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br>#include &lt;limits&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;numeric&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>const int RC_MAX = 15, SUB_MAX = (1 &lt;&lt; 13) + 5, INF = 1000000005;<br> <br>int R, C;<br>bool cell[RC_MAX][RC_MAX], save[RC_MAX][RC_MAX];<br> <br>void flip(int r, int c)<br>{<br>    cell[r][c] = !cell[r][c];<br>}<br> <br>void type1(int r, int c)<br>{<br>    flip(r - 1, c);<br>    flip(r + 1, c);<br>    flip(r, c - 1);<br>    flip(r, c + 1);<br>}<br> <br>void type2(int r, int c)<br>{<br>    flip(r, c);<br>    type1(r, c);<br>}<br> <br>void move(int type, int r, int c)<br>{<br>    if (type == 1)<br>        type1(r, c);<br>    else<br>        type2(r, c);<br>}<br> <br>int solve(int mask, int on_mask)<br>{<br>    memcpy(cell, save, sizeof(cell));<br>    int moves = 0;<br> <br>    for (int r = 1; r &lt;= R; r++)<br>        for (int c = 1, types = 0; c &lt;= C; c++)<br>        {<br>            int type = (mask &amp; 1 &lt;&lt; (c - 1)) == 0 ? 1 : 2;<br> <br>            if (r == 1)<br>            {<br>                if (on_mask &amp; 1 &lt;&lt; (c - 1))<br>                {<br>                    move(type, r, c);<br>                    moves++;<br>                    types |= type;<br>                }<br>            }<br>            else if (cell[r - 1][c])<br>            {<br>                move(type, r, c);<br>                moves++;<br>                types |= type;<br>            }<br> <br>            if (types == 3)<br>                return INF;<br>        }<br> <br>    for (int c = 1; c &lt;= C; c++)<br>        if (cell[R][c])<br>            return INF;<br> <br>    return moves;<br>}<br> <br>// 0 bits: type 1; 1 bits: type 2<br>int column_mask(int mask)<br>{<br>    int best = INF;<br> <br>    for (int on_mask = mask; ; on_mask = (on_mask - 1) &amp; mask)<br>    {<br>        best = min(best, solve(mask, on_mask));<br> <br>        if (on_mask == 0)<br>            break;<br>    }<br> <br>    int other_mask = (1 &lt;&lt; C) - 1 - mask;<br> <br>    for (int on_mask = other_mask; ; on_mask = (on_mask - 1) &amp; other_mask)<br>    {<br>        best = min(best, solve(mask, on_mask));<br> <br>        if (on_mask == 0)<br>            break;<br>    }<br> <br>    return best;<br>}<br> <br>struct YetAnotherBoardGame<br>{<br>    int minimumMoves(vector&lt;string&gt; board)<br>    {<br>        R = board.size();<br>        C = board[0].length();<br> <br>        for (int i = 0; i &lt; R; i++)<br>            for (int j = 0; j &lt; C; j++)<br>                cell[i + 1][j + 1] = board[i][j] == 'W';<br> <br>        memcpy(save, cell, sizeof(cell));<br>        int best = INF;<br> <br>        for (int mask = 0; mask &lt; 1 &lt;&lt; C; mask++)<br>            best = min(best, column_mask(mask));<br> <br>        return best &lt; INF ? best : -1;<br>    }<br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.17pre2 [modified TZTester]<br>// Powered by CodeProcessor<br></td>