<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;ctime&gt;<br>#include &lt;string&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;cassert&gt;<br>#include &lt;stack&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br> <br>using namespace std;<br> <br>#define pb               push_back<br>#define mp              make_pair<br>#define fill(a,v)           memset(a, v, sizeof a)<br>#define INF              (int)1e9<br> <br>typedef vector&lt;int&gt; VI;<br>typedef long long LL;<br>typedef pair&lt;int, int &gt; PII;<br> <br> <br>VI splitInt(string s)<br>{<br>  s+=(' ');<br>  int n=s.size();<br>  int cur=0;<br>  VI ret;<br>  for(int i=0;i&lt;n;i++)<br>    if(s[i]==' ')<br>    {<br>      int z=0;<br>      bool neg=false;<br>      if(s[cur]=='-')  neg=true;<br>      if(s[cur]=='-' || s[cur]=='+') cur++;<br>        <br>      for(int j=cur;j&lt;i;j++)<br>        z=z*10+s[j]-'0';<br>      if(neg) z=-z;      <br>      ret.pb(z);<br>      cur=i+1;<br>    }<br>  return ret;<br>}<br> <br>int N;<br>int d1[305][305];<br>int d2[305][305];<br> <br>int cnt1[10];<br>int cnt2[10];<br> <br>class TreeUnion <br>{<br>public:<br> <br> <br>double expectedCycles(vector &lt;string&gt; tree1, vector &lt;string&gt; tree2, int K) <br>{<br>  string t1="";<br>  for(int i=0;i&lt;tree1.size();i++) t1+=tree1[i];<br>  string t2="";<br>  for(int i=0;i&lt;tree2.size();i++) t2+=tree2[i];<br>  <br>  VI a1 = splitInt(t1);<br>  VI a2 = splitInt(t2);<br>  N=a1.size() + 1;<br>  <br>  for(int i=0;i&lt;N;i++) {<br>    for(int j=0;j&lt;N;j++) {<br>      if(i==j) {<br>        d1[i][j]=0;<br>        d2[i][j]=0;<br>      } else {<br>        d1[i][j]=INF;<br>        d2[i][j]=INF;<br>      }<br>    }<br>  }<br>  <br>  for(int i=0; i&lt;a1.size(); i++) {<br>    d1[a1[i]][i+1]=1;<br>    d1[i+1][a1[i]]=1;<br>    <br>    d2[a2[i]][i+1]=1;<br>    d2[i+1][a2[i]]=1;<br>  }<br>  <br>  for(int i=0;i&lt;N;i++) {<br>    for(int j=0;j&lt;N;j++) {<br>      for(int k=0;k&lt;N;k++) {<br>        d1[j][k] = min(d1[j][k], d1[j][i] + d1[i][k]);<br>        d2[j][k] = min(d2[j][k], d2[j][i] + d2[i][k]);<br>      }<br>    }<br>  }<br>    <br>  fill(cnt1,0);<br>  fill(cnt2,0);<br>  <br>  for(int i=0;i&lt;N;i++) {<br>    for(int j=0; j&lt;N; j++) {<br>      int z1 = d1[i][j];<br>      int z2 = d2[i][j];<br>      if(z1&lt;10) cnt1[z1]++;<br>      if(z2&lt;10) cnt2[z2]++;<br>    }<br>  }<br>    <br>  double ans = 0;<br>  for(int a=1; a&lt;=6; a++) {<br>    for(int b=1; b&lt;=6; b++) {<br>      if(a+1+b+1 != K) continue;<br>        <br>      ans = ans + cnt1[a] * (cnt2[b] / (N * 1.0 * (N-1)));<br>    }<br>  }<br>  <br>  return ans/2;  <br>}<br> <br> <br> <br>};<br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!<br></td>