<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br>import java.util.Comparator;<br>import java.util.NoSuchElementException;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class SpaceWarDiv1 {<br>    public long minimalFatigue(int[] magicalGirlStrength, int[] enemyStrength, long[] enemyCount) {<br>    int count = magicalGirlStrength.length;<br>    Arrays.sort(magicalGirlStrength);<br>    ArrayUtils.reverse(magicalGirlStrength);<br>    int[] order = ArrayUtils.order(enemyStrength);<br>    ArrayUtils.reverse(order);<br>    long answer = 0;<br>    int j = 0;<br>    long current = 0;<br>    for (int i = 0; i &lt; count; i++) {<br>      while (j &lt; order.length &amp;&amp; enemyStrength[order[j]] &gt; magicalGirlStrength[i])<br>        current += enemyCount[order[j++]];<br>      if (i == 0 &amp;&amp; current != 0)<br>        return -1;<br>      if (i != 0)<br>        answer = Math.max(answer, (current + i - 1) / i);<br>    }<br>    while (j &lt; order.length)<br>      current += enemyCount[order[j++]];<br>    answer = Math.max(answer, (current + count - 1) / count);<br>    return answer;<br>  }<br>}<br> <br>class ArrayUtils {<br> <br>  public static int[] createOrder(int size) {<br>    int[] order = new int[size];<br>    for (int i = 0; i &lt; size; i++)<br>      order[i] = i;<br>    return order;<br>  }<br> <br>  public static int[] sort(int[] array, IntComparator comparator) {<br>    return sort(array, 0, array.length, comparator);<br>  }<br> <br>  public static int[] sort(int[] array, int from, int to, IntComparator comparator) {<br>    new IntArray(array).subList(from, to).inPlaceSort(comparator);<br>//    ensureCapacityInt(to - from);<br>//    System.arraycopy(array, from, tempInt, 0, to - from);<br>//    sortImpl(array, from, to, tempInt, 0, to - from, comparator);<br>    return array;<br>  }<br> <br>  public static int[] order(final int[] array) {<br>    return sort(createOrder(array.length), new IntComparator() {<br>      public int compare(int first, int second) {<br>        if (array[first] &lt; array[second])<br>          return -1;<br>        if (array[first] &gt; array[second])<br>          return 1;<br>        return 0;<br>      }<br>    });<br>  }<br> <br>  public static void reverse(int[] array) {<br>    for (int i = 0, j = array.length - 1; i &lt; j; i++, j--) {<br>      int temp = array[i];<br>      array[i] = array[j];<br>      array[j] = temp;<br>    }<br>  }<br> <br>  }<br> <br>interface IntComparator {<br>    public static final IntComparator DEFAULT = new IntComparator() {<br>        public int compare(int first, int second) {<br>            if (first &lt; second)<br>                return -1;<br>            if (first &gt; second)<br>                return 1;<br>            return 0;<br>        }<br>    };<br> <br>  public int compare(int first, int second);<br>}<br> <br>abstract class IntList extends IntCollection implements Comparable&lt;IntList&gt; {<br>  private static final int INSERTION_THRESHOLD = 8;<br> <br>  public abstract int get(int index);<br>  public abstract void set(int index, int value);<br> <br>  public IntIterator iterator() {<br>    return new IntIterator() {<br>      private int size = size();<br>      private int index = 0;<br> <br>      public int value() throws NoSuchElementException {<br>        if (!isValid())<br>          throw new NoSuchElementException();<br>        return get(index);<br>      }<br> <br>      public void advance() throws NoSuchElementException {<br>        if (!isValid())<br>          throw new NoSuchElementException();<br>        index++;<br>      }<br> <br>      public boolean isValid() {<br>        return index &lt; size;<br>      }<br>    };<br>  }<br> <br>  public IntList subList(final int from, final int to) {<br>    return new SubList(from, to);<br>  }<br> <br>  private void swap(int first, int second) {<br>    if (first == second)<br>      return;<br>    int temp = get(first);<br>    set(first, get(second));<br>    set(second, temp);<br>  }<br> <br>  public IntSortedList inPlaceSort(IntComparator comparator) {<br>    quickSort(0, size() - 1, size(), comparator);<br>    return new IntSortedArray(this, comparator);<br>  }<br> <br>  private void quickSort(int from, int to, int remaining, IntComparator comparator) {<br>    if (to - from &lt; INSERTION_THRESHOLD) {<br>      insertionSort(from, to, comparator);<br>      return;<br>    }<br>    if (remaining == 0) {<br>      heapSort(from, to, comparator);<br>      return;<br>    }<br>    remaining &gt;&gt;= 1;<br>    int pivotIndex = (from + to) &gt;&gt; 1;<br>    int pivot = get(pivotIndex);<br>    swap(pivotIndex, to);<br>    int storeIndex = from;<br>    int equalIndex = to;<br>    for (int i = from; i &lt; equalIndex; i++) {<br>      int value = comparator.compare(get(i), pivot);<br>      if (value &lt; 0)<br>        swap(storeIndex++, i);<br>      else if (value == 0)<br>        swap(--equalIndex, i--);<br>    }<br>    quickSort(from, storeIndex - 1, remaining, comparator);<br>    for (int i = equalIndex; i &lt;= to; i++)<br>      swap(storeIndex++, i);<br>    quickSort(storeIndex, to, remaining, comparator);<br>  }<br> <br>  private void heapSort(int from, int to, IntComparator comparator) {<br>    for (int i = (to + from - 1) &gt;&gt; 1; i &gt;= from; i--)<br>      siftDown(i, to, comparator, from);<br>    for (int i = to; i &gt; from; i--) {<br>      swap(from, i);<br>      siftDown(from, i - 1, comparator, from);<br>    }<br>  }<br> <br>  private void siftDown(int start, int end, IntComparator comparator, int delta) {<br>    int value = get(start);<br>    while (true) {<br>      int child = ((start - delta) &lt;&lt; 1) + 1 + delta;<br>      if (child &gt; end)<br>        return;<br>      int childValue = get(child);<br>      if (child + 1 &lt;= end) {<br>        int otherValue = get(child + 1);<br>        if (comparator.compare(otherValue, childValue) &gt; 0) {<br>          child++;<br>          childValue = otherValue;<br>        }<br>      }<br>      if (comparator.compare(value, childValue) &gt;= 0)<br>        return;<br>      swap(start, child);<br>      start = child;<br>    }<br>  }<br> <br>  private void insertionSort(int from, int to, IntComparator comparator) {<br>    for (int i = from + 1; i &lt;= to; i++) {<br>      int value = get(i);<br>      for (int j = i - 1; j &gt;= from; j--) {<br>        if (comparator.compare(get(j), value) &lt;= 0)<br>          break;<br>        swap(j, j + 1);<br>      }<br>    }<br>  }<br> <br>  public int hashCode() {<br>    int hashCode = 1;<br>    for (IntIterator i = iterator(); i.isValid(); i.advance())<br>      hashCode = 31 * hashCode + i.value();<br>    return hashCode;<br>  }<br> <br>  public boolean equals(Object obj) {<br>    if (!(obj instanceof IntList))<br>      return false;<br>    IntList list = (IntList)obj;<br>    if (list.size() != size())<br>      return false;<br>    IntIterator i = iterator();<br>    IntIterator j = list.iterator();<br>    while (i.isValid()) {<br>      if (i.value() != j.value())<br>        return false;<br>      i.advance();<br>      j.advance();<br>    }<br>    return true;<br>  }<br> <br>  public int compareTo(IntList o) {<br>    IntIterator i = iterator();<br>    IntIterator j = o.iterator();<br>    while (true) {<br>      if (i.isValid()) {<br>        if (j.isValid()) {<br>          if (i.value() != j.value()) {<br>            if (i.value() &lt; j.value())<br>              return -1;<br>            else<br>              return 1;<br>          }<br>        } else<br>          return 1;<br>      } else {<br>        if (j.isValid())<br>          return -1;<br>        else<br>          return 0;<br>      }<br>      i.advance();<br>      j.advance();<br>    }<br>  }<br> <br>  private class SubList extends IntList {<br>        private final int to;<br>        private final int from;<br>        private int size;<br> <br>        public SubList(int from, int to) {<br>            this.to = to;<br>            this.from = from;<br>            size = to - from;<br>        }<br> <br>        public int get(int index) {<br>            if (index &lt; 0 || index &gt;= size)<br>                throw new IndexOutOfBoundsException();<br>            return IntList.this.get(index + from);<br>        }<br> <br>        public void set(int index, int value) {<br>            if (index &lt; 0 || index &gt;= size)<br>                throw new IndexOutOfBoundsException();<br>            IntList.this.set(index + from, value);<br>        }<br> <br>        public int size() {<br>            return size;<br>        }<br> <br>        }<br>}<br> <br>abstract class IntSortedList extends IntList {<br>  protected final IntComparator comparator;<br> <br>  protected IntSortedList(IntComparator comparator) {<br>    this.comparator = comparator;<br>  }<br> <br>  public void set(int index, int value) {<br>    throw new UnsupportedOperationException();<br>  }<br> <br>  public IntSortedList inPlaceSort(IntComparator comparator) {<br>    if (comparator == this.comparator)<br>      return this;<br>    throw new UnsupportedOperationException();<br>  }<br> <br>  protected void ensureSorted() {<br>    int size = size();<br>    if (size == 0)<br>      return;<br>    int last = get(0);<br>    for (int i = 1; i &lt; size; i++) {<br>      int current = get(i);<br>      if (comparator.compare(last, current) &gt; 0)<br>        throw new IllegalArgumentException();<br>      last = current;<br>    }<br>  }<br> <br>  public IntSortedList subList(final int from, final int to) {<br>    return new IntSortedList(comparator) {<br>      private int size = to - from;<br> <br>      @Override<br>      public int get(int index) {<br>        if (index &lt; 0 || index &gt;= size)<br>          throw new IndexOutOfBoundsException();<br>        return IntSortedList.this.get(index + from);<br>      }<br> <br>      @Override<br>      public int size() {<br>        return size;<br>      }<br>    };<br>  }<br>}<br> <br>class IntArray extends IntList {<br>  private final int[] array;<br> <br>  public IntArray(int[] array) {<br>    this.array = array;<br>  }<br> <br>  public IntArray(IntCollection collection) {<br>    array = new int[collection.size()];<br>    int i = 0;<br>    for (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator.advance())<br>      array[i++] = iterator.value();<br>  }<br> <br>  public int get(int index) {<br>    return array[index];<br>  }<br> <br>  public void set(int index, int value) {<br>    array[index] = value;<br>  }<br> <br>  public int size() {<br>    return array.length;<br>  }<br> <br>  }<br> <br>abstract class IntCollection {<br>  public abstract IntIterator iterator();<br>  public abstract int size();<br> <br>  }<br> <br>interface IntIterator {<br>  public int value() throws NoSuchElementException;<br>  /*<br>   * @throws NoSuchElementException only if iterator already invalid<br>   */<br>  public void advance() throws NoSuchElementException;<br>  public boolean isValid();<br>}<br> <br>class IntSortedArray extends IntSortedList {<br>  private final int[] array;<br> <br>  public IntSortedArray(int[] array) {<br>    this(array, IntComparator.DEFAULT);<br>  }<br> <br>  public IntSortedArray(IntCollection collection) {<br>    this(collection, IntComparator.DEFAULT);<br>  }<br> <br>  public IntSortedArray(int[] array, IntComparator comparator) {<br>    super(comparator);<br>    this.array = array;<br>    ensureSorted();<br>  }<br> <br>  public IntSortedArray(IntCollection collection, IntComparator comparator) {<br>    super(comparator);<br>    array = new int[collection.size()];<br>    int i = 0;<br>    for (IntIterator iterator = collection.iterator(); iterator.isValid(); iterator.advance())<br>      array[i++] = iterator.value();<br>    ensureSorted();<br>  }<br> <br>  public int get(int index) {<br>    return array[index];<br>  }<br> <br>  public int size() {<br>    return array.length;<br>  }<br>}<br></td>