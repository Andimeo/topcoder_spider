<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Iterator;<br>import java.util.Arrays;<br>import java.util.NoSuchElementException;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class TurnOnLamps {<br>  int answer;<br>  Graph graph;<br>  boolean[] init;<br>  boolean[] important;<br> <br>    public int minimize(int[] roads, String initState, String isImportant) {<br>    answer = 0;<br>    int count = roads.length + 1;<br>    init = new boolean[count - 1];<br>    important = new boolean[count - 1];<br>    int[] to = new int[count - 1];<br>    for (int i = 0; i &lt; count - 1; i++) {<br>      init[i] = initState.charAt(i) == '1';<br>      important[i] = isImportant.charAt(i) == '1';<br>      to[i] = i + 1;<br>    }<br>    graph = Graph.createGraph(count, roads, to);<br>    if (go(0, -1))<br>      answer++;<br>    return answer;<br>    }<br> <br>  private boolean go(int vertex, int last) {<br>    int id = graph.firstOutbound(vertex);<br>    int looseEnds = 0;<br>    while (id != -1) {<br>      int next = graph.destination(id);<br>      if (next != last) {<br>        boolean end = go(next, vertex);<br>        if (important[id]) {<br>          if (init[id]) {<br>            if (end)<br>              answer++;<br>            end = false;<br>          } else<br>            end = true;<br>        }<br>        if (end)<br>          looseEnds++;<br>      }<br>      id = graph.nextOutbound(id);<br>    }<br>    answer += looseEnds &gt;&gt; 1;<br>    return (looseEnds &amp; 1) != 0;<br>  }<br>}<br> <br>class Graph {<br>  public static final int REMOVED_BIT = 0;<br> <br>  protected int vertexCount;<br>  protected int edgeCount;<br> <br>  private int[] firstOutbound;<br>  private int[] firstInbound;<br> <br>  private Edge[] edges;<br>  private int[] nextInbound;<br>  private int[] nextOutbound;<br>  private int[] from;<br>  private int[] to;<br>  private long[] weight;<br>  private long[] capacity;<br>  private int[] reverseEdge;<br>  private int[] flags;<br> <br>  public Graph(int vertexCount) {<br>    this(vertexCount, vertexCount);<br>  }<br> <br>  public Graph(int vertexCount, int edgeCapacity) {<br>    this.vertexCount = vertexCount;<br>    firstOutbound = new int[vertexCount];<br>    Arrays.fill(firstOutbound, -1);<br> <br>    from = new int[edgeCapacity];<br>    to = new int[edgeCapacity];<br>    nextOutbound = new int[edgeCapacity];<br>    flags = new int[edgeCapacity];<br>  }<br> <br>  public static Graph createGraph(int vertexCount, int[] from, int[] to) {<br>    Graph graph = new Graph(vertexCount, from.length);<br>    for (int i = 0; i &lt; from.length; i++)<br>      graph.addSimpleEdge(from[i], to[i]);<br>    return graph;<br>  }<br> <br>  public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {<br>    ensureEdgeCapacity(edgeCount + 1);<br>    if (firstOutbound[fromID] != -1)<br>      nextOutbound[edgeCount] = firstOutbound[fromID];<br>    else<br>      nextOutbound[edgeCount] = -1;<br>    firstOutbound[fromID] = edgeCount;<br>    if (firstInbound != null) {<br>      if (firstInbound[toID] != -1)<br>        nextInbound[edgeCount] = firstInbound[toID];<br>      else<br>        nextInbound[edgeCount] = -1;<br>      firstInbound[toID] = edgeCount;<br>    }<br>    this.from[edgeCount] = fromID;<br>    this.to[edgeCount] = toID;<br>    if (capacity != 0) {<br>      if (this.capacity == null)<br>        this.capacity = new long[from.length];<br>      this.capacity[edgeCount] = capacity;<br>    }<br>    if (weight != 0) {<br>      if (this.weight == null)<br>        this.weight = new long[from.length];<br>      this.weight[edgeCount] = weight;<br>    }<br>    if (reverseEdge != -1) {<br>      if (this.reverseEdge == null) {<br>        this.reverseEdge = new int[from.length];<br>        Arrays.fill(this.reverseEdge, 0, edgeCount, -1);<br>      }<br>      this.reverseEdge[edgeCount] = reverseEdge;<br>    }<br>    if (edges != null)<br>      edges[edgeCount] = createEdge(edgeCount);<br>    return edgeCount++;<br>  }<br> <br>  protected final GraphEdge createEdge(int id) {<br>    return new GraphEdge(id);<br>  }<br> <br>  public final int addFlowWeightedEdge(int from, int to, long weight, long capacity) {<br>    if (capacity == 0) {<br>      return addEdge(from, to, weight, 0, -1);<br>    } else {<br>      int lastEdgeCount = edgeCount;<br>      addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());<br>      return addEdge(from, to, weight, capacity, lastEdgeCount);<br>    }<br>  }<br> <br>  protected int entriesPerEdge() {<br>    return 1;<br>  }<br> <br>  public final int addWeightedEdge(int from, int to, long weight) {<br>    return addFlowWeightedEdge(from, to, weight, 0);<br>  }<br> <br>  public final int addSimpleEdge(int from, int to) {<br>    return addWeightedEdge(from, to, 0);<br>  }<br> <br>  public final int firstOutbound(int vertex) {<br>    int id = firstOutbound[vertex];<br>    while (id != -1 &amp;&amp; isRemoved(id))<br>      id = nextOutbound[id];<br>    return id;<br>  }<br> <br>  public final int nextOutbound(int id) {<br>    id = nextOutbound[id];<br>    while (id != -1 &amp;&amp; isRemoved(id))<br>      id = nextOutbound[id];<br>    return id;<br>  }<br> <br>  public final int destination(int id) {<br>    return to[id];<br>  }<br> <br>  public final boolean flag(int id, int bit) {<br>    return (flags[id] &gt;&gt; bit &amp; 1) != 0;<br>  }<br> <br>  public final boolean isRemoved(int id) {<br>    return flag(id, REMOVED_BIT);<br>  }<br> <br>  protected void ensureEdgeCapacity(int size) {<br>    if (from.length &lt; size) {<br>      int newSize = Math.max(size, 2 * from.length);<br>      if (edges != null)<br>        edges = resize(edges, newSize);<br>      from = resize(from, newSize);<br>      to = resize(to, newSize);<br>      nextOutbound = resize(nextOutbound, newSize);<br>      if (nextInbound != null)<br>        nextInbound = resize(nextInbound, newSize);<br>      if (weight != null)<br>        weight = resize(weight, newSize);<br>      if (capacity != null)<br>        capacity = resize(capacity, newSize);<br>      if (reverseEdge != null)<br>        reverseEdge = resize(reverseEdge, newSize);<br>      flags = resize(flags, newSize);<br>    }<br>  }<br> <br>  protected final int[] resize(int[] array, int size) {<br>    int[] newArray = new int[size];<br>    System.arraycopy(array, 0, newArray, 0, array.length);<br>    return newArray;<br>  }<br> <br>  private long[] resize(long[] array, int size) {<br>    long[] newArray = new long[size];<br>    System.arraycopy(array, 0, newArray, 0, array.length);<br>    return newArray;<br>  }<br> <br>  private Edge[] resize(Edge[] array, int size) {<br>    Edge[] newArray = new Edge[size];<br>    System.arraycopy(array, 0, newArray, 0, array.length);<br>    return newArray;<br>  }<br> <br>  protected class GraphEdge implements Edge {<br>    protected int id;<br> <br>    protected GraphEdge(int id) {<br>      this.id = id;<br>    }<br> <br>    }<br> <br>  }<br> <br>interface Edge {<br>  }<br></td>