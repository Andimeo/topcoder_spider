<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class Excavations {<br>    public long count(int[] kind, int[] depth, int[] found, int K) {<br>        int maxDepth = 0;<br>        for (int x : depth) maxDepth = Math.max(maxDepth, x);<br>        int maxKind = 0;<br>        for (int x : kind) maxKind = Math.max(maxKind, x);<br>        int[] countLess = new int[maxKind + 1];<br>        boolean[] must = new boolean[maxKind + 1];<br>        for (int x : found) {<br>            must[x] = true;<br>        }<br>        int[] sortedDepth = depth.clone();<br>        Arrays.sort(sortedDepth);<br>        long res = 0;<br>        int totalLess = 0;<br>        long[] ways = new long[K + 1];<br>        long[][] comb = new long[Math.max(K, kind.length) + 1][Math.max(K, kind.length) + 1];<br>        comb[0][0] = 1;<br>        for (int i = 1; i &lt; comb.length; ++i) {<br>            comb[i][0] = 1;<br>            for (int j = 1; j &lt; comb.length; ++j) {<br>                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];<br>            }<br>        }<br>        for (int firstBad = 0; firstBad &lt;= sortedDepth.length; ++firstBad) {<br>            if (firstBad &gt; 0 &amp;&amp; firstBad &lt; sortedDepth.length &amp;&amp; sortedDepth[firstBad] == sortedDepth[firstBad - 1])<br>                continue;<br>            boolean last = firstBad == sortedDepth.length;<br>            int numBad = 0;<br>            if (!last) {<br>                for (int i = 0; i &lt; kind.length; ++i) {<br>                    if (depth[i] == sortedDepth[firstBad]) {<br>                        if (!must[kind[i]]) {<br>                            ++numBad;<br>                        }<br>                    }<br>                }<br>            }<br>            int nonzero = 0;<br>            for (int x : countLess) if (x &gt; 0) ++nonzero;<br>            if (nonzero == found.length &amp;&amp; (last || numBad &gt; 0)) {<br>                Arrays.fill(ways, 0);<br>                ways[0] = 1;<br>                for (int x : countLess) if (x &gt; 0) {<br>                    for (int old = K; old &gt;= 0; --old) {<br>                        for (int take = 1; old + take &lt;= K; ++take)<br>                            ways[old + take] += ways[old] * comb[x][take];<br>                        ways[old] = 0;<br>                    }<br>                }<br>                if (!last) {<br>                    int x = numBad;<br>                    for (int old = K; old &gt;= 0; --old) {<br>                        for (int take = 1; old + take &lt;= K; ++take)<br>                            ways[old + take] += ways[old] * comb[x][take];<br>                        ways[old] = 0;<br>                    }<br>                }<br>                int rem = kind.length - totalLess - numBad;<br>                for (int step = 0; step &lt; rem; ++step)<br>                    for (int old = K - 1; old &gt;= 0; --old)<br>                        ways[old + 1] += ways[old];<br>                res += ways[K];<br>            }<br>            if (!last) {<br>                for (int i = 0; i &lt; kind.length; ++i) {<br>                    if (depth[i] == sortedDepth[firstBad]) {<br>                        ++totalLess;<br>                        if (must[kind[i]]) {<br>                            ++countLess[kind[i]];<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        return res;<br>    }<br>}<br></td>