<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cmath&gt;<br>#include &lt;sstream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cstring&gt;<br>using namespace std;<br>#define pb push_back<br>#define INF 1000000000<br>#define L(s) (int)((s).size())<br>#define FOR(i,a,b) for (int _n(b), i(a); i &lt;= _n; i++)<br>#define FORD(i,a,b) for(int i=(a),_b=(b);i&gt;=_b;i--)<br>#define rep(i,n) FOR(i,1,(n))<br>#define rept(i,n) FOR(i,0,(n)-1)<br>#define C(a) memset((a),0,sizeof(a))<br>#define ll long long<br>#define all(c) (c).begin(), (c).end()<br>#define SORT(c) sort(all(c))<br>#define VI vector&lt;int&gt;<br>#define ppb pop_back<br>#define mp make_pair<br>#define pii pair&lt;int,int&gt;<br>#define pdd pair&lt;double,double&gt;<br>#define x first<br>#define y second<br><br>int mn[51][51], mx[51][51], mn2[51][51], mx2[51][51];<br>vector&lt;pii&gt; sm[51];<br>int n;<br>inline void add(int v1, pii t1, int v2, pii t2) {<br>  mn[v1][v2] = max(mn[v1][v2], t1.x - t2.y);<br>  mx[v1][v2] = min(mx[v1][v2], t1.y - t2.x);<br>}<br>inline void parse(string s) {<br>  rept(i, L(s)) if (s[i] == '-') s[i] = ' ';<br>  istringstream iss2(s);<br>  string s1, s2;<br>  iss2 &gt;&gt; s1 &gt;&gt; s2;<br>  int v1, v2;<br>  sscanf(s1.substr(1, L(s1) - 1).c_str(), "%d", &amp;v1);<br>  sscanf(s2.substr(1, L(s2) - 1).c_str(), "%d", &amp;v2);<br><br>  int n1 = s1[0] - 'A';<br>  int n2 = s2[0] - 'A';<br><br>  add(n1, sm[n1][v1], n2, sm[n2][v2]);<br>  add(n2, sm[n2][v2], n1, sm[n1][v1]);<br>}<br><br>inline bool check() {<br>  rept(i, n) mn[i][i] = mx[i][i] = 0;<br>  rept(z, n) {<br>    rept(i, n) {<br>      rept(j, n) {<br>        mn[i][j] = max(mn[i][j], mn[i][z] + mn[z][j]);<br>        mx[i][j] = min(mx[i][j], mx[i][z] + mx[z][j]);<br>      }<br>    }<br>  }<br><br>  rept(i, n) {<br>    rept(j, n) {<br>      if (mn[i][j] &gt; mx[i][j]) return 0;<br>    }<br>  }<br>  return 1;<br>}<br>class History <br>  {<br>    public:<br>       string verifyClaims( vector &lt;string&gt; dynasties, vector &lt;string&gt; battles, vector &lt;string&gt; queries )<br>    {<br>      rept(i, 51) sm[i].clear();<br>      n = L(dynasties);<br>      rept(i, n) {<br>        istringstream iss(dynasties[i]);<br>        VI cur;<br>        int a;<br>        while (iss &gt;&gt; a) cur.pb(a);<br>        rept(j, L(cur) - 1) {<br>          sm[i].pb(mp(cur[j], cur[j + 1] - 1));<br>        }<br>      }<br><br>      rept(i, n) rept(j, n) mn[i][j] = -INF, mx[i][j] = INF;<br><br>      string s = "";<br>      rept(i, L(battles)) s += battles[i];<br>      istringstream iss(s);<br>      while (iss &gt;&gt; s) {<br>        parse(s);  <br>      }<br><br>      memmove(mx2, mx, sizeof(mx));<br>      memmove(mn2, mn, sizeof(mn));<br><br>      string ans = "";<br>      rept(i, L(queries)) {<br>        memcpy(mx, mx2, sizeof(mx2));<br>        memcpy(mn, mn2, sizeof(mn2));<br>        parse(queries[i]);<br>        if (check()) ans += 'Y'; else<br>        ans += 'N';<br>      }<br>      return ans;<br>    }<br>  };<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.17 [modified TZTester]<br>// Powered by CodeProcessor<br></td>