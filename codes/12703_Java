<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.List;<br>import java.util.Arrays;<br>import java.util.ArrayList;<br>import java.util.NoSuchElementException;<br>import java.math.BigInteger;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class LittleElephantAndBoard {<br>  private static final long MOD = (long) (1e9 + 7);<br>  static long[] fac;<br>  static long[] rev;<br>  static long[] two;<br> <br>    public int getNumber(int M, int R, int G, int B) {<br>    fac = IntegerUtils.generateFactorial(M + 1, MOD);<br>    rev = IntegerUtils.generateReverseFactorials(M + 1, MOD);<br>    two = IntegerUtils.generatePowers(2, M + 1, MOD);<br>    int RG = (R + G - B) / 2;<br>    int BR = (B + R - G) / 2;<br>    int GB = (G + B - R) / 2;<br>    if (RG &lt; 0 || BR &lt; 0 || GB &lt; 0)<br>      return 0;<br>    if (RG == 0) {<br>      if (Math.abs(GB - BR) == 1)<br>        return 2;<br>      if (BR == GB)<br>        return 4;<br>      return 0;<br>    }<br>    int dif = Math.abs(BR - GB);<br>    long answer = 0;<br>    for (int i = dif; i &lt;= RG + 1; i += 2) {<br>      int remaining = M - (RG + i);<br>      if (remaining &lt; 0)<br>        continue;<br>      for (int j = 0; j &lt; 2; j++) {<br>        for (int k = 0; k &lt; 2; k++) {<br>          if (RG - j - k &gt; ((M - RG + i) &gt;&gt; 1) - 1 || i &gt; RG + 1 - j - k)<br>            continue;<br>          long qty = c(((M - RG + i) &gt;&gt; 1) - 1, RG - j - k) * c(RG + 1 - j - k, i) % MOD * two[RG + 1 - j - k - i] % MOD * c(i, (i - dif) &gt;&gt; 1) % MOD;<br>          answer += qty;<br>        }<br>      }<br>    }<br>    return (int) (answer * 2 % MOD);<br>    }<br> <br>  private long c(int n, int m) {<br>    return fac[n] * rev[m] % MOD * rev[n - m] % MOD;<br>  }<br>}<br> <br>class IntegerUtils {<br> <br>    public static long[] generateFactorial(int count, long module) {<br>    long[] result = new long[count];<br>    if (module == -1) {<br>      if (count != 0)<br>        result[0] = 1;<br>      for (int i = 1; i &lt; count; i++)<br>        result[i] = result[i - 1] * i;<br>    } else {<br>      if (count != 0)<br>        result[0] = 1 % module;<br>      for (int i = 1; i &lt; count; i++)<br>        result[i] = (result[i - 1] * i) % module;<br>    }<br>    return result;<br>  }<br> <br>  public static long[] generateReverse(int upTo, long module) {<br>    long[] result = new long[upTo];<br>    if (upTo &gt; 1)<br>      result[1] = 1;<br>    for (int i = 2; i &lt; upTo; i++)<br>      result[i] = (module - module / i * result[((int) (module % i))] % module) % module;<br>    return result;<br>  }<br> <br>  public static long[] generateReverseFactorials(int upTo, long module) {<br>    long[] result = generateReverse(upTo, module);<br>    if (upTo &gt; 0)<br>      result[0] = 1;<br>    for (int i = 1; i &lt; upTo; i++)<br>      result[i] = result[i] * result[i - 1] % module;<br>    return result;<br>  }<br> <br>  public static long[] generatePowers(long base, int count, long mod) {<br>    long[] result = new long[count];<br>    if (count != 0)<br>      result[0] = 1 % mod;<br>    for (int i = 1; i &lt; count; i++)<br>      result[i] = result[i - 1] * base % mod;<br>    return result;<br>  }<br> <br>    }<br></td>