<td class="problemText" colspan="8" valign="middle" align="left">
            // Includes<br> <br>#include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;string&gt;<br>#include &lt;sstream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>// Macros<br> <br>#define ld    long double<br>#define ll    long long<br>#define MIN(x,y)  ((x)&lt;(y)?(x):(y))<br>#define MAX(x,y)  ((x)&gt;(y)?(x):(y))<br>#define ABS(x)    ((x)&gt;0?(x):-(x))<br>#define PI    3.14159265358979323846<br>#define EPSILON   0.0000000001<br> <br>// General parsing/formatting<br> <br>ll toInt(string s) {stringstream in(s, ios_base::in); ll result; in &gt;&gt; result; return result;}<br>ld toDouble(string s) {stringstream in(s, ios_base::in); ld result; in &gt;&gt; result; return result;}<br>string toString(ll n) {stringstream out(ios_base::out); out &lt;&lt; n; return out.str();}<br>string toString(ld d, int precision = -1) {stringstream out(ios_base::out); if (precision &gt;= 0) {out.precision(precision); out.setf(ios::fixed);} out &lt;&lt; d; return out.str();}<br>string toString(int n) {return toString((ll)(n));}<br>string toString(char ch) {string s="?"; s[0]=ch; return s;}<br>string toString(const string &amp;s) {return s;}<br>string toString(pair&lt;int,int&gt; u) {return toString("(") + toString(u.first) + "," + toString(u.second) + ")";}<br>int getNumWords(string s) {stringstream in(s, ios_base::in); int result=0; string t; while (in&gt;&gt;t) result++; return result;}<br>string getWord(string s, int i) {stringstream in(s, ios_base::in); string t; for (;i&gt;=0;i--) in &gt;&gt; t; return t;}<br> <br>// Basic math<br> <br>bool isEqual(ld v1, ld v2) {return ABS(v1-v2)&lt;EPSILON;}<br>bool isLess(ld v1, ld v2) {return v1-v2&lt;-EPSILON;}<br>ll gcd(ll n1, ll n2) {return n2==0? ABS(n1) : gcd(n2,n1%n2);}<br>ll lcm(ll n1, ll n2) {return n1==0 &amp;&amp; n2==0? 0 : ABS(n1*n2)/gcd(n1,n2);}<br> <br>// Real code<br> <br>class TileMatch {<br>  public:<br>  <br>  int l;<br>  bool getCell(vector &lt;string&gt; &amp;pattern, int side, int dist) {<br>    if (side == 0) return pattern[0][dist] == 'X';<br>    if (side == 1) return pattern[dist][l-1] == 'X';<br>    if (side == 2) return pattern[l-1][l-1-dist] == 'X';<br>    if (side == 3) return pattern[l-1-dist][0] == 'X';<br>  }<br>  <br>  void clearCell(vector &lt;string&gt; &amp;pattern, int side, int dist) {<br>    if (side == 0) pattern[0][dist] = '.';<br>    if (side == 1) pattern[dist][l-1] = '.';<br>    if (side == 2) pattern[l-1][l-1-dist] = '.';<br>    if (side == 3) pattern[l-1-dist][0] = '.';<br>  }<br>  <br>  int uncolor(vector &lt;string&gt; pattern) {<br>    l=pattern.size();<br>    int count = 0;<br>    bool change = true;<br>    while (change) {<br>      change = false;<br>      for (int i = 0; i &lt; 4; i++)<br>      for (int n = 0; n &lt; l-1; n++) <br>      if (getCell(pattern, i, n))<br>      {<br>        int satisfied[4] = {0,0,0,0};<br>        if (n == 0) {if (getCell(pattern,0,0) &amp;&amp; getCell(pattern,1,0) &amp;&amp; getCell(pattern,2,0) &amp;&amp; getCell(pattern,3,0)) continue;}<br>        for (int j = 0; j &lt; 4; j++)<br>        {<br>          if (n &gt; 0 &amp;&amp; getCell(pattern,j,l-n)) satisfied[j] = true;<br>          if (getCell(pattern,j,l-n-1)) satisfied[j] = true;<br>          if (n &lt; l-1 &amp;&amp; getCell(pattern,j,l-n-2)) satisfied[j] = true;<br>        }<br>        if (satisfied[0] &amp;&amp; satisfied[1] &amp;&amp; satisfied[2] &amp;&amp; satisfied[3]) continue;<br>        satisfied[0] = satisfied[1] = satisfied[2] = satisfied[3] = 0;<br>        if (n == 0)<br>        {<br>          n=l-1;<br>          for (int j = 0; j &lt; 4; j++)<br>          {<br>            if (n &gt; 0 &amp;&amp; getCell(pattern,j,l-n)) satisfied[j] = true;<br>            if (getCell(pattern,j,l-n-1)) satisfied[j] = true;<br>            if (n &lt; l-1 &amp;&amp; getCell(pattern,j,l-n-2)) satisfied[j] = true;<br>          }<br>          n=0;<br>        }<br>        if (satisfied[0] &amp;&amp; satisfied[1] &amp;&amp; satisfied[2] &amp;&amp; satisfied[3]) continue;<br>        <br> <br>        clearCell(pattern, i,n);<br>        count++;<br>        cout &lt;&lt; count &lt;&lt; " " &lt;&lt; i &lt;&lt; " " &lt;&lt; n &lt;&lt; " " &lt;&lt; endl;<br>        change = true;<br>      }<br>    }<br>    return count;<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>