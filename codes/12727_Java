<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br>import java.util.Comparator;<br>import java.util.NoSuchElementException;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class FoxAndCity {<br>    public int minimalCost(String[] linked, int[] want) {<br>    int count = want.length;<br>    int[][] distance = new int[count][count];<br>    ArrayUtils.fill(distance, count);<br>    for (int i = 0; i &lt; count; i++) {<br>      distance[i][i] = 0;<br>      for (int j = 0; j &lt; count; j++) {<br>        if (linked[i].charAt(j) == 'Y')<br>          distance[i][j] = 1;<br>      }<br>    }<br>    for (int i = 0; i &lt; count; i++) {<br>      for (int j = 0; j &lt; count; j++) {<br>        for (int k = 0; k &lt; count; k++)<br>          distance[j][k] = Math.min(distance[j][k], distance[j][i] + distance[i][k]);<br>      }<br>    }<br>    int[] current = distance[0].clone();<br>    int[] benefit = new int[count];<br>    while (true) {<br>      for (int i = 0; i &lt; count; i++) {<br>        if (current[i] &lt;= 1)<br>          benefit[i] = -1000000;<br>        else<br>          benefit[i] = 2 * (current[i] - want[i]) - 1;<br>      }<br>      int[] good = new int[count];<br>      int[] bad = new int[count];<br>      int goodCount = 0;<br>      int badCount = 0;<br>      for (int i = 0; i &lt; count; i++) {<br>        if (benefit[i] &gt; 0)<br>          good[goodCount++] = i;<br>        else<br>          bad[badCount++] = i;<br>      }<br>      good = Arrays.copyOf(good, goodCount);<br>      bad = Arrays.copyOf(bad, badCount);<br>      long[] required = new long[goodCount];<br>      for (int i = 0; i &lt; goodCount; i++) {<br>        for (int j = 0; j &lt; badCount; j++) {<br>          if (current[bad[j]] - current[good[i]] == distance[good[i]][bad[j]])<br>            required[i] += 1L &lt;&lt; j;<br>        }<br>      }<br>      long best = 0;<br>      long bestBad = 0;<br>      int bestBenefit = 0;<br>      if (goodCount &lt;= badCount) {<br>        for (int i = 0; i &lt; (1 &lt;&lt; goodCount); i++) {<br>          long allBad = 0;<br>          for (int j = 0; j &lt; goodCount; j++) {<br>            if ((i &gt;&gt; j &amp; 1) == 1)<br>              allBad |= required[j];<br>          }<br>          int curBenefit = 0;<br>          for (int j = 0; j &lt; goodCount; j++) {<br>            if ((i &gt;&gt; j &amp; 1) == 1)<br>              curBenefit += benefit[good[j]];<br>          }<br>          for (int j = 0; j &lt; badCount; j++) {<br>            if ((allBad &gt;&gt; j &amp; 1) == 1)<br>              curBenefit += benefit[bad[j]];<br>          }<br>          if (curBenefit &gt; bestBenefit) {<br>            best = i;<br>            bestBad = allBad;<br>            bestBenefit = curBenefit;<br>          }<br>        }<br>      } else {<br>        for (int i = 0; i &lt; (1 &lt;&lt; badCount); i++) {<br>          long allGood = 0;<br>          for (int j = 0; j &lt; goodCount; j++) {<br>            if ((required[j] &amp; i) == required[j])<br>              allGood += 1L &lt;&lt; j;<br>          }<br>          int curBenefit = 0;<br>          for (int j = 0; j &lt; goodCount; j++) {<br>            if ((allGood &gt;&gt; j &amp; 1) == 1)<br>              curBenefit += benefit[good[j]];<br>          }<br>          for (int j = 0; j &lt; badCount; j++) {<br>            if ((i &gt;&gt; j &amp; 1) == 1)<br>              curBenefit += benefit[bad[j]];<br>          }<br>          if (curBenefit &gt; bestBenefit) {<br>            best = allGood;<br>            bestBad = i;<br>            bestBenefit = curBenefit;<br>          }<br>        }<br>      }<br>      if (best == 0)<br>        break;<br>      for (int i = 0; i &lt; goodCount; i++) {<br>        if ((best &gt;&gt; i &amp; 1) == 1)<br>          current[good[i]]--;<br>      }<br>      for (int i = 0; i &lt; badCount; i++) {<br>        if ((bestBad &gt;&gt; i &amp; 1) == 1)<br>          current[bad[i]]--;<br>      }<br>    }<br>    int answer = 0;<br>    for (int i = 0; i &lt; count; i++)<br>      answer += (current[i] - want[i]) * (current[i] - want[i]);<br>    return answer;<br>    }<br>}<br> <br>class ArrayUtils {<br> <br>  public static void fill(int[][] array, int value) {<br>    for (int[] row : array)<br>      Arrays.fill(row, value);<br>  }<br> <br>  }<br></td>