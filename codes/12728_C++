<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;list&gt;<br>#include &lt;complex&gt;<br>#include &lt;queue&gt;<br>#include &lt;climits&gt;<br> <br>using namespace std;<br> <br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef long long ll;<br>typedef complex&lt;double&gt; pnt;<br>typedef pair&lt;int, int&gt; pii;<br> <br>#define RA(x) (x).begin(), (x).end()<br>#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)<br>#define SZ(x) ((int) (x).size())<br> <br> <br>class FlippingBitsDiv1<br>{<br>public:<br>    int getmin(vector &lt;string&gt; S, int M);<br>};<br> <br>int FlippingBitsDiv1::getmin(vector &lt;string&gt; S_, int M)<br>{<br>    string S = accumulate(RA(S_), string());<br>    int L = SZ(S);<br>    int ans = INT_MAX;<br>    if (M &lt;= 17)<br>    {<br>        for (int ref = 0; ref &lt; (1 &lt;&lt; M); ref++)<br>        {<br>            int dp[2] = {0, 0};<br>            for (int start = 0; start &lt; L; start += M)<br>            {<br>                int t = min(M, L - start);<br>                int cmask = (1 &lt;&lt; t) - 1;<br>                int cur = 0;<br>                for (int i = 0; i &lt; t; i++)<br>                    if (S[start + i] == '1')<br>                        cur |= 1 &lt;&lt; i;<br>                int cost1 = dp[0] + __builtin_popcount((ref ^ cur) &amp; cmask);<br>                int cost2 = dp[1] + __builtin_popcount((~ref ^ cur) &amp; cmask);<br>                dp[0] = min(cost1, cost2 + 1);<br>                dp[1] = min(cost2, cost1 + 1);<br>            }<br>            int sub = min(dp[0], dp[1]);<br>            ans = min(ans, sub);<br>        }<br>    }<br>    else<br>    {<br>        int groups = (L + M - 1) / M;<br>        for (int flip = 0; flip &lt; (1 &lt;&lt; groups) - 1; flip++)<br>        {<br>            int score = 0;<br>            int prev = 0;<br>            for (int i = 0; i &lt; groups; i++)<br>            {<br>                int cur = (flip &gt;&gt; i) &amp; 1;<br>                if (cur != prev)<br>                    score++;<br>                prev = cur;<br>            }<br> <br>            for (int pos = 0; pos &lt; M; pos++)<br>            {<br>                int vals[2] = {0, 0};<br>                for (int i = pos, g = 0; i &lt; L; i += M, g++)<br>                {<br>                    int v = (S[i] == '1') ^ ((flip &gt;&gt; g) &amp; 1);<br>                    vals[v]++;<br>                }<br>                score += min(vals[0], vals[1]);<br>            }<br> <br>            ans = min(ans, score);<br>        }<br>    }<br>    return ans;<br>}<br> <br> <br>// Powered by FileEdit<br></td>