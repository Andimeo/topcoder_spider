<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br> <br>public class GearsDiv1<br>{<br>  public int getmin(string color, string[] graph)<br>  {<br>    int ans = int.MaxValue;<br>    int n = color.Length;<br>    for(int i = 0; i &lt; 3; i++)<br>      for(int i2 = i + 1; i2 &lt; 3; i2++)<br>      {<br>        char c1 = "RGB"[i];<br>        char c2 = "RGB"[i2];<br>        MaxFlow mf = new MaxFlow(n);<br>        for(int j = 0; j &lt; n; j++)<br>        {<br>          if(color[j] == c1)<br>            mf.Add(mf.Source, j, 1);<br>          else if(color[j] == c2)<br>            mf.Add(j, mf.Sink, 1);<br>          for(int k = 0; k &lt; n; k++)<br>            if(graph[j][k] == 'Y' &amp;&amp; color[j] == c1 &amp;&amp; color[k] == c2)<br>            {<br>              mf.Add(j, k, 1);<br>            }<br>        }<br>        int cur = mf.NetworkFlow();<br>        ans = Math.Min(ans, cur);<br>      }<br>    return ans;<br>  }<br> <br>public class MaxFlow<br>{<br>  public int Nodes;<br>  public int Source;<br>  public int Sink;<br>  public int[,] Capacity;<br>  LinkedList&lt;int&gt;[] Neighbours;<br>  bool[,] NeighbourAdded;<br> <br>  public MaxFlow(int Nodes)<br>  {<br>    this.Nodes = Nodes + 2;<br>    this.Source = Nodes;<br>    this.Sink = Nodes + 1;<br>    Neighbours = new LinkedList&lt;int&gt;[this.Nodes];<br>    for (int i = 0; i &lt; this.Nodes; i++)<br>      Neighbours[i] = new LinkedList&lt;int&gt;();<br>    Capacity = new int[this.Nodes, this.Nodes];<br>    NeighbourAdded = new bool[this.Nodes, this.Nodes];<br>  }<br> <br>  public void Add(int From, int To, int Cap)<br>  {<br>    Capacity[From, To] += Cap;<br>    if (!NeighbourAdded[From, To])<br>    {<br>      NeighbourAdded[From, To] = true;<br>      NeighbourAdded[To, From] = true;<br>      Neighbours[From].AddLast(To);<br>      Neighbours[To].AddLast(From);<br>    }<br>  }<br> <br>  public int NetworkFlow()<br>  {<br>    int[,] flow = new int[Nodes, Nodes];<br>    int[] parent = new int[Nodes];<br>    int[] cap = new int[Nodes];<br> <br>    int total = 0;<br>    while (true)<br>    {<br>      for (int i = 0; i &lt; Nodes; i++)<br>        parent[i] = -1;<br>      parent[this.Source] = -2;<br>      cap[this.Source] = int.MaxValue;<br>      Queue&lt;int&gt; Q = new Queue&lt;int&gt;();<br>      Q.Enqueue(this.Source);<br>      while (Q.Count &gt; 0 &amp;&amp; parent[this.Sink] == -1)<br>      {<br>        int act = Q.Dequeue();<br>        foreach (int next in Neighbours[act])<br>        {<br>          if (parent[next] == -1 &amp;&amp; Capacity[act, next] &gt;<br>              flow[act, next])<br>          {<br>            parent[next] = act;<br>            cap[next] = Math.Min(cap[act], Capacity[act, next] -<br>                                 flow[act, next]);<br>            Q.Enqueue(next);<br>          }<br>        }<br>      }<br> <br>      if (parent[this.Sink] == -1)<br>        return total;<br> <br>      total += cap[this.Sink];<br>      int j = this.Sink;<br>      while (j != this.Source)<br>      {<br>        flow[parent[j], j] += cap[this.Sink];<br>        flow[j, parent[j]] -= cap[this.Sink];<br>        j = parent[j];<br>      }<br>    }<br>  }<br>}<br> <br> <br> <br>}<br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>