<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;numeric&gt;<br>#include &lt;iterator&gt;<br>#include &lt;functional&gt;<br>#include &lt;complex&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;tuple&gt;<br>using namespace std;<br>typedef long long LL;<br>typedef complex&lt;double&gt; CMP;<br><br>typedef int           vert;<br>typedef vert          edge;<br>typedef vector&lt;edge&gt;  edges;<br>typedef vector&lt;edges&gt; graph;<br><br>bool augment( graph&amp; G, int v, vector&lt;vert&gt;&amp; matchTo, bool visited[] )<br>{<br>  for(int i=0; i&lt;G[v].size(); ++i) {<br>    vert u = G[v][i];<br>    if( visited[u] ) continue;<br>    visited[u] = true;<br><br>    if( matchTo[u]&lt;0 || augment(G, matchTo[u], matchTo, visited) )<br>      { matchTo[v]=u, matchTo[u]=v; return true; }<br>  }<br>  return false;<br>}<br><br>template&lt;int NV&gt;<br>int biMatch( graph&amp; G, int L ) // [0,L):left, [L,?):right<br>    // only left-&gt;right edges are used during computation<br>{<br>  vector&lt;vert&gt; matchTo(G.size(), -1);<br>  int ans = 0;<br>  for(vert v=0; v&lt;L; ++v) {<br>    bool visited[NV] = {};<br>    if( augment(G, v, matchTo, visited) )<br>      ++ans;<br>  }<br>  return ans;<br>}<br><br>class GearsDiv1 { public:<br>  int getmin(string color, vector &lt;string&gt; graph)<br>  {<br>    vector&lt;int&gt; r, g, b;<br>    for(int i=0; i&lt;color.size(); ++i)<br>      (color[i]=='R' ? r : color[i]=='G' ? g : b).push_back(i);<br><br>    int rg = calc(graph, r, g);<br>    int gb = calc(graph, g, b);<br>    int br = calc(graph, b, r);<br>    return min(rg, min(gb, br));<br>  }<br><br>  int calc(const vector&lt;string&gt;&amp; G, const vector&lt;int&gt;&amp; A, const vector&lt;int&gt;&amp; B)<br>  {<br>    if(A.empty() || B.empty())<br>      return 0;<br><br>    graph gr(A.size() + B.size());<br>    for(int a=0; a&lt;A.size(); ++a)<br>    for(int b=0; b&lt;B.size(); ++b)<br>    {<br>      if(G[A[a]][B[b]] == 'Y')<br>        gr[a].push_back(A.size()+b);<br>    }<br>    return biMatch&lt;256&gt;(gr, A.size());<br>  }<br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] : &lt;cafelier&amp;naoya_t&gt;-custom<br>// Powered by CodeProcessor<br></td>