<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Iterator;<br>import java.util.Arrays;<br>import java.util.NoSuchElementException;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class GearsDiv1 {<br>  char[] colors = "RGB".toCharArray();<br> <br>    public int getmin(String color, String[] graph) {<br>    int count = color.length();<br>    int answer = Integer.MAX_VALUE;<br>    for (char first : colors) {<br>      for (char second : colors) {<br>        if (first == second)<br>          break;<br>        Graph current = new Graph(count + 2);<br>        for (int i = 0; i &lt; count; i++) {<br>          if (color.charAt(i) == first) {<br>            current.addFlowEdge(count, i, 1);<br>            for (int j = 0; j &lt; count; j++) {<br>              if (graph[i].charAt(j) == 'Y')<br>                current.addFlowEdge(i, j, 1);<br>            }<br>          } else if (color.charAt(i) == second)<br>            current.addFlowEdge(i, count + 1, 1);<br>        }<br>        answer = (int) Math.min(answer, MaxFlow.dinic(current, count, count + 1));<br>      }<br>    }<br>    return answer;<br>    }<br>}<br> <br>class Graph {<br>  public static final int REMOVED_BIT = 0;<br> <br>  protected int vertexCount;<br>  protected int edgeCount;<br> <br>  private int[] firstOutbound;<br>  private int[] firstInbound;<br> <br>  private Edge[] edges;<br>  private int[] nextInbound;<br>  private int[] nextOutbound;<br>  private int[] from;<br>  private int[] to;<br>  private long[] weight;<br>  private long[] capacity;<br>  private int[] reverseEdge;<br>  private int[] flags;<br> <br>  public Graph(int vertexCount) {<br>    this(vertexCount, vertexCount);<br>  }<br> <br>  public Graph(int vertexCount, int edgeCapacity) {<br>    this.vertexCount = vertexCount;<br>    firstOutbound = new int[vertexCount];<br>    Arrays.fill(firstOutbound, -1);<br> <br>    from = new int[edgeCapacity];<br>    to = new int[edgeCapacity];<br>    nextOutbound = new int[edgeCapacity];<br>    flags = new int[edgeCapacity];<br>  }<br> <br>  public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {<br>    ensureEdgeCapacity(edgeCount + 1);<br>    if (firstOutbound[fromID] != -1)<br>      nextOutbound[edgeCount] = firstOutbound[fromID];<br>    else<br>      nextOutbound[edgeCount] = -1;<br>    firstOutbound[fromID] = edgeCount;<br>    if (firstInbound != null) {<br>      if (firstInbound[toID] != -1)<br>        nextInbound[edgeCount] = firstInbound[toID];<br>      else<br>        nextInbound[edgeCount] = -1;<br>      firstInbound[toID] = edgeCount;<br>    }<br>    this.from[edgeCount] = fromID;<br>    this.to[edgeCount] = toID;<br>    if (capacity != 0) {<br>      if (this.capacity == null)<br>        this.capacity = new long[from.length];<br>      this.capacity[edgeCount] = capacity;<br>    }<br>    if (weight != 0) {<br>      if (this.weight == null)<br>        this.weight = new long[from.length];<br>      this.weight[edgeCount] = weight;<br>    }<br>    if (reverseEdge != -1) {<br>      if (this.reverseEdge == null) {<br>        this.reverseEdge = new int[from.length];<br>        Arrays.fill(this.reverseEdge, 0, edgeCount, -1);<br>      }<br>      this.reverseEdge[edgeCount] = reverseEdge;<br>    }<br>    if (edges != null)<br>      edges[edgeCount] = createEdge(edgeCount);<br>    return edgeCount++;<br>  }<br> <br>  protected final GraphEdge createEdge(int id) {<br>    return new GraphEdge(id);<br>  }<br> <br>  public final int addFlowWeightedEdge(int from, int to, long weight, long capacity) {<br>    if (capacity == 0) {<br>      return addEdge(from, to, weight, 0, -1);<br>    } else {<br>      int lastEdgeCount = edgeCount;<br>      addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());<br>      return addEdge(from, to, weight, capacity, lastEdgeCount);<br>    }<br>  }<br> <br>  protected int entriesPerEdge() {<br>    return 1;<br>  }<br> <br>  public final int addFlowEdge(int from, int to, long capacity) {<br>    return addFlowWeightedEdge(from, to, 0, capacity);<br>  }<br> <br>  public final int vertexCount() {<br>    return vertexCount;<br>  }<br> <br>  public final int firstOutbound(int vertex) {<br>    int id = firstOutbound[vertex];<br>    while (id != -1 &amp;&amp; isRemoved(id))<br>      id = nextOutbound[id];<br>    return id;<br>  }<br> <br>  public final int nextOutbound(int id) {<br>    id = nextOutbound[id];<br>    while (id != -1 &amp;&amp; isRemoved(id))<br>      id = nextOutbound[id];<br>    return id;<br>  }<br> <br>  public final int destination(int id) {<br>    return to[id];<br>  }<br> <br>  public final long capacity(int id) {<br>    if (capacity == null)<br>      return 0;<br>    return capacity[id];<br>  }<br> <br>  public final long flow(int id) {<br>    if (reverseEdge == null)<br>      return 0;<br>    return capacity[reverseEdge[id]];<br>  }<br> <br>  public final void pushFlow(int id, long flow) {<br>    if (flow == 0)<br>      return;<br>    if (flow &gt; 0) {<br>      if (capacity(id) &lt; flow)<br>        throw new IllegalArgumentException("Not enough capacity");<br>    } else {<br>      if (flow(id) &lt; -flow)<br>        throw new IllegalArgumentException("Not enough capacity");<br>    }<br>    capacity[id] -= flow;<br>    capacity[reverseEdge[id]] += flow;<br>  }<br> <br>  public final boolean flag(int id, int bit) {<br>    return (flags[id] &gt;&gt; bit &amp; 1) != 0;<br>  }<br> <br>  public final boolean isRemoved(int id) {<br>    return flag(id, REMOVED_BIT);<br>  }<br> <br>  protected void ensureEdgeCapacity(int size) {<br>    if (from.length &lt; size) {<br>      int newSize = Math.max(size, 2 * from.length);<br>      if (edges != null)<br>        edges = resize(edges, newSize);<br>      from = resize(from, newSize);<br>      to = resize(to, newSize);<br>      nextOutbound = resize(nextOutbound, newSize);<br>      if (nextInbound != null)<br>        nextInbound = resize(nextInbound, newSize);<br>      if (weight != null)<br>        weight = resize(weight, newSize);<br>      if (capacity != null)<br>        capacity = resize(capacity, newSize);<br>      if (reverseEdge != null)<br>        reverseEdge = resize(reverseEdge, newSize);<br>      flags = resize(flags, newSize);<br>    }<br>  }<br> <br>  protected final int[] resize(int[] array, int size) {<br>    int[] newArray = new int[size];<br>    System.arraycopy(array, 0, newArray, 0, array.length);<br>    return newArray;<br>  }<br> <br>  private long[] resize(long[] array, int size) {<br>    long[] newArray = new long[size];<br>    System.arraycopy(array, 0, newArray, 0, array.length);<br>    return newArray;<br>  }<br> <br>  private Edge[] resize(Edge[] array, int size) {<br>    Edge[] newArray = new Edge[size];<br>    System.arraycopy(array, 0, newArray, 0, array.length);<br>    return newArray;<br>  }<br> <br>  protected class GraphEdge implements Edge {<br>    protected int id;<br> <br>    protected GraphEdge(int id) {<br>      this.id = id;<br>    }<br> <br>    }<br> <br>  }<br> <br>class MaxFlow {<br>  private final Graph graph;<br>  private int source;<br>  private int destination;<br>  private int[] queue;<br>  private int[] distance;<br>  private int[] nextEdge;<br> <br>  private MaxFlow(Graph graph, int source, int destination) {<br>    this.graph = graph;<br>    this.source = source;<br>    this.destination = destination;<br>    int vertexCount = graph.vertexCount();<br>    queue = new int[vertexCount];<br>    distance = new int[vertexCount];<br>    nextEdge = new int[vertexCount];<br>  }<br> <br>  public static long dinic(Graph graph, int source, int destination) {<br>    return new MaxFlow(graph, source, destination).dinic();<br>  }<br> <br>  private long dinic() {<br>    long totalFlow = 0;<br>    while (true) {<br>      edgeDistances();<br>      if (distance[destination] == -1)<br>        break;<br>      Arrays.fill(nextEdge, -2);<br>      totalFlow += dinicImpl(source, Long.MAX_VALUE);<br>    }<br>    return totalFlow;<br>  }<br> <br>  private void edgeDistances() {<br>    Arrays.fill(distance, -1);<br>    distance[source] = 0;<br>    int size = 1;<br>    queue[0] = source;<br>    for (int i = 0; i &lt; size; i++) {<br>      int current = queue[i];<br>      int id = graph.firstOutbound(current);<br>      while (id != -1) {<br>        if (graph.capacity(id) != 0) {<br>          int next = graph.destination(id);<br>          if (distance[next] == -1) {<br>            distance[next] = distance[current] + 1;<br>            queue[size++] = next;<br>          }<br>        }<br>        id = graph.nextOutbound(id);<br>      }<br>    }<br>  }<br> <br>  private long dinicImpl(int source, long flow) {<br>    if (source == destination)<br>      return flow;<br>    if (flow == 0 || distance[source] == distance[destination])<br>      return 0;<br>    int id = nextEdge[source];<br>    if (id == -2)<br>      nextEdge[source] = id = graph.firstOutbound(source);<br>    long totalPushed = 0;<br>    while (id != -1) {<br>      int nextDestinationID = graph.destination(id);<br>      if (graph.capacity(id) != 0 &amp;&amp; distance[nextDestinationID] == distance[source] + 1) {<br>        long pushed = dinicImpl(nextDestinationID, Math.min(flow, graph.capacity(id)));<br>        if (pushed != 0) {<br>          graph.pushFlow(id, pushed);<br>          flow -= pushed;<br>          totalPushed += pushed;<br>          if (flow == 0)<br>            return totalPushed;<br>        }<br>      }<br>      nextEdge[source] = id = graph.nextOutbound(id);<br>    }<br>    return totalPushed;<br>  }<br>}<br> <br>interface Edge {<br>  }<br></td>