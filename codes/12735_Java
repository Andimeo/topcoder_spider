<td class="problemText" colspan="8" valign="middle" align="left">
            /**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class LittleElephantAndPermutationDiv1 {<br>    static final int MODULO = (int) 1e9 + 7;<br> <br>    public int getNumber(int N, int K) {<br>        int[][][] ways = new int[1][1][1];<br>        ways[0][0][0] = 1;<br>        int maxSum = 0;<br>        for (int cur = N; cur &gt;= 1; --cur) {<br>            int maxSkipped = N - cur + 1;<br>            maxSkipped = Math.min(maxSkipped, cur - 1);<br>            int[][][] nways = new int[maxSkipped + 1][maxSkipped + 1][maxSum + 2 * cur + 1];<br>            for (int sa = 0; sa &lt; ways.length; ++sa)<br>                for (int sb = 0; sb &lt; ways.length; ++sb)<br>                    for (int s = 0; s &lt; ways[sa][sb].length; ++s) {<br>                        int old = ways[sa][sb][s];<br>                        if (old == 0) continue;<br>                        int freeSlots = (2 * cur - sa - sb) / 2;<br>                        if (sa &lt;= maxSkipped &amp;&amp; sb &lt;= maxSkipped) {<br>                            nways[sa][sb][s + cur] = (int) ((nways[sa][sb][s + cur] + old * (long) freeSlots) % MODULO);<br>                            maxSum = Math.max(maxSum, s + cur);<br>                        }<br>                        if (sa + 1 &lt;= maxSkipped &amp;&amp; sb + 1 &lt;= maxSkipped) {<br>                            nways[sa + 1][sb + 1][s + 2 * cur] = (int) ((nways[sa + 1][sb + 1][s + 2 * cur] + old * (long) (freeSlots * (freeSlots - 1))) % MODULO);<br>                            maxSum = Math.max(maxSum, s + 2 * cur);<br>                        }<br>                        if (sa &gt;= 1 &amp;&amp; sb &gt;= 1) {<br>                            nways[sa - 1][sb - 1][s] = (int) ((nways[sa - 1][sb - 1][s] + old * (long) sa * (long) sb) % MODULO);<br>                        }<br>                        if (sa &gt;= 1 &amp;&amp; sb &lt;= maxSkipped) {<br>                            nways[sa][sb][s + cur] = (int) ((nways[sa][sb][s + cur] + old * (long) sa * (long) freeSlots) % MODULO);<br>                            maxSum = Math.max(maxSum, s + cur);<br>                        }<br>                        if (sb &gt;= 1 &amp;&amp; sa &lt;= maxSkipped) {<br>                            nways[sa][sb][s + cur] = (int) ((nways[sa][sb][s + cur] + old * (long) sb * (long) freeSlots) % MODULO);<br>                            maxSum = Math.max(maxSum, s + cur);<br>                        }<br>                    }<br>            ways = nways;<br>        }<br>        int res = 0;<br>        for (int s = K; s &lt; ways[0][0].length; ++s) {<br>            res += ways[0][0][s];<br>            if (res &gt;= MODULO) res -= MODULO;<br>        }<br>        return res;<br>    }<br>}<br></td>