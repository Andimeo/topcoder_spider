<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class SparseFactorial {<br>    static final long INF = (long) 1.1e6;<br> <br>    public long getCount(long lo, long hi, long divisor) {<br>        long[] atleast = new long[(int) divisor];<br>        Arrays.fill(atleast, 0);<br>        long tmp = divisor;<br>        for (long i = 2; i * i &lt;= tmp; ++i)<br>            if (tmp % i == 0) {<br>                int pow = 0;<br>                while (tmp % i == 0) {<br>                    ++pow;<br>                    tmp /= i;<br>                }<br>                long[] sub = solveOne(i, pow);<br>                for (int j = 0; j &lt; atleast.length; ++j)<br>                    atleast[j] = Math.max(atleast[j], sub[j % sub.length]);<br>            }<br>        if (tmp &gt; 1) {<br>            long[] sub = solveOne(tmp, 1);<br>            for (int j = 0; j &lt; atleast.length; ++j)<br>                atleast[j] = Math.max(atleast[j], sub[j % sub.length]);<br>        }<br>        long res = 0;<br>        for (int rem = 0; rem &lt; atleast.length; ++rem) {<br>            long first = atleast[rem] * atleast[rem] + 1;<br>            first = Math.max(first, lo);<br>            long delta = rem - first % divisor;<br>            if (delta &lt; 0) delta += divisor;<br>            first += delta;<br>            long last = hi;<br>            delta = rem - last % divisor;<br>            if (delta &gt; 0) delta -= divisor;<br>            last += delta;<br>            if (first &lt;= last) {<br>                res += (last - first) / divisor + 1;<br>            }<br>        }<br>        return res;<br>    }<br> <br>    private long[] solveOne(long p, int k) {<br>        long mx = 1;<br>        for (int i = 0; i &lt; k; ++i) mx *= p;<br>        long[] res = new long[(int) mx];<br>        Arrays.fill(res, INF);<br>        for (long i = 0; i &lt;= p - i; ++i) {<br>            long val = i * i % p;<br>            for (long s = val; s &lt; mx; s += p) {<br>                int togo = k;<br>                for (int loop = 0;; ++loop) {<br>                    long t = loop * p + i;<br>                    if (t &gt;= INF) {<br>                        break;<br>                    }<br>                    long r = s - t * t;<br>                    if (r % p != 0) throw new RuntimeException();<br>                    while (togo &gt; 0 &amp;&amp; r % p == 0) {<br>                        r /= p;<br>                        --togo;<br>                    }<br>                    if (togo &lt;= 0) {<br>                        res[((int) s)] = t;<br>                        break;<br>                    }<br>                    if (i &lt; p - i &amp;&amp; i &gt; 0) {<br>                        t = loop * p + (p - i);<br>                        if (t &gt;= INF) {<br>                            break;<br>                        }<br>                        r = s - t * t;<br>                        if (r % p != 0) throw new RuntimeException();<br>                        while (togo &gt; 0 &amp;&amp; r % p == 0) {<br>                            r /= p;<br>                            --togo;<br>                        }<br>                        if (togo &lt;= 0) {<br>                            res[((int) s)] = t;<br>                            break;<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        return res;<br>    }<br>}<br></td>