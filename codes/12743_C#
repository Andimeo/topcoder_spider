<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class FoxAndGo {<br>    class Point<br>    {<br>        public int X { get; set; }<br>        public int Y { get; set; }<br>    }<br><br>    public int maxKill(string[] board)<br>    {<br>        int result = 0;<br><br>        int n = board.Length;<br><br>        bool[,] flags = new bool[n, n];<br><br>        List&lt;List&lt;Point&gt;&gt; components = new List&lt;List&lt;Point&gt;&gt;();<br>        List&lt;Point&gt; empties = new List&lt;Point&gt;();<br><br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            for (int j = 0; j &lt; n; j++)<br>            {<br>                if (board[i][j] == 'o' &amp;&amp; !flags[i, j])<br>                {<br>                    components.Add(DiscoverComponent(n, flags, board, i, j));<br>                }<br><br>                if (board[i][j] == '.')<br>                {<br>                    empties.Add(new Point { X = i, Y = j });<br>                }<br>            }<br>        }<br><br>        foreach (Point e in empties)<br>        {<br>            int r = 0;<br><br>            foreach (var component in components)<br>            {<br>                if (CanRemove(n, board, e, component))<br>                {<br>                    r += component.Count;<br>                }<br>            }<br><br>            if (r &gt; result) result = r;<br>        }<br><br>        return result;<br>    }<br><br>    private bool CanRemove(int n,  string[] board,Point e, List&lt;Point&gt; component)<br>    {<br>        foreach (Point p in component)<br>        {<br>            int x = p.X;<br>            int y = p.Y;<br>            for (int i = 0; i &lt; 4; i++)<br>            {<br>                if (x + dx[i] &lt; n &amp;&amp; y + dy[i] &lt; n &amp;&amp; x + dx[i] &gt;= 0 &amp;&amp; y + dy[i] &gt;= 0 &amp;&amp; (!(x + dx[i] == e.X &amp;&amp; y + dy[i] == e.Y)) &amp;&amp; board[x + dx[i]][y + dy[i]] == '.')<br>                {<br>                    return false;<br>                }<br>            }<br>        }<br><br>        return true;<br>    }<br><br>    int[] dx = { 1, 0, 0, -1};<br>    int[] dy = { 0, 1, -1, 0};<br>    private List&lt;Point&gt; DiscoverComponent(int n, bool[,] flags, string[] board, int x, int y)<br>    {<br>        List&lt;Point&gt; result = new List&lt;Point&gt;();<br><br>        Queue&lt;Point&gt; q = new Queue&lt;Point&gt;();<br>        q.Enqueue(new Point { X = x, Y = y });<br>        flags[x, y] = true;<br>        while (q.Count &gt; 0)<br>        {<br>            Point p = q.Dequeue();<br><br>            result.Add(p);<br><br>            x = p.X;<br>            y = p.Y;<br>            for (int i = 0; i &lt; 4; i++)<br>            {<br>                if (x + dx[i] &lt; n &amp;&amp; y + dy[i] &lt; n &amp;&amp; x + dx[i] &gt;= 0 &amp;&amp; y + dy[i] &gt;= 0 &amp;&amp; board[x + dx[i]][y + dy[i]] == 'o' &amp;&amp; !flags[x + dx[i], y + dy[i]])<br>                {<br>                    flags[x + dx[i], y + dy[i]] = true;<br><br>                    q.Enqueue(new Point { X = x + dx[i], Y = y + dy[i] });<br>                }<br>            }<br>        }<br><br>        return result;<br>    }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>