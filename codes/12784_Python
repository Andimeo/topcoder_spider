<td class="problemText" colspan="8" valign="middle" align="left">
            class HexagonalBoard:<br> <br>  def neigh(self, v):<br>    r, c = v<br>    candidates = [(r, c-1), (r, c+1), (r+1, c-1), (r+1, c), (r-1, c), (r-1, c+1)]<br>    return set([(r, c) for r, c in candidates if (0 &lt;= r &lt; self.n) and (0 &lt;= c &lt; self.n)])<br>    <br>  def is_bipartite(self, vertices, sos):<br>    color = dict()<br>    for u in vertices:<br>      color[u] = None<br>    q = []<br>    for v in vertices:<br>      if color[v] is None:<br>        q.append(v)<br>        color[v] = 0<br>      while len(q) &gt; 0:<br>        u = q.pop()<br>        for w in sos[u]:<br>          if color[w] is None:<br>            color[w] = 1 - color[u]<br>            q.append(w)<br>          elif color[w] == color[u]:<br>            return False<br>    return True<br> <br>  def minColors(self, board):<br>    self.n = len(board)<br>    vertices = set()<br>    for i in range(self.n):<br>       for j in range(self.n):<br>          if board[i][j] == 'X':<br>            vertices.add( (i, j) )<br>    sos = dict()<br>    for u in vertices:<br>      sos[u] = self.neigh(u) &amp; vertices<br>    if len(vertices) == 0: # is it empty?<br>      return 0<br>    if all([len(s) == 0 for s in sos.values()]): # is it disconnected?<br>      return 1<br>    if self.is_bipartite(vertices, sos): # is it bipartite?<br>      return 2<br>    return 3 # three color always suffice<br></td>