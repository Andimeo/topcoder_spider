<td class="problemText" colspan="8" valign="middle" align="left">
            /**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class ConvexPolygonGame {<br>    static class SingleLineChecker {<br>        int cnt;<br>        int x1;<br>        int y1;<br>        int x2;<br>        int y2;<br>        long a;<br>        long b;<br>        long c;<br> <br>        boolean handle(int x, int y) {<br>            if (cnt == 0) {<br>                cnt = 1;<br>                x1 = x;<br>                y1 = y;<br>                return true;<br>            } else if (cnt == 1) {<br>                cnt = 2;<br>                x2 = x;<br>                y2 = y;<br>                a = y2 - y1;<br>                b = x1 - x2;<br>                c = -(a * x1 + b * y1);<br>                return true;<br>            } else {<br>                return a * x + b * y + c == 0;<br>            }<br>        }<br>    }<br> <br>    public String winner(int[] X, int[] Y) {<br>        int min = 0;<br>        int max = 0;<br>        for (int i = 0; i &lt; X.length; ++i)<br>            if (X[i] &lt; X[min] || X[i] == X[min] &amp;&amp; Y[i] &lt; Y[min]) min = i;<br>        for (int i = 0; i &lt; X.length; ++i)<br>            if (X[i] &gt; X[max] || X[i] == X[max] &amp;&amp; Y[i] &gt; Y[max]) max = i;<br>        int n = X.length;<br>        int bottomStart = min;<br>        int bottomEnd = max;<br>        if (X[(max + n - 1) % n] == X[max]) bottomEnd = (max + n - 1) % n;<br>        int topEnd = max;<br>        int topStart = min;<br>        if (X[(min + n - 1) % n] == X[min]) topStart = (min + n - 1) % n;<br>        SingleLineChecker checker = new SingleLineChecker();<br>        for (int x = X[min]; x &lt;= X[max]; ++x) {<br>            while (X[(bottomStart + 1) % n] &lt; x) bottomStart = (bottomStart + 1) % n;<br>            while (X[(topStart + n - 1) % n] &lt; x) topStart = (topStart + n - 1) % n;<br>            int bottomx1 = X[bottomStart];<br>            int bottomy1 = Y[bottomStart];<br>            int bottomNext = (bottomStart + 1) % n;<br>            int bottomx2 = X[bottomNext];<br>            int bottomy2 = Y[bottomNext];<br>            long bottomp = (x - bottomx1) * (long) bottomy2 + (bottomx2 - x) * (long) bottomy1;<br>            long bottomq = bottomx2 - bottomx1;<br>            if (bottomq &lt;= 0) throw new RuntimeException();<br>            long bottomcoord = bottomp / bottomq - 1;<br>            while (bottomcoord * bottomq &lt; bottomp) ++bottomcoord;<br>            if (x == bottomx1 || x == bottomx2) ++bottomcoord;<br>            int topx1 = X[topStart];<br>            int topy1 = Y[topStart];<br>            int topNext = (topStart + n - 1) % n;<br>            int topx2 = X[topNext];<br>            int topy2 = Y[topNext];<br>            long topp = (x - topx1) * (long) topy2 + (topx2 - x) * (long) topy1;<br>            long topq = topx2 - topx1;<br>            if (topq &lt;= 0) throw new RuntimeException();<br>            long topcoord = topp / topq + 1;<br>            while (topcoord * topq &gt; topp) --topcoord;<br>            if (x == topx1 || x == topx2) --topcoord;<br>            if (bottomcoord &lt;= topcoord) {<br>                for (long y = bottomcoord; y &lt;= topcoord; ++y)<br>                    if (!checker.handle(x, (int) y)) return "Masha";<br>            }<br>        }<br>        return "Petya";<br>    }<br>}<br></td>