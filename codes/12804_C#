<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br> <br>public class AstronomicalRecords<br>{<br>    public int minimalPlanets(int[] A, int[] B)<br>    {<br>        int N = A.Length;<br>        int M = B.Length;<br>        int ret = 999;<br> <br>        for (int a = 0; a &lt; N; a++)<br>        {<br>            for (int b = 0; b &lt; M; b++)<br>            {<br>                List&lt;Fraction&gt; leftA = new List&lt;Fraction&gt;();<br>                List&lt;Fraction&gt; leftB = new List&lt;Fraction&gt;();<br>                for (int i = a - 1; i &gt;= 0; i--)<br>                {<br>                    leftA.Add(new Fraction(A[i], A[a]));<br>                }<br>                for (int j = b - 1; j &gt;= 0; j--)<br>                {<br>                    leftB.Add(new Fraction(B[j], B[b]));<br>                }<br> <br>                List&lt;Fraction&gt; rightA = new List&lt;Fraction&gt;();<br>                List&lt;Fraction&gt; rightB = new List&lt;Fraction&gt;();<br>                for (int i = a + 1; i &lt; N; i++)<br>                {<br>                    rightA.Add(new Fraction(A[i], A[a]));<br>                }<br>                for (int j = b + 1; j &lt; M; j++)<br>                {<br>                    rightB.Add(new Fraction(B[j], B[b]));<br>                }<br> <br>                ret = Math.Min(ret, minFracs(leftA.ToArray(), leftB.ToArray()) + minFracs(rightA.ToArray(), rightB.ToArray()) + 1);<br> <br>            }<br>        }<br> <br>        return ret;<br>    }<br> <br>    private int minFracs(Fraction[] A, Fraction[] B)<br>    {<br>        int N = A.Length;<br>        int M = B.Length;<br> <br>        int[,] min = new int[N + 1, M + 1];<br>        for (int i = 0; i &lt; N + 1; i++)<br>        {<br>            for (int j = 0; j &lt; M + 1; j++)<br>            {<br>                min[i, j] = 999;<br>            }<br>        }<br> <br>        min[0, 0] = 0;<br>        for (int i = 0; i &lt; N + 1; i++)<br>        {<br>            for (int j = 0; j &lt; M + 1; j++)<br>            {<br>                if (i &gt; 0)<br>                {<br>                    min[i, j] = Math.Min(min[i, j], min[i - 1, j] + 1);<br>                }<br>                if (j &gt; 0)<br>                {<br>                    min[i, j] = Math.Min(min[i, j], min[i, j - 1] + 1);<br>                }<br>                if (i * j &gt; 0)<br>                {<br>                    if (A[i - 1].CompareTo(B[j - 1]) == 0)<br>                    {<br>                        min[i, j] = Math.Min(min[i, j], min[i - 1, j - 1] + 1);<br>                    }<br>                }<br>            }<br>        }<br> <br>        return min[N, M];<br>    }<br> <br>    class Fraction : IComparable<br>    {<br>        private long n;<br>        private long d;<br> <br>        public long Numerator<br>        {<br>            get<br>            {<br>                return n;<br>            }<br>        }<br> <br>        public long Denominator<br>        {<br>            get<br>            {<br>                return d;<br>            }<br>        }<br> <br>        public Fraction()<br>        {<br>            this.n = 0;<br>            this.d = 1;<br>        }<br> <br>        public Fraction(long numerator, long denominator)<br>        {<br>            if (denominator == 0)<br>            {<br>                throw new Exception("Denominator cannot be 0");<br>            }<br>            this.n = numerator;<br>            this.d = denominator;<br>            Simplify();<br>        }<br> <br>        public Fraction(long number)<br>            : this(number, 1)<br>        {<br> <br>        }<br> <br>        private void Simplify()<br>        {<br>            if (d &lt; 0)<br>            {<br>                d = -d;<br>                n = -n;<br>            }<br>            long g = gcd(n, d);<br>            if (g &gt; 1)<br>            {<br>                n /= g;<br>                d /= g;<br>            }<br>            if (n == 0) d = 1;<br>        }<br> <br>        private static long gcd(long a, long b)<br>        {<br>            if (a &lt; 0) return gcd(-a, b);<br>            if (b &lt; 0) return gcd(a, -b);<br>            if (b &lt; a) return gcd(b, a);<br>            if (a == 0) return b;<br>            return gcd(b % a, a);<br>        }<br> <br>        public Fraction Inverse()<br>        {<br>            if (this.Numerator == 0) throw new Exception("Cannot get the inverse of a zero fraction");<br>            return new Fraction(this.Denominator, this.Numerator);<br>        }<br> <br>        public override string ToString()<br>        {<br>            return string.Format("{0}/{1}", Numerator, Denominator);<br>        }<br> <br>        public override int GetHashCode()<br>        {<br>            return this.ToString().GetHashCode();<br>        }<br> <br>        public override bool Equals(object obj)<br>        {<br>            Fraction f = obj as Fraction;<br>            if (f.Numerator != this.Numerator) return false;<br>            if (f.Denominator != this.Denominator) return false;<br>            return true;<br>        }<br> <br>        #region "Safe methods"<br> <br>        public static Fraction Multiply(Fraction a, Fraction b)<br>        {<br>            long g1 = gcd(a.Numerator, b.Denominator);<br>            long g2 = gcd(a.Denominator, b.Numerator);<br>            long n = (a.Numerator / g1) * (b.Numerator / g2);<br>            long d = (a.Denominator / g2) * (b.Denominator / g1);<br>            return new Fraction(n, d);<br>        }<br> <br>        public static Fraction Add(Fraction a, Fraction b)<br>        {<br>            long g = gcd(a.Denominator, b.Denominator);<br>            long d = a.Denominator / g * b.Denominator;<br>            long n = a.Numerator * (b.Denominator / g) + b.Numerator * (a.Denominator / g);<br>            return new Fraction(n, d);<br>        }<br> <br>        public static Fraction Divide(Fraction a, Fraction b)<br>        {<br>            if (b.Numerator == 0) throw new Exception("Cannot divide by a zero fraction");<br>            long gn = gcd(a.Numerator, b.Numerator);<br>            long gd = gcd(a.Denominator, b.Denominator);<br>            long n = (a.Numerator / gn) * (b.Denominator / gd);<br>            long d = (a.Denominator / gd) * (b.Numerator / gn);<br>            return new Fraction(n, d);<br>        }<br> <br>        public int CompareTo(object obj)<br>        {<br>            Fraction f = obj as Fraction;<br>            long g = gcd(this.Denominator, f.Denominator);<br>            return (this.Numerator * (f.Denominator / g)).CompareTo(f.Numerator * (this.Denominator / g));<br>        }<br> <br>        #endregion<br> <br>        #region "Perf functions"<br> <br>        /*<br>    public static Fraction Multiply(Fraction a, Fraction b)<br>    {<br>        long n = a.Numerator * b.Numerator;<br>        long d = a.Denominator * b.Denominator;<br>        return new Fraction(n, d);<br>    }<br> <br>    public static Fraction Add(Fraction a, Fraction b)<br>    {<br>        long d = a.Denominator * b.Denominator;<br>        long n = a.Numerator * b.Denominator + b.Numerator * a.Denominator;<br>        return new Fraction(n, d);<br>    }<br> <br>    public static Fraction Divide(Fraction a, Fraction b)<br>    {<br>        if (b.Numerator == 0) throw new Exception("Cannot divide by a zero fraction");<br>        long n = a.Numerator * b.Denominator;<br>        long d = a.Denominator * b.Numerator;<br>        return new Fraction(n, d);<br>    }<br> <br>    public int CompareTo(object obj)<br>    {<br>        Fraction f = obj as Fraction;<br>        return (this.Numerator * f.Denominator).CompareTo(f.Numerator * this.Denominator);<br>    }<br>    <br>    */<br>        #endregion<br> <br> <br>    }<br> <br> <br> <br>}<br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>