<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;bits/stdc++.h&gt;<br>using namespace std;<br>typedef long long ll;<br> <br>#define REP(i,n) for (int i=0; i&lt;(int)(n); ++i)<br>#define FOR(i,k,n) for (int i=(k); i&lt;(int)(n); ++i)<br>#define FOREQ(i,k,n) for (int i=(k); i&lt;=(int)(n); ++i)<br>#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)<br>#define SZ(v) (int)((v).size())<br>#define MEMSET(v,h) memset((v),(h),sizeof(v))<br> <br>#include &lt;complex&gt;<br>typedef long double ld;<br>typedef complex&lt;ld&gt; P;<br>const ld EPS=1e-8, PI=acos(-1.0);<br>#define EQ(a,b) (abs((a)-(b)) &lt; EPS)<br> <br>typedef vector&lt;P&gt; VP;<br> <br>ld dot(P a, P b) { return real(conj(a)*b); }<br>ld cross(P a, P b) { return imag(conj(a)*b); }<br>int ccw(P a, P b, P c) {<br>  b -= a; c -= a;<br>  if (cross(b, c) &gt; +EPS)   return +1;    // counter clockwise<br>  if (cross(b, c) &lt; -EPS)   return -1;    // clockwise<br>  if (dot(b, c) &lt; 0)     return +2;       // c--a--b on line<br>  if (norm(b) &lt; norm(c)) return -2;       // a--b--c on line<br>  return 0;                               // a--c--b<br>}<br> <br>class Constellation {<br>  public:<br>  double expectation(vector&lt;int&gt; vx_, vector&lt;int&gt; vy_, vector&lt;int&gt; prob_) {<br>    // UOOOOOOOO<br>    int N = SZ(vx_);<br>    P vp[N];<br>    REP(i, N) vp[i] = P(vx_[i], vy_[i]);<br> <br>    double prob[N];<br>    REP(i, N) prob[i] = prob_[i] / 1000.0;<br> <br>    ld ret = 0;<br>    REP(i, N) REP(j, N) if (i!=j) {<br>      P A = vp[i];<br>      P B = vp[j];<br> <br>      double q = prob[i] * prob[j];<br> <br>      REP(k, N) if (k!=i &amp;&amp; k!=j) {<br>        P C = vp[k];<br>        int c = ccw(A, B, C);<br>        if (c == -1 || c == 0) {<br>          q *= (1.0-prob[k]);<br>        }<br>      }<br> <br>      ret += cross(A, B) * q;<br>    }<br> <br>    return (double)ret/2.0;<br>  }<br>};<br> <br>// Powered by Greed 1.5<br></td>