<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cmath&gt;<br>#include &lt;sstream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;functional&gt;<br>#include &lt;cstring&gt;<br>#include &lt;bitset&gt;<br>using namespace std;<br>#define pb push_back<br>#define INF 1000000000<br>#define L(s) (int)((s).size())<br>#define FOR(i,a,b) for (int _n(b), i(a); i &lt;= _n; i++)<br>#define FORD(i,a,b) for(int i=(a),_b=(b);i&gt;=_b;i--)<br>#define rep(i,n) FOR(i,1,(n))<br>#define rept(i,n) FOR(i,0,(n)-1)<br>#define C(a) memset((a),0,sizeof(a))<br>#define ll long long<br>#define all(c) (c).begin(), (c).end()<br>#define SORT(c) sort(all(c))<br>#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())<br>#define VI vector&lt;int&gt;<br>#define ppb pop_back<br>#define mp make_pair<br>#define pii pair&lt;int,int&gt;<br>#define pdd pair&lt;double,double&gt;<br>#define x first<br>#define y second<br>#define pi 3.1415926535897932384626433832795028841971<br>#define rnd() ((rand() &lt;&lt; 16) ^ rand())<br> <br>const int dx[] = {0, -1, 1, 0};<br>const int dy[] = {1, 0,  0, -1};<br> <br>int n, m;<br> <br>inline bool cann(int x) {<br>  return 0 &lt;= x &amp;&amp; x &lt; n;<br>}<br> <br>inline bool canm(int x) {<br>  return 0 &lt;= x &amp;&amp; x &lt; m;<br>}<br> <br>class FoxAndGo2 {<br>   public:<br>     vector&lt;string&gt; s, vs;<br>     vector&lt;vector&lt;int&gt; &gt; w;<br>     map&lt;int, int&gt; sz;<br>     int dfs(int i, int j, int col) {<br>       w[i][j] = col;<br>       int res = 1;<br>       rept(k, 4) {<br>         int x = i + dx[k];<br>         int y = j + dy[k]; <br>         if (cann(x) &amp;&amp; canm(y))<br>           if (w[x][y] == 0 &amp;&amp; s[x][y] == 'o') {<br>             res += dfs(x, y, col);<br>           }<br>       }<br>       return res;<br>     }<br>     vector&lt;vector&lt;int&gt; &gt; q;<br>     bool dfs2(int i, int j, int col) {<br>       bool res = 0;<br>       q[i][j] = col;<br>       rept(k, 4) {<br>         int x = i + dx[k];<br>         int y = j + dy[k];<br>         if (!cann(x)) continue;<br>         if (!canm(y)) continue;<br>         if (q[x][y]) continue;<br>         if (vs[x][y] == 'x') {<br>           res |= dfs2(x, y, col);<br>         } else if (vs[x][y] == '.') {<br>           res |= true;<br>         }<br>       }<br>       return res;<br>     }<br>     bool check(vector&lt;string&gt; &amp;cs) {<br>       vs = cs;<br>       q.assign(n, vector&lt;int&gt;(m));<br>       int cnt = 0;<br>       int c = 1;<br>       rept(i, n)<br>         rept(j, m) <br>           if (vs[i][j] == 'x' &amp;&amp; q[i][j] == 0) {<br>             bool t = true ^ dfs2(i, j, c);<br>             cnt += t;<br>             c++;             <br>           }<br>       return cnt &lt;= 1;<br>     }<br>     int maxKill( vector &lt;string&gt; _s ) {<br>       s = _s;<br>       n = L(s);<br>       m = L(s[0]);<br>       w.assign(n, vector&lt;int&gt;(m));<br>       int c = 1;<br>       rept(i, n)<br>         rept(j, m) {<br>           if (s[i][j] == '.') continue;<br>           if (w[i][j]) continue;<br>           sz[c] = dfs(i, j, c);<br>           c++;<br>         }<br>       int res = 0;<br> <br>    map&lt;int, int&gt;::iterator it = sz.begin();<br>    while (it != sz.end()) {<br>      int col = it-&gt;first;<br>      vector&lt;string&gt; r = s;<br>      rept(i, n)<br>        rept(j, m)<br>          if (w[i][j] == col) {<br>            rept(k, 4)<br>              if (cann(i + dx[k]) &amp;&amp; canm(j + dy[k])) {<br>                if (r[i + dx[k]][j + dy[k]] == 'o') continue;<br>                r[i + dx[k]][j + dy[k]] = 'x';<br>              }<br>          } <br>      // generate<br>      if (check(r)) {<br>        res += it-&gt;second;<br>        rept(i, n)<br>          rept(j, m)<br>            if (s[i][j] == 'o' &amp;&amp; w[i][j] == it-&gt;first)<br>              s[i][j] = '.';<br>        //cerr &gt;&gt; s &lt;&lt; endl;<br> <br>        sz.erase(it);<br>        it = sz.begin();<br>      } else it++;<br>    }<br>       return res;<br>  }<br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>