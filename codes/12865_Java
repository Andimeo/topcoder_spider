<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Comparator;<br>import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class WinterAndShopping {<br>    static class Shop {<br>        int first;<br>        int red;<br>        int green;<br>        int blue;<br> <br>        Shop(int first, int red, int green, int blue) {<br>            this.first = first;<br>            this.red = red;<br>            this.green = green;<br>            this.blue = blue;<br>        }<br>    }<br> <br>    static final int MODULO = (int) (1e9 + 7);<br>    static final int MAXONE = 100;<br> <br>    public int getNumber(int[] _first, int[] _red, int[] _green, int[] _blue) {<br>        Shop[] shops = new Shop[_first.length + 1];<br>        for (int i = 0; i &lt; shops.length - 1; ++i) {<br>            shops[i] = new Shop(_first[i], _red[i], _green[i], _blue[i]);<br>        }<br>        shops[shops.length - 1] = new Shop((int) 1e9, 0, 0, 0);<br>        Arrays.sort(shops, new Comparator&lt;Shop&gt;() {<br>            @Override<br>            public int compare(Shop o1, Shop o2) {<br>                return o1.first - o2.first;<br>            }<br>        });<br>        Shop nowActive = null;<br>        int[][] comb = new int[3 * MAXONE + 1][3 * MAXONE + 1];<br>        comb[0][0] = 1;<br>        for (int i = 1; i &lt; comb.length; ++i) {<br>            comb[i][0] = 1;<br>            for (int j = 1; j &lt; comb.length; ++j) {<br>                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];<br>                if (comb[i][j] &gt;= MODULO) comb[i][j] -= MODULO;<br>            }<br>        }<br>        int[][] ways = new int[MAXONE + 1][MAXONE + 1];<br>        int[][] nways = new int[MAXONE + 1][MAXONE + 1];<br>        int start = 0;<br>        ways[0][0] = 1;<br>        for (Shop s : shops) {<br>            if (nowActive != null) {<br>                while (start &lt; s.first) {<br>                    int remains = (nowActive.blue + nowActive.red + nowActive.green - (start - nowActive.first));<br>                    for (int[] x : nways) Arrays.fill(x, 0);<br>                    for (int red = 0; red &lt;= nowActive.red; ++red)<br>                        for (int green = 0; green &lt;= nowActive.green; ++green) {<br>                            int blue = remains - red - green;<br>                            if (blue &gt;= 0 &amp;&amp; blue &lt;= nowActive.blue) {<br>                                int old = ways[red][green];<br>                                if (old == 0) continue;<br>                                if (red &gt; 0) {<br>                                    nways[red - 1][green] += old;<br>                                    if (nways[red - 1][green] &gt;= MODULO) nways[red - 1][green] -= MODULO;<br>                                }<br>                                if (green &gt; 0) {<br>                                    nways[red][green - 1] += old;<br>                                    if (nways[red][green - 1] &gt;= MODULO) nways[red][green - 1] -= MODULO;<br>                                }<br>                                if (blue &gt; 0) {<br>                                    nways[red][green] += old;<br>                                    if (nways[red][green] &gt;= MODULO) nways[red][green] -= MODULO;<br>                                }<br>                            }<br>                        }<br>                    int[][] tmp = ways;<br>                    ways = nways;<br>                    nways = tmp;<br>                    ++start;<br>                    --remains;<br>                    if (remains == 0) {<br>                        nowActive = null;<br>                        break;<br>                    }<br>                }<br>            }<br>            if (nowActive == null) {<br>                nowActive = s;<br>                int old = ways[0][0];<br>                ways[0][0] = 0;<br>                ways[s.red][s.green] = old;<br>                start = s.first;<br>            } else {<br>                if (start != s.first) throw new RuntimeException();<br>                int remains = (nowActive.blue + nowActive.red + nowActive.green - (start - nowActive.first));<br>                int remainsNew = s.red + s.green + s.blue;<br>                for (int[] x : nways) Arrays.fill(x, 0);<br>                if (remains &lt;= remainsNew) {<br>                    for (int red = 0; red &lt;= nowActive.red; ++red)<br>                        for (int green = 0; green &lt;= nowActive.green; ++green) {<br>                            int blue = remains - red - green;<br>                            if (blue &gt;= 0 &amp;&amp; blue &lt;= nowActive.blue) {<br>                                int old = ways[red][green];<br>                                if (old == 0) continue;<br>                                int remRed = s.red - red;<br>                                int remGreen = s.green - green;<br>                                int remBlue = s.blue - blue;<br>                                if (remRed &gt;= 0 &amp;&amp; remGreen &gt;= 0 &amp;&amp; remBlue &gt;= 0) {<br>                                    nways[remRed][remGreen] = (int) ((nways[remRed][remGreen] + old * (long) comb[red + green + blue][red + green] % MODULO * (long) comb[red + green][red]) % MODULO);<br>                                }<br>                            }<br>                        }<br>                    start += remains;<br>                    if (remains == remainsNew) {<br>                        nowActive = null;<br>                    } else {<br>                        nowActive = s;<br>                    }<br>                } else {<br>                    for (int red = 0; red &lt;= nowActive.red; ++red)<br>                        for (int green = 0; green &lt;= nowActive.green; ++green) {<br>                            int blue = remains - red - green;<br>                            if (blue &gt;= 0 &amp;&amp; blue &lt;= nowActive.blue) {<br>                                int old = ways[red][green];<br>                                if (old == 0) continue;<br>                                int remRed = red - s.red;<br>                                int remGreen = green - s.green;<br>                                int remBlue = blue - s.blue;<br>                                if (remRed &gt;= 0 &amp;&amp; remGreen &gt;= 0 &amp;&amp; remBlue &gt;= 0) {<br>                                    nways[remRed][remGreen] = (int) ((nways[remRed][remGreen] + old * (long) comb[s.red + s.green + s.blue][s.red + s.green] % MODULO * (long) comb[s.red + s.green][s.red]) % MODULO);<br>                                }<br>                            }<br>                        }<br>                    start += remainsNew;<br>                }<br>                int[][] tmp = ways;<br>                ways = nways;<br>                nways = tmp;<br>            }<br>        }<br>        return ways[0][0];<br>    }<br>}<br></td>