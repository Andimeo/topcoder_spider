<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;string&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;cassert&gt;<br>#include &lt;cstring&gt;<br> <br>using namespace std;<br> <br>#define eprintf printf<br>#define pb push_back<br>#define mp make_pair<br>#define sz(x) ((int)(x).size())<br>#define sqr(x) ((x) * (x))<br>typedef long long ll;<br>typedef vector&lt;ll&gt; vll;<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;vi&gt; vvi;<br>typedef vector&lt;bool&gt; vb;<br>typedef vector&lt;vb&gt; vvb;<br>typedef pair&lt;int, int&gt; pii;<br> <br>class Dsu {<br>  vi par, ss;<br>  vi cnt0, cnt1;<br>  <br>  int get(int x) { return par[x] == x ? x : par[x] = get(par[x]); }<br>  public:<br>  void reset(int n) {<br>    par.clear(); ss.clear(); cnt0.clear(); cnt1.clear();<br>    par.resize(n, 0);<br>    ss.resize(n, 1);<br>    cnt0.resize(n, 0);<br>    cnt1.resize(n, 0);<br>    for (int i = 0; i &lt; n; i++)<br>      par[i] = i;<br>  }<br>  void paint(int a, int col) {<br>    a = get(a);<br>    assert(ss[a] == 1);<br>    assert(!cnt0[a] &amp;&amp; !cnt1[a]);<br>    assert(col == !!col);<br>    if (col == 0) cnt0[a]++;<br>    else cnt1[a]++;<br>  }<br>  void merge(int a, int b) {<br>    a = get(a); b = get(b);<br>    if (a == b) return;<br>    if (ss[a] &gt; ss[b]) swap(a, b);<br>    par[a] = b;<br>    ss[b] += ss[a];<br>    cnt0[b] += cnt0[a];<br>    cnt1[b] += cnt1[a];<br>  }<br>  int solve() {<br>    int res = 0;<br>    for (int i = 0; i &lt; sz(par); i++)<br>      if (par[i] == i)<br>        res += min(cnt0[i], cnt1[i]);<br>    return res;<br>  }<br>};<br> <br>const int inf = 1e9;<br> <br>class PalindromeMatrix {<br>public:<br>  int minChange(vector &lt;string&gt; A, int rowCount, int colCount) {<br>    int h = sz(A);<br>    int w = sz(A[0]);<br>    assert(h % 2 == 0 &amp;&amp; w % 2 == 0);<br>    assert(0 &lt;= rowCount &amp;&amp; rowCount &lt;= h);<br>    assert(0 &lt;= colCount &amp;&amp; colCount &lt;= w);<br>    <br>    int ans = inf;<br>    for (int mrow = 0; mrow &lt; (1 &lt;&lt; h); mrow++) if (__builtin_popcount(mrow) &gt;= rowCount) {<br>      vi dyn(w + 1, inf), ndyn;<br>      dyn[0] = 0;<br>      Dsu dsu;<br>      for (int x = 0; x &lt; w / 2; x++) {<br>        int cnts[3] = {inf,inf,inf};<br>        for (int cm = 0; cm &lt; 4; cm++) {<br>          dsu.reset(2 * h);<br>          for (int y = 0; y &lt; h; y++) {<br>            dsu.paint(y, A[y][x] - '0');<br>            dsu.paint(h + y, A[y][w - x - 1] - '0');<br>          }<br>          <br>          for (int y = 0; y &lt; h; y++) if (mrow &amp; (1 &lt;&lt; y))<br>            dsu.merge(y, h + y);<br>            <br>          for (int y = 0; y &lt; h / 2; y++) {<br>            if (cm &amp; 1) dsu.merge(y, h - y - 1);<br>            if (cm &amp; 2) dsu.merge(h + y, h + h - y - 1);<br>          }<br>          <br>          int mcnt = __builtin_popcount(cm);<br>          cnts[mcnt] = min(cnts[mcnt], dsu.solve());<br>        }<br>        ndyn.clear();<br>        ndyn.resize(w + 1, inf);<br>        for (int i = 0; i &lt;= w; i++)<br>        for (int i2 = 0; i + i2 &lt;= w &amp;&amp; i2 &lt;= 2; i2++)<br>          ndyn[i + i2] = min(ndyn[i + i2], dyn[i] + cnts[i2]);<br>        dyn.swap(ndyn);<br>      }<br>      for (int i = colCount; i &lt;= w; i++)<br>        ans = min(ans, dyn[i]);<br>    }<br>    return ans;<br>  }<br>};<br> <br> <br> <br> <br> <br> <br> <br> <br>//Powered by KawigiEdit 2.1.6 (beta) modified by pivanof (C++ patch by vexorian)!<br></td>