<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;queue&gt;<br>#include &lt;cstring&gt;<br>using namespace std;<br><br>struct PalindromeMatrixDiv2 {<br>  int minChange(vector &lt;string&gt; A, int rowCount, int columnCount);<br>};<br><br>inline int BIT(int n, int i) { return (n&gt;&gt;i)&amp;1; }<br><br>void Generate(vector&lt;int&gt; &amp;t, int n, int c) {<br>  t.clear();<br>  for(int i = 0; i &lt; (1&lt;&lt;n); i++) {<br>    int cnt = 0;<br>    for(int j = 0; j &lt; n; j++)<br>      if (BIT(i, j)) cnt++;<br>    if (cnt == c) t.push_back(i);<br>  }<br>}<br><br>int a[8][8];<br>int consider[8][8], key;<br>int n, m;<br><br>void dfs(int i, int j, int r, int c, int Count[2]) {<br>  if (consider[r][c] == key) return;<br>  consider[r][c] = key;<br>  Count[a[r][c]]++;<br>  if (BIT(i, r)) dfs(i, j, r, m-c-1, Count);<br>  if (BIT(j, c)) dfs(i, j, n-r-1, c, Count);<br>}<br><br>int PalindromeMatrixDiv2::minChange(vector &lt;string&gt; A, int rowCount, int columnCount) {<br><br>  n = A.size();<br>  m = A[0].length();<br>  for(int i = 0; i &lt; n; i++)<br>    for(int j = 0; j &lt; m; j++)<br>      a[i][j] = A[i][j]-'0';<br><br>  vector&lt;int&gt; tr, tc;<br>  Generate(tr, n, rowCount);<br>  Generate(tc, m, columnCount);<br><br>  key = 0;<br>  memset(consider, 0, sizeof consider);<br><br>  int ret = 1e9;<br>  for(int ii = 0; ii &lt; tr.size(); ii++) {<br>    int i = tr[ii];<br>    for(int jj = 0; jj &lt; tc.size(); jj++) {<br>      int j = tc[jj];<br>      int tret = 0;<br>      key++;<br>      for(int r = 0; r &lt; n; r++)<br>        for(int c = 0; c &lt; m; c++) {<br>          int Count[2] = {0, 0};<br>          dfs(i, j, r, c, Count);<br>          tret += min(Count[0], Count[1]);<br>        }<br><br>      ret = min(ret, tret);<br>    }<br>  }<br><br>  return ret;<br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by TesterDream 1.2.4 by fushar (December 19 2012)<br>// Powered by CodeProcessor<br></td>