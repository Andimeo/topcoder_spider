<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class Ordered{<br>public class frac{<br>    public long n,d;<br>    public frac( long _n, long _d ){<br>      n = _n;<br>      d = _d;<br>      reduce();<br>    }<br>    public frac( long _n ){<br>      n = _n;<br>      d = 1;<br>      reduce();<br>    }<br>    public frac add( frac x ){<br>      return new frac( n*x.d + d*x.n, d*x.d );<br>    }<br>    public frac subtract( frac x ){<br>      return add( x.multiply( new frac( -1 ) ) );<br>    }<br>    public frac multiply( frac x ){<br>      return new frac( n*x.n, d*x.d );<br>    }<br>    public frac divide( frac x ){<br>      return new frac( n*x.d, d*x.n );<br>    }<br>    private void reduce(){<br>      if( d&lt;0 ){<br>        n *= -1;<br>        d *= -1;<br>      }<br>      if( n == 0 ){<br>        d = 1;<br>      }else if( d == 0 ){<br>        n = 1;<br>      }else{<br>        long g = gcd( Math.abs(n), Math.abs(d) );<br>        n /= g;<br>        d /= g;<br>      }<br>    }<br>    public long gcd( long a, long b ){<br>      return b==0 ? a : gcd(b, a%b);<br>    }<br>    public String toString(){<br>      return n + "/" + d;<br>    }<br>  }<br>  public String getType( int[] values ){<br>    boolean a=true, d=true, na=true, nd=true;<br>    int i;<br>    for( i=0; i+1&lt;values.length; i++ ){<br>      if( values[i]&lt;values[i+1] ){<br>        d=na=false;<br>      }else if( values[i]==values[i+1] ){<br>        a=d=false;<br>      }else{<br>        a=nd=false;<br>      }<br>    }<br>    frac mean=new frac(0);<br>    for( i=0; i&lt;values.length; i++ ){<br>      mean = mean.add(new frac(values[i]));<br>    }<br>    mean = mean.divide(new frac(values.length));<br>    int best=1;<br>    int j;<br>    for( i=0; i&lt;values.length; i++ ){<br>      int mod=0;<br>      for( j=0; j&lt;values.length; j++ ){<br>        if( values[i]==values[j] ){<br>          mod++;<br>        }<br>      }<br>      best = Math.max(best,mod);<br>    }<br>    if( a ){<br>      return "ASCENDING " + mean;<br>    }else if( d ){<br>      return "DESCENDING " + mean;<br>    }else if( na ){<br>      return "NONASCENDING " + best;<br>    }else if( nd ){<br>      return "NONDESCENDING " + best;<br>    }else{<br>      return "NOTHING";<br>    }<br>  }<br> <br> <br>}<br> <br>// Powered by PopsEdit<br>// Powered by CodeProcessor<br></td>