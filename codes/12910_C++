<td class="problemText" colspan="8" valign="middle" align="left">
            #line 6 "SumOfArrays.cpp"<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;complex&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>long long a[100001];<br>long long b[100001];<br>int cntA[100001];<br>int cntB[100001];<br>vector &lt;int&gt; occurA[100001];<br>vector &lt;int&gt; occurB[100001];<br>long long ans[200001];<br><br>string toString(int x)<br>{<br>  if(x == 0) return "0";<br>  string ret;<br>  while(x)<br>  {<br>    ret = char('0' + x%10) + ret;<br>    x /= 10;<br>  }<br>  return ret;<br>}<br><br>int LIMIT = 10000;<br><br>void bruteForce(int lv)<br>{<br>  //cout &lt;&lt; lv &lt;&lt; " " &lt;&lt; occurA[lv].size() &lt;&lt; " " &lt;&lt; occurB[lv].size() &lt;&lt; endl;<br>  if(occurA[lv].size() == 0 || occurB[lv].size() == 0) return;<br>  for(int i = 0; i &lt; occurA[lv].size(); i++)<br>    for(int j = 0; j &lt; occurB[lv].size(); j++)<br>      ans[occurA[lv][i] + occurB[lv][j]] ++;<br>}<br><br>int n = 18, aa[1&lt;&lt;18], bb[1&lt;&lt;18], cc[1&lt;&lt;18];<br><br>class FFT_GF<br>{<br>public:<br>  static const int MAXN = 20;<br>  static const int Mod=104857601;<br>  static const int alpha=79427530;<br>  int Alpha[MAXN],Beta[MAXN];<br>  FFT_GF()<br>  {<br>    for (int i=MAXN-1,a=alpha;i&gt;=0;i--){<br>      Alpha[i]=a;Beta[i]=Pow(a,Mod-2);a=Mul(a,a);<br>    }<br>  }<br>  int Mul(int a,int b){return (((long long)a)*b)%Mod;}<br>  int Add(int a,int b){long long c=(long long)a+b;if (c&gt;=Mod)  return c-Mod;return c;}<br>  int Sub(int a,int b){long long c=(long long)a-b;if (c&lt;0)return c+Mod;  return c;}<br>  int Pow(int a,int n){if (n==0)return 1;int r=Pow(a,n&gt;&gt;1);r=Mul(r,r);if (n&amp;1)r=Mul(r,a);return r;}<br>  void FFT(int *A,int n){<br>    for (int i=0,j=0;i&lt;(1&lt;&lt;n);i++){<br>      if (i&lt;j)swap(A[i],A[j]);<br>      int high=(1&lt;&lt;(n-1));<br>      while (high&amp;j){j^=high;high&gt;&gt;=1;}<br>      j^=high;<br>    }<br>    for (int level=0;level&lt;n;level++){<br>      for (int i=0;i&lt;(1&lt;&lt;n);i+=(2&lt;&lt;level)){<br>        int w=1,a=Alpha[level];<br>        for (int j=0,k=(1&lt;&lt;level);j&lt;(1&lt;&lt;level);j++,k++){<br>          int t=Mul(A[i+k],w);<br>          A[i+k]=Sub(A[i+j],t);A[i+j]=Add(A[i+j],t);<br>          w=Mul(w,a);<br>        }<br>      }<br>    }<br>  }<br>  void revFFT(int *A,int n){<br>    for (int i=0,j=0;i&lt;(1&lt;&lt;n);i++){<br>      if (i&lt;j)swap(A[i],A[j]);<br>      int high=(1&lt;&lt;(n-1));<br>      while (high&amp;j){j^=high;high&gt;&gt;=1;}<br>      j^=high;<br>    }<br>    for (int level=0;level&lt;n;level++){<br>      for (int i=0;i&lt;(1&lt;&lt;n);i+=(2&lt;&lt;level)){<br>        int w=1,a=Beta[level];<br>        for (int j=0,k=(1&lt;&lt;level);j&lt;(1&lt;&lt;level);j++,k++){<br>          int t=Mul(A[i+k],w);<br>          A[i+k]=Sub(A[i+j],t);A[i+j]=Add(A[i+j],t);<br>          w=Mul(w,a);<br>        }<br>      }<br>    }<br>    unsigned int rep=1;<br>    for (int i=0;i&lt;n;i++){<br>      if (!(rep&amp;1))rep&gt;&gt;=1;<br>      else rep=(rep+Mod)&gt;&gt;1;<br>    }<br>  }<br>  void convolution(int* A, int *B, int *C, int n) // C &lt;- A * B  (|C| = 2**n) it will destory A and B!<br>  {<br>    FFT(A, n); FFT(B, n);<br>    for(int i=0;i&lt;(1&lt;&lt;n);i++) C[i] = Mul(A[i], B[i]);<br>    revFFT(C, n);<br>    for(int i=0;i&lt;(1&lt;&lt;n);i++) C[i] = Mul(C[i], Pow(Pow(2, n), Mod-2));<br>  }<br>}FFT_GF_solver;<br><br>/*  Note<br>  1. length of vector = 2**n<br>  2. result must &lt; 104857601<br>*/<br><br>/*  Example<br>  int n, a[100], b[100], c[100];<br>  cin &gt;&gt; n;<br>  for(int i = 0; i &lt; (1&lt;&lt;n); i++)<br>    cin &gt;&gt; a[i];<br>  for(int i = 0; i &lt; (1&lt;&lt;n); i++)<br>    cin &gt;&gt; b[i];<br>  FFT_GF_solver.convolution(a, b, c, n);<br>  for(int i = 0; i &lt; (1&lt;&lt;n); i++)<br>    cout &lt;&lt; c[i] &lt;&lt; endl;<br>*/<br><br>int bads = 0;<br><br>void fastSolution(int lv)<br>{<br><br>  bads ++;<br>  //return;<br>  memset(aa, 0, sizeof(aa));<br>  memset(bb, 0, sizeof(bb));<br>  for(int i = 0; i &lt; occurA[lv].size(); i++)<br>    aa[occurA[lv][i]] ++;<br>  for(int i = 0; i &lt; occurB[lv].size(); i++)<br>    bb[occurB[lv][i]] ++;<br>  FFT_GF_solver.convolution(aa, bb, cc, n);<br>  for(int i = 0; i &lt;= 200000; i++)<br>    ans[i] += cc[i];<br>}<br><br>void calcLevel(int lv)<br>{<br>  if(occurA[lv].size() &lt;= LIMIT || occurB[lv].size() &lt;= LIMIT)<br>    bruteForce(lv);<br>  else<br>    fastSolution(lv);<br>}<br><br>class SumOfArrays<br>{<br>  public:<br>  string findbestpair(int n, vector &lt;int&gt; Aseed, vector &lt;int&gt; Bseed)<br>  {<br>    //if(n &gt; 1000) return "TODO";<br>    memset(cntA, 0, sizeof(cntA));<br>    memset(cntB, 0, sizeof(cntB));<br>    //cout &lt;&lt; "&lt;1&gt;" &lt;&lt; endl;<br>    a[0] = Aseed[0];<br>    a[1] = Aseed[1];<br>    for(int i = 2; i &lt; n; i++)<br>      a[i] = (a[i-1] * Aseed[2] + a[i-2] * Aseed[3] + Aseed[4]) % Aseed[5];<br>    //cout &lt;&lt; "&lt;2&gt;" &lt;&lt; endl;<br>    for(int i = 0; i &lt; n; i++)<br>    {<br>      //cout &lt;&lt; i &lt;&lt; ": " &lt;&lt; a[i] &lt;&lt; endl;<br>      cntA[a[i]] ++;<br>    }<br>    //cout &lt;&lt; "&lt;3&gt;" &lt;&lt; endl;<br><br>    b[0] = Bseed[0];<br>    b[1] = Bseed[1];<br>    for(int i = 2; i &lt; n; i++)<br>      b[i] = (b[i-1] * Bseed[2] + b[i-2] * Bseed[3] + Bseed[4]) % Bseed[5];<br>    //cout &lt;&lt; "&lt;4&gt;" &lt;&lt; endl;<br>    for(int i = 0; i &lt; n; i++)<br>      cntB[b[i]] ++;<br>    //cout &lt;&lt; "&lt;5&gt;" &lt;&lt; endl;<br>    for(int i = 0; i &lt;= n; i++)<br>    {<br>      occurA[i].clear();<br>      occurB[i].clear();<br>    }<br>    for(int i = 0; i &lt; 100000; i++)<br>      if(cntA[i] &gt; 0)<br>        for(int j = 0; j &lt;= cntA[i]; j++)<br>          occurA[j].push_back(i);<br>    for(int i = 0; i &lt; 100000; i++)<br>      if(cntB[i] &gt; 0)<br>        for(int j = 0; j &lt;= cntB[i]; j++)<br>          occurB[j].push_back(i);<br>    memset(ans, 0, sizeof(ans));<br>    for(int i = 1; i &lt;= n; i++)<br>      calcLevel(i);<br><br>    int maxV = 0, which = 0;<br>    for(int i = 0; i &lt;= 200000; i++)<br>      if(ans[i] &gt;= maxV)<br>      {<br>        maxV = ans[i];<br>        which = i;<br>      }<br>    cout &lt;&lt; "bads = " &lt;&lt; bads &lt;&lt; endl;<br>    return toString(maxV) + " " + toString(which);<br>  }<br><br>  <br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>