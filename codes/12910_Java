<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.NoSuchElementException;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class SumOfArrays {<br>    public String findbestpair(int n, int[] Aseed, int[] Bseed) {<br>    long[] a = generate(n, Aseed);<br>    long[] b = generate(n, Bseed);<br>    long[] result = new long[200000];<br>    long[] aCur = new long[100000];<br>    long[] bCur = new long[100000];<br>    for (int i = 0; i &lt; 10; i++) {<br>      for (int j = 0; j &lt; 100000; j++) {<br>        aCur[j] = Math.min(1, a[j]);<br>        bCur[j] = Math.min(1, b[j]);<br>      }<br>      long[] c = FastFourierTransform.multiply(aCur, bCur);<br>      for (int j = 0; j &lt; 200000; j++)<br>        result[j] += c[j];<br>      for (int j = 0; j &lt; 100000; j++) {<br>        a[j] -= aCur[j];<br>        b[j] -= bCur[j];<br>      }<br>    }<br>    int[] nonZeroA = getNonZero(a);<br>    int[] nonZeroB = getNonZero(b);<br>    for (int i : nonZeroA) {<br>      for (int j : nonZeroB)<br>        result[i + j] += Math.min(a[i], b[j]);<br>    }<br>    int at = -1;<br>    int total = 0;<br>    for (int i = 199998; i &gt;= 0; i--) {<br>      if (result[i] &gt; total) {<br>        total = (int) result[i];<br>        at = i;<br>      }<br>    }<br>    return total + " " + at;<br>    }<br> <br>  private int[] getNonZero(long[] array) {<br>    IntList result = new IntArrayList();<br>    for (int i = 0; i &lt; array.length; i++) {<br>      if (array[i] != 0)<br>        result.add(i);<br>    }<br>    return result.toArray();<br>  }<br> <br>  private long[] generate(int n, int[] seed) {<br>    int[] result = new int[n];<br>    result[0] = seed[0];<br>    result[1] = seed[1];<br>    for (int i = 2; i &lt; n; i++)<br>      result[i] = (int) (((long)result[i - 1] * seed[2] + (long)result[i - 2] * seed[3] + seed[4]) % seed[5]);<br>    long[] qty = new long[100000];<br>    for (int i : result)<br>      qty[i]++;<br>    return qty;<br>  }<br>}<br> <br>class FastFourierTransform {<br>  public static void fft(double[] a, double[] b, boolean invert) {<br>    int count = a.length;<br>    for (int i = 1, j = 0; i &lt; count; i++) {<br>      int bit = count &gt;&gt; 1;<br>      for (; j &gt;= bit; bit &gt;&gt;= 1)<br>        j -= bit;<br>      j += bit;<br>      if (i &lt; j) {<br>        double temp = a[i];<br>        a[i] = a[j];<br>        a[j] = temp;<br>        temp = b[i];<br>        b[i] = b[j];<br>        b[j] = temp;<br>      }<br>    }<br>    for (int len = 2; len &lt;= count; len &lt;&lt;= 1) {<br>      int halfLen = len &gt;&gt; 1;<br>      double angle = 2 * Math.PI / len;<br>      if (invert)<br>        angle = -angle;<br>      double wLenA = Math.cos(angle);<br>      double wLenB = Math.sin(angle);<br>      for (int i = 0; i &lt; count; i += len) {<br>        double wA = 1;<br>        double wB = 0;<br>        for (int j = 0; j &lt; halfLen; j++) {<br>          double uA = a[i + j];<br>          double uB = b[i + j];<br>          double vA = a[i + j + halfLen] * wA - b[i + j + halfLen] * wB;<br>          double vB = a[i + j + halfLen] * wB + b[i + j + halfLen] * wA;<br>          a[i + j] = uA + vA;<br>          b[i + j] = uB + vB;<br>          a[i + j + halfLen] = uA - vA;<br>          b[i + j + halfLen] = uB - vB;<br>          double nextWA = wA * wLenA - wB * wLenB;<br>          wB = wA * wLenB + wB * wLenA;<br>          wA = nextWA;<br>        }<br>      }<br>    }<br>    if (invert) {<br>      for (int i = 0; i &lt; count; i++) {<br>        a[i] /= count;<br>        b[i] /= count;<br>      }<br>    }<br>  }<br> <br>  public static long[] multiply(long[] a, long[] b) {<br>    int resultSize = Integer.highestOneBit(Math.max(a.length, b.length) - 1) &lt;&lt; 2;<br>    resultSize = Math.max(resultSize, 1);<br>    double[] aReal = new double[resultSize];<br>    double[] aImaginary = new double[resultSize];<br>    double[] bReal = new double[resultSize];<br>    double[] bImaginary = new double[resultSize];<br>    for (int i = 0; i &lt; a.length; i++)<br>      aReal[i] = a[i];<br>    for (int i = 0; i &lt; b.length; i++)<br>      bReal[i] = b[i];<br>    fft(aReal, aImaginary, false);<br>    if (a == b) {<br>      System.arraycopy(aReal, 0, bReal, 0, aReal.length);<br>      System.arraycopy(aImaginary, 0, bImaginary, 0, aImaginary.length);<br>    } else<br>      fft(bReal, bImaginary, false);<br>    for (int i = 0; i &lt; resultSize; i++) {<br>      double real = aReal[i] * bReal[i] - aImaginary[i] * bImaginary[i];<br>      aImaginary[i] = aImaginary[i] * bReal[i] + bImaginary[i] * aReal[i];<br>      aReal[i] = real;<br>    }<br>    fft(aReal, aImaginary, true);<br>    long[] result = new long[resultSize];<br>    for (int i = 0; i &lt; resultSize; i++)<br>      result[i] = Math.round(aReal[i]);<br>    return result;<br>  }<br>}<br> <br>abstract class IntList extends IntCollection implements Comparable&lt;IntList&gt; {<br> <br>  public abstract int get(int index);<br> <br>  public IntIterator iterator() {<br>    return new IntIterator() {<br>      private int size = size();<br>      private int index = 0;<br> <br>      public int value() throws NoSuchElementException {<br>        if (!isValid())<br>          throw new NoSuchElementException();<br>        return get(index);<br>      }<br> <br>      public void advance() throws NoSuchElementException {<br>        if (!isValid())<br>          throw new NoSuchElementException();<br>        index++;<br>      }<br> <br>      public boolean isValid() {<br>        return index &lt; size;<br>      }<br>    };<br>  }<br> <br>  public int hashCode() {<br>    int hashCode = 1;<br>    for (IntIterator i = iterator(); i.isValid(); i.advance())<br>      hashCode = 31 * hashCode + i.value();<br>    return hashCode;<br>  }<br> <br>  public boolean equals(Object obj) {<br>    if (!(obj instanceof IntList))<br>      return false;<br>    IntList list = (IntList)obj;<br>    if (list.size() != size())<br>      return false;<br>    IntIterator i = iterator();<br>    IntIterator j = list.iterator();<br>    while (i.isValid()) {<br>      if (i.value() != j.value())<br>        return false;<br>      i.advance();<br>      j.advance();<br>    }<br>    return true;<br>  }<br> <br>  public int compareTo(IntList o) {<br>    IntIterator i = iterator();<br>    IntIterator j = o.iterator();<br>    while (true) {<br>      if (i.isValid()) {<br>        if (j.isValid()) {<br>          if (i.value() != j.value()) {<br>            if (i.value() &lt; j.value())<br>              return -1;<br>            else<br>              return 1;<br>          }<br>        } else<br>          return 1;<br>      } else {<br>        if (j.isValid())<br>          return -1;<br>        else<br>          return 0;<br>      }<br>      i.advance();<br>      j.advance();<br>    }<br>  }<br> <br>  }<br> <br>class IntArrayList extends IntList {<br>  private int[] array;<br>  private int size;<br> <br>  public IntArrayList() {<br>    this(10);<br>  }<br> <br>  public IntArrayList(int capacity) {<br>    array = new int[capacity];<br>  }<br> <br>  public IntArrayList(IntList list) {<br>    this(list.size());<br>    addAll(list);<br>  }<br> <br>  public int get(int index) {<br>    if (index &gt;= size)<br>      throw new IndexOutOfBoundsException();<br>    return array[index];<br>  }<br> <br>  public int size() {<br>    return size;<br>  }<br> <br>  public void add(int value) {<br>    ensureCapacity(size + 1);<br>    array[size++] = value;<br>  }<br> <br>  public void ensureCapacity(int newCapacity) {<br>    if (newCapacity &gt; array.length) {<br>      int[] newArray = new int[Math.max(newCapacity, array.length &lt;&lt; 1)];<br>      System.arraycopy(array, 0, newArray, 0, size);<br>      array = newArray;<br>    }<br>  }<br> <br>  public int[] toArray() {<br>    int[] array = new int[size];<br>    System.arraycopy(this.array, 0, array, 0, size);<br>    return array;<br>  }<br> <br>    }<br> <br>abstract class IntCollection {<br>  public abstract IntIterator iterator();<br>  public abstract int size();<br>  public abstract void add(int value);<br> <br>  public int[] toArray() {<br>    int size = size();<br>    int[] array = new int[size];<br>    int i = 0;<br>    for (IntIterator iterator = iterator(); iterator.isValid(); iterator.advance())<br>      array[i++] = iterator.value();<br>    return array;<br>  }<br> <br>  public void addAll(IntCollection values) {<br>    for (IntIterator it = values.iterator(); it.isValid(); it.advance()) {<br>      add(it.value());<br>    }<br>  }<br> <br>  }<br> <br>interface IntIterator {<br>  public int value() throws NoSuchElementException;<br>  /*<br>   * @throws NoSuchElementException only if iterator already invalid<br>   */<br>  public void advance() throws NoSuchElementException;<br>  public boolean isValid();<br>}<br></td>