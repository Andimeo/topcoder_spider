<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;ctime&gt;<br>#include &lt;cmath&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;list&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;iostream&gt;<br><br>#define pb push_back<br>#define mp make_pair<br>#define TASKNAME ""<br><br>#ifdef LOCAL<br>#define eprintf(...) fprintf(stderr,__VA_ARGS__)<br>#else<br>#define eprintf(...)<br>#endif<br><br>#define TIMESTAMP(x) eprintf("[" #x "] Time = %.3lfs\n",clock()*1.0/CLOCKS_PER_SEC)<br><br>#ifdef linux<br>#define LLD "%lld"<br>#else<br>#define LLD "%I64d"<br>#endif<br><br>#define sz(x) ((int)(x).size())<br><br>using namespace std;<br><br>typedef long double ld;<br>typedef long long ll;<br>typedef vector&lt;ll&gt; vll;<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;vi&gt; vvi;<br>typedef vector&lt;bool&gt; vb;<br>typedef vector&lt;vb&gt; vvb;<br>typedef pair&lt;int, int&gt; pii;<br>typedef pair &lt;ll, ll&gt; pll;<br><br>const int inf = 1e9;<br>const double eps = 1e-9;<br>const double INF = inf;<br>const double EPS = eps;<br><br>vi G[60];<br>int H[60];<br>bool u[60];<br>int n, Cnt[60], SD[60], m, CC[60];<br>int D[60][60], Tmp[60], res=inf;<br><br>void dfs0 (int v)<br>{<br>  u[v]=1, Cnt[v]=H[v];<br>  for (int i=0; i&lt;(int)G[v].size(); i++)<br>  {<br>    if (u[G[v][i]])<br>    {<br>      G[v].erase(G[v].begin()+i), i--;<br>      continue;<br>    }<br>    dfs0(G[v][i]), Cnt[v]+=Cnt[G[v][i]], CC[v]+=Cnt[G[v][i]]+CC[G[v][i]];<br>  }<br>  //cerr&lt;&lt;v&lt;&lt;" "&lt;&lt;H[v]&lt;&lt;" "&lt;&lt;Cnt[v]&lt;&lt;" "&lt;&lt;CC[v]&lt;&lt;endl;<br>}<br><br>void dfs1 (int v)<br>{<br>  for (int i=0; i&lt;(int)G[v].size(); i++)<br>  {<br>    SD[G[v][i]]=SD[v]+(m-Cnt[G[v][i]])+(CC[v]-CC[G[v][i]]-Cnt[G[v][i]]);<br>    dfs1(G[v][i]);<br>  }<br>  //cerr&lt;&lt;v&lt;&lt;" "&lt;&lt;SD[v]&lt;&lt;endl;<br>}<br>       <br>void dfs2 (int v)<br>{ <br>  int i, j, c;<br>  for (i=2; i&lt;=m; i++)<br>    D[v][i]=inf;<br>  for (int it=0; it&lt;(int)G[v].size(); it++)<br>  {<br>    int nv=G[v][it];<br>    dfs2(nv);<br>    for (i=0; i&lt;=m; i++)<br>      Tmp[i]=inf;<br>    for (i=0; i&lt;=m; i++)<br>      for (j=0; i+j&lt;=m; j++)<br>      {<br>        if (D[v][i]==inf || D[nv][j]==inf)<br>          continue;<br>        if (i==0 &amp;&amp; j!=0)<br>          continue;<br>        c=D[v][i]+D[nv][j];<br>        c+=abs(j-Cnt[nv]);<br>        Tmp[i+j]=min(Tmp[i+j],c);<br>      }<br>    memcpy(D[v],Tmp,sizeof(Tmp));<br>  }<br> /* for (i=0; i&lt;=m; i++)<br>    cerr&lt;&lt;D[v][i]&lt;&lt;" ";<br>  cerr&lt;&lt;endl;*/<br>  res=min(res,D[v][m]+SD[v]);<br>}<br><br>class <br>FoxConnection<br>{<br>public:<br>int minimalDistance(vector &lt;int&gt; A, vector &lt;int&gt; B, string str)<br>{<br>  int i;<br>  n=(int)A.size()+1;<br>  for (i=0; i&lt;n-1; i++)<br>    A[i]--, B[i]--, G[A[i]].pb(B[i]), G[B[i]].pb(A[i]);<br>  for (i=0; i&lt;n; i++)<br>    if (str[i]=='Y')<br>      H[i]=1, m++;<br>  dfs0(0);<br>  assert(Cnt[0]==m);<br>  dfs1(0);<br>  dfs2(0);<br>  return res;<br>}<br><br>};<br></td>