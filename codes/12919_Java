<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class FoxConnection {<br>    int[] A;<br>    int[] B;<br>    String haveFox;<br>    int totalFoxes;<br>    static final int INF = (int) 1e9;<br>    <br>    static class Description {<br>        int startingFoxes;<br>        int[] bestForEndingFoxes;<br>    }<br> <br>    public int minimalDistance(int[] A, int[] B, String haveFox) {<br>        this.A = A;<br>        this.B = B;<br>        this.haveFox = haveFox;<br>        totalFoxes = 0;<br>        int n = haveFox.length();<br>        for (int i = 0; i &lt; n; ++i) if (haveFox.charAt(i) == 'Y') ++totalFoxes;<br>        Description res = dfs(0, -1);<br>        return res.bestForEndingFoxes[totalFoxes];<br>    }<br> <br>    private Description dfs(int root, int parent) {<br>        Description res = new Description();<br>        res.startingFoxes = 0;<br>        if (haveFox.charAt(root) == 'Y') ++res.startingFoxes;<br>        res.bestForEndingFoxes = new int[]{0, 0};<br>        for (int edge = 0; edge &lt; A.length; ++edge)<br>            if (A[edge] == root + 1 || B[edge] == root + 1) {<br>                int dest = A[edge] + B[edge] - (root + 1) - 1;<br>                if (dest != parent) {<br>                    Description child = dfs(dest, root);<br>                    res = addChild(res, child);<br>                }<br>            }<br>        for (int i = 0; i &lt; res.bestForEndingFoxes.length; ++i) {<br>            res.bestForEndingFoxes[i] += Math.abs(i - res.startingFoxes);<br>        }<br>        return res;<br>    }<br> <br>    private Description addChild(Description res, Description child) {<br>        Description united = new Description();<br>        united.startingFoxes = res.startingFoxes + child.startingFoxes;<br>        united.bestForEndingFoxes = new int[res.bestForEndingFoxes.length + child.bestForEndingFoxes.length - 1];<br>        Arrays.fill(united.bestForEndingFoxes, INF);<br>        united.bestForEndingFoxes[0] = res.bestForEndingFoxes[0] + child.bestForEndingFoxes[0];<br>        for (int first = 1; first &lt; res.bestForEndingFoxes.length; ++first)<br>            for (int second = 0; second &lt; child.bestForEndingFoxes.length; ++second)<br>                united.bestForEndingFoxes[first + second] = Math.min(united.bestForEndingFoxes[first + second], res.bestForEndingFoxes[first] + child.bestForEndingFoxes[second]);<br>        if (totalFoxes &lt; child.bestForEndingFoxes.length)<br>            united.bestForEndingFoxes[totalFoxes] = Math.min(united.bestForEndingFoxes[totalFoxes], res.bestForEndingFoxes[0] + child.bestForEndingFoxes[totalFoxes]);<br>        return united;<br>    }<br>}<br></td>