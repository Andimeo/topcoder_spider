<td class="problemText" colspan="8" valign="middle" align="left">
            import java.io.IOException;<br>import java.util.Arrays;<br>import java.util.InputMismatchException;<br>import java.math.BigInteger;<br>import java.io.InputStream;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class FamilyCrest {<br>    public String canBeInfinite(int[] A, int[] B, int[] C, int[] D) {<br>    int count = A.length;<br>    double[] directions = new double[count];<br>    for (int i = 0; i &lt; count; i++) {<br>      directions[i] = Math.atan2(D[i] - B[i], C[i] - A[i]);<br>      if (directions[i] &gt; Math.PI / 2)<br>        directions[i] -= Math.PI;<br>      if (directions[i] &lt; Math.PI / 2)<br>        directions[i] += Math.PI;<br>    }<br>    Arrays.sort(directions);<br>    directions = Arrays.copyOf(directions, count + 1);<br>    directions[count] = directions[0] + Math.PI;<br>    GeometryUtils.epsilon = 1e-10;<br>    for (int i = 0; i &lt; count; i++) {<br>      if (Math.abs(directions[i] - directions[i + 1]) &lt; 1e-12)<br>        continue;<br>      double angle = (directions[i] + directions[i + 1]) / 2;<br>      Segment[] was = new Segment[count];<br>      for (int j = 0; j &lt; count; j++)<br>        was[j] = new Segment(new Point(A[j], B[j]), new Point(C[j], D[j]));<br>      double dx = Math.cos(angle) * 1e-5;<br>      double dy = Math.sin(angle) * 1e-5;<br>      Segment[] will = new Segment[count];<br>      for (int j = 0; j &lt; count; j++)<br>        will[j] = new Segment(new Point(A[j] + dx, B[j] + dy), new Point(C[j] + dx, D[j] + dy));<br>      boolean good = true;<br>      for (Segment first : was) {<br>        for (Segment second : will) {<br>          if (first.intersect(second, false) != null) {<br>            good = false;<br>            break;<br>          }<br>        }<br>        if (!good)<br>          break;<br>      }<br>      if (good)<br>        return "Infinite";<br>    }<br>    return "Finite";<br>    }<br>}<br> <br>class GeometryUtils {<br>  public static double epsilon = 1e-8;<br> <br>  public static double fastHypot(double x, double y) {<br>        return Math.sqrt(x * x + y * y);<br>    }<br> <br>  }<br> <br>class Segment {<br>  public final Point a;<br>  public final Point b;<br>    private Line line = null;<br> <br>  public Segment(Point a, Point b) {<br>    this.a = a;<br>    this.b = b;<br>  }<br> <br>  public Point intersect(Segment other, boolean includeEnds) {<br>    Line line = line();<br>    Line otherLine = other.a.line(other.b);<br>    if (line.parallel(otherLine))<br>      return null;<br>    Point intersection = line.intersect(otherLine);<br>    if (contains(intersection, includeEnds) &amp;&amp; other.contains(intersection, includeEnds))<br>      return intersection;<br>    else<br>      return null;<br>  }<br> <br>  public boolean contains(Point point, boolean includeEnds) {<br>    if (a.equals(point) || b.equals(point))<br>      return includeEnds;<br>    if (a.equals(b))<br>      return false;<br>    Line line = line();<br>    if (!line.contains(point))<br>      return false;<br>    Line perpendicular = line.perpendicular(a);<br>    double aValue = perpendicular.value(a);<br>    double bValue = perpendicular.value(b);<br>    double pointValue = perpendicular.value(point);<br>    return aValue &lt; pointValue &amp;&amp; pointValue &lt; bValue || bValue &lt; pointValue &amp;&amp; pointValue &lt; aValue;<br>  }<br> <br>  public Line line() {<br>        if (line == null)<br>            line = a.line(b);<br>    return line;<br>  }<br> <br>  }<br> <br>class Point {<br>  public final double x;<br>  public final double y;<br> <br>  public String toString() {<br>    return "(" + x + ", " + y + ")";<br>  }<br> <br>  public Point(double x, double y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br> <br>  public Line line(Point other) {<br>    if (equals(other))<br>      return null;<br>    double a = other.y - y;<br>    double b = x - other.x;<br>    double c = -a * x - b * y;<br>    return new Line(a, b, c);<br>  }<br> <br>  public boolean equals(Object o) {<br>    if (this == o)<br>      return true;<br>    if (o == null || getClass() != o.getClass())<br>      return false;<br> <br>    Point point = (Point) o;<br> <br>    return Math.abs(x - point.x) &lt;= GeometryUtils.epsilon &amp;&amp; Math.abs(y - point.y) &lt;= GeometryUtils.epsilon;<br>  }<br> <br>  public int hashCode() {<br>    int result;<br>    long temp;<br>    temp = x != +0.0d ? Double.doubleToLongBits(x) : 0L;<br>    result = (int) (temp ^ (temp &gt;&gt;&gt; 32));<br>    temp = y != +0.0d ? Double.doubleToLongBits(y) : 0L;<br>    result = 31 * result + (int) (temp ^ (temp &gt;&gt;&gt; 32));<br>    return result;<br>  }<br> <br>  }<br> <br>class Line {<br>  public final double a;<br>  public final double b;<br>  public final double c;<br> <br>  public Line(Point p, double angle) {<br>    a = Math.sin(angle);<br>    b = -Math.cos(angle);<br>    c = -p.x * a - p.y * b;<br>  }<br> <br>  public Line(double a, double b, double c) {<br>    double h = GeometryUtils.fastHypot(a, b);<br>    this.a = a / h;<br>    this.b = b / h;<br>    this.c = c / h;<br>  }<br> <br>  public Point intersect(Line other) {<br>    if (parallel(other))<br>      return null;<br>    double determinant = b * other.a - a * other.b;<br>    double x = (c * other.b - b * other.c) / determinant;<br>    double y = (a * other.c - c * other.a) / determinant;<br>    return new Point(x, y);<br>  }<br> <br>  public boolean parallel(Line other) {<br>    return Math.abs(a * other.b - b * other.a) &lt; GeometryUtils.epsilon;<br>  }<br> <br>  public boolean contains(Point point) {<br>    return Math.abs(value(point)) &lt; GeometryUtils.epsilon;<br>  }<br> <br>  public Line perpendicular(Point point) {<br>    return new Line(-b, a, b * point.x - a * point.y);<br>  }<br> <br>  public double value(Point point) {<br>    return a * point.x + b * point.y + c;<br>  }<br> <br>  public boolean equals(Object o) {<br>    if (this == o) return true;<br>    if (o == null || getClass() != o.getClass()) return false;<br> <br>    Line line = (Line) o;<br> <br>    if (!parallel(line)) return false;<br>    if (Math.abs(a * line.c - c * line.a) &gt; GeometryUtils.epsilon || Math.abs(b * line.c - c * line.b) &gt; GeometryUtils.epsilon) return false;<br> <br>    return true;<br>  }<br>}<br></td>