<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cassert&gt;<br>#include &lt;cmath&gt;<br>#include &lt;complex&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;deque&gt;<br>#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>typedef long long LL;<br>typedef long double LD;<br>typedef vector&lt;int&gt; VI;<br>typedef pair&lt;int,int&gt; PII;<br> <br>#define REP(i,n) for(int i=0;i&lt;(n);++i)<br>#define SIZE(c) ((int)((c).size()))<br>#define FOR(i,a,b) for (int i=(a); i&lt;(b); ++i)<br>#define FOREACH(i,x) for (__typeof((x).begin()) i=(x).begin(); i!=(x).end(); ++i)<br>#define FORD(i,a,b) for (int i=((int)(a))-1; i&gt;=(b); --i)<br> <br>#define pb push_back<br>#define mp make_pair<br>#define st first<br>#define nd second<br> <br>LL X[200000];<br>LL Y[200000];<br> <br>vector&lt;pair&lt;LL,LL&gt; &gt; rs;<br>class PilingRectsDiv1 {<br>public:<br>  long long getmax(int N, vector &lt;int&gt; XS, vector &lt;int&gt; YS, int XA, int XB, int XC, int YA, int YB, int YC) {<br>    REP(i,XS.size()) {<br>      X[i] = XS[i]; Y[i] = YS[i];<br>    }<br>    FOR(i, XS.size(), 2*N) {<br>        X[i] = (X[i - 1] * XA + XB) % XC + 1;<br>        Y[i] = (Y[i - 1] * YA + YB) % YC + 1;  <br>    }<br>    <br>    rs.clear();<br>    LL minX = 1000000000, minY = 1000000000;<br>    REP(i,2*N) {<br>      if (X[i] &gt; Y[i]) swap(X[i], Y[i]);<br>      minX = min(minX, X[i]); minY = min(minY, Y[i]);<br>      rs.push_back(make_pair(X[i],Y[i]));<br>    }<br>    sort(rs.begin(), rs.end());<br>    <br>    LL result = 0;<br>    // X and Y in the same<br>    multiset&lt;LL&gt; cury;<br>    FORD(i,2*N,0) {<br>      cury.insert(rs[i].nd);<br>      while (cury.size() &gt; N) cury.erase(cury.begin());<br>      if (cury.size() == N) result = max(result, minX * minY + rs[i].st * *cury.begin());<br>    }<br>    <br>    cury.clear();<br>    REP(i,2*N) cury.insert(rs[i].nd);<br>    multiset&lt;LL&gt; cury2;<br>    FORD(i,2*N,0) {<br>      cury.erase(cury.find(rs[i].nd));<br>      cury2.insert(rs[i].nd);<br>      while (cury2.size() &gt; N) {<br>        int k = *cury2.rbegin();<br>        cury2.erase(cury2.find(k));<br>        cury.insert(k);<br>      }<br>      if (cury2.size() == N) result = max(result, minY * rs[i].st + minX * *cury.begin());<br>    }<br>    <br>    return result;<br>  }<br>};<br> <br> <br> <br> <br> <br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>