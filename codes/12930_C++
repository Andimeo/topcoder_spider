<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;memory.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;iostream&gt;<br>#include &lt;memory.h&gt;<br>#include &lt;assert.h&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;math.h&gt;<br> <br>#define fo(a,b,c) for(int a = ( b ); a &lt; ( c ); ++ a )<br>#define fr(a,b) fo( a, 0, ( b ) )<br>#define fi(a) fr( i, ( a ) )<br>#define fj(a) fr( j, ( a ) )<br>#define fk(a) fr( k, ( a ) )<br>#define fit(v) for( auto&amp; it : v )<br>#define fkv(v) for( auto&amp; kv : v )<br>#define fit1(v) for( auto&amp; it1 : v )<br>#define fit2(v) for( auto&amp; it2 : v )<br>#define mp make_pair<br>#define pb push_back<br>#define all(v) (v).begin( ), (v).end( )<br>#define _(a,b) memset( a, b, sizeof( a ) )<br>using namespace std;<br> <br>typedef long long ll;<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef pair&lt;int,int&gt; pii;<br>typedef map&lt;string,int&gt; msi;<br>typedef map&lt;int,int&gt; mii;<br> <br>class MiningGoldHard {<br>public:<br>  int GetMaximumGold(int, int, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;, vector &lt;int&gt;);<br>};<br>void sink(vector&lt;int&gt;&amp; v) {<br>  int id = (int)v.size() - 1;<br>  while (id &gt; 0 &amp;&amp; v[id] &lt; v[id - 1]) {<br>    swap(v[id], v[id - 1]);<br>    -- id;<br>  }<br>}<br> <br>int addend(int a, int b) {<br>  if (b &gt; a) return b - a;<br>  return a - b;<br>}<br> <br>int solve(int n, vector&lt;int&gt; evt, vector&lt;int&gt; di) {<br>  vector&lt;int&gt; ptr, mids;<br>  <br>  ptr.push_back(evt[0]);<br>  ptr.push_back(evt[0]);<br>  <br>  mids.push_back(evt[0]);<br>  for (int i = 1; i &lt; evt.size(); ++ i) {<br>    assert(ptr.size() == i * 2);<br>    for (int j = 0; j &lt; ptr.size(); ++ j) {<br>      if (j &lt; i) ptr[j] -= di[i - 1];<br>      else ptr[j] += di[i - 1];<br>    }<br>    ptr.push_back(evt[i]);<br>    sink(ptr);<br>    ptr.push_back(evt[i]);<br>    sink(ptr);<br>    mids.push_back(ptr[i]);<br>  }<br>  assert(mids.size() == evt.size());<br>  int pos = mids.back();<br>  int ret = n - addend(pos, evt.back());<br>  for (int i = (int)evt.size() - 2; i &gt;= 0; -- i) {<br>    int target = mids[i];<br>    if (target &lt; pos &amp;&amp; pos - target &gt; di[i]) {<br>      pos -= di[i];<br>    }<br>    else if (target &gt; pos &amp;&amp; target - pos &gt; di[i]) {<br>      pos += di[i];<br>    }<br>    else pos = target;<br>    ret += n - addend(pos, evt[i]);<br>  }<br>  return ret;<br>}<br> <br>int MiningGoldHard::GetMaximumGold(int N, int M, vector &lt;int&gt; event_i, vector &lt;int&gt; event_j, vector &lt;int&gt; event_di, vector &lt;int&gt; event_dj) {<br>  return solve(N, event_i, event_di) + solve(M, event_j, event_dj);<br>}<br> <br> <br> <br>//Powered by [KawigiEdit] 2.0!<br></td>