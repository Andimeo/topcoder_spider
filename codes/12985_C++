<td class="problemText" colspan="8" valign="middle" align="left">
            #line 6 "LotteryTree.cpp"<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;complex&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>int n;<br>vector &lt;int&gt; sons[101];<br><br>map &lt; vector &lt;long long&gt; , bool &gt; mem;<br><br>long long gcd(long long a, long long b)<br>{<br>  if(a == 0 || b == 0)return a + b;<br>  return gcd(b, a % b);<br>}<br><br>vector &lt;long long&gt; reduce(vector &lt;long long&gt; lis)<br>{<br>  long long g = 0;<br>  for(int i = 0; i &lt; lis.size(); i++)<br>    g = gcd(g, lis[i]);<br>  for(int i = 0; i &lt; lis.size(); i++)<br>    lis[i] /= g;<br>  return lis;<br>}<br><br>void getNeeds(vector &lt;long long&gt; ret[101], vector &lt;long long&gt; eachCut, long long nPart)<br>{<br>  long long sum = 0;<br>  for(int i = 0; i &lt; eachCut.size(); i++)<br>    sum += eachCut[i];<br>  vector &lt;long long&gt; cutPoints;<br>  long long now = 0;<br>  for(int i = 0; i &lt; eachCut.size(); i++)<br>  {<br>    now += eachCut[i];<br>    cutPoints.push_back(now * nPart);<br>  }<br>  int p = 0;<br>  for(int i = 0; i &lt; nPart; i++)<br>  {<br>    long long L = i * sum;<br>    long long R = (i+1) * sum;<br>    ret[i].clear();<br>    long long now = L;<br>    while(p &lt; cutPoints.size() &amp;&amp; cutPoints[p] &lt; R)<br>    {<br>      if(cutPoints[p] - now &gt; 0)<br>        ret[i].push_back(cutPoints[p] - now);<br>      now = cutPoints[p];<br>      p ++;<br>    }<br>    ret[i].push_back(R - now);<br>  }<br>}<br><br>#define MAXN 301<br><br>int maxint = ~0U&gt;&gt;1;<br>int flow;<br>int pi[MAXN+1], v[MAXN+1];<br>int S, T;<br><br>struct etype<br>{<br>  int t, c;<br>  etype* next;<br>  etype* pair;<br>  etype(){next=0;}<br>  etype(int _t, int _c, etype* _n){t=_t, c=_c, next=_n;}<br>}*e[MAXN+1], *eb[MAXN+1], *Pe, *Pool;<br><br>int aug(int w, int lim)<br>{<br>  int t;<br>  v[w] = 1;<br>  if(w == T)<br>  {<br>    flow += lim;<br>    return lim;<br>  }<br>  for(etype *&amp; i=e[w]; i; i = i-&gt;next)<br>    if(i-&gt;c &amp;&amp; !v[i-&gt;t] &amp;&amp; pi[w] == pi[i-&gt;t] + 1)<br>      if(t = aug(i-&gt;t, min(lim, i-&gt;c)))<br>        return i-&gt;c -= t, i-&gt;pair-&gt;c += t, t;<br>  return 0;<br>}<br><br>bool fix()<br>{<br>  int t = maxint;<br>  for(int i = S; i &lt;= T; i++)<br>    if(v[i])<br>    {<br>      for(etype *j = eb[i]; j; j = j-&gt;next)<br>        if(j-&gt;c &amp;&amp; !v[j-&gt;t])<br>          t = min(t, pi[j-&gt;t] + 1 - pi[i]);<br>    }<br>  if(t == maxint)<br>    return 0;<br><br>  for(int i = S; i &lt;= T; i++)<br>    if(v[i])<br>      e[i] = eb[i], pi[i] += t;<br>  return 1;<br>}<br><br>void addedge(int s, int t, int c)<br>{<br>  ++Pe;<br>  Pe-&gt;t = t, Pe-&gt;c = c, Pe-&gt;next = e[s];<br>  e[s] = Pe;<br>  ++Pe;<br>  Pe-&gt;t = s, Pe-&gt;c = 0, Pe-&gt;next = e[t];<br>  e[t] = Pe;<br>  e[s]-&gt;pair=e[t];<br>  e[t]-&gt;pair=e[s];<br>}<br><br>void prepare()<br>{<br>  if(Pool == NULL)<br>    Pool = new etype[1000001];<br>  Pe = Pool;<br>  memset(e, 0, sizeof(e));<br>}<br><br>int MaxFlow()<br>{<br>  flow = 0;<br>  memcpy(eb, e, sizeof(e));<br>  memset(pi, 0, sizeof(pi));<br>  do<br>  {<br>    do<br>    memset(v, 0, sizeof(v));<br>    while(aug(S, maxint));<br>  }<br>  while(fix());<br>  return flow;<br>}<br><br>/*  Note<br>  1. Set maxNodes here: #define MAXN 200001<br>  2. Set maxEdges here: Pool = new etype[1000001];<br>  3. S must be the min id, T must be the max id<br>*/<br><br>/*  Eaxmple<br>  prepare();<br>  S = 1, T = 2;<br>  addedge(1, 2, 3);<br>  cout &lt;&lt; MaxFlow() &lt;&lt; endl;<br>*/<br><br><br>bool solve(int node, vector &lt;long long&gt; parts)<br>{<br>  if(parts.size() == 1) return true;<br>  if(sons[node].size() == 0) return false;<br>  parts = reduce(parts);<br>  vector &lt;long long&gt; hash = parts;<br>  hash.push_back(node);<br>  if(mem.count(hash)) return mem[hash];<br>  bool ret = false;<br><br>  vector &lt;long long&gt; needs[101];<br>  getNeeds(needs, parts, sons[node].size());<br><br>  bool matchMatrix[101][101];<br>  int N = sons[node].size();<br>  for(int i = 0; i &lt; N; i++)<br>    for(int j = 0; j &lt; N; j++)<br>      matchMatrix[i][j] = solve(sons[node][i], needs[j]);<br><br>  prepare();<br>  S = 1;<br>  T = 1 + N + N + 1;<br>  for(int i = 1; i &lt;= N; i++)<br>  {<br>    addedge(S, 1+i, 1);<br>    addedge(1+N+i, T, 1);<br>    for(int j = 1; j &lt;= N; j++)<br>      if(matchMatrix[i-1][j-1])<br>        addedge(1+i, 1+N+j, 1);<br>  }<br><br>  ret = (N == MaxFlow());<br>  mem[hash] = ret;<br>  return ret;<br>}<br><br>class LotteryTree<br>{<br>  public:<br>  string isFairTree(vector &lt;int&gt; tree, int P)<br>  {<br>    n = tree.size() + 1;<br>    for(int i = 0; i &lt; n; i++)<br>      sons[i].clear();<br>    for(int i = 0; i &lt; n-1; i++)<br>      sons[tree[i]].push_back(i+1);<br>    mem.clear();<br>    vector &lt;long long&gt; part;<br>    for(int i = 0; i &lt; P; i++)<br>      part.push_back(1);<br>    if(solve(0, part)) return "YES";<br>    return "NO";<br>  }<br><br>  <br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>