<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br> <br>using namespace std;<br> <br>struct Segment {<br>  int l, r, val;<br>  Segment() {<br>  }<br>  Segment(int l, int r, int val) :<br>      l(l), r(r), val(val) {<br>  }<br>};<br> <br>class OneDimensionalRobot {<br>public:<br>  string join(vector&lt;string&gt; s) {<br>    return accumulate(s.begin(), s.end(), string());<br>  }<br> <br>  long long theSum(vector&lt;string&gt; commands1, vector&lt;string&gt; commands2,<br>      int minA, int maxA, int minB, int maxB) {<br>    string S = join(commands1) + join(commands2);<br>    //Fix A+B<br> <br>    long long ans = 0;<br> <br>    for (int sum = minA + minB; sum &lt;= maxA + maxB; ++sum) {<br>      //A+B<br>      int L = max(minA, sum - maxB), R = min(maxA, sum - minB);<br>      //[L..R] = [L..R]<br>      static Segment que[50000];<br>      int qh = 0, qt = 0;<br>      for (int i = L; i &lt;= R; ++i) {<br>        que[qt++] = Segment(i, i, i);<br>      }<br> <br>      int delta = 0;<br>      for (int i = 0; i &lt; S.size(); ++i) {<br>        if (S[i] == 'L') {<br>          delta -= 1;<br>          if (que[qh].val + delta == -1) {<br>            ++que[qh].val;<br>            while (qh + 1 &lt; qt &amp;&amp; que[qh].val == que[qh + 1].val) {<br>              que[qh + 1].l = que[qh].l;<br>              ++qh;<br>            }<br>          }<br>        } else {<br>          delta += 1;<br>          if (que[qt - 1].val + delta &gt; sum) {<br>            --que[qt - 1].val;<br>            while (qh + 1 &lt; qt &amp;&amp; que[qt - 1].val == que[qt - 2].val) {<br>              que[qt - 2].r = que[qt - 1].r;<br>              --qt;<br>            }<br>          }<br>        }<br>      }<br> <br>      for (int i = qh; i &lt; qt; ++i) {<br>        for (int a = que[i].l; a &lt;= que[i].r; ++a) {<br>          int x = que[i].val + delta;<br>          ans += x - a;<br>        }<br>      }<br>    }<br> <br>    return ans;<br>  }<br>};<br> <br> <br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>