<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class BigO {<br>    public int minK(string[] graph)<br>    {<br>        int n = graph.Length;<br><br>        int[,] dist = new int[n, n];<br>        int MAX = 9999;<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            for (int j = 0; j &lt; n; j++)<br>            {<br>                dist[i, j] = MAX;<br>                if (graph[i][j] == 'Y') dist[i, j] = 1;<br>            }<br>        }<br><br>        for (int k = 0; k &lt; n; k++)<br>        {<br>            for (int i = 0; i &lt; n; i++)<br>            {<br>                for (int j = 0; j &lt; n; j++)<br>                {<br>                    dist[i, j] = Math.Min(dist[i, j], dist[i, k] + dist[k, j]);<br>                }<br>            }<br>        }<br><br>        int loopcount = 0;<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            if (dist[i, i] != MAX) loopcount++;<br>        }<br>        if (loopcount == 0) return 0;<br><br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            int lc = 0;<br>            for (int j = 0; j &lt; n; j++)<br>            {<br>                if (graph[i][j] == 'N') continue;<br>                if (dist[j, i] != MAX) lc++;<br>            }<br>            if (lc &gt;= 2) return -1;<br>        }<br><br>        int[][] es = new int[n][];<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            List&lt;int&gt; l = new List&lt;int&gt;();<br>            for (int j = 0; j &lt; n; j++)<br>            {<br>                if (graph[i][j] == 'Y') l.Add(j);<br>            }<br>            es[i] = l.ToArray();<br>        }<br>        int[][] g = StronglyConnectedComponents(n, es);<br>        Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;();<br><br><br>        int gn = g.Length;<br>        for (int i = 0; i &lt; g.Length; i++)<br>        {<br>            for (int j = 0; j &lt; g[i].Length; j++)<br>            {<br>                dic[g[i][j]] = i;<br>            }<br>            //Console.WriteLine(g[i].Length);<br>        }<br><br>        int ret = 0;<br><br>        for (int i = 0; i &lt; gn; i++)<br>        {<br>            int[] d = new int[gn];<br>            for (int j = 0; j &lt; gn; j++)<br>            {<br>                d[j] = -1;<br>            }<br>            d[i] = 0;<br>            if (g[i].Length &gt; 1) d[i]++;<br>            Queue&lt;int&gt; q = new Queue&lt;int&gt;();<br>            q.Enqueue(i);<br>            //Console.WriteLine("start " + i);<br>            while (q.Count != 0)<br>            {<br>                int now = q.Dequeue();<br>                //Console.WriteLine("now " + now + " " + d[now]);<br>                foreach (var p in g[now])<br>                {<br>                    foreach (var tnext in es[p])<br>                    {<br>                        int next = dic[tnext];<br>                        if (now == next) continue;<br><br>                        int nextnum = d[now];<br>                        if (g[next].Length &gt; 1) nextnum++;<br><br>                        if (d[next] &gt;= nextnum) continue;<br>                        d[next] = d[now];<br>                        if (g[next].Length &gt; 1) d[next]++;<br>                        q.Enqueue(next);<br>                    }<br>                }<br>            }<br><br><br>            for (int j = 0; j &lt; gn; j++)<br>            {<br>                ret = Math.Max(ret, d[j] - 1);<br>            }<br>            //Console.WriteLine(ret);<br>        }<br><br>        return ret;<br><br>    }<br><br>    //[\u24375][\u36899][\u32080][\u25104][\u20998][\u20998][\u35299]<br>    int[][] StronglyConnectedComponents(int n, int[][] es)<br>    {<br>        List&lt;List&lt;int&gt;&gt; retl = new List&lt;List&lt;int&gt;&gt;();<br>        int[] num = new int[n];<br>        int[] min = new int[n];<br>        int[] memo = new int[n];<br>        bool[] check = new bool[n];<br>        Stack&lt;int&gt; s = new Stack&lt;int&gt;();<br>        Stack&lt;int&gt; ss = new Stack&lt;int&gt;();<br>        int time = 0;<br>        for (int i = 0; i &lt; n; i++)<br>        {<br>            if (num[i] == 0)<br>            {<br>                s.Push(i);<br>                while (s.Count != 0)<br>                {<br>                    int now = s.Peek();<br>                    if (min[now] == 0)<br>                    {<br>                        min[now] = num[now] = ++time;<br>                        check[now] = true;<br>                        ss.Push(now);<br>                    }<br>                    for (; memo[now] &lt; es[now].Length; memo[now]++)<br>                    {<br>                        int next = es[now][memo[now]];<br>                        if (num[next] == 0)<br>                        {<br>                            s.Push(next);<br>                            break;<br>                        }<br>                        else if (check[next])<br>                        {<br>                            min[now] = Math.Min(min[now], min[next]);<br>                        }<br>                    }<br>                    if (memo[now] == es[now].Length)<br>                    {<br>                        s.Pop();<br>                        if (min[now] == num[now])<br>                        {<br>                            List&lt;int&gt; l = new List&lt;int&gt;();<br>                            while (true)<br>                            {<br>                                int next = ss.Pop();<br>                                check[next] = false;<br>                                l.Add(next);<br>                                if (now == next) break;<br>                            }<br>                            retl.Add(l);<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        int[][] ret = new int[retl.Count][];<br>        int count = 0;<br>        foreach (List&lt;int&gt; l in retl)<br>        {<br>            ret[count++] = l.ToArray();<br>        }<br>        return ret;<br>    } <br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] Modified for C# by ysn<br>// Powered by CodeProcessor<br></td>