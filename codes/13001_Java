<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.Arrays;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class BigO {<br>    public int minK(String[] graph) {<br>        int n = graph.length;<br>        boolean[][] edge = new boolean[n][n];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>                edge[i][j] = graph[i].charAt(j) == 'Y';<br>        boolean[][] reach = new boolean[n][n];<br>        for (int i = 0; i &lt; n; ++i) {<br>            for (int j = 0; j &lt; n; ++j)<br>                reach[i][j] = edge[i][j];<br>            reach[i][i] = true;<br>        }<br>        for (int k = 0; k &lt; n; ++k)<br>            for (int i = 0; i &lt; n; ++i)<br>                for (int j = 0; j &lt; n; ++j)<br>                    reach[i][j] |= reach[i][k] &amp;&amp; reach[k][j];<br>        int[] comp = new int[n];<br>        Arrays.fill(comp, -1);<br>        int ncomp = 0;<br>        for (int i = 0; i &lt; n; ++i) if (comp[i] &lt; 0) {<br>            for (int j = 0; j &lt; n; ++j) if (reach[i][j] &amp;&amp; reach[j][i]) comp[j] = ncomp;<br>            ++ncomp;<br>        }<br>        boolean[][] cedge = new boolean[n][n];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>                if (edge[i][j]) cedge[comp[i]][comp[j]] = true;<br>        int[] cweight = new int[ncomp];<br>        for (int i = 0; i &lt; n; ++i) {<br>            int nout = 0;<br>            int nin = 0;<br>            int count = 0;<br>            for (int j = 0; j &lt; n; ++j) if (comp[j] == comp[i]) {<br>                ++count;<br>                if (edge[j][i]) ++nin;<br>                if (edge[i][j]) ++nout;<br>            }<br>            if (count == 1) {<br>                cweight[comp[i]] = 0;<br>            } else {<br>                if (nin != 1 || nout != 1) return -1;<br>                cweight[comp[i]] = 1;<br>            }<br>        }<br>        int[] maxpath = cweight.clone();<br>        while (true) {<br>            boolean updated = false;<br>            for (int i = 0; i &lt; ncomp; ++i)<br>                for (int j = 0; j &lt; ncomp; ++j)<br>                    if (i != j &amp;&amp; cedge[i][j] &amp;&amp; maxpath[i] + cweight[j] &gt; maxpath[j]) {<br>                        maxpath[j] = maxpath[i] + cweight[j];<br>                        updated = true;<br>                    }<br>            if (!updated) break;<br>        }<br>        int res = 0;<br>        for (int x : maxpath) res = Math.max(res, x);<br>        return Math.max(0, res - 1);<br>    }<br>}<br></td>