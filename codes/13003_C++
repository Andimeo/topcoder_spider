<td class="problemText" colspan="8" valign="middle" align="left">
            /* &amp;*#()&amp;*#)&amp;E*F&amp; */<br><br>#include &lt;iostream&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstring&gt;<br>#include &lt;ctime&gt;<br>#include &lt;cmath&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br><br>using namespace std;<br><br>#define REP(I, N) for (int I=0;I&lt;int(N);++I)<br>#define FOR(I, A, B) for (int I=int(A);I&lt;int(B);++I)<br>#define DWN(I, B, A) for (int I=int(B-1);I&gt;=int(A);--I)<br>#define ECH(it, A) for (typeof(A.begin()) it=A.begin(); it != A.end(); ++it)<br><br>#define ALL(A) A.begin(), A.end()<br>#define CLR(A) A.clear()<br>#define CPY(A, B) memcpy(A, B, sizeof(A))<br>#define INS(A, P, B) A.insert(A.begin() + P, B)<br>#define ERS(A, P) A.erase(A.begin() + P)<br>#define SRT(A) sort(ALL(A))<br>#define SZ(A) int(A.size())<br>#define PB push_back<br>#define MP(A, B) make_pair(A, B)<br><br>typedef long long LL;<br>typedef double DB;<br><br>template&lt;class T&gt; inline void RST(T &amp;A){memset(A, 0, sizeof(A));}<br>template&lt;class T&gt; inline void FLC(T &amp;A, int x){memset(A, x, sizeof(A));}<br><br>template&lt;class T&gt; inline void checkMin(T &amp;a, T b){if (b&lt;a) a=b;}<br>template&lt;class T&gt; inline void checkMax(T &amp;a, T b){if (b&gt;a) a=b;}<br><br>/* -&amp;$&amp;#*( &amp;#*@)^$@&amp;*)*/<br><br>const int MOD = 1000000007;<br>const int INF = 0x7fffffff;<br><br><br><br><br>const int N = 10000;<br>int pre[N] , nex[N] , n;<br>class MagicalStringDiv1 {<br>public:<br>  int getLongest(string S);<br>};<br><br><br>int MagicalStringDiv1 :: getLongest(string S) {<br>  n = S.length();<br>    RST(pre);RST(nex);<br>    for (int i = 0 ; i &lt; n ; ++i){<br>        pre[i] = S[i] == '&gt;';<br>        if (i) pre[i] += pre[i - 1];<br>    }<br>    for (int i = n - 1 ; i &gt;= 0 ; --i){<br>        nex[i] = S[i] == '&lt;';<br>        if (i &lt; n - 1) nex[i] += nex[i + 1];<br>    }<br>    int ans = 0;<br>    for (int i = 0 ; i &lt; n ; ++i) if (pre[i] &amp;&amp; nex[i])<br>        checkMax(ans , min(pre[i] , nex[i]) * 2);<br>    return ans;<br><br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.16 [modified TZTester]<br>// Powered by CodeProcessor<br></td>