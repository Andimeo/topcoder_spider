<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.List;<br>import java.util.Arrays;<br>import java.util.ArrayList;<br>import java.util.NoSuchElementException;<br>import java.math.BigInteger;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class CycleColoring {<br>  private static final long MOD = (long) (1e9 + 7);<br> <br>  public int countColorings(int[] vertexCount, int[] fromVertex, int[] toVertex, int K) {<br>    long[] same = new long[1000001];<br>    long[] different = new long[1000001];<br>    same[0] = 1;<br>    different[0] = 0;<br>    for (int i = 1; i &lt;= 1000000; i++) {<br>      same[i] = different[i - 1];<br>      different[i] = (different[i - 1] * (K - 2) + same[i - 1] * (K - 1)) % MOD;<br>    }<br>    long reverse = IntegerUtils.reverse(K - 1, MOD);<br>    for (int i = 1; i &lt;= 1000000; i++)<br>      different[i] = different[i] * reverse % MOD;<br>    long tSame = K;<br>    long tDifferent = 0;<br>    for (int i = 1; i &lt; fromVertex.length; i++) {<br>      int difference1 = Math.abs(toVertex[i - 1] - fromVertex[i]);<br>      int difference2 = vertexCount[i] - difference1;<br>      long nTSame = same[difference1] * same[difference2] % MOD * tSame + different[difference1] * different[difference2] % MOD * tDifferent;<br>      long nTDifferent = same[difference1] * same[difference2] % MOD * tDifferent + different[difference1] * different[difference2] % MOD * (tSame * (K - 1) % MOD + tDifferent * (K - 2) % MOD);<br>      tSame = nTSame % MOD;<br>      tDifferent = nTDifferent % MOD;<br>    }<br>    int difference1 = Math.abs(toVertex[vertexCount.length - 1] - fromVertex[0]);<br>    int difference2 = vertexCount[0] - difference1;<br>    long answer = same[difference1] * same[difference2] % MOD * tSame + different[difference1] * different[difference2] % MOD * tDifferent;<br>    return (int) (answer % MOD);<br>    }<br>}<br> <br>class IntegerUtils {<br> <br>    public static long power(long base, long exponent, long mod) {<br>    if (base &gt;= mod)<br>      base %= mod;<br>    if (exponent == 0)<br>      return 1 % mod;<br>    long result = power(base, exponent &gt;&gt; 1, mod);<br>    result = result * result % mod;<br>    if ((exponent &amp; 1) != 0)<br>      result = result * base % mod;<br>    return result;<br>  }<br> <br>  public static long reverse(long number, long module) {<br>    return power(number, module - 2, module);<br>  }<br> <br>  }<br></td>