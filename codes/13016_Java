<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.List;<br>import java.util.Arrays;<br>import java.util.ArrayList;<br>import java.util.Comparator;<br>import java.util.NoSuchElementException;<br>import java.math.BigInteger;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class RandomGCD {<br>  private static final long MOD = (long) (1e9 + 7);<br> <br>  public int countTuples(int N, int K, int low, int high) {<br>    low = (low + K - 1) / K;<br>    high = high / K;<br>    if (low &gt; high)<br>      return 0;<br>    long answer = 0;<br>    long[] mu = MultiplicativeFunction.MOBIUS.calculateUpTo(high - low + 1);<br>    for (int i = 1; i &lt;= high - low; i++) {<br>      if (mu[i] == 0)<br>        continue;<br>      int from = (low + i - 1) / i;<br>      int to = high / i;<br>      if (to - from &gt;= 0)<br>        answer += mu[i] * IntegerUtils.power(to - from + 1, N, MOD);<br>    }<br>    int[] m = new int[high - low + 1];<br>    if (low == 1)<br>      m[0] = -1;<br>    for (int i = 1; i &lt;= high - low; i++) {<br>      if (mu[i] == 0)<br>        continue;<br>      int start = low + (i - low % i) % i;<br>      for (int j = start; j &lt;= high; j += i) {<br>        m[j - low] += mu[i];<br>      }<br>    }<br>    answer -= ArrayUtils.sumArray(m);<br>    answer %= MOD;<br>    answer += MOD;<br>    answer %= MOD;<br>    return (int) answer;<br>    }<br>}<br> <br>abstract class MultiplicativeFunction {<br> <br>  public static final MultiplicativeFunction MOBIUS = new MultiplicativeFunction() {<br>    @Override<br>    protected long value(long p, int exponent, long power) {<br>      return exponent == 1 ? -1 : 0;<br>    }<br>  };<br> <br>  protected abstract long value(long p, int exponent, long power);<br> <br>  public long[] calculateUpTo(int upTo) {<br>    int[] divisor = IntegerUtils.generateDivisorTable(upTo);<br>    long[] result = new long[upTo];<br>    if (upTo &lt;= 1)<br>      return result;<br>    result[1] = 1;<br>    for (int i = 2; i &lt; upTo; i++) {<br>      int iDivided = i;<br>      int exponent = 0;<br>      do {<br>        iDivided /= divisor[i];<br>        exponent++;<br>      } while (iDivided % divisor[i] == 0);<br>      result[i] = result[iDivided] * value(divisor[i], exponent, i / iDivided);<br>    }<br>    return result;<br>  }<br>}<br> <br>class IntegerUtils {<br> <br>    public static int[] generateDivisorTable(int upTo) {<br>    int[] divisor = new int[upTo];<br>    for (int i = 1; i &lt; upTo; i++)<br>      divisor[i] = i;<br>    for (int i = 2; i * i &lt; upTo; i++) {<br>      if (divisor[i] == i) {<br>        for (int j = i * i; j &lt; upTo; j += i)<br>          divisor[j] = i;<br>      }<br>    }<br>    return divisor;<br>  }<br> <br>  public static long power(long base, long exponent, long mod) {<br>    if (base &gt;= mod)<br>      base %= mod;<br>    if (exponent == 0)<br>      return 1 % mod;<br>    long result = power(base, exponent &gt;&gt; 1, mod);<br>    result = result * result % mod;<br>    if ((exponent &amp; 1) != 0)<br>      result = result * base % mod;<br>    return result;<br>  }<br> <br>  }<br> <br>class ArrayUtils {<br> <br>  public static long sumArray(int[] array) {<br>    long result = 0;<br>    for (int element : array)<br>      result += element;<br>    return result;<br>  }<br> <br>  }<br></td>