<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.List;<br>import java.util.Arrays;<br>import java.util.ArrayList;<br>import java.util.Random;<br>import java.util.NoSuchElementException;<br>import java.math.BigInteger;<br> <br>/**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> * @author Egor Kulikov (egor@egork.net)<br> */<br>public class AmebaDiv1 {<br>    public int count(int[] X) {<br>    IntSet impossible = new IntHashSet();<br>    for (int i : X)<br>      impossible.add(i);<br>    for (int i : X) {<br>      for (int j : X) {<br>        if (i == j)<br>          i *= 2;<br>      }<br>      impossible.remove(i);<br>    }<br>    return impossible.size();<br>    }<br>}<br> <br>abstract class IntSet extends IntCollection {<br>}<br> <br>class IntHashSet extends IntSet {<br>  private static final Random RND = new Random();<br>  private static final int[] SHIFTS = new int[4];<br>  private static final byte PRESENT_MASK = 1;<br>  private static final byte REMOVED_MASK = 2;<br> <br>  static {<br>    for (int i = 0; i &lt; 4; i++)<br>      SHIFTS[i] = RND.nextInt(31) + 1;<br>  }<br> <br>  private int size;<br>  private int[] values;<br>  private byte[] present;<br>  private int step;<br>  private int ratio;<br> <br>  public IntHashSet() {<br>    this(3);<br>  }<br> <br> <br>  public IntHashSet(int capacity) {<br>    capacity = Math.max(capacity, 1);<br>    values = new int[capacity];<br>    present = new byte[capacity];<br>    ratio = 2;<br>    initStep(capacity);<br>  }<br> <br>  private void initStep(int capacity) {<br>    step = RND.nextInt(capacity - 2) + 1;<br>    while (IntegerUtils.gcd(step, capacity) != 1)<br>      step++;<br>  }<br> <br>  public int size() {<br>    return size;<br>  }<br> <br>  public void add(int value) {<br>    ensureCapacity((size + 1) * ratio + 2);<br>    int current = getHash(value);<br>    while ((present[current] &amp; PRESENT_MASK) != 0) {<br>      if (values[current] == value)<br>        return;<br>      current += step;<br>      if (current &gt;= values.length)<br>        current -= values.length;<br>    }<br>    present[current] = PRESENT_MASK;<br>    values[current] = value;<br>    size++;<br>  }<br> <br>  private int getHash(int value) {<br>    int result = value;<br>    for (int i : SHIFTS)<br>      result ^= value &gt;&gt; i;<br>    result %= values.length;<br>    if (result &lt; 0)<br>      result += values.length;<br>    return result;<br>  }<br> <br>  private void ensureCapacity(int capacity) {<br>    if (values.length &lt; capacity) {<br>      capacity = Math.max(capacity * 2, values.length);<br>      rebuild(capacity);<br>    }<br>  }<br> <br>  private void squish() {<br>    if (values.length &gt; size * ratio * 2 + 10) {<br>      rebuild(size * ratio + 3);<br>    }<br>  }<br> <br>  private void rebuild(int capacity) {<br>    initStep(capacity);<br>    int[] oldValues = values;<br>    byte[] oldPresent = present;<br>    values = new int[capacity];<br>    present = new byte[capacity];<br>    size = 0;<br>    for (int i = 0; i &lt; oldValues.length; i++) {<br>      if ((oldPresent[i] &amp; PRESENT_MASK) == PRESENT_MASK)<br>        add(oldValues[i]);<br>    }<br>  }<br> <br>  public void remove(int value) {<br>    int current = getHash(value);<br>    while (present[current] != 0) {<br>      if (values[current] == value &amp;&amp; (present[current] &amp; PRESENT_MASK) != 0) {<br>        present[current] = REMOVED_MASK;<br>        size--;<br>        squish();<br>        return;<br>      }<br>      current += step;<br>      if (current &gt;= values.length)<br>        current -= values.length;<br>    }<br>  }<br> <br>}<br> <br>abstract class IntCollection {<br>  public abstract int size();<br>  public abstract void add(int value);<br>  public abstract void remove(int value);<br> <br>}<br> <br>class IntegerUtils {<br> <br>  public static int gcd(int a, int b) {<br>        a = Math.abs(a);<br>        b = Math.abs(b);<br>        while (b != 0) {<br>            int temp = a % b;<br>            a = b;<br>            b = temp;<br>        }<br>        return a;<br>    }<br> <br>}<br></td>