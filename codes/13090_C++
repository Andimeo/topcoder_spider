<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;stack&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;cmath&gt;<br>using namespace std;<br> <br>typedef vector &lt;int &gt; VI;<br>typedef long long LL;<br> <br>#define ALL(x) (x).begin(),(x).end()<br>#define REP(i,n) for (int i=0; i&lt;(n); ++i)<br>#define FOR(var,pocz,koniec) for (int var=(pocz); var&lt;=(koniec); ++var)<br>#define FOREACH(it, X) for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it)<br>#define PB push_back<br>#define SIZE(x) (int)(x).size()<br> <br> <br>typedef pair&lt;int,int&gt; PII;<br>typedef vector &lt;PII&gt; VPII;<br>#define MP(a,b) make_pair(a,b)<br>#define ST first<br>#define ND second<br> <br>const int N = 55;<br>const int MAX = 21000;<br>const LL INF = 1001LL * 1001 * 1001 * 1001 * 1001 * 1001;<br>LL dist[MAX][N];<br>VPII kraw[N];<br> <br>string impossible = "Impossible";<br>string possible = "Possible";<br> <br>class LongLongTripDiv1 {<br>  public:<br>  string isAble(int n, vector &lt;int&gt; A, vector &lt;int&gt; B, vector &lt;int&gt; D, long long T) {<br>    int d = MAX;<br>    int m = SIZE(A);<br>    REP(i,m) if (A[i] == 0 || B[i] == 0) d = min(d, 2*D[i]);<br> <br>    REP(i,m) {<br>      kraw[A[i]].PB(MP(B[i], D[i]));<br>      kraw[B[i]].PB(MP(A[i], D[i]));<br>    }<br> <br>    if (d == MAX) return impossible;<br> <br>    REP(j,d) REP(i,n) dist[j][i] = INF;<br>    dist[0][0] = 0;<br>    priority_queue&lt;pair&lt;LL,PII&gt; &gt; q;<br>    q.push(MP(0,MP(0,0)));<br>    while (!q.empty()) {<br>      pair&lt;LL,PII&gt; p = q.top();<br>      q.pop();<br> <br>      LL cost = -p.ST;<br>      int r = p.ND.ST;<br>      int i = p.ND.ND;<br>      if (cost != dist[r][i]) continue;<br> <br>      FOREACH(it, kraw[i]) {<br>        LL cand = cost + it-&gt;ND;<br>        int nr = (r+it-&gt;ND) % d;<br>        if (cand &lt; dist[nr][it-&gt;ST]) {<br>          dist[nr][it-&gt;ST] = cand;<br>          q.push(MP(-cand, MP(nr, it-&gt;ST)));<br>        }<br>      }<br>    }<br> <br>    return (dist[T % d][n-1] &lt;= T) ? possible : impossible;<br>  }<br>  <br> <br>};<br> <br> <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>