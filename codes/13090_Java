<td class="problemText" colspan="8" valign="middle" align="left">
            /**<br> * Built using CHelper plug-in<br> * Actual solution is at the top<br> */<br>public class LongLongTripDiv1 {<br>    static class Node {<br>        long dist;<br>        int vertex;<br>        int rem;<br>        int inTree;<br> <br>        Node(long dist, int vertex, int rem, int inTree) {<br>            this.dist = dist;<br>            this.vertex = vertex;<br>            this.rem = rem;<br>            this.inTree = inTree;<br>        }<br>    }<br> <br>    static class Edge {<br>        int dest;<br>        int len;<br> <br>        Edge(int dest, int len) {<br>            this.dest = dest;<br>            this.len = len;<br>        }<br>    }<br> <br>    public String isAble(int N, int[] A, int[] B, int[] D, long T) {<br>        int someAEdge = -1;<br>        for (int i = 0; i &lt; A.length; ++i) if (A[i] == 0 || B[i] == 0) {<br>            someAEdge = D[i];<br>            break;<br>        }<br>        if (someAEdge &lt; 0) return "Impossible";<br>        Edge[][] edges = new Edge[N][A.length];<br>        int[] edgeCnt = new int[N];<br>        for (int i = 0; i &lt; A.length; ++i) {<br>            edges[A[i]][edgeCnt[A[i]]++] = new Edge(B[i], D[i]);<br>            edges[B[i]][edgeCnt[B[i]]++] = new Edge(A[i], D[i]);<br>        }<br>        int modulo = 2 * someAEdge;<br>        Node[][] nodes = new Node[N][modulo];<br>        Node[] tree = new Node[N * modulo];<br>        int ntree = 0;<br>        for (int index = 0; index &lt; N; ++index)<br>            for (int rem = 0; rem &lt; modulo; ++rem) {<br>                nodes[index][rem] = new Node((index == 0 &amp;&amp; rem == 0 ? 0 : (T + 1)), index, rem, ntree);<br>                tree[ntree++] = nodes[index][rem];<br>                treeUp(tree, 0);<br>            }<br>        while (ntree &gt; 0) {<br>            Node cur = tree[0];<br>            swap(tree, 0, ntree - 1);<br>            --ntree;<br>            if (ntree &gt; 0) {<br>                treeDown(tree, 0, ntree);<br>            }<br>            cur.inTree = -1;<br>            Edge[] ee = edges[cur.vertex];<br>            for (int i = 0; i &lt; edgeCnt[cur.vertex]; ++i) {<br>                Edge e = ee[i];<br>                int erem = (cur.rem + e.len) % modulo;<br>                long elen = cur.dist + e.len;<br>                Node dest = nodes[e.dest][erem];<br>                if (dest.dist &gt; elen) {<br>                    dest.dist = elen;<br>                    treeUp(tree, dest.inTree);<br>                }<br>            }<br>        }<br>        Node finish = nodes[N - 1][((int) (T % modulo))];<br>        if (finish.dist &lt;= T) return "Possible"; else return "Impossible";<br>    }<br> <br>    private void treeDown(Node[] tree, int at, int ntree) {<br>        while (true) {<br>            int i = at;<br>            if (2 * at + 1 &lt; ntree &amp;&amp; tree[2 * at + 1].dist &lt; tree[i].dist) i = 2 * at + 1;<br>            if (2 * at + 2 &lt; ntree &amp;&amp; tree[2 * at + 2].dist &lt; tree[i].dist) i = 2 * at + 2;<br>            if (i == at) break;<br>            swap(tree, at, i);<br>            at = i;<br>        }<br>    }<br> <br>    private void treeUp(Node[] tree, int at) {<br>        while (at &gt; 0) {<br>            int i = (at - 1) / 2;<br>            if (tree[i].dist &lt;= tree[at].dist) break;<br>            swap(tree, at, i);<br>            at = i;<br>        }<br>    }<br> <br>    private void swap(Node[] tree, int a, int b) {<br>        Node tmp = tree[a];<br>        tree[a] = tree[b];<br>        tree[b] = tmp;<br>        tree[a].inTree = a;<br>        tree[b].inTree = b;<br>    }<br>}<br></td>