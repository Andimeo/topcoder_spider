<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>typedef long double ld;<br>typedef long long ll;<br>template &lt;class T&gt; T MIN(T a, T b) {return a &lt; b? a : b;}<br>template &lt;class T&gt; T MAX(T a, T b) {return b &lt; a? a : b;}<br>template &lt;class T&gt; T ABS(T a) {return MAX(a, -a);}<br> <br>string toString(ld d, int precision=-1) {ostringstream out; if (precision != -1) {out.precision(precision); out.setf(ios::fixed);} out &lt;&lt; d; return out.str();}<br>string toString(ll n) {ostringstream out; out &lt;&lt; n; return out.str();}<br>string toString(int n) {return toString(ll(n));}<br>ll toInt(string s) {istringstream in(s); ll n; in &gt;&gt; n; return n;}<br>ld toDouble(string s) {istringstream in(s); ld d; in &gt;&gt; d; return d;}<br>int getNumWords(string s) {int n=0; string t; istringstream in(s); while (in &gt;&gt; t) n++; return n;}<br>string getWord(string s, int n) {string t; istringstream in(s); while (n &gt;= 0) {n--; in &gt;&gt; t;} return t;}<br>ll gcd(ll n, ll m) {return m==0? ABS(n) : gcd(m, n%m);}<br> <br>class TreeTraversals {<br>  public:<br>  <br>/*  vector &lt;int&gt; rwidth;<br>  vector &lt;int&gt; inOrder;<br>  vector &lt;int&gt; breadthFirst;<br>  <br>  vector &lt;int&gt; rowi1;<br>  vector &lt;int&gt; rowi2;<br>  <br>  int best;<br>  bool isPossible;<br>  <br>  <br>  void height(int i1, int i2, int j1, int j2, int level) {<br>    cout &lt;&lt; i1 &lt;&lt; " " &lt;&lt; i2 &lt;&lt; " " &lt;&lt; j1 &lt;&lt; " " &lt;&lt; j2 &lt;&lt; " " &lt;&lt; level &lt;&lt; endl;<br>    if (j1 &gt; j2) return;<br>    int root = breadthFirst[j1];<br>    rwidth[level]++;<br>    if (rwidth[level] &gt; best) best = rwidth[level];<br>    <br>    bool gotHit = false;<br>    for (int k = i1; k &lt;= i2; k++) <br>    if (inOrder[k] == root) {<br>      gotHit = true;<br>      int newi1 = i1;<br>      int newi2 = k-1;<br>      int newj1 = j1+1;<br>      int newj2 = newj1 + (newi2-newi1);<br>      height(newi1, newi2, newj1, newj2, level+1);<br>      newi1 = k+1;<br>      newi2 = i2;<br>      newj1 = newj2+1;<br>      newj2 = j2;<br>      height(newi1, newi2, newj1, newj2, level+1);<br>    }<br>    <br>    if (!gotHit) isPossible = false;<br>  }*/<br>  <br>  int bestHeight;<br>  vector &lt;int&gt; rowHeight;<br>  vector &lt;int&gt; height;<br>  vector &lt;int&gt; i1;<br>  vector &lt;int&gt; i2;<br>  <br>  int width(vector &lt;int&gt; inOrder, vector &lt;int&gt; breadthFirst) {<br>    int bPos = 0;<br>    int tPos = 0;<br>//    int i;<br>    <br>    rowHeight.resize(500,0);<br>    bestHeight = 0;<br>    <br>    i1.push_back(0);<br>    i2.push_back(inOrder.size()-1);<br>    height.push_back(0);<br>    <br>    while (tPos &lt; height.size()) {<br>      int j1 = i1[tPos];<br>      int j2 = i2[tPos];<br>      int m = -1;<br>      cout &lt;&lt; j1 &lt;&lt; " " &lt;&lt; j2 &lt;&lt; endl;<br>      for (int k = j1; k &lt;= j2; k++) if (inOrder[k] == breadthFirst[bPos]) m = k;<br>      if (m == -1) return -1;<br>      <br>      if (j1 &lt;= m-1) {<br>        i1.push_back(j1);<br>        i2.push_back(m-1);<br>        height.push_back(height[tPos]+1);<br>      }<br>      if (m+1 &lt;= j2) {<br>        i1.push_back(m+1);<br>        i2.push_back(j2);<br>        height.push_back(height[tPos]+1);<br>      }<br>      rowHeight[height[tPos]]++;<br>      if (rowHeight[height[tPos]] &gt; bestHeight) bestHeight = rowHeight[height[tPos]];<br>      tPos++;<br>      bPos++;<br>    }<br>    <br>    return bestHeight;<br>/*    isPossible = true;<br>    best = 0;<br>    inOrder = _inOrder;<br>    breadthFirst = _breadthFirst;<br>    rwidth.resize(500);<br>    <br>    <br>    height(0, inOrder.size()-1, 0, breadthFirst.size()-1, 0);<br>    if (isPossible) return best;<br>    else return -1;*/<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>