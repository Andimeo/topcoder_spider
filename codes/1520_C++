<td class="problemText" colspan="8" valign="middle" align="left">
            // Includes<br> <br>#include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;string&gt;<br>#include &lt;sstream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>// Macros<br> <br>typedef long double ld;<br>typedef long long ll;<br>template &lt;class T&gt; T MIN(const T &amp;x, const T &amp;y) {return x&lt;y? x:y;}<br>template &lt;class T&gt; T MAX(const T &amp;x, const T &amp;y) {return x&gt;y? x:y;}<br>template &lt;class T&gt; T ABS(const T &amp;x) {return x&gt;0? x:-x;}<br>template &lt;class T&gt; void SWAP(T &amp;x, T &amp;y) {T z=x; x=y; y=z;}<br>const ld PI = 3.14159265358979323846;<br>const ld EPSILON = 0.000000000001;<br> <br>// General parsing/formatting<br> <br>ll toInt(string s) {stringstream in(s, ios_base::in); ll result; in &gt;&gt; result; return result;}<br>ld toDouble(string s) {stringstream in(s, ios_base::in); ld result; in &gt;&gt; result; return result;}<br>string toString(ll n) {stringstream out(ios_base::out); out &lt;&lt; n; return out.str();}<br>string toString(ld d, int precision = -1) {stringstream out(ios_base::out); if (precision &gt;= 0) {out.precision(precision); out.setf(ios::fixed);} out &lt;&lt; d; string s=out.str();<br>  bool nonZero=false; for(int i=0;i&lt;s.size();i++) if (s[i]!='0' &amp;&amp; s[i]!='-' &amp;&amp; s[i]!='.') nonZero=true; if (s[0]=='-' &amp;&amp; !nonZero) return s.substr(1); else return s;}<br>string toString(int n) {return toString((ll)(n));}<br>string toString(char ch) {string s="?"; s[0]=ch; return s;}<br>string toString(const string &amp;s) {return s;}<br>template &lt;class U, class V&gt; string toString(pair&lt;U,V&gt; u) {return toString("(") + toString(u.first) + "," + toString(u.second) + ")";}<br>template &lt;class T&gt; string toString(const vector&lt;T&gt; &amp;v, string delim=",") {string s="("; for(int i=0;i&lt;v.size();i++) {if(i!=0)s+=delim; s += toString(v[i]);} return s+")";}<br>template &lt;class T&gt; string toString(const set&lt;T&gt; &amp;t, string delim=",") {string s="{"; for(typename set&lt;T&gt;::const_iterator it=t.begin(); it!=t.end(); it++) {if(it!=t.begin())s+=delim+" "; s += toString(*it);} return s+"}";}<br>template &lt;class U, class V&gt; string toString(const map&lt;U,V&gt; &amp;m, string delim=",") {string s="{"; for(typename map&lt;U,V&gt;::const_iterator it=m.begin(); it!=m.end(); it++) {if(it!=m.begin())s+=delim+" "; s += toString(it-&gt;first) + "-&gt;" + toString(it-&gt;second);} return s+"}";}<br>int getNumWords(string s, string delim=" ") {int count=0; for(int i=0; i&lt;s.size(); i++) if ( (i==0 || delim.find(s[i-1])!=-1) &amp;&amp; delim.find(s[i]) == -1) count++; return count;}<br>string getWord(string s, int j, string delim=" ") {int count=0; string t; for(int i=0; i&lt;s.size(); i++) {if (delim.find(s[i])==-1) t += s[i]; else {if (i!=0 &amp;&amp; delim.find(s[i-1]) == -1) count++; if(count&gt;j) return t; t="";}} return t;}<br>string getDelimiter(string s, int j, string delim=" ") {int count=0; string t; for(int i=0; i&lt;s.size(); i++) {if (delim.find(s[i])!=-1) t += s[i]; else {if (i==0 || delim.find(s[i-1]) != -1) count++; if(count&gt;j) return t; t="";}} return t;}<br> <br>// Basic math<br> <br>bool isEqual(ld v1, ld v2) {return ABS(v1-v2)&lt;EPSILON;}<br>bool isLess(ld v1, ld v2) {return v1-v2&lt;-EPSILON;}<br>ll gcd(ll n1, ll n2) {return n2==0? ABS(n1) : gcd(n2,n1%n2);}<br>ll lcm(ll n1, ll n2) {return n1==0 &amp;&amp; n2==0? 0 : ABS(n1*n2)/gcd(n1,n2);}<br> <br>struct Fraction {<br>  Fraction(ll n, ll d) {ll g=gcd(n,d); num = n/g; den = d/g; if (den&lt;0) {num=-num; den=-den;}}<br>  Fraction(ll n=0) {num=n; den=1;}<br>  ll num, den;<br> <br>  Fraction operator+(const Fraction &amp;rhs) const {ll g=gcd(rhs.den,den); return Fraction(num*(rhs.den/g)+(den/g)*rhs.num,den*(rhs.den/g));}<br>  Fraction operator-(const Fraction &amp;rhs) const {ll g=gcd(rhs.den,den); return Fraction(num*(rhs.den/g)-(den/g)*rhs.num,den*(rhs.den/g));}<br>  Fraction operator-() const {return Fraction(-num,den);}<br>  Fraction operator*(const Fraction &amp;rhs) const {ll g1=gcd(rhs.den,num); ll g2=gcd(rhs.num,den); return Fraction( (num/g1)*(rhs.num/g2), (den/g2)*(rhs.den/g1));}<br>  Fraction operator/(const Fraction &amp;rhs) const {ll g1=gcd(rhs.num,num); ll g2=gcd(rhs.den,den); return Fraction( (num/g1)*(rhs.den/g2), (den/g2)*(rhs.num/g1));}<br>};<br>ld toDouble(const Fraction &amp;f) {return ((ld)f.num) / ((ld)f.den);}<br>string toString(const Fraction &amp;f) {return toString(f.num) + "/" + toString(f.den);}<br>bool operator&lt;(const Fraction &amp;f1, const Fraction &amp;f2) {return toDouble(f1) &lt; toDouble(f2);}<br>bool operator!=(const Fraction &amp;f1, const Fraction &amp;f2) {return f1.num!=f2.num || f1.den!=f2.den;}<br>bool operator==(const Fraction &amp;f1, const Fraction &amp;f2) {return f1.num==f2.num &amp;&amp; f1.den==f2.den;}<br> <br>// Real code<br> <br>class Dragons <br>{<br>  public:<br>  string snaug(vector &lt;int&gt; initialFood, int rounds) <br>  {<br>    int adj[6][6] = {{0,0,1,1,1,1},<br>      {0,0,1,1,1,1},<br>      {1,1,0,0,1,1},<br>      {1,1,0,0,1,1},<br>      {1,1,1,1,0,0},<br>      {1,1,1,1,0,0}};<br>    int i, j;<br>      <br>    vector&lt;Fraction&gt; food;<br>    for (i = 0; i &lt; 6; i++)<br>    food.push_back(Fraction(initialFood[i],1));<br>    <br>    for (int t = 0; t&lt; rounds; t++) {<br>      cout &lt;&lt; toString(food);      <br>      vector&lt;Fraction&gt; newFood(6,Fraction(0,1));<br>      for (i = 0; i &lt; 6; i++)<br>      for (j = 0; j &lt; 6; j++)<br>      if (adj[i][j]) newFood[i] = newFood[i] + food[j]/4;<br>      food = newFood;<br>    }<br>    cout &lt;&lt; toString(food);  <br>    <br>    if (food[2].den == 1) return toString(food[2].num);<br>    else return toString(food[2]);<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>