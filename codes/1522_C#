<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Drawing;<br>using System.Collections;<br> <br>public class Planets {<br>  public string[] locations(string[] planets, int time) {<br>    const double G = 6.673e-11;<br>    const int t = 3600;<br>    Planet[] ps = new Planet[planets.Length];<br>    for (int i = 0; i &lt; planets.Length; ++i){<br>      ps[i] = new Planet();<br>      string[] ss = planets[i].Split();<br>      ps[i].X = double.Parse(ss[0]);<br>      ps[i].Y = double.Parse(ss[1]);<br>      ps[i].Z = double.Parse(ss[2]);<br>      ps[i].Vx = double.Parse(ss[3]);<br>      ps[i].Vy = double.Parse(ss[4]);<br>      ps[i].Vz = double.Parse(ss[5]);<br>      ps[i].M = double.Parse(ss[6]);<br>    }<br>    for (int i = 0; i &lt; time; ++i){<br>      for (int j = 0; j &lt; ps.Length; ++j){<br>        double Fx = 0.0, Fy = 0.0, Fz = 0.0;<br>        for (int k = 0; k &lt; ps.Length; ++k){<br>          if (j == k) continue;<br>          double dist = ps[j].distanceTo(ps[k]);<br>          double F = G * ps[j].M * ps[k].M / (dist * dist);<br>          Fx += (F * (ps[k].X - ps[j].X) / dist);<br>          Fy += (F * (ps[k].Y - ps[j].Y) / dist);<br>          Fz += (F * (ps[k].Z - ps[j].Z) / dist);<br>        }<br>        ps[j].Vx += t * Fx / ps[j].M;<br>        ps[j].Vy += t * Fy / ps[j].M;<br>        ps[j].Vz += t * Fz / ps[j].M;<br>      }<br>      for (int j = 0; j &lt; ps.Length; ++j){<br>        ps[j].X += ps[j].Vx * t;<br>        ps[j].Y += ps[j].Vy * t;<br>        ps[j].Z += ps[j].Vz * t;<br>      }<br>    }<br>    string[] result = new string[planets.Length];<br>    for (int i = 0; i &lt; planets.Length; ++i){<br>      result[i] = ps[i].ToString();<br>    }<br>    return result;<br>  }<br>  <br>  class Planet{<br>    public double X, Y, Z, Vx, Vy, Vz, M;<br>    public double distanceTo(Planet p){<br>      return Math.Sqrt((X-p.X)*(X-p.X)+(Y-p.Y)*(Y-p.Y)+(Z-p.Z)*(Z-p.Z));<br>    }<br>    public override string ToString(){<br>      return format(X) + " " + format(Y) + " " + format(Z);<br>    }<br>    <br>    private string format(double d){<br>      if (d &lt; 0.001 &amp;&amp; d &gt; -0.001) return "0.000E0";<br>      string s = d.ToString("0.##0E0");<br>      if (s[s.IndexOf('E')+1] == '-'){<br>        return d.ToString("0.##0") + "E0";<br>      }<br>      return s;<br>    }<br>  }<br> <br> <br>  //  COMMON USEFUL METHODS<br> <br>  // Array Sorting<br>  private int compare(IComparable a, IComparable b)<br>  {<br>    return a.CompareTo(b);<br>  }<br> <br>  private void swap(object[] arr, int a, int b)<br>  {<br>    object o = arr[a];<br>    arr[a] = arr[b];<br>    arr[b] = o;<br>  }<br> <br>  private void stableSort(IComparable[] arr)<br>  {<br>    stableSort(arr, 0, arr.Length - 1);<br>  }<br> <br>  private void stableSort(IComparable[] arr, int start, int end)<br>  {<br>    if (end - start &lt; 20)<br>    {<br>      insSort(arr, start, end);<br>    }<br>    else<br>    {<br>      int middle = (start + end - 1) / 2;<br>      stableSort(arr, start, middle);<br>      stableSort(arr, middle + 1, end);<br>      merge(arr, start, middle + 1, end);<br>    }<br>  }<br> <br>  private void insSort(IComparable[] arr, int start, int end)<br>  {<br>    int sentPos = start;<br>    IComparable sentVal = arr[start];<br>    for (int i = start + 1; i &lt; end + 1; ++i)<br>      if (compare(arr[i], sentVal) &lt; 0)<br>      {<br>        sentPos = i;<br>        sentVal = arr[i];<br>      }<br>    for (int i = sentPos; i &gt; 0; --i)<br>      arr[i] = arr[i - 1];<br>    arr[start] = sentVal;<br>    for (int i = start + 2; i &lt; end + 1; ++i)<br>    {<br>      int j = i;<br>      IComparable ic = arr[j];<br>      while (compare(arr[j - 1], ic) &gt; 0)<br>      {<br>        arr[j] = arr[j - 1];<br>        --j;<br>      }<br>      arr[j] = ic;<br>    }<br>  }<br> <br>  private void merge(IComparable[] arr, int start, int middle, int end)<br>  {<br>    IComparable[] temp = new IComparable[arr.Length];<br>    int index = start;<br>    int i = start, j = middle;<br>    while (i &lt; middle &amp;&amp; j &lt;= end)<br>      temp[index++] = compare(arr[i], arr[j]) &gt; 0 ? arr[j++] : arr[i++];<br>    while (i &lt; middle)<br>      temp[index++] = arr[i++];<br>    while (j &lt;= end)<br>      temp[index++] = arr[j++];<br>    Array.Copy(temp, start, arr, start, end - start + 1);<br>  }<br> <br>  // GCD<br>  private long gcd(long a, long b){<br>    long c = a % b;<br>    while (c != 0){<br>      a = b;<br>      b = c;<br>      c = a % b;<br>    }<br>    return b;<br>  }<br> <br>  private long gcd2(long a, long b, long prev){<br>    if (((a|b)&amp;1) == 0) return gcd2(a&gt;&gt;1,b&gt;&gt;1,prev&lt;&lt;1);<br>    return prev;<br>  }<br>}<br> <br>// Powered by PopsEdit<br></td>