<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>using namespace std;<br>typedef vector&lt;int&gt; VI; typedef vector&lt;VI&gt; VVI;<br>typedef vector&lt;string&gt; VS; typedef vector&lt;VS&gt; VVS;<br>typedef vector&lt;bool&gt; VB; typedef vector&lt;VB&gt; VVB;<br>typedef vector&lt;double&gt; VD; typedef vector&lt;VD&gt; VVD;<br>#define guard(X) for(bool X=1;X;X=0)<br>#define for_up(X, L) for(int X=0;X&lt;(L);X++)<br>#define for_down(X, L) for(int X=(L)-1;X&gt;=0;X--)<br>#define for_range(X, L, H) guard(X##_fi)for(typeof(H)X=(L);X!=(H);++X,X##_fi=0)<br>#define for_each(X, C) for_range(X,(C).begin(),(C).end())<br>#define for_tok(X,D,S) guard(X##_fi)for(char*for_tok__s1=strdup((S).c_str()),*for_tok__s3;for_tok__s1;free(for_tok__s1),for_tok__s1=0)for(char*X=strtok_r(for_tok__s1,(D),&amp;for_tok__s3);X;X=strtok_r(0,(D),&amp;for_tok__s3),X##_fi=0)<br>#define for_tok_ws(X,S) for_tok(X," \n\t",S)<br>#define for_bool(X) for(bool X=0,__g=1;__g;__g=X=!X)<br>#define let(X,V) guard(__g)for(typeof(V)X=V;__g;__g=0)<br> <br>int Y, X;<br>int t[60][60];<br>int gy, gx;<br> <br>const int FAR = 1000000000;<br> <br>struct DesertWind {<br> <br>int daysNeeded(vector &lt;string&gt; theMap) {<br>  Y = theMap.size(); X = theMap[0].size();<br>  for (int i = 0; i &lt; Y; i++) {<br>    for (int j = 0; j &lt; X; j++) {<br>      t[i][j] = FAR;<br>      switch (theMap[i][j]) {<br>        case '*': t[i][j] = 0; break;<br>        case '@': theMap[i][j] = '-'; gy = i; gx = j; break;<br>      }<br>    }<br>  }<br>  int gen = 0;<br>  for (bool act = true; act; gen++) {<br>    act = false;<br>    for (int i = 0; i &lt; Y; i++) {<br>      for (int j = 0; j &lt; X; j++) {<br>        if (theMap[i][j] != '-') continue;<br>        int t1 = FAR, t2 = FAR;<br>        for (int ii = i - 1; ii &lt;= i + 1; ii++) if (ii &gt;= 0 &amp;&amp; ii &lt; Y) {<br>          for (int jj = j - 1; jj &lt;= j + 1; jj++) if (jj &gt;= 0 &amp;&amp; jj &lt; X &amp;&amp; (ii != i || jj != j)) {<br>            if (theMap[ii][jj] == 'X') continue;<br>            if (t[ii][jj] &lt; t1) {<br>              t2 = t1; t1 = t[ii][jj];<br>            } else if (t[ii][jj] &lt; t2) {<br>              t2 = t[ii][jj];<br>            }<br>          }<br>        }<br>        t1 = min(3 + t1, 1 + t2);<br>        if (t1 &lt; t[i][j]) {<br>          t[i][j] = t1;<br>          act = true;<br>        }<br>      }<br>    }<br>  }<br>  cout &lt;&lt; gen &lt;&lt; " relaxations\n";<br>  for (int i = 0; i &lt; Y; i++) {<br>    for (int j = 0; j &lt; X; j++) {<br>      cout &lt;&lt; t[i][j] &lt;&lt; ' ';<br>    }<br>    cout &lt;&lt; '\n';<br>  }<br>  if (t[gy][gx] == 1000000000) return -1;<br>  return t[gy][gx];<br>}<br> <br>};<br> <br> <br>// vim:ts=4:sw=4<br></td>