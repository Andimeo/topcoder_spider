<td class="problemText" colspan="8" valign="middle" align="left">
            #ifdef WIN32<br>#pragma warning(disable:4786 4503)<br>#endif<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdarg&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>using namespace std;<br>#ifdef WIN32<br>#define min _cpp_min<br>#define max _cpp_max<br>#define i64 __int64<br>#define u64 unsigned __int64<br>#else<br>#define i64 long long<br>#define u64 unsigned long long<br>#endif<br>#define all(x) (x).begin(), (x).end()<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;vi&gt; vvi;<br>typedef vector&lt;string&gt; vs;<br>typedef vector&lt;vs&gt; vvs;<br>typedef set&lt;int&gt; si;<br>typedef set&lt;string&gt; ss;<br>typedef set&lt;char&gt; sc;<br>typedef pair&lt;int,int&gt; pii;<br>#ifdef WIN32<br>#include &lt;conio.h&gt;<br>#include "..\\utils\\debug.cpp"<br>#endif<br><br>#include &lt;stdarg.h&gt;<br><br>template &lt;class T&gt; ostream &amp;operator &lt;&lt; (ostream &amp;out, const vector&lt;T&gt; &amp;a);<br>template &lt;class T&gt; void print(const T &amp;a);<br>template &lt;class Ta, class Tb&gt; bool eq(const Ta &amp;a, const Tb &amp;b);<br>vector&lt;int&gt; mkvecint(int n, ...);<br>vector&lt;string&gt; mkvecstring(int n, ...);<br><br><br>struct expr;<br>typedef expr* pexpr;<br>typedef list&lt;pexpr&gt; lpexpr;<br><br>#define prod 1<br>#define sum 2<br>#define var 3<br>#define num 4<br> <br>struct expr<br>{<br>  int type;<br>  string sval;<br>  double dval;<br>  lpexpr lval;<br>};<br><br>string s;<br>int i;<br><br>pexpr expr1();<br>pexpr expr2();<br>pexpr expr3();<br><br>pexpr expr1()<br>{<br>  pexpr r=new expr;<br>  r-&gt;type=sum;<br>  r-&gt;lval.push_back(expr2());<br>  while(i&lt;s.size() &amp;&amp; s[i]=='+')<br>  {<br>    i++;<br>    r-&gt;lval.push_back(expr2());<br>  }<br>  if(r-&gt;lval.size()==1)<br>    return r-&gt;lval.front();<br>  return r;<br>}<br><br>pexpr expr2()<br>{<br>  pexpr r=new expr;<br>  r-&gt;type=prod;<br>  r-&gt;lval.push_back(expr3());<br>  while(i&lt;s.size() &amp;&amp; s[i]=='*')<br>  {<br>    i++;<br>    r-&gt;lval.push_back(expr3());<br>  }<br>  if(r-&gt;lval.size()==1)<br>    return r-&gt;lval.front();<br>  return r;<br>}<br><br>void valassert(int q)<br>{<br>  if(!q)<br>  {<br>    int *p=NULL;<br>    *p=0;<br>  }<br>}<br><br>pexpr expr3()<br>{<br>  if(i&lt;s.size() &amp;&amp; s[i]=='(')<br>  {<br>    i++;<br>    pexpr r=expr1();<br>    valassert(i&lt;s.size() &amp;&amp; s[i]==')');<br>    i++;<br>    return r;<br>  }<br>  string tok;<br>  while(i&lt;s.size() &amp;&amp; isalnum(s[i]))<br>  {<br>    tok+=s[i];<br>    i++;<br>  }<br>  valassert(tok.size());<br>  pexpr r=new expr;<br>  int k;<br>  if(sscanf(tok.c_str(),"%d",&amp;k)==1)<br>  {<br>    r-&gt;type=num;<br>    r-&gt;dval=k;<br>  }<br>  else<br>  {<br>    r-&gt;type=var;<br>    r-&gt;sval=tok;<br>  }<br>  return r;<br>}<br><br>void execsum(pexpr&amp; p)<br>{<br>  double dsum=0;<br>  lpexpr::iterator it;<br>  for(it=p-&gt;lval.begin();it!=p-&gt;lval.end();)<br>    if((*it)-&gt;type==num)<br>    {<br>      dsum+=(*it)-&gt;dval;<br>      it=p-&gt;lval.erase(it);<br>    }<br>    else<br>      it++;<br>  if(dsum!=0 || p-&gt;lval.size()==0)<br>  {<br>    pexpr p2=new expr;<br>    p2-&gt;type=num;<br>    p2-&gt;dval=dsum;<br>    p-&gt;lval.push_back(p2);<br>  }<br>  if(p-&gt;lval.size()==1)<br>  {<br>    p=p-&gt;lval.front();<br>  }<br>}<br><br>void execprod(pexpr&amp; p)<br>{<br>  double dprod=1;<br>  lpexpr::iterator it;<br>  for(it=p-&gt;lval.begin();it!=p-&gt;lval.end();)<br>    if((*it)-&gt;type==num)<br>    {<br>      dprod*=(*it)-&gt;dval;<br>      it=p-&gt;lval.erase(it);<br>    }<br>    else<br>      it++;<br>  if(dprod==0)<br>  {<br>    p=new expr;<br>    p-&gt;type=num;<br>    p-&gt;dval=dprod;<br>    return;<br>  }<br>  if(dprod!=1 || p-&gt;lval.size()==0)<br>  {<br>    pexpr p2=new expr;<br>    p2-&gt;type=num;<br>    p2-&gt;dval=dprod;<br>    p-&gt;lval.push_back(p2);<br>  }<br>  if(p-&gt;lval.size()==1)<br>  {<br>    p=p-&gt;lval.front();<br>  }<br>}<br><br>pexpr optimize(pexpr p)<br>{<br>  switch(p-&gt;type)<br>  {<br>  case sum:<br>    {<br>      lpexpr::iterator it,it2;<br>      pexpr r=new expr;<br>      r-&gt;type=sum;<br>      for(it=p-&gt;lval.begin();it!=p-&gt;lval.end();it++)<br>      {<br>        *it=optimize(*it);<br>        switch((*it)-&gt;type)<br>        {<br>        case sum:<br>          for(it2=(*it)-&gt;lval.begin();it2!=(*it)-&gt;lval.end();it2++)<br>            r-&gt;lval.push_back(*it2);<br>          break;<br>        default:<br>          r-&gt;lval.push_back(*it);<br>        }<br>      }<br>      execsum(r);<br>      return r;<br>    }<br>  case prod:<br>    {<br>      lpexpr::iterator it,it2;<br>      pexpr r=new expr;<br>      r-&gt;type=prod;<br>      for(it=p-&gt;lval.begin();it!=p-&gt;lval.end();it++)<br>      {<br>        *it=optimize(*it);<br>        switch((*it)-&gt;type)<br>        {<br>        case prod:<br>          for(it2=(*it)-&gt;lval.begin();it2!=(*it)-&gt;lval.end();it2++)<br>            r-&gt;lval.push_back(*it2);<br>          break;<br>        default:<br>          r-&gt;lval.push_back(*it);<br>        }<br>      }<br>      execprod(r);<br>      return r;<br>    }<br>  default:<br>    return p;<br>  }<br>}<br><br>int nops(pexpr p)<br>{<br>  int r=0;<br>  switch(p-&gt;type)<br>  {<br>  case sum:<br>    r+=p-&gt;lval.size()-1;<br>    {<br>      for(lpexpr::iterator it=p-&gt;lval.begin();it!=p-&gt;lval.end();it++)<br>        r+=nops(*it);<br>    }<br>    break;<br>  case prod:<br>    r+=10*(p-&gt;lval.size()-1);<br>    {<br>      for(lpexpr::iterator it=p-&gt;lval.begin();it!=p-&gt;lval.end();it++)<br>        r+=nops(*it);<br>    }<br>    break;<br>  }<br>  return r;<br>}<br><br><br>class Optimizer<br>{<br>public:<br>  int reduce(string ex)<br>  {<br>    s="";<br>    for(i=0;i&lt;ex.size();i++)<br>      if(ex[i]!=' ')<br>        s=s+ex[i];<br>    i=0;<br>    pexpr r=expr1();<br>    pexpr r2=optimize(r);<br>    return nops(r2);<br>  }<br>  static bool fmain;<br>static void main(){<br>  if(fmain) return;<br>  fmain = true;<br>  validateExample("1", (new Optimizer())-&gt;reduce("  alpha*beta+5*006  "), 11, "reduce(\"  alpha*beta+5*006  \")");<br>  validateExample("2", (new Optimizer())-&gt;reduce("a * b * 00 + 1 * 5"), 0, "reduce(\"a * b * 00 + 1 * 5\")");<br>  validateExample("3", (new Optimizer())-&gt;reduce("dx + a * b * 0 + 1 * c"), 1, "reduce(\"dx + a * b * 0 + 1 * c\")");<br>  validateExample("4", (new Optimizer())-&gt;reduce("5 * (3 + 4 + c) + (a + c) * (c + d)"), 24, "reduce(\"5 * (3 + 4 + c) + (a + c) * (c + d)\")");<br>  validateExample("5", (new Optimizer())-&gt;reduce("9 * ((4 + 4)) * (7) * (3 + 1) + 504"), 0, "reduce(\"9 * ((4 + 4)) * (7) * (3 + 1) + 504\")");<br>  validateExample("6", (new Optimizer())-&gt;reduce("((((aa))))"), 0, "reduce(\"((((aa))))\")");<br>  validateExample("7", (new Optimizer())-&gt;reduce("(1 + 0 * a) * c + (0 + 0 * b) * d"), 0, "reduce(\"(1 + 0 * a) * c + (0 + 0 * b) * d\")");<br>  validateExample("8", (new Optimizer())-&gt;reduce("5 * d + 5 * b"), 21, "reduce(\"5 * d + 5 * b\")");<br>  validateExample("9", (new Optimizer())-&gt;reduce("(a*5)*4+((a+4)+5)"), 12, "reduce(\"(a*5)*4+((a+4)+5)\")");<br>  validateExample("10", (new Optimizer())-&gt;reduce("(a*5)*(b*6)"), 20, "reduce(\"(a*5)*(b*6)\")");<br>  validateExample("11", (new Optimizer())-&gt;reduce("(1)+0+1*(w+6)*1"), 1, "reduce(\"(1)+0+1*(w+6)*1\")");<br>}<br>  static void validateExample(string exampleNum, int returned, int expected, string methodInvocation) {<br>    print(exampleNum);<br>    print("  ");<br>    if (!eq(returned,expected)) {<br>      print("FAIL");<br>    } else {<br>      print("SUCCESS");<br>    }<br>    print(" ");  <br>    print(methodInvocation);<br>    print("\tGot:[");<br>    print(returned);<br>    print("]\t");<br>    print("Expected:[");<br>    print(expected);<br>    print("]");<br>    print("\n");<br>  }<br><br><br>};<br><br>bool Optimizer::fmain = false;<br><br>template &lt;class T&gt; ostream &amp;operator &lt;&lt; (ostream &amp;out, const vector&lt;T&gt; &amp;a){<br>  int s = a.size();<br>  for(int i=0; i&lt;s-1; i++)<br>    out &lt;&lt; a[i] &lt;&lt; ",";<br>  if(s&gt;0)<br>    out &lt;&lt; a[s-1];<br>  return out;<br>}<br><br>template &lt;class T&gt; void print(const T &amp;a){<br>  cout &lt;&lt; a;<br>}<br><br>template &lt;class Ta, class Tb&gt; bool eq(const Ta &amp;a, const Tb &amp;b){<br>  return (a==b);<br>}<br><br>vector&lt;int&gt; mkvecint(int n, ...){<br>  vector&lt;int&gt; v(0);<br>  va_list vl;<br>  va_start(vl, n);<br>  for(int i=0; i&lt;n; i++){<br>    int t = va_arg(vl, int);<br>    v.push_back(t);<br>  }<br>  va_end(vl);<br>  return v;<br>}<br><br>vector&lt;string&gt; mkvecstring(int n, ...){<br>  vector&lt;string&gt; v(0);<br>  va_list vl;<br>  va_start(vl, n);<br>  for(int i=0; i&lt;n; i++){<br>    char *t = va_arg(vl, char *);<br>    v.push_back(t);<br>  }<br>  va_end(vl);<br>  return v;<br>}<br><br><br>#ifdef WIN32<br>void main()<br>{<br>  Optimizer::main();<br>}<br>#endif<br> <br>// Powered by CodeProcessor<br></td>