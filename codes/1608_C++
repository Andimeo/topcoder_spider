<td class="problemText" colspan="8" valign="middle" align="left">
            /****************************  http://www.thisisjeff.com/  ****************************/<br> <br>#include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;deque&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stdarg.h&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>#define Forc(i, c) for(typeof(c.begin()) i(c.begin()); i != c.end(); ++i)<br>#define In(c, x) (c.find(x) != c.end())<br>#define Inv(v, x) (find(v, x) &gt;= 0)<br>#define X first<br>#define Y second<br>#define Pair(x, y) make_pair(x, y)<br>#define SetPair(a, x, y) pair&lt;typeof(x), typeof(y)&gt; a(x, y)<br>#define mkvecint makeVec&lt;int, int&gt;<br>#define mkvecstring makeVec&lt;string, char *&gt;<br>typedef pair&lt;int, int&gt; point; typedef long long ll;<br> <br>template &lt;class T&gt; T strToInt(string); template &lt;class T&gt; string intToStr(T);<br>int strToInt(string str) { return strToInt&lt;int&gt;(str); }<br>string intToStr(int x) { return intToStr&lt;int&gt;(x); }<br>vector&lt;string&gt; tokenize(string, string = " ", bool = false);<br>vector&lt;int&gt; tokenizeInt(string, string = " ", bool = false);<br>template &lt;class A, class B&gt; int find(const vector&lt;A&gt;&amp;, B);<br>template &lt;class T&gt; T nth(const set&lt;T&gt;&amp;, int);<br>template &lt;class A, class B&gt; void hookSort(vector&lt;A&gt;&amp;, vector&lt;B&gt;&amp;, bool = false);<br>template &lt;class T&gt; ostream &amp;operator &lt;&lt;(ostream&amp;, const vector&lt;T&gt;&amp;);<br>template &lt;class A, class B&gt; ostream &amp;operator &lt;&lt;(ostream&amp;, const pair&lt;A, B&gt;&amp;);<br>template &lt;class A, class B&gt; vector&lt;A&gt; makeVec(int, ...);<br>void validateExample(string, string, string, string);<br> <br>/**************************************************************************************/<br>/*************************** Here is where my code begins. ****************************/<br>/**************************************************************************************/<br> <br>const int RDIR[] = {0, -1, 0, 1};<br>const int CDIR[] = {1, 0, -1, 0};<br> <br>string MyCode(int a, int b, vector&lt;string&gt; c) {<br>  vector&lt;vector&lt;int&gt; &gt; q(300, vector&lt;int&gt;(300, -1));<br>  int r = 150, C = 150;<br>  vector&lt;vector&lt;int&gt; &gt; toSort(c.size(), vector&lt;int&gt;(3, 0));<br>  for (int i(0); i &lt; c.size(); ++i)<br>    toSort[i][2] = i;<br>  int lastCol(0), currDir(0);<br>  for (int i(0); i &lt; a * b; ++i) {<br>    for (int j(0); j &lt; c.size(); ++j)<br>      toSort[j][0] = 0;<br>    for (int j(-1); j &lt; 2; ++j) for (int k(-1); k &lt; 2; ++k)<br>      if (q[r + j][C + k] &gt;= 0)<br>        ++toSort[q[r + j][C + k]][0];<br>    vector&lt;vector&lt;int&gt; &gt; cop(toSort);<br>    sort(cop.begin(), cop.end());<br>    lastCol = cop[0][2];<br>    q[r][C] = lastCol;<br>    ++toSort[lastCol][1];<br>    int goodDir((currDir + 1) % 4);<br>    if (q[r + RDIR[goodDir]][C + CDIR[goodDir]] == -1)<br>      currDir = goodDir;<br>    r += RDIR[currDir];<br>    C += CDIR[currDir];<br>  }<br>  return c[lastCol];<br>}<br> <br>/**************************************************************************************/<br>/**************** And here is where my code ends.  Thanks for looking! ****************/<br>/**************************************************************************************/<br> <br>struct Quilting {<br>  string lastPatch(int a, int b, vector&lt;string&gt; c) {<br>    validateExample("1", MyCode(3,2,mkvecstring(3,"RED","BLUE","TAN")), "TAN", "lastPatch(3,2,mkvecstring(3,\"RED\",\"BLUE\",\"TAN\"))");<br>    validateExample("2", MyCode(4,3,mkvecstring(5,"E","D","C","B","A")), "E", "lastPatch(4,3,mkvecstring(5,\"E\",\"D\",\"C\",\"B\",\"A\"))");<br>    validateExample("3", MyCode(3,3,mkvecstring(4,"A","B","C","D")), "C", "lastPatch(3,3,mkvecstring(4,\"A\",\"B\",\"C\",\"D\"))");<br>    validateExample("4", MyCode(1,1,mkvecstring(3,"RED","BLUE","YELLOW")), "RED", "lastPatch(1,1,mkvecstring(3,\"RED\",\"BLUE\",\"YELLOW\"))");<br>    validateExample("5", MyCode(10,10,mkvecstring(3,"X","Y","Z")), "Z", "lastPatch(10,10,mkvecstring(3,\"X\",\"Y\",\"Z\"))");<br>    return MyCode(a,b,c);<br>  }<br>};<br> <br>template &lt;class T&gt; T strToInt(string str) {<br>  stringstream ss(str);<br>  T answer;<br>  ss &gt;&gt; answer;<br>  return answer;<br>}<br> <br>template &lt;class T&gt; string intToStr(T x) {<br>  stringstream s;<br>  s &lt;&lt; x;<br>  return s.str();<br>}<br> <br>vector&lt;string&gt; tokenize(string str, string delim, bool returnDelims) {<br>  vector&lt;string&gt; answer;<br>  string temp;<br>  for (int i(0); i &lt; str.length(); ++i) {<br>    bool isDelim(false);<br>    for (int j(0); j &lt; delim.length(); ++j)<br>      if (str[i] == delim[j]) isDelim = true;<br>    if (!isDelim) {<br>      temp += str[i];<br>      continue;<br>    }<br>    if (temp != "") answer.push_back(temp);<br>    temp = "";<br>    if (returnDelims) answer.push_back(string(1, str[i]));<br>  }<br>  if (temp != "") answer.push_back(temp);<br>  return answer;<br>}<br> <br>vector&lt;int&gt; tokenizeInt(string str, string delim, bool returnDelims) {<br>  vector&lt;string&gt; tokens(tokenize(str, delim, returnDelims));<br>  vector&lt;int&gt; answer(tokens.size());<br>  for (int i(0); i &lt; tokens.size(); ++i)<br>    answer[i] = strToInt(tokens[i]);<br>  return answer;<br>}<br> <br>template &lt;class A, class B&gt; int find(const vector&lt;A&gt; &amp;vec, B item) {<br>  for (int i(0); i &lt; vec.size(); ++i)<br>    if (vec[i] == item) return i;<br>  return -1;<br>}<br> <br>template &lt;class T&gt; T nth(const set&lt;T&gt; &amp;s, int x) {<br>  typename set&lt;T&gt;::iterator answer(s.begin());<br>  for (int i(0); i &lt; x; ++i) ++answer;<br>  return *answer;<br>}<br> <br>template &lt;class A, class B&gt; void hookSort(vector&lt;A&gt; &amp;a, vector&lt;B&gt; &amp;b, bool complete) {<br>  vector&lt;pair&lt;A, int&gt; &gt; toSort(a.size());<br>  for (int i(0); i &lt; a.size(); ++i)<br>    toSort[i] = Pair(a[i], i);<br>  sort(toSort.begin(), toSort.end());<br>  vector&lt;B&gt; old(b);<br>  for (int i(0); i &lt; b.size(); ++i)<br>    b[i] = old[toSort[i].Y];<br>  if (complete)<br>    sort(a.begin(), a.end());<br>}<br> <br>template &lt;class T&gt; ostream &amp;operator &lt;&lt;(ostream &amp;os, const vector&lt;T&gt; &amp;vec) {<br>  if (vec.empty()) return os;<br>  for (int i(0); i &lt; vec.size() - 1; ++i) os &lt;&lt; vec[i] &lt;&lt; ',';<br>  return os &lt;&lt; vec[vec.size() - 1];<br>}<br> <br>template &lt;class A, class B&gt; ostream &amp;operator &lt;&lt;(ostream &amp;os, const pair&lt;A, B&gt; &amp;p) {<br>  return os &lt;&lt; '(' &lt;&lt; p.X &lt;&lt; ',' &lt;&lt; p.Y &lt;&lt; ')';<br>}<br> <br>template &lt;class A, class B&gt; vector&lt;A&gt; makeVec(int n, ...) {<br>  vector&lt;A&gt; answer(n);<br>  va_list vl;<br>  va_start(vl, n);<br>  for (int i(0); i &lt; n; ++i) answer[i] = va_arg(vl, B);<br>  va_end(vl);<br>  return answer;<br>}<br> <br>void validateExample(string exampleNo, string returned, string expected, string args) {<br>  cout &lt;&lt; "Example " &lt;&lt; exampleNo &lt;&lt; ": ";<br>  if (returned == expected)<br>    cout &lt;&lt; "Success!" &lt;&lt; endl;<br>  else {<br>    cout &lt;&lt; "FAILURE..." &lt;&lt; endl;<br>    cout &lt;&lt; "   Expected: " &lt;&lt; expected &lt;&lt; endl;<br>    cout &lt;&lt; "   Returned: " &lt;&lt; returned &lt;&lt; endl;<br>    cout &lt;&lt; "   " &lt;&lt; args &lt;&lt; endl;<br>  }<br>}<br> <br>// Powered by the awesomeness that is LunaticFringe.<br>// Powered by CodeProcessor<br></td>