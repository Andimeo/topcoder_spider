<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;vector&gt;<br>#include&lt;string&gt;<br>#include&lt;set&gt;<br>#include&lt;map&gt;<br>#include&lt;list&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;iostream&gt;<br>#include&lt;math.h&gt;<br>#include&lt;stdio.h&gt;<br>#include&lt;queue&gt;<br>#include&lt;iterator&gt;<br> <br>#define q(x) #x<br>#define qq(x) #x[0]<br> <br>#define fori(st, end) for (int i = ((int)(st)); i &lt;= ((int)(end)); i++) <br>#define forj(st, end) for (int j = ((int)(st)); j &lt;= ((int)(end)); j++)<br>#define fork(st, end) for (int k = ((int)(st)); k &lt;= ((int)(end)); k++)<br>#define forl(st, end) for (int l = ((int)(st)); l &lt;= ((int)(end)); l++)<br>#define form(st, end) for (int m = ((int)(st)); m &lt;= ((int)(end)); m++)<br> <br>#define VECI  vector&lt;int&gt;<br>#define LISTI list&lt;int&gt;<br> <br>#define VECS vector&lt;string&gt;<br>#define LISTS list&lt;string&gt;<br> <br>#define VECD vector&lt;double&gt;<br> <br>using namespace std;<br>typedef vector&lt;int&gt; veci;<br>typedef vector&lt;double&gt; vecd;<br>typedef vector&lt;string&gt; vecs;<br>typedef vector&lt;char&gt;   vecch;<br>typedef string str;<br> <br> <br>#define ITRI vector&lt;int&gt;::iterator<br>#define ITRS vector&lt;string&gt;::iterator<br> <br>#define vp(vec, val) vec.push_back(val)    <br>#define vf(vec, val) find(vec.begin(), vec.end(), val)<br>#define vs(vec) sort(vec.begin(), vec.end())<br>#define ve(vec, val) (vf(vec, val) != vec.end())<br>#define va(vec) vec.begin(), vec.end()<br>#define vind(vec, val) (ve(vec, val) ? vf(vec, val) - vec.begin() : -1)<br>#define vins(vec, val) do { if (!ve(vec, val)) vp(vec, val); } while(0)<br> <br>#define lint long long<br> <br>#define ABS(x) ((x) &gt; 0 ? (x) : -(x))<br>#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))<br>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))<br>#define DIST(x, y) ABS((x)-(y))<br> <br>typedef pair&lt;int, int&gt; PAIRI;<br>typedef pair&lt;double, double&gt; PAIRD;<br> <br>typedef PAIRI pairi;<br>typedef PAIRD paird;<br> <br>typedef pair&lt; PAIRD, int &gt; TRIPLEI;<br> <br>#define mp(x, y) make_pair(x, y)<br>#define pq priority_queue<br> <br>#include &lt;sstream&gt;<br> <br>#define vall(v) v.begin(), v.end()<br> <br>template&lt;class T&gt; <br>vector&lt;T&gt; parsestr(string s, string delims = " ") {<br>   string s1;<br>   vector&lt;T&gt; ret;<br>   while (s != "") {<br>      while(delims.find(s[0]) != string::npos) s = s.erase(0, 1);<br>      while(delims.find(s[s.length()-1]) != string::npos)  s = s.erase(s.length()-1, 1);   <br> <br>      int pos = s.find_first_of(delims);<br>      if (pos == string::npos) {<br>         s1 = s;<br>         s  = "";<br>      } else {<br>         s1 = s.substr(0, pos);<br>         s  = s.substr(pos+1, s.length());<br>      }<br> <br>      T val;<br>      istringstream st(s1);<br>      st &gt;&gt; val;<br>      vp(ret, val);<br>   }<br>   return ret;<br> <br>}<br> <br>string toupper(string s) {<br>   string s1 = "";<br>   fori(0, s.size()-1) s1 += toupper(s[i]);<br>   return s1;<br>}<br> <br>string tolower(string s) {<br>   string s1 = "";<br>   fori(0, s.size()-1) s1 += tolower(s[i]);<br>   return s1;<br>}<br> <br>int gcd(int a, int b) {<br>  if (b &gt; a) swap(a, b);<br>  if ((a%b)==0) return b;<br>  return gcd(b, a%b);<br>}<br> <br>int lcm(int a, int b) {<br>  return (a*b)/gcd(a, b);<br>}<br> <br>lint choose(int n, int k) {<br>  lint ret = 1;<br>  int x = n;<br>  int y = 1;<br>  while (x != n-k) {<br>    ret *= x;<br>    x--;<br>    while (y != k+1 &amp;&amp; (ret % y) == 0)  {  ret /= y; y++; }<br>  }<br>  return ret;<br>}<br> <br>#define USE_EXTRA 0<br>#if USE_EXTRA<br>void bfForVECS(const VECS &amp;field, PAIRI st, const vector&lt; PAIRI &gt; &amp;adj, char wall, map&lt; PAIRI, int &gt; &amp;dists) {<br>   list&lt; PAIRI &gt;  t;<br>   t.push_back(st);<br>   while (!t.empty()) {<br>      PAIRI cur = t.front(); <br>      t.pop_front();<br>      fori(0, adj.size()-1) {<br>         int nx = cur.first + adj[i].first;<br>         int ny = cur.second + adj[i].second;<br>         if (nx &lt; 0 || ny &lt;0 || nx &gt;= field.size() || ny &gt;= field[0].size()) continue;<br>         if (field[nx][ny] == wall) continue;<br>         if (dists.find(mp(nx, ny)) == dists.end()) {<br>            dists[mp(nx, ny)] = dists[cur]+1;<br>            vp(t, mp(nx, ny));<br>         }<br>      }<br>   }<br>   return;<br>}<br> <br>template&lt;class T&gt;<br>double get_area(const pair&lt; T, T&gt; &amp;p1, const pair&lt; T, T&gt; &amp;p2, const pair&lt;T, T&gt; &amp;p3) {<br>  return ((double)0.5)*(p1.first*p2.second-p2.first*p1.second +<br>  p2.first*p3.second-p3.first*p2.second+p3.first*p1.second-p1.first*p3.second);<br>}<br>  <br>template &lt;class T&gt; <br>vector&lt;pair&lt; T, T&gt; &gt; get_chull(vector&lt;pair&lt; T, T &gt; &gt; &amp;v) {<br>  vector&lt;pair&lt;T, T&gt; &gt; ret;<br>    <br>  vs(v);<br>  vp(ret, v[0]);<br>    <br>  pair&lt; T, T&gt; cur=v[0];<br>  while(1) {<br>    pair&lt; T, T &gt; p;  <br>    fori(0, v.size()-1) if (v[i]!=cur) {<br>      bool f=true;<br>        <br>    forj(0, v.size()-1) if (j!=i&amp;&amp;v[j]!=cur)<br>      if (get_area(cur, v[i], v[j])&lt;0) { f=false; break; }<br>        <br>      if (f) {p=v[i]; break; }<br>    }<br>    if (p==v[0]) break;<br>    vp(ret, p);<br>    cur=p;<br>  }<br>  return ret;<br>}<br> <br>#endif<br> <br>class TickTick {<br>  public:<br>  int count(vector &lt;string&gt; events) {<br>    <br>// BEGIN CUT HERE<br>    static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }<br>    // END CUT HERE<br>    vecd v;<br>    fori(0, events.size()-1) {<br>      istringstream st(events[i]);<br>      double x;<br>      st &gt;&gt; x;<br>      vp(v, x);<br>    }<br> <br>set&lt;string&gt; u;<br> <br>vecd a;<br>fori(0, v.size()-1) vp(a, v[i]-(int)v[i]);<br>vs(a);<br>int cnt=a.size();<br>fori(0, cnt-2) vp(a, (a[i]+a[i+1])/2);<br>vp(a, (a[a.size()-1]+1)/2);<br> <br>fori(0, a.size()-1) {<br>  double aa = a[i];<br>  double prev = 0;  <br>  <br> <br>  string s;<br>  forj(0, v.size()-1) <br>  {<br>    if ((int)(v[j]-aa+1) == (int)(prev-aa+1)) s += 'S';<br>    else s += 'D';<br>    prev = v[j];<br>  }<br>//    cout &lt;&lt; aa &lt;&lt; " " &lt;&lt; s &lt;&lt; endl;<br>  u.insert(s);<br>}<br> <br>return u.size();<br>    <br>  }<br>  <br>// BEGIN CUT HERE<br>  public:<br>  void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); }<br>  private:<br>  template &lt;typename T&gt; string print_array(const vector&lt;T&gt; &amp;V) { ostringstream os; os &lt;&lt; "{ "; for (typename vector&lt;T&gt;::const_iterator iter = V.begin(); iter != V.end(); ++iter) os &lt;&lt; '\"' &lt;&lt; *iter &lt;&lt; "\","; os &lt;&lt; " }"; return os.str(); }<br>  void verify_case(int Case, const int &amp;Expected, const int &amp;Received) { cerr &lt;&lt; "Test Case #" &lt;&lt; Case &lt;&lt; "..."; if (Expected == Received) cerr &lt;&lt; "PASSED" &lt;&lt; endl; else { cerr &lt;&lt; "FAILED" &lt;&lt; endl; cerr &lt;&lt; "\tExpected: \"" &lt;&lt; Expected &lt;&lt; '\"' &lt;&lt; endl; cerr &lt;&lt; "\tReceived: \"" &lt;&lt; Received &lt;&lt; '\"' &lt;&lt; endl; } }<br>  void test_case_0() { string Arr0[] = {".222","00.223","1.221","4.220"}; vector &lt;string&gt; Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 4; verify_case(0, Arg1, count(Arg0)); }<br>  void test_case_1() { string Arr0[] = {"4.220112","4.221","4.222","4.223"}; vector &lt;string&gt; Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 4; verify_case(1, Arg1, count(Arg0)); }<br>  void test_case_2() { string Arr0[] = {"123456.1","123456.7"}; vector &lt;string&gt; Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 2; verify_case(2, Arg1, count(Arg0)); }<br> <br>// END CUT HERE<br> <br>};<br> <br>TickTick TickTick_obj;<br> <br>extern  "C" void i_know_it_would_fail_but_at_least_i_can_try() {<br>  TickTick_obj.run_test(-1);<br>}<br> <br> <br>// Powered by PopsEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>