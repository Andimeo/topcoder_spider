<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cassert&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstring&gt;<br>#include &lt;iostream&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>typedef map&lt;int,int&gt; MII;<br>typedef map&lt;string,int&gt; MSI;<br>typedef pair&lt;int,int&gt; PII;<br>typedef pair&lt;string,int&gt; PSI;<br>typedef set&lt;int&gt; SI;<br>typedef set&lt;string&gt; SS;<br>typedef vector&lt;bool&gt; VB;<br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br><br>#define de(i,v) typeof(v) i(v)<br>#define fe(i,c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)<br>#define fer(i,c) for (typeof((c).rbegin()) i = (c).rbegin(); it != (c).rend(); ++i)<br>#define fi(i,a,b) for (typeof(a) i = (a); i &lt; (b); ++i)<br>#define fir(i,a,b) for (typeof(a) i = (b), --i; i &gt;= (a); --i)<br><br>// Shifts uniformly adds or pops elements from STL structures<br>template &lt; typename T &gt; list&lt;T&gt; &amp;operator &lt;&lt; (list&lt;T&gt; &amp;c, const T &amp;v) { c.push_back(v); return c; }<br>template &lt; typename T &gt; list&lt;T&gt; &amp;operator &gt;&gt; (list&lt;T&gt; &amp;c, T &amp;v) { v = c.pop_back(); return c; }<br>template &lt; typename T &gt; priority_queue&lt;T&gt; &amp;operator &lt;&lt; (priority_queue&lt;T&gt; &amp;c, const T &amp;v) { c.push(v); return c; }<br>template &lt; typename T &gt; priority_queue&lt;T&gt; &amp;operator &gt;&gt; (priority_queue&lt;T&gt; &amp;c, T &amp;v) { v = c.top(); c.pop(); return c; }<br>template &lt; typename T &gt; queue&lt;T&gt; &amp;operator &lt;&lt; (queue&lt;T&gt; &amp;c, const T &amp;v) { c.push(v); return c; }<br>template &lt; typename T &gt; queue&lt;T&gt; &amp;operator &gt;&gt; (queue&lt;T&gt; &amp;c, T &amp;v) { v = c.top(); c.pop(); return c; }<br>template &lt; typename T &gt; set&lt;T&gt; &amp;operator &lt;&lt; (set&lt;T&gt; &amp;c, const T &amp;v) { c.insert(v); return c; }<br>template &lt; typename T &gt; vector&lt;T&gt; &amp;operator &lt;&lt; (vector&lt;T&gt; &amp;c, const T &amp;v) { c.push_back(v); return c; }<br>template &lt; typename T &gt; vector&lt;T&gt; &amp;operator &gt;&gt; (vector&lt;T&gt; &amp;c, T &amp;v) { v = c.pop_back(); return c; }<br><br>// PROBLEM STARTS HERE<br><br>struct ele;<br><br>bool operator &lt; (const set&lt;ele&gt; &amp;a, const set&lt;ele&gt; &amp;b);<br><br>struct ele {<br>  string x;<br>  set&lt;ele&gt; child;<br><br>  ele() : x(), child() {}<br><br>  bool operator &lt; (const ele &amp;o) const {<br>    if (x != o.x) return x &lt; o.x;<br>    return child &lt; o.child;<br>  }<br>  bool operator == (const ele &amp;o) const {<br>    return x == o.x &amp;&amp; child == o.child;<br>  }<br>  bool operator != (const ele &amp;o) const {<br>    return x != o.x || child != o.child;<br>  }<br>  bool operator &gt; (const ele &amp;o) const {<br>    return !(*this &lt; o || *this == o);<br>  }<br>};<br><br>bool operator &lt; (const set&lt;ele&gt; &amp;a, const set&lt;ele&gt; &amp;b) {<br>  de(ia,a.begin());<br>  de(ib,b.begin());<br>  for (; ia != a.end() &amp;&amp; ib != b.end(); ++ia, ++ib) {<br>    if (*ia != *ib) return *ia &lt; *ib;<br>  }<br>  return a.size() &lt; b.size();<br>}<br><br>ele parse(istringstream &amp;in) {<br>  ele curr; curr.x = "";<br>  if (in.peek() == '{') {<br>    in.get();<br>    while (in.good() &amp;&amp; in.peek() != '}') {<br>      curr.child &lt;&lt; parse(in);<br>      if (in.peek() != '}') assert(in.get() == ',');<br>    }<br>    assert(in.get() == '}');<br>  }<br>  else {<br>    while (isalpha(in.peek())) curr.x += (char) in.get();<br>  }<br>  return curr;<br>}<br><br>bool member(ele &amp;a, ele &amp;b) {<br>  fe(it,b.child) {<br>    if (a == *it) return true;<br>  }<br>  return false;<br>}<br><br>bool subset(ele &amp;a, ele &amp;b) {<br>  de(ia, a.child.begin());<br>  de(ib, b.child.begin());<br>  <br>  while (ia != a.child.end() &amp;&amp; ib != b.child.end()) {<br>    if (*ia &lt; *ib) return false;<br>    else if (*ia &gt; *ib) ++ib;<br>    else ++ia, ++ib;<br>  }<br>  return ia == a.child.end();<br>}<br><br>bool power(ele &amp;a, ele &amp;b) {<br>  if (b.child.size() != (1&lt;&lt;a.child.size())) return false;<br>  for (int i = 0; i &lt; (1&lt;&lt;a.child.size()); ++i) {<br>    ele c;<br>    int j = 0;<br>    fe(ia,a.child) {<br>      if (i&amp;(1&lt;&lt;j)) c.child &lt;&lt; *ia;<br>      ++j;<br>    }<br>    if (!member(c,b)) return false;<br>  }<br>  return true;<br>}<br><br>bool equip(ele &amp;a, ele &amp;b) {<br>  return a.child.size() == b.child.size();<br>}<br><br>void dump(const ele &amp;a) {<br>  if (a.x != "") cout &lt;&lt; a.x;<br>  else {<br>    cout &lt;&lt; "{";<br>    fe(i,a.child) {<br>      if (i != a.child.begin()) cout &lt;&lt; ",";<br>      dump(*i);<br>    }<br>    cout &lt;&lt; "}";<br>  }<br>}<br><br>class SetComparison { public:  vector &lt;string&gt; relation(string a, string b) {<br>  istringstream sa(a);<br>  istringstream sb(b);<br>  ele ea = parse(sa);<br>  ele eb = parse(sb);<br>  <br>  //dump(ea); cout &lt;&lt; endl;<br>  //dump(eb); cout &lt;&lt; endl;<br><br>  //ele test; test.x = "a";<br>  //ele test2; test2.child &lt;&lt; test;<br>  //cout &lt;&lt; (test &lt; test2) &lt;&lt; ' ' &lt;&lt; (test2 &lt; test) &lt;&lt; endl;<br><br>  VS out;<br>  if (member(ea,eb)) out &lt;&lt; (string)"MEMBER";<br>  bool eq = ea == eb;<br>  if (eq) out &lt;&lt; (string)"EQUIVALENT";<br>  bool sub = subset(ea,eb);<br>  if (sub) out &lt;&lt; (string)"SUBSET";<br>  if (!eq &amp;&amp; sub) out &lt;&lt; (string)"PROPER SUBSET";<br>  if (power(eb,ea)) out &lt;&lt; (string)"POWERSET";<br>  if (equip(ea,eb)) out &lt;&lt; (string)"EQUIPOTENT";<br>  sort(out.begin(), out.end());<br>  return out;<br>}};<br><br><br>// Powered by FileEdit<br></td>