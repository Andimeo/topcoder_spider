<td class="problemText" colspan="8" valign="middle" align="left">
            //program framework generated with WishingBone's parser :)-<br> <br>//common header<br>#ifdef WIN32<br>#  pragma warning(disable:4786)<br>#  define for if (0); else for<br>#endif<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;deque&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cmath&gt;<br>using namespace std;<br> <br>//64 bit integer definition<br>#ifdef WIN32<br>#define in_routine(type,spec) \<br>istream&amp; operator&gt;&gt;(istream&amp; s,type &amp;d){char b[30];s&gt;&gt;b;sscanf(b,spec,&amp;d);return s;}<br>#define out_routine(type,spec) \<br>ostream&amp; operator&lt;&lt;(ostream&amp; s,type d){char b[30];sprintf(b,spec,d);s&lt;&lt;b;return s;}<br>typedef signed __int64 i64; in_routine(i64,"%I64d") out_routine(i64,"%I64d")<br>typedef unsigned __int64 u64; in_routine(u64,"%I64u") out_routine(u64,"%I64u")<br>#else<br>typedef signed long long i64;<br>typedef unsigned long long u64;<br>#endif<br> <br>//common routines<br>#ifdef WIN32<br>#define min(a,b) _cpp_min(a,b)<br>#define max(a,b) _cpp_max(a,b)<br>#endif<br>#define abs(a) ((a)&gt;0?(a):-(a))<br>#define s2d(s,d) {istringstream(s)&gt;&gt;d;}<br>#define d2s(d,s) {ostringstream t;t&lt;&lt;d;s=t.str();}<br>int gcd(int a,int b){for(int c;b;c=a,a=b,b=c%b);return a;}<br>int lcm(int a,int b){return a/gcd(a,b)*b;}<br> <br>//remove routine<br>template &lt;class T&gt;<br>void remove(vector&lt;T&gt;&amp; v,const T&amp;e){<br>  v.resize(remove(v.begin(),v.end(),e)-v.begin());<br>}<br>template &lt;class T&gt;<br>vector&lt;T&gt; remove_copy(vector&lt;T&gt;&amp; v,const T&amp;e){<br>  vector&lt;T&gt; result;<br>  remove_copy(v.begin(),v.end(),back_inserter(result),e);<br>  return result;<br>}<br> <br>//output routine<br>ostream&amp; operator&lt;&lt;(ostream&amp; s,string d){<br>  s&lt;&lt;'\"'&lt;&lt;d.c_str()&lt;&lt;'\"';<br>  return s;<br>}<br>template &lt;class T&gt;<br>ostream&amp; operator&lt;&lt;(ostream&amp; s,vector&lt;T&gt; d){<br>  s&lt;&lt;"{"&lt;&lt;endl;<br>  for (typename vector&lt;T&gt;::iterator i=d.begin();i!=d.end();i++)<br>    s&lt;&lt;(i!=d.begin()?",":"")&lt;&lt;*i&lt;&lt;endl;<br>  s&lt;&lt;"}";<br>  return s;<br>}<br> <br>//parsing routine<br>template &lt;class T&gt;<br>vector&lt;basic_string&lt;T&gt; &gt; parse(const basic_string&lt;T&gt; &amp;s,const basic_string&lt;T&gt; &amp;delim){<br>  vector&lt;basic_string&lt;T&gt; &gt; ret(0);<br>  for (int b,e=0;;ret.push_back(s.substr(b,e-b)))<br>    if ((b=s.find_first_not_of(delim,e))==(e=s.find_first_of(delim,b)))<br>      return ret;<br>}<br>vector&lt;int&gt; intparse(const string &amp;s,const string &amp;delim=" \t\n"){<br>  vector&lt;string&gt; tmp=parse(s,delim);<br>  vector&lt;int&gt; ret(0);<br>  int t;<br>  for (vector&lt;string&gt;::iterator i=tmp.begin();i!=tmp.end();i++)<br>    sscanf(i-&gt;c_str(),"%d",&amp;t),ret.push_back(t);<br>  return ret;<br>}<br> <br>//name mapper<br>class mapper{<br>public:<br>  map&lt;string,int&gt; m;<br>  vector&lt;string&gt; v;<br>  void reset(){<br>    v.clear();<br>    m.clear();<br>  }<br>  int size(){<br>    return v.size();<br>  }<br>  int get(const string str){<br>    if (m.find(str)==m.end()){<br>      m[str]=v.size();<br>      v.push_back(str);<br>    }<br>    return m[str];<br>  }<br>  string get(int i){<br>    return v[i];<br>  }<br>  vector&lt;int&gt; get(const vector&lt;string&gt;&amp; strs){<br>    vector&lt;int&gt; ret;<br>    ret.reserve(strs.size()+2);<br>    for(int i=0;i&lt;strs.size();i++)<br>      ret.push_back(get(strs[i]));<br>    return ret;<br>  }<br>  vector&lt;string&gt; get(const vector&lt;int&gt;&amp; is){<br>    vector&lt;string&gt; ret;<br>    ret.reserve(is.size()+2);<br>    for(int i=0;i&lt;is.size();i++)<br>      ret.push_back(get(is[i]));<br>    return ret;<br>  }<br>};<br> <br>/*<br>'.' = open street <br>'X' = obstacles <br>'A' = available parking spots <br>'U' = used parking spots <br>'E' = the store entrance <br>'Y' = your car <br>'C' = other cars<br>*/<br> <br>const int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};<br> <br>class ParkingLot{<br>public:<br>  int m, n;<br>  int youx, youy, shopx, shopy, carx, cary, meid;<br>  int parkedtime[50][50], parkedid[50][50], carid[50][50];<br>  bool carmove(char c) {<br>    return c != 'X' &amp;&amp; c != 'U' &amp;&amp; c != 'E';<br>  }<br>  bool youmove(char c) {<br>    return c != 'X';<br>  }<br>  bool range(int x, int y) {<br>    return x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n;<br>  }<br>  bool assigncars(vector&lt;string&gt;&amp; lot) {<br>    int ret = 10000, x = 0, y = 0, tox = 0, toy = 0;<br>    int step[50][50];<br>    for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) if (lot[i][j] == 'C') {<br>      for (int ii = 0; ii &lt; m; ++ii) for (int jj = 0; jj &lt; n; ++jj) step[ii][jj] = 10000;<br>      deque&lt;pair&lt;int, int&gt; &gt; que;<br>      que.push_back(make_pair(i, j));<br>      step[i][j] = 0;<br>      int park = 10000, parkx = 10000, parky = 10000;<br>      while (!que.empty()) {<br>        int x = que.front().first;<br>        int y = que.front().second;<br>        que.pop_front();<br>        int p = step[x][y];<br>        if (p &gt;= park) continue;<br>        for (int d = 0; d &lt; 4; ++d) {<br>          int xx = x + dir[d][0];<br>          int yy = y + dir[d][1];<br>          if (!range(xx, yy)) continue;<br>          if (step[xx][yy] &lt; 10000) continue;<br>          if (!carmove(lot[xx][yy])) continue;<br>          if (lot[xx][yy] == 'A') {<br>            park = p + 1;<br>            if (xx &lt; parkx || (xx == parkx &amp;&amp; yy &lt; parky)) {<br>              parkx = xx;<br>              parky = yy;<br>            }<br>          }<br>          que.push_back(make_pair(xx, yy));<br>          step[xx][yy] = p + 1;<br>        }<br>      }<br>      if (park &lt; ret) {<br>        ret = park;<br>        x = i;<br>        y = j;<br>        tox = parkx;<br>        toy = parky;<br>      }<br>    }<br>    if (ret &lt; 10000) {<br>  //    cout &lt;&lt; "debug:  car at " &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; " parked at " &lt;&lt; tox &lt;&lt; ' ' &lt;&lt; toy &lt;&lt; " with time " &lt;&lt; ret &lt;&lt; endl;<br>      parkedtime[tox][toy] = ret;<br>      parkedid[tox][toy] = carid[x][y];<br>      lot[x][y] = '.';<br>      lot[tox][toy] = 'U';<br>      if (x == youx &amp;&amp; y == youy) {<br>        carx = tox;<br>        cary = toy;<br>      }<br>    }<br>    return ret &lt; 10000;<br>  }<br>  int findfast(vector&lt;string&gt;&amp; lot) {<br>    int step[50][50];<br>    for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) step[i][j] = 10000;<br>    deque&lt;pair&lt;int, int&gt; &gt; que;<br>    que.push_back(make_pair(youx, youy));<br>    step[youx][youy] = 0;<br>    while (!que.empty()) {<br>      int x = que.front().first;<br>      int y = que.front().second;<br>      que.pop_front();<br>      int p = step[x][y];<br>      for (int d = 0; d &lt; 4; ++d) {<br>        int xx = x + dir[d][0];<br>        int yy = y + dir[d][1];<br>        if (!range(xx, yy)) continue;<br>        if (step[xx][yy] &lt; 10000) continue;<br>        if (carmove(lot[xx][yy])) {<br>          step[xx][yy] = p + 1;<br>          if (lot[xx][yy] != 'A') {<br>            que.push_back(make_pair(xx, yy));<br>          }<br>        } else if (lot[xx][yy] == 'U' &amp;&amp; (parkedtime[xx][yy] &gt; p + 1 || (parkedtime[xx][yy] == p + 1 &amp;&amp; parkedid[xx][yy] &gt;= meid))) {<br>          step[xx][yy] = p + 1;<br>        }<br>      }<br>    }<br>    int step2[50][50];<br>    for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) step2[i][j] = 10000;<br>    que.clear();<br>    que.push_back(make_pair(shopx, shopy));<br>    step2[shopx][shopy] = 0;<br>    while (!que.empty()) {<br>      int x = que.front().first;<br>      int y = que.front().second;<br>      que.pop_front();<br>      int p = step2[x][y];<br>      for (int d = 0; d &lt; 4; ++d) {<br>        int xx = x + dir[d][0];<br>        int yy = y + dir[d][1];<br>        if (!range(xx, yy)) continue;<br>        if (step2[xx][yy] &lt; 10000) continue;<br>        if (youmove(lot[xx][yy])) {<br>          step2[xx][yy] = p + 2;<br>          que.push_back(make_pair(xx, yy));<br>        }<br>      }<br>    }<br>    int ret = 10000;<br>    for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) {<br>      if (lot[i][j] == 'A' || (lot[i][j] == 'U' &amp;&amp; step[i][j] &lt; 10000)) {<br>        int t = step[i][j] + step2[i][j];<br>        if (t &lt; ret) ret = t;<br>      }<br>    }<br>    if (ret &lt; 10000) return ret;<br>    else return -1;<br>  }<br>  int fastest(vector&lt;string&gt; lot) {<br>    m = lot.size();<br>    n = lot[0].length();<br>    int idid = 0;<br>    for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) {<br>      parkedtime[i][j] = 0;<br>      if (lot[i][j] == 'Y') {<br>        youx = i, youy = j;<br>        lot[i][j] = 'C';<br>        carid[i][j] = meid = idid++;<br>      } else if (lot[i][j] == 'E') {<br>        shopx = i, shopy = j;<br>        lot[i][j] = 'X';<br>      } else if (lot[i][j] == 'C') {<br>        carid[i][j] = idid++;<br>      }<br>    }<br>    carx = -1;<br>    while (assigncars(lot));<br>    if (carx == -1) return -1;<br>    return findfast(lot);<br>  }<br>};<br></td>