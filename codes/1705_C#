<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Text.RegularExpressions;<br> <br>public class Fraction<br>{<br> <br>  public long num = 0;<br>  public long denom = 1;<br> <br>  public Fraction() { num = 0; denom = 1; }<br>  public Fraction( long n, long d ) { num = n; denom = d; }<br>  public override string ToString()   {<br>    if( denom == 1 ) return num.ToString();<br>    else return num.ToString() + "/" + denom.ToString();<br>  }<br>  public double ToDouble() {<br>    return (double)num / (double)denom;<br>  }<br>  public void simplify() {<br>    for( long i = 2; i &lt;= num &amp;&amp; i &lt;= denom; i++ ) {<br>      if( num % i == 0 &amp;&amp; denom % i == 0 ) {<br>        num /= i;<br>        denom /= i;<br>        i = 2;<br>      }<br>    }<br>  }<br>  public static Fraction operator +( Fraction c1, Fraction c2 ) {<br>    Fraction temp = new Fraction();<br>    temp.num = c1.num * c2.denom + c2.num * c1.denom;<br>    temp.denom = c1.denom * c2.denom;<br>    temp.simplify();<br>    return temp;<br>  }  <br>  public static Fraction operator -( Fraction c1, Fraction c2 ) {<br>    Fraction temp = new Fraction();<br>    temp.num = c1.num * c2.denom - c2.num * c1.denom;<br>    temp.denom = c1.denom * c2.denom;<br>    temp.simplify();<br>    return temp;<br>  }<br>  public static Fraction operator *( Fraction c1, Fraction c2 ) {<br>    Fraction temp = new Fraction();<br>    temp.num = c1.num * c2.num;<br>    temp.denom = c1.denom * c2.denom;<br>    temp.simplify();<br>    return temp;<br>  }<br>  public static Fraction operator /( Fraction c1, Fraction c2 ) {<br>    Fraction temp = new Fraction();<br>    temp.num = c1.num * c2.denom;<br>    temp.denom = c1.denom * c2.num;<br>    temp.simplify();<br>    return temp;<br>  }<br>  public static Fraction operator +( Fraction c1, long c2 ) {<br>    Fraction temp = new Fraction();<br>    temp.num = c1.num + c2 * c1.denom;<br>    temp.denom = c1.denom;<br>    temp.simplify();<br>    return temp;<br>  }  <br>  public static Fraction operator -( Fraction c1, long c2 ) {<br>    Fraction temp = new Fraction();<br>    temp.num = c1.num - c2 * c1.denom;<br>    temp.denom = c1.denom;<br>    temp.simplify();<br>    return temp;<br>  }<br>  public static Fraction operator *( Fraction c1, long c2 ) {<br>    Fraction temp = new Fraction();<br>    temp.num = c1.num * c2;<br>    temp.denom = c1.denom;<br>    temp.simplify();<br>    return temp;<br>  }<br>  public static Fraction operator /( Fraction c1, long c2 ) {<br>    Fraction temp = new Fraction();<br>    temp.num = c1.num;<br>    temp.denom = c1.denom * c2;<br>    temp.simplify();<br>    return temp;<br>  }<br>}<br> <br>public class MergeSort <br>{<br>  public int factorial( int input ) {<br>    int val = 1;<br>    for( int i = 2; i &lt;= input; i++ ) val *= i;<br>    return val;<br>  }<br>  public int numPermutations( int a, int b ) {<br>    if( b &gt; a ) return 0;<br>    return factorial(a) / factorial(a-b);<br>  }<br>  public int numCombinations( int a, int b ) {<br>    return numPermutations( a, b ) / factorial( b );<br>  }<br>  public int[] permute( int[] input ) {  <br>    int[] result = (int[])input.Clone();<br> <br>    int key = result.Length-1;<br>    while( key &gt; 0 &amp;&amp; result[key] &lt;= result[key-1] ) key--;<br>    if( key == 0 ) return null;<br>    key--;<br> <br>    int better = result.Length-1;<br>    while( result[better] &lt;= result[key] ) better--;<br> <br>    int temp = result[better];<br>    result[better] = result[key];<br>    result[key] = temp;<br> <br>    int top = result.Length-1;<br>    int bottom = key+1;<br>    while( bottom &lt; top ) {<br>      temp = result[top];<br>      result[top] = result[bottom];<br>      result[bottom] = temp;<br>      top--;<br>      bottom++;<br>    }<br>    return result;<br>  }<br>  public ArrayList permuteAll( int[] input ) {  <br>    ArrayList bibble = new ArrayList();<br>    foreach( int i in input ) bibble.Add( i );<br>    bibble.Sort();<br> <br>    ArrayList results = new ArrayList();<br>    int[] current = new int[input.Length];<br>    for( int i = 0; i &lt; input.Length; i++ ) current[i] = (int)bibble[i];<br> <br>    while( current != null ) {<br>      results.Add( current );<br>      current = permute( current );<br>    }<br> <br>    return results;<br>  }<br>  public ArrayList choose_results = null;<br>  public int[] choose_vals = null;<br>  public int[] choose_counts = null;<br>  public ArrayList chooseAll( int[] input, int count ) {  <br>    int[] current = new int[count];<br> <br>    Hashtable hash = new Hashtable();<br>    foreach( int i in input ) {<br>      if( hash.ContainsKey( i ) ) hash[i] = (int)hash[i] + 1;<br>      else hash[i] = 1;<br>    }<br>  <br>    choose_results = new ArrayList();<br>    choose_vals = new int[ hash.Count ];<br>    choose_counts = new int[ hash.Count ];<br> <br>    int curr = 0;<br>    ArrayList temp = new ArrayList();<br>    foreach( int i in hash.Keys ) {<br>      temp.Add( i );<br>    }<br>    temp.Sort();<br>    foreach( int i in temp ) {<br>      choose_vals[ curr ] = i;<br>      choose_counts[ curr ] = (int)hash[i];<br>      curr++;<br>    }<br>  <br>    _chooses( current, 0, 0 );<br> <br>    return choose_results;<br>  }<br>  public void _chooses( int[] current, int index, int val ) {<br>    if( index == current.Length ) {<br>      int[] x = (int[])current.Clone();<br>      choose_results.Insert( 0, x );<br>      return;<br>    }<br>    if( index &gt;= choose_counts.Length ) return;<br>    if( val &gt;= choose_vals.Length ) return;<br> <br>    for( int i = 0; i &lt;= choose_counts[val] &amp;&amp; index + i &lt;= current.Length; i++ ) {<br>      if( i != 0 ) current[ index + i - 1 ] = choose_vals[ val ];<br>      _chooses( current, index+i, val+1 );<br>    }<br>  }<br>  public int[] factors( int a ) {<br>    int current = a;<br>    ArrayList factors = new ArrayList();<br>    while( current % 2 == 0 ) {<br>      factors.Add( 2 );<br>      current /= 2;<br>    }<br>    int factor = 3;<br>    while( factor &lt;= current ) {<br>      if( current % factor == 0 ) {<br>        current /= factor;<br>        factors.Add( factor );<br>        factor = 3;<br>      }<br>      else factor += 2;<br>    }<br>    int[] results = new int[ factors.Count ];<br>    for( int i = 0; i &lt; results.Length; i++ ) results[i] = (int)factors[i];<br>    return results;<br>  }<br>  int comp = 0;<br>  <br>  ArrayList mergeSort( ArrayList a )<br>  {<br>    if( a.Count &lt;= 1 ) return a;<br>    ArrayList b = new ArrayList();<br>    ArrayList c = new ArrayList();<br>    <br>    int k = a.Count / 2;<br>    for( int i = 0; i &lt; a.Count; i++ )<br>    {<br>      if( i &lt; k ) b.Add( a[i] );<br>      else c.Add( a[i] );<br>    }<br>    <br>    ArrayList sb = mergeSort( b );<br>    ArrayList sc = mergeSort( c );<br>    return merge( sb, sc );<br>  }<br>  <br>  ArrayList merge( ArrayList b, ArrayList c )<br>  {<br>    ArrayList a = new ArrayList();<br>    while( b.Count &gt; 0 &amp;&amp; c.Count &gt; 0 )<br>    {<br>      comp++;<br>      int bx = (int)b[0];<br>      int cx = (int)c[0];<br>      if( bx &lt; cx )<br>      {<br>        b.RemoveAt(0);<br>        a.Add( bx );<br>      }<br>      else if( cx &lt; bx )<br>      {<br>        c.RemoveAt(0);<br>        a.Add( cx );<br>      }<br>      else<br>      {<br>        b.RemoveAt(0);<br>        c.RemoveAt(0);<br>        a.Add( bx );<br>        a.Add( cx );<br>      }<br>    }<br>    <br>    if( b.Count &gt; 0 )<br>    {<br>      foreach( int i in b ) a.Add( i );<br>    }<br>    if( c.Count &gt; 0 )<br>    {<br>      foreach( int i in c ) a.Add( i );<br>    }<br>    <br>    return a;<br>  }<br> <br>  public int howManyComparisons( int[] numbers )<br>  {<br>    ArrayList temp = new ArrayList();<br>    foreach( int i in numbers ) temp.Add( i );<br>    mergeSort( temp );<br>    return comp;    <br>  }<br>}<br> <br>// Powered by PopsEdit<br></td>