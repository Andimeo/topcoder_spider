<td class="problemText" colspan="8" valign="middle" align="left">
            /*/*///*/*/ Powered by radedit!            /*/*/*/*/*/ ;<br>/*/*//*/*/  import java . util .           /*/*/*/*/*/ ;<br>/*/*//*/*/  import java . lang . reflect . /*/*/*/*/*/ ;<br>public class RoboCourier {<br>  boolean ddd = false ;<br>  Hashtable pred = new Hashtable() ;<br>int[] s2ia(String s) {<br>  StringTokenizer t=new StringTokenizer(s.trim(), ",");<br>  int[]r=new int[t.countTokens()];<br>  int i=0;<br>  while(t.hasMoreTokens())try{<br>     r[i++]=Integer.parseInt((String)t.nextToken());<br>  }catch(Exception e){};<br>  return r;<br>}<br> <br>  /**<br>   *   Not the fastest djikstra in the world.<br>   */<br>  class ent {<br>    Object o ;<br>    double pri ;<br>    int at ;<br>    ent(Object o_, double p, int a) {<br>       o = o_ ;<br>       pri = p ;<br>       at = a ;<br>    }<br>    public String toString() {<br>       return "(" + o + "," + pri + "," + at + ")" ;<br>    }<br>  }<br>  class djik {<br>    djik(Object start) {<br>       if (start != null) addState(start, 0.0) ;<br>    }<br>    double valueOf(Object o) {<br>      ent e = (ent)h.get(o) ;<br>      if (e == null) return -1.0 ; // not found: returns -1<br>      return e.pri ;<br>    }<br>    boolean addState(Object o, double value) {<br>      return addState(null, o, value) ;<br>    }<br>    boolean addState(Object prev, Object o, double value) {<br>      ent e = (ent)h.get(o) ;<br>      if (e != null &amp;&amp; e.pri &lt;= value)<br>         return false ; // already here<br>      if (e == null) {<br>         e = new ent(o, value, heap.size()) ;<br>         heap.add(e) ;<br>         h.put(o, e) ;<br>      } else {<br>         e.pri = value ;<br>      }<br>      upheap(e) ;<br>      if (prev != null)<br>         pred.put(o, prev) ;<br>      return true ;<br>    }<br>    Object nextState() {<br>      if (heap.size() == 0) return null ;<br>      ent e = (ent)(heap.get(0)) ;<br>      if (heap.size() &gt; 1) {<br>         ent otop = (ent)(heap.get(heap.size()-1)) ;<br>         heap.set(0, otop) ;<br>         otop.at = 0 ;<br>         heap.remove(heap.size()-1) ;<br>         downheap(otop) ;<br>      } else {<br>         heap.remove(0) ;<br>      }<br>      return e.o ;<br>    }<br>    void upheap(ent e) {<br>      int w = e.at ;<br>      while (w &gt; 0) {<br>         int par = w / 2 ;<br>         ent pare = (ent)(heap.get(par)) ;<br>         if (pare.pri &lt;= e.pri)<br>            break ;<br>         pare.at = w ;<br>         heap.set(w, pare) ;<br>         w = par ;<br>      }<br>      e.at = w ;<br>      heap.set(w, e) ;<br>    }<br>    void downheap(ent e) {<br>      int w = e.at ;<br>      int n = heap.size()-1 ;<br>      while (w &lt;= n/2) {<br>         int par = w * 2 ;<br>         ent pare = (ent)(heap.get(par)) ;<br>         if (par&lt;n) {<br>            ent par2 = (ent)(heap.get(par+1)) ;<br>            if (par2.pri &lt; pare.pri) {<br>               par++ ;<br>               pare = par2 ;<br>            }<br>         }<br>         if (pare.pri &gt;= e.pri)<br>            break ;<br>         pare.at = w ;<br>         heap.set(w, pare) ;<br>         w = par ;<br>      }<br>      e.at = w ;<br>      heap.set(w, e) ;<br>    }<br>    int size() { return h.size() ; }<br>    int levAt = 0 ;<br>    ArrayList heap = new ArrayList() ;<br>    Map h = new HashMap() ;<br>  }<br>  int dir[] = { 1, -1000, -1001, -1, 1000, 1001, 1 } ;<br>  HashSet vd = new HashSet() ;<br>  HashSet pts = new HashSet() ;<br>  void seen(int i) {<br>    pts.add(new Integer(i)) ;<br>  }<br>  void tran(int p1, int d) {<br>    //    System.out.println("Can go " + p1 + "," + d) ;<br>    vd.add(p1 + "," + d) ;<br>  }<br>  public int timeToDeliver(String[] path) {<br>    int i, j, k ;<br>    int p = 0 ;<br>    int d = 0 ;<br>    for (i=0; i&lt;path.length; i++) {<br>      String s = path[i] ;<br>      for (j=0; j&lt;s.length(); j++) {<br>  switch (s.charAt(j)) {<br>  case 'L': d = (d + 5) % 6 ; break ;<br>  case 'R': d = (d + 1) % 6 ; break ;<br>  case 'F': tran(p, d) ;<br>    tran(p+dir[d], (d+3)%6) ;<br>    seen(p) ; seen(p+dir[d]) ;<br>    p += dir[d] ;<br>    //    System.out.println("At " + p) ;<br>    break ;<br>  }<br>      }<br>    }<br>    int best = 1000000000 ;<br>    djik dj = new djik("0,0") ;<br>    while (true) {<br>       String s = (String)(dj.nextState()) ;<br>       if (s == null) return best ;<br>       //       System.out.println("At " + s) ;<br>       int[] p2 = s2ia(s) ;<br>       double oval = dj.valueOf(s) ;<br>       if (p2[0] == p) {<br>   best = Math.min(best, (int)oval) ;<br>       }<br>       dj.addState("" + p2[0] + "," + ((p2[1] + 1) % 6), oval+3) ;<br>       dj.addState("" + p2[0] + "," + ((p2[1] + 5) % 6), oval+3) ;<br>       int pp = p2[0] ;<br>       int cst = 4 ;<br>       for (i=0; true; i++) {<br>   String t = "" + pp + "," + p2[1] ;<br>   if (vd.contains(t)) {<br>     pp += dir[p2[1]] ;<br>     //     System.out.println("Can go " + t + " -&gt; " + pp + "," + p2[1] + " " + oval+cst) ;<br>     dj.addState("" + pp + "," + p2[1], oval+cst) ;<br>     if (i == 0) {<br>       cst += 4 ;<br>     } else {<br>       cst += 2 ;<br>     }<br>   } else {<br>     break ;<br>   }<br>       }<br>    }<br>  }<br>}<br></td>