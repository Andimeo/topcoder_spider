<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;ext/algorithm&gt;<br>#include &lt;ext/numeric&gt;<br>using namespace std;<br>using namespace __gnu_cxx;<br>class BrickByBrick<br>{<br>public:<br>  int timeToClear(vector &lt;string&gt; map);<br>// {{{<br>  <br><br>// }}}<br>};<br><br>class state<br>{<br>public:<br>  state() {}<br>  state(int x, int y, int velx, int vely) : _pos_x(x), _pos_y(y), _velx(velx), _vely(vely) { }<br>  bool operator== (const state &amp;oth) {<br>    return(_pos_x == oth._pos_x &amp;&amp; _pos_y == oth._pos_y &amp;&amp; _velx == oth._velx &amp;&amp; _vely == oth._vely);<br>  }<br>private:<br>  int _pos_x, _pos_y, _velx, _vely;<br>};<br><br>struct brick<br>{<br>  brick(int p_x, int p_y, bool b) : x(p_x), y(p_y), isbrick(b) {}<br>  int x, y;<br>  bool isbrick;<br>};<br><br>int BrickByBrick::timeToClear(vector &lt;string&gt; map)<br>{<br>  int vel_x=1, vel_y=1;<br>  int pos_x=1, pos_y=0;<br>  int num_bricks = 0;<br>  int time = 0;<br>  vector&lt;brick&gt; blocks;<br>  vector&lt;state&gt; old_states;<br>  <br>  for(int i=0; i&lt;map.size(); i++)<br>  for(int j=0; j&lt;map[i].size(); j++)<br>  {<br>    if(map[i][j] == 'B') {<br>      num_bricks++;<br>      blocks.push_back( brick(j*2, i*2, true) );<br>    } else if(map[i][j] == '#') {<br>      blocks.push_back( brick(j*2, i*2, false) );<br>    }<br>  }<br>  <br>  int field_width = map[0].size() * 2, field_height = map.size() * 2;<br>  while(1)<br>  {<br>    state now(pos_x, pos_y, vel_x, vel_y);<br>    <br>    for(int i=0; i&lt;old_states.size(); i++)<br>      if(old_states[i] == now) return -1;<br>    <br>    old_states.push_back( now );<br>    <br>    for(int i=0; i&lt;blocks.size(); i++)<br>    {<br>      if(pos_x &gt;= blocks[i].x &amp;&amp; pos_x &lt;= blocks[i].x + 2 &amp;&amp; pos_y &gt;= blocks[i].y &amp;&amp; pos_y &lt;= blocks[i].y + 2)<br>      {<br>        if(pos_x == blocks[i].x)<br>          vel_x = -1;<br>        else if(pos_x == blocks[i].x + 2)<br>          vel_x = 1;<br>        else if(pos_y == blocks[i].y)<br>          vel_y = -1;<br>        else<br>          vel_y = 1;<br>        <br>        if(blocks[i].isbrick) {<br>          blocks[i] = blocks[blocks.size()-1];<br>          blocks.pop_back();<br>          num_bricks--;<br>          old_states.clear();<br>          if(num_bricks == 0)<br>            return time;<br>        }<br>      }<br>    }<br>    <br>    if(pos_x &lt;= 0)<br>      vel_x = 1;<br>    if(pos_y &lt;= 0)<br>      vel_y = 1;<br>    if(pos_x &gt;= field_width)<br>      vel_x = -1;<br>    if(pos_y &gt;= field_height)<br>      vel_y = -1;<br>    <br><br>    pos_x += vel_x;<br>    pos_y += vel_y;<br>    <br>    time++;<br>  }<br>  <br>  return -1;<br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>