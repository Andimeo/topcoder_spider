<td class="problemText" colspan="8" valign="middle" align="left">
            /****************************  http://www.thisisjeff.com/  ****************************/<br> <br>#include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;deque&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stdarg.h&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>#define Forc(i, c) for(typeof(c.begin()) i(c.begin()); i != c.end(); ++i)<br>#define In(c, x) (c.find(x) != c.end())<br>#define Inv(v, x) (find(v, x) &gt;= 0)<br>#define X first<br>#define Y second<br>#define Pair(x, y) make_pair(x, y)<br>#define SetPair(a, x, y) pair&lt;typeof(x), typeof(y)&gt; a(x, y)<br>#define mkvecint makeVec&lt;int, int&gt;<br>#define mkvecstring makeVec&lt;string, char *&gt;<br>typedef pair&lt;int, int&gt; point;<br> <br>int strToInt(string); string intToStr(int);<br>vector&lt;string&gt; tokenize(string, string = " ", bool = false);<br>vector&lt;int&gt; tokenizeInt(string, string = " ", bool = false);<br>template &lt;class A, class B&gt; int find(const vector&lt;A&gt;&amp;, B);<br>template &lt;class T&gt; T nth(const set&lt;T&gt;&amp;, int);<br>template &lt;class T&gt; ostream &amp;operator &lt;&lt;(ostream&amp;, const vector&lt;T&gt;&amp;);<br>template &lt;class A, class B&gt; ostream &amp;operator &lt;&lt;(ostream&amp;, const pair&lt;A, B&gt;&amp;);<br>template &lt;class A, class B&gt; vector&lt;A&gt; makeVec(int, ...);<br>void validateExample(string, string, string, string);<br> <br>/**************************************************************************************/<br>/*************************** Here is where my code begins. ****************************/<br>/**************************************************************************************/<br> <br>string MyCode(string source) {<br>  bool noInc(false);<br>  int N(source.length()), IP(0), D(1), oldD(1), answer(0);<br>  vector&lt;int&gt; st;<br>  string output;<br>  while (true) {<br>    D = oldD;<br>    noInc = false;<br>    char c(source[IP]);<br>    if (c &gt;= '0' &amp;&amp; c &lt;= '9')<br>      st.push_back(c - '0');<br>    if (c == '$' &amp;&amp; st.size() &gt; 0)<br>      st.pop_back();<br>    if (c == ':') {<br>      int x(0);<br>      if (st.size() &gt; 0) {<br>        x = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      st.push_back(x);<br>      st.push_back(x);<br>    }<br>    if (c == 'W') {<br>      int x(0), y(0);<br>      if (st.size() &gt; 0) {<br>        x = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      if (st.size() &gt; 0) {<br>        y = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      st.push_back(x);<br>      st.push_back(y);<br>    }<br>    if (c == ',') {<br>      int x(0);<br>      if (st.size() &gt; 0) {<br>        x = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      output += source[abs(x) % N];<br>    }<br>    if (c == '+') {<br>      int x(0), y(0);<br>      if (st.size() &gt; 0) {<br>        x = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      if (st.size() &gt; 0) {<br>        y = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      long long z(0);<br>      z += x;<br>      z += y;<br>      if (z &lt; -1000000000 || z &gt; 1000000000)<br>        return string("OVERFLOW ") + intToStr(answer);<br>      st.push_back(z);<br>    }<br>    if (c == '-') {<br>      int x(0), y(0);<br>      if (st.size() &gt; 0) {<br>        x = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      if (st.size() &gt; 0) {<br>        y = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      long long z(0);<br>      z += x;<br>      z -= y;<br>      if (z &lt; -1000000000 || z &gt; 1000000000)<br>        return string("OVERFLOW ") + intToStr(answer);<br>      st.push_back(z);<br>    }<br>    if (c == '#')<br>      D *= 2;<br>    if (c == 'R') {<br>      D *= -1;<br>      oldD = D;<br>    }<br>    if (c == 'S') {<br>      int x(0);<br>      if (st.size() &gt; 0) {<br>        x = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      if (x &gt; 0)<br>        st.push_back(1);<br>      else<br>        st.push_back(-1);<br>    }<br>    if (c == '_') {<br>      int x(0);<br>      if (st.size() &gt; 0) {<br>        x = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      D = x % N;<br>      oldD = D;<br>    }<br>    if (c == 'J') {<br>      int x(0);<br>      if (st.size() &gt; 0) {<br>        x = st[st.size() - 1];<br>        st.pop_back();<br>      }<br>      IP = abs(x) % N;<br>      noInc = true;<br>    }<br>    if (c == '@')<br>      return string("BADEND ") + intToStr(answer);<br>    if (source.substr(0, output.length()) != output)<br>      return string("MISMATCH ") + intToStr(answer);<br>    if (source == output)<br>      return string("QUINES ") + intToStr(answer);<br>    if (!noInc)<br>      IP = (3 * N + IP + D) % N;<br>    ++answer;<br>    if (answer == 80000) return "TIMEOUT";<br>  }<br>}<br> <br>/**************************************************************************************/<br>/**************** And here is where my code ends.  Thanks for looking! ****************/<br>/**************************************************************************************/<br> <br>struct QuiningTopCoder {<br>  string testCode(string source) {<br>    validateExample("1", MyCode(","), "QUINES 0", "testCode(\",\")");<br>    validateExample("2", MyCode("_"), "TIMEOUT", "testCode(\"_\")");<br>    validateExample("3", MyCode("1:+:1J"), "OVERFLOW 147", "testCode(\"1:+:1J\")");<br>    validateExample("4", MyCode("0,1+:#@:$1J"), "QUINES 91", "testCode(\"0,1+:#@:$1J\")");<br>    validateExample("5", MyCode("0,1+::9W-9W-S1W1W:+2_J_@_@"), "BADEND 437", "testCode(\"0,1+::9W-9W-S1W1W:+2_J_@_@\")");<br>    validateExample("6", MyCode("#R,#:+1+:#,R#"), "QUINES 97", "testCode(\"#R,#:+1+:#,R#\")");<br>    validateExample("7", MyCode("R,#1+1:"), "MISMATCH 7", "testCode(\"R,#1+1:\")");<br>    return MyCode(source);<br>  }<br>};<br> <br>int strToInt(string str) {<br>  stringstream ss(str);<br>  int answer;<br>  ss &gt;&gt; answer;<br>  return answer;<br>}<br> <br>string intToStr(int x) {<br>  stringstream s;<br>  s &lt;&lt; x;<br>  return s.str();<br>}<br> <br>vector&lt;string&gt; tokenize(string str, string delim, bool returnDelims) {<br>  vector&lt;string&gt; answer;<br>  string temp;<br>  for (int i(0); i &lt; str.length(); ++i) {<br>    bool isDelim(false);<br>    for (int j(0); j &lt; delim.length(); ++j)<br>      if (str[i] == delim[j]) isDelim = true;<br>    if (!isDelim) {<br>      temp += str[i];<br>      continue;<br>    }<br>    if (temp != "") answer.push_back(temp);<br>    temp = "";<br>    if (returnDelims) answer.push_back(string(1, str[i]));<br>  }<br>  if (temp != "") answer.push_back(temp);<br>  return answer;<br>}<br> <br>vector&lt;int&gt; tokenizeInt(string str, string delim, bool returnDelims) {<br>  vector&lt;string&gt; tokens(tokenize(str, delim, returnDelims));<br>  vector&lt;int&gt; answer(tokens.size());<br>  for (int i(0); i &lt; tokens.size(); ++i)<br>    answer[i] = strToInt(tokens[i]);<br>  return answer;<br>}<br> <br>template &lt;class A, class B&gt; int find(const vector&lt;A&gt; &amp;vec, B item) {<br>  for (int i(0); i &lt; vec.size(); ++i)<br>    if (vec[i] == item) return i;<br>  return -1;<br>}<br> <br>template &lt;class T&gt; T nth(const set&lt;T&gt; &amp;s, int x) {<br>  typename set&lt;T&gt;::iterator answer(s.begin());<br>  for (int i(0); i &lt; x; ++i) ++answer;<br>  return *answer;<br>}<br> <br>template &lt;class T&gt; ostream &amp;operator &lt;&lt;(ostream &amp;os, const vector&lt;T&gt; &amp;vec) {<br>  if (vec.empty()) return os;<br>  for (int i(0); i &lt; vec.size() - 1; ++i) os &lt;&lt; vec[i] &lt;&lt; ',';<br>  return os &lt;&lt; vec[vec.size() - 1];<br>}<br> <br>template &lt;class A, class B&gt; ostream &amp;operator &lt;&lt;(ostream &amp;os, const pair&lt;A, B&gt; &amp;p) {<br>  return os &lt;&lt; '(' &lt;&lt; p.X &lt;&lt; ',' &lt;&lt; p.Y &lt;&lt; ')';<br>}<br> <br>template &lt;class A, class B&gt; vector&lt;A&gt; makeVec(int n, ...) {<br>  vector&lt;A&gt; answer(n);<br>  va_list vl;<br>  va_start(vl, n);<br>  for (int i(0); i &lt; n; ++i) answer[i] = va_arg(vl, B);<br>  va_end(vl);<br>  return answer;<br>}<br> <br>void validateExample(string exampleNo, string returned, string expected, string args) {<br>  cout &lt;&lt; "Example " &lt;&lt; exampleNo &lt;&lt; ": ";<br>  if (returned == expected)<br>    cout &lt;&lt; "Success!" &lt;&lt; endl;<br>  else {<br>    cout &lt;&lt; "FAILURE..." &lt;&lt; endl;<br>    cout &lt;&lt; "   Expected: " &lt;&lt; expected &lt;&lt; endl;<br>    cout &lt;&lt; "   Returned: " &lt;&lt; returned &lt;&lt; endl;<br>    cout &lt;&lt; "   " &lt;&lt; args &lt;&lt; endl;<br>  }<br>}<br> <br>// Powered by CodeProcessor<br></td>