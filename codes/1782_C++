<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>using namespace std;<br><br>#define REP(i,n) for(int i=0;i&lt;(n);++i)<br>#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)<br>#define FORD(i,a,b) for(int i=(a);i&gt;=(b);--i)<br>#define FOREACH(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)<br><br>template&lt;class T&gt; inline int size(const T&amp;c) { return c.size(); }<br>typedef long long LL; typedef vector&lt;int&gt; VI; typedef vector&lt;string&gt; VS;<br>const int INF = 1000000000;<br><br>const int MAX = 64;<br>int sx,sy;<br><br>bool conn[MAX][MAX][4];<br><br>int dx[4] = {0,1,0,-1};<br>int dy[4] = {-1,0,1,0};<br><br>inline bool dead(int x,int y) {<br>  return conn[x][y][0]+conn[x][y][1]+conn[x][y][2]+conn[x][y][3]==1;<br>}<br><br>inline bool shortdead(int x,int y) {<br>  if(!dead(x,y)) return false;<br>  int d=0;<br>  while(!conn[x][y][d]) ++d;<br>  y+=dy[d]; x+=dx[d];<br>  return conn[x][y][0]+conn[x][y][1]+conn[x][y][2]+conn[x][y][3]!=2;<br>}<br><br>void unconn(int x,int y) {<br>  REP(i,4) if(conn[x][y][i]) {<br>    conn[x][y][i]=false;<br>    conn[x+dx[i]][y+dy[i]][(i+2)%4] = false;<br>  }<br>}<br><br>void cn(int x1,int y1,int x2,int y2) {<br>  REP(i,4) if(x2==x1+dx[i] &amp;&amp; y2==y1+dy[i]) {<br>    conn[x1][y1][i]=true;<br>    conn[x2][y2][(i+2)%4]=true;<br>  }<br>}<br><br>void go() {<br>  for(;;) {<br>    REP(y,sy) REP(x,sx) {<br>      if(shortdead(x,y)) {<br>        bool kon = true;<br>        if(y&gt;0 &amp;&amp; shortdead(x,y-1)) { unconn(x,y); cn(x,y,x,y-1); }<br>        else if(x&gt;0 &amp;&amp; shortdead(x-1,y)) { unconn(x,y); cn(x,y,x-1,y); }<br>        else if(x&lt;sx-1 &amp;&amp; shortdead(x+1,y)) { unconn(x,y); cn(x,y,x+1,y); }<br>        else if(y&lt;sy-1 &amp;&amp; shortdead(x,y+1)) { unconn(x,y); cn(x,y,x,y+1); }<br>        else if(y&gt;0 &amp;&amp; dead(x,y-1)) { unconn(x,y); cn(x,y,x,y-1); }<br>        else if(x&gt;0 &amp;&amp; dead(x-1,y)) { unconn(x,y); cn(x,y,x-1,y); }<br>        else if(x&lt;sx-1 &amp;&amp; dead(x+1,y)) { unconn(x,y); cn(x,y,x+1,y); }<br>        else if(y&lt;sy-1 &amp;&amp; dead(x,y+1)) { unconn(x,y); cn(x,y,x,y+1); }<br>        else kon=false;<br>        if(kon) goto xxx;<br>      }<br>    }<br>    break;<br>xxx: ;<br>  }<br>}<br><br>struct MazeImprovement {<br>  // MAIN<br>  vector &lt;string&gt; improve(vector &lt;string&gt; maze) {<br>    sy = size(maze); sx= size(maze[0]);<br>    REP(x,sx) REP(y,sy) REP(i,4) conn[x][y][i]=false;<br>    REP(x,sx) REP(y,sy) {<br>      if(maze[y][x]=='|' || maze[y][x]=='L') {<br>        conn[x][y][0] = true;<br>        conn[x][y-1][2] = true;<br>      }<br>      if(maze[y][x]=='-' || maze[y][x]=='L') {<br>        conn[x][y][1]=true;<br>        conn[x+1][y][3]=true;<br>      }<br>    }<br>    go();<br>    REP(x,sx) REP(y,sy) {<br>      if(conn[x][y][0] &amp;&amp; conn[x][y][1]) maze[y][x]='L';<br>      if(conn[x][y][0] &amp;&amp; !conn[x][y][1]) maze[y][x]='|';<br>      if(!conn[x][y][0] &amp;&amp; conn[x][y][1]) maze[y][x]='-';<br>      if(!conn[x][y][0] &amp;&amp; !conn[x][y][1]) maze[y][x]='.';<br>    }<br>    return maze;<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>