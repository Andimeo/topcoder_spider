<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Drawing;<br>using System.Collections;<br> <br>public class Rochambo {<br>  public int wins(string opp) {<br>    int result = 0;<br>    if (opp[0] == 'S') ++ result;<br>    if (opp[1] == 'S') ++ result;<br>    for (int i = 2; i &lt; opp.Length; ++i){<br>      char pred;<br>      if (opp[i-1] == opp[i-2]) pred = opp[i-1];<br>      else if (opp[i-1] != 'R' &amp;&amp; opp[i-2] != 'R') pred = 'R';<br>      else if (opp[i-1] != 'S' &amp;&amp; opp[i-2] != 'S') pred = 'S';<br>      else pred = 'P';<br>      if (opp[i] == pred) ++result;<br>    }<br>    return result;<br>  }<br> <br> <br>  //  COMMON USEFUL METHODS<br> <br>  // Array Sorting<br>  private int compare(IComparable a, IComparable b)<br>  {<br>    return a.CompareTo(b);<br>  }<br> <br>  private void swap(object[] arr, int a, int b)<br>  {<br>    object o = arr[a];<br>    arr[a] = arr[b];<br>    arr[b] = o;<br>  }<br> <br>  private void stableSort(IComparable[] arr)<br>  {<br>    stableSort(arr, 0, arr.Length - 1);<br>  }<br> <br>  private void stableSort(IComparable[] arr, int start, int end)<br>  {<br>    if (end - start &lt; 20)<br>    {<br>      insSort(arr, start, end);<br>    }<br>    else<br>    {<br>      int middle = (start + end - 1) / 2;<br>      stableSort(arr, start, middle);<br>      stableSort(arr, middle + 1, end);<br>      merge(arr, start, middle + 1, end);<br>    }<br>  }<br> <br>  private void insSort(IComparable[] arr, int start, int end)<br>  {<br>    int sentPos = start;<br>    IComparable sentVal = arr[start];<br>    for (int i = start + 1; i &lt; end + 1; ++i)<br>      if (compare(arr[i], sentVal) &lt; 0)<br>      {<br>        sentPos = i;<br>        sentVal = arr[i];<br>      }<br>    for (int i = sentPos; i &gt; 0; --i)<br>      arr[i] = arr[i - 1];<br>    arr[start] = sentVal;<br>    for (int i = start + 2; i &lt; end + 1; ++i)<br>    {<br>      int j = i;<br>      IComparable ic = arr[j];<br>      while (compare(arr[j - 1], ic) &gt; 0)<br>      {<br>        arr[j] = arr[j - 1];<br>        --j;<br>      }<br>      arr[j] = ic;<br>    }<br>  }<br> <br>  private void merge(IComparable[] arr, int start, int middle, int end)<br>  {<br>    IComparable[] temp = new IComparable[arr.Length];<br>    int index = start;<br>    int i = start, j = middle;<br>    while (i &lt; middle &amp;&amp; j &lt;= end)<br>      temp[index++] = compare(arr[i], arr[j]) &gt; 0 ? arr[j++] : arr[i++];<br>    while (i &lt; middle)<br>      temp[index++] = arr[i++];<br>    while (j &lt;= end)<br>      temp[index++] = arr[j++];<br>    Array.Copy(temp, start, arr, start, end - start + 1);<br>  }<br> <br>  // GCD<br>  private long gcd(long a, long b){<br>    long c = a % b;<br>    while (c != 0){<br>      a = b;<br>      b = c;<br>      c = a % b;<br>    }<br>    return b;<br>  }<br> <br>  private long gcd2(long a, long b, long prev){<br>    if (((a|b)&amp;1) == 0) return gcd2(a&gt;&gt;1,b&gt;&gt;1,prev&lt;&lt;1);<br>    return prev;<br>  }<br>}<br> <br>// Powered by PopsEdit<br></td>