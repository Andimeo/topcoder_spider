<td class="problemText" colspan="8" valign="middle" align="left">
            using System; using System.Collections; using System.Text; public class Amoebae {<br>public int cultureX(string[] kn, string[] cand) {<br>ArrayList L1 = Parse(kn);<br>ArrayList L2 = Parse(cand);<br> <br>int matches = 0;<br>foreach (char[,] g1 in L1)<br> for (int i=0; i&lt;L2.Count; i++)<br>  if (Match(g1, (char[,])L2[i]))<br>   {<br>   L2.RemoveAt(i);<br>   matches++;<br>   break;<br>   }<br> <br>return L1.Count + L2.Count - matches;<br>}<br> <br>ArrayList Parse(String[] grid) {<br>ArrayList ar = new ArrayList();<br>int X = grid[0].Length;<br>int Y = grid.Length;<br>int[,] visited = new int[X,Y];<br>int[] xs = new int[2500];<br>int[] ys = new int[2500];<br>int done,todo;<br>int phase=0;<br>for (int x=0; x&lt;X; x++)<br> for (int y=0; y&lt;Y; y++)<br>  if (visited[x,y]==0 &amp;&amp; grid[y][x] == 'X')<br>   {<br>   phase++;<br>   done=0; todo=0;<br>   xs[todo] = x; ys[todo] = y; todo++; visited[x,y] = phase;<br>   int minx = x, maxx = x, miny = y, maxy = y;<br>   while (done &lt; todo)<br>    {<br>    int xx = xs[done]; int yy = ys[done]; done++;<br>    minx = Math.Min(minx, xx); miny = Math.Min(miny, yy);<br>    maxx = Math.Max(maxx, xx); maxy = Math.Max(maxy, yy);<br>    if (xx &gt; 0 &amp;&amp; visited[xx-1,yy]==0 &amp;&amp; grid[yy][xx-1] == 'X') { xs[todo] = xx-1; ys[todo] = yy; todo++; visited[xx-1,yy] = phase; }<br>    if (xx &lt; X-1 &amp;&amp; visited[xx+1,yy]==0 &amp;&amp; grid[yy][xx+1] == 'X') { xs[todo] = xx+1; ys[todo] = yy; todo++; visited[xx+1,yy] = phase; }<br>    if (yy &gt; 0 &amp;&amp; visited[xx,yy-1]==0 &amp;&amp; grid[yy-1][xx] == 'X') { xs[todo] = xx; ys[todo] = yy-1; todo++; visited[xx,yy-1] = phase; }<br>    if (yy &lt; Y-1 &amp;&amp; visited[xx,yy+1]==0 &amp;&amp; grid[yy+1][xx] == 'X') { xs[todo] = xx; ys[todo] = yy+1; todo++; visited[xx,yy+1] = phase; }<br>    }<br>   <br>   if (maxx-minx &gt;= maxy-miny)<br>    {<br>    char[,] group = new char[maxx-minx+1, maxy-miny+1];<br>    for (int xx=minx; xx&lt;=maxx; xx++)<br>     for (int yy=miny; yy&lt;=maxy; yy++)<br>      group[xx-minx,yy-miny] = (visited[xx,yy] == phase) ? grid[yy][xx] : '.';<br>    ar.Add(group);<br>    }<br>   else<br>    {<br>    char[,] group = new char[maxy-miny+1, maxx-minx+1];<br>    for (int xx=minx; xx&lt;=maxx; xx++)<br>     for (int yy=miny; yy&lt;=maxy; yy++)<br>      group[yy-miny,xx-minx] = (visited[xx,yy] == phase) ? grid[yy][xx] : '.';<br>    ar.Add(group);<br>    }<br>   }<br> <br>return ar;<br>}<br> <br>bool Match(char[,] A, char[,] B) {<br>int X = A.GetLength(0);<br>int Y = A.GetLength(1);<br>if (X != B.GetLength(0) || Y != B.GetLength(1))<br> return false;<br> <br>bool ok1 = true, ok2=true, ok3=true, ok4=true;<br>for (int x=0; x&lt;X; x++)<br> for (int y=0; y&lt;Y; y++)<br>  {<br>  if (A[x,y] != B[x,y]) ok1 = false;<br>  if (A[X-1-x,y] != B[x,y]) ok2 = false;<br>  if (A[x,Y-1-y] != B[x,y]) ok3 = false;<br>  if (A[X-1-x,Y-1-y] != B[x,y]) ok4 = false;<br>  }<br>if (ok1||ok2||ok3||ok4) return true;<br> <br>if (X==Y)<br> {<br> ok1 = true; ok2=true; ok3=true; ok4=true;<br> for (int x=0; x&lt;X; x++)<br>  for (int y=0; y&lt;Y; y++)<br>   {<br>   if (A[x,y] != B[y,x]) ok1 = false;<br>   if (A[X-1-x,y] != B[y,x]) ok2 = false;<br>   if (A[x,Y-1-y] != B[y,x]) ok3 = false;<br>   if (A[X-1-x,Y-1-y] != B[y,x]) ok4 = false;<br>   }<br> if (ok1||ok2||ok3||ok4) return true;<br> }<br> <br>return false;<br>}<br> <br>static int BC(int x) { int tot = 0; while (x &gt; 0) { tot += (x&amp;1); x &gt;&gt;= 1; } return tot; }<br>static long[,] ch = new long[51,51];<br>Object foo = new Initer();<br>class Initer { public Initer() {<br>for (int i=0; i&lt;=50; i++) ch[i,0] = 1;<br> for (int i=1; i&lt;=50; i++)<br>  for (int j=1; j&lt;=i; j++)<br>   ch[i,j] = ch[i-1,j-1] + ch[i-1,j];<br>}}<br> <br>static bool NextPerm(int[] a)<br>{<br>int N = a.Length;<br>for (int i=N-2; i&gt;=0; i--)<br> if (a[i] &lt; a[i+1])<br>  {<br>  Array.Reverse(a, i+1, N-i-1);<br>  for (int j=i+1; j&lt;N; j++)<br>   if (a[i] &lt; a[j])<br>    { int t = a[i]; a[i] = a[j]; a[j] = t; return true; }<br>  }<br>return false;<br>}<br> <br>static int Compare(IEnumerable a, IEnumerable b)<br>{<br>IEnumerator aa = a.GetEnumerator();<br>IEnumerator bb = b.GetEnumerator();<br>while (true)<br> {<br> if (aa.MoveNext())<br>  if (bb.MoveNext())<br>   {<br>   int temp = ((IComparable)aa.Current).CompareTo((IComparable)bb.Current);<br>   if (temp != 0) return temp;<br>   }<br>  else<br>   return 1; // a is longer, hence "larger"<br> else<br>  if (bb.MoveNext())<br>   return -1; // a is shorter, hence "smaller"<br>  else<br>   break;<br> }<br> <br>return 0;<br>}<br> <br>static void WR(Object x, params object[] p) { Console.Write(x.ToString(), p); }<br>static void WL(Object x, params object[] p) { Console.WriteLine(x.ToString(), p); }<br>static void WL() { WL(""); }<br>static void WS(params Object[] c) { foreach (Object x in c) WR(x.ToString() + " "); }<br>static void WS(Array ar, int X) { for (int x=0; x&lt;X; x++) WS(ar.GetValue(x)); WL(); }<br>static void WS(Array ar, int X, int Y) { for (int y=0; y&lt;Y; y++) { for (int x=0; x&lt;X; x++) WS(ar.GetValue(x,y)); WL(); }}<br>void MATCH(String lbl, Object x, Object y)<br> { if (!x.Equals(y)) throw new Exception(lbl + String.Format(" expected [{0}], got [{1}]", x, y)); }<br>void MATCH(ICollection x, ICollection y) {<br> MATCH("count", x.Count, y.Count);<br> int i=0; ArrayList ay = new ArrayList(y);<br> foreach (Object ox in x) { MATCH(i.ToString(), ox, ay[i]); i++; }<br>}}<br></td>