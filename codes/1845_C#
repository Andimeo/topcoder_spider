<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br><br>public class HardDequeSort {<br>  int[] tmp = new int[200];<br><br>  struct Pair<br>  {<br>    public int what;<br>    public int where;<br><br>    public Pair(int what, int where)<br>    {<br>      this.what = what;<br>      this.where = where;<br>    }<br>  }<br><br>  class PairComparer : IComparer<br>  {<br>    public int Compare(object x, object y)<br>    {<br>      Pair px = (Pair) x;<br>      Pair py = (Pair) y;<br><br>      if (px.what &lt; py.what)<br>        return -1;<br>      else if (px.what &gt; py.what)<br>        return 1;<br>      else if (px.where &lt; py.where)<br>        return -1;<br>      else if (px.where &gt; py.where)<br>        return 1;<br>      else<br>        return 0;<br>    }<br>  }<br><br>  bool canFit(int[] data, bool[] take)<br>  {<br>    int head = 70;<br>    int tail = 71;<br><br>    for (int i = 0; i &lt; data.Length; ++i)<br>      if (take[i])<br>      {<br>        if (head &lt; tail)<br>        {<br>          tmp[--tail] = data[i];<br>        } else<br>        {<br>          if (data[i] &gt;= tmp[head])<br>            tmp[++head] = data[i];<br>          else if (data[i] &lt;= tmp[tail])<br>            tmp[--tail] = data[i];<br>          else<br>            return false;<br>        }<br>      }<br><br>    return true;<br>  }<br><br>  public int minDeques(int[] data) {<br>    int n = data.Length;<br><br>    Pair[] p = new Pair[n];<br>    for (int i = 0; i &lt; n; ++i)<br>      p[i] = new Pair(data[i], i);<br><br>    Array.Sort(p, new PairComparer());<br><br>    bool anyBad = false;<br>    int lastBad = 0;<br><br>    bool[] take = new bool[n];<br>    int numtake = 0;<br><br>    for (int i = 0; i &lt; n; ++i)<br>    {<br>      if (anyBad &amp;&amp; lastBad != p[i].what)<br>        break;<br><br>      take[p[i].where] = true;<br>      ++numtake;<br>      if (!canFit(data, take))<br>      {<br>        take[p[i].where] = false;<br>        --numtake;<br>        anyBad = true;<br>        lastBad = p[i].what;<br>      }<br>    }<br><br>    if (numtake == n)<br>      return 1;<br><br>    int[] ndata = new int[n - numtake];<br>    int k = 0;<br><br>    for (int i = 0; i &lt; n; ++i)<br>      if (!take[i])<br>        ndata[k++] = data[i];<br><br>    return 1 + minDeques(ndata);<br>  }<br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>