<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Text.RegularExpressions;<br><br>public class BirthdayOdds <br>{<br>  public int minPeople(int minOdds, int daysInYear) <br>  {<br>    double dProb = 1.0;<br>    double dOdds = 1.0 - minOdds / 100.0;<br><br>    for(int people = 1; true; ++people)<br>    {<br>      dProb *= (double)(daysInYear - (people - 1)) / (double)daysInYear;<br>      if(dProb &lt; dOdds)<br>        return people;<br><br>//Console.WriteLine(dProb);<br>    }<br>  }<br>  <br>   <br><br>}<br><br><br>class JVSLib<br>{<br>  public static int IndexOfNotOneOf(string input,char[] delimiters)<br>  {<br>    return IndexOfNotOneOf(input,delimiters,0,input.Length);<br>  }<br>  public static int IndexOfNotOneOf(string input,char[] delimiters,int startIndex)<br>  {<br>    return IndexOfNotOneOf(input,delimiters,startIndex,input.Length - startIndex);<br>  }<br>  public static int IndexOfNotOneOf(string input,char[] delimiters,int startIndex,int count)<br>  {<br>    int index = startIndex;<br>    int finalIndex = startIndex + count;  // one past the last one we check<br>    for( ; ; )<br>    {<br>      if(index == finalIndex)<br>        return -1;<br>      else<br>      {<br>        bool isDelimiter = false;<br>        for(int i = 0; !isDelimiter &amp;&amp; (i &lt; delimiters.Length); ++i)<br>          if(delimiters[i] == input[index])<br>            isDelimiter = true;<br><br>        if(isDelimiter)<br>          ++index;<br>        else<br>          return index;<br>      }<br>    }<br>  }<br>  public static string[] TokStr(string input,char[] delimiters)<br>  {<br>    ArrayList a = new ArrayList();<br>    int offset = 0;<br>    for(bool breakOut = false; !breakOut; )<br>    {<br>      offset = IndexOfNotOneOf(input,delimiters,offset);<br>      if(offset &lt; 0)  <br>        breakOut = true;<br>      else<br>      {<br>        int newOffset = input.IndexOfAny(delimiters,offset);<br>        if(newOffset &lt; 0)<br>        {<br>          a.Add(input.Substring(offset));<br>          breakOut = true;<br>        }<br>        else<br>          a.Add(input.Substring(offset,newOffset - offset));<br>        offset = newOffset;<br>      }<br>    }<br><br>    string[] ret = (string[])a.ToArray(typeof(string));<br>    return ret;  <br>  }<br>  public static int[] TokInt(string input,char[] delimiters)<br>  {<br>    ArrayList a = new ArrayList();<br>    string[] stringList = TokStr(input,delimiters);<br>    foreach(string str in stringList)<br>      a.Add(int.Parse(str));<br>    int[] ret = (int[])a.ToArray(typeof(int));<br>    return ret;  <br>  }<br>  public static int[][] Tk2Int(string[] input,char[] delimiters)<br>  {<br>    ArrayList a = new ArrayList();<br>    foreach(string str in input)<br>      a.Add(TokInt(str,delimiters));<br>    int[][] ret = (int[][])a.ToArray(typeof(int[]));<br>      return ret;  <br>  }<br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.10 [30-Nov-2003]<br>// Powered by CodeProcessor<br></td>