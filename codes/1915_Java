<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.Map.*;<br>import java.math.*;<br> <br>// Java solution to TopCoder problem for RecurrenceRelation.moduloTen<br>// Written by: router<br> <br>public class RecurrenceRelation {<br> <br> <br>public int moduloTen(int[] coefficients, int[] initial, int N) {<br>  int k = initial.length;<br>  for (int i=k; i&lt;=N; i++) {<br>    int xi = 0;<br>    for (int j=0; j&lt;k; j++) xi += coefficients[j]*initial[(i+j)%k];<br>    xi = xi%10;<br>    if (xi &lt; 0) xi+=10;<br>    initial[i%k] = xi;<br>  }<br>  int r = initial[N%k] % 10;<br>  if (r&lt;0) r+=10;<br>  return r;<br>}<br> <br>// @@MAIN@@ ~RouterProc~<br> <br>//////////////////////////////////////////////////////////////////////////<br>// Copyright: The following library of routines may be freely copied<br>// This library written by router for use in TopCoder competitions<br>// Warning: TopCoder may have rules restricting direct copying  <br>// Split a string into an array of strings<br>static String[] split(String s, String delim, boolean returnDelims) {<br>  StringTokenizer st = new StringTokenizer(s, delim, returnDelims);<br>  int size = st.countTokens();<br>  String[] sv = new String[size];<br>  for (int i=0; i&lt;size; i++)<br>    sv[i] = st.nextToken();<br>  return sv; }<br>static String[] split(String s, String delim) { return split(s, delim, false); }<br>static String[] split(String s) { return split(s, " ", false); }<br>// Join arrays<br>static String join(String[] s, String delim) {<br>  String join = "";<br>  for (int i=0; i&lt;s.length; i++) {<br>    if (i&gt;0) join += delim;<br>    join += s[i]; }<br>  return join; }<br>static String join(String[] s) { return join(s, " "); }<br>static String join(int[] v, int width, String delim) {<br>  String join = "";<br>  for (int i=0; i&lt;v.length; i++) {<br>    if (i&gt;0) join += delim;<br>    join += itoa(v[i], width); }<br>  return join; }<br>// sort arrays (return array unlike Arrays.sort which returns void)<br>static int[] sort(int[] v) { Arrays.sort(v); return v; }<br>static Object[] sort(Object[] v) { Arrays.sort(v); return v; }<br>// Convert an array of strings into an array of integers<br>static int   atoi(String s) { return Integer.parseInt(s); }<br>static int[] atoi(int[] v, String[] s) {<br>  int excess=s.length, i=0, ev[];<br>  if (v != null) {<br>    int size = Math.min(v.length, excess);<br>    excess -= size;<br>    for (; i&lt;size; i++) v[i] = atoi(s[i]); }<br>  ev = new int[excess];<br>  for (int j=0; j&lt;excess; j++) ev[j] = atoi(s[i++]);<br>  return ev; }<br>static int[] atoi(String[] s) { return atoi(null, s); }<br>// Format an integer into a string of given width;<br>// left justify if width&lt;0<br>// pad with leading 0, if width&gt;100<br>final static String spaces = rpts(" ",16);<br>final static String zeroes = rpts("0",16);<br>static String itoa(int i, int width) {<br>  String pads, n=String.valueOf(i); int pad;<br>  if (width &gt; 100)  { pads = zeroes; pad = Math.min(width-100,pads.length()); }<br>  else    { pads = spaces; pad = Math.min(Math.abs(width),pads.length()); }<br>  if (n.length() &lt; pad) {<br>    if (width &lt; 0)  { n = (n+pads).substring(0,pad); }<br>    else  { n = pads+n; n = n.substring(n.length()-pad); }}<br>  return n; }<br>// Create a repeated string<br>static String rpts(String s, int count) {<br>  String res="";<br>  while (count &gt; 0) {<br>    if ((count &amp; 1) != 0) res += s;<br>    if (count &gt; 1)    s += s;<br>    count &gt;&gt;= 1; }<br>  return res; }<br>// Useful print functions<br>static java.io.PrintStream _o=System.out;<br>static void p(int i, int width) { p(itoa(i,width)); }<br>static void p(int i)  { _o.print(i); }<br>static void p(char c)  { _o.print(c); }<br>static void p(Object o)  { _o.print(o); }<br>static void pn(Object o)  {_o.println(o); }<br>static void pn(int i)  { _o.println(i); }<br>static void pn(double d)  { _o.println(d); }<br>static void pn()    { _o.println(); }<br>static void pn(int[] v) {<br>  p('{'); for (int i=0; i&lt;v.length; i++) {<br>    if (i&gt;0) p(", ");<br>    p(v[i]);<br>  }; pn("}"); }<br>static void pn(String[] v)  {<br>  p('{'); for (int i=0; i&lt;v.length; i++) {<br>    if (i&gt;0) p(", ");<br>    if (v[i] == null) p("null");<br>    else { p('"'); p(v[i]); p('"'); }<br>  }; pn("}"); }<br>// Greatest Common Divisor<br>static long gcd(long a, long b) { return b==0? Math.abs(a): gcd(b, a%b); }<br>static int gcd(int a, int b)  { return b==0? Math.abs(a): gcd(b, a%b); }<br>// identity vector<br>static int[] list(int n) {<br>  int[] a = new int[n];<br>  for (int i=0; i&lt;n; i++) a[i]=i;<br>  return a; }<br>// reverse vector<br>static int[] reverse(int[] a) {<br>  int i=0, j=a.length;<br>  int[] b = new int[j];<br>  while (i&lt;j) {<br>    b[i]=a[--j]; b[j]=a[i++]; }<br>  return b; }<br>// simplify array access<br>static int get(int[] v, int index) {<br>  if (index &lt; 0) index += v.length;<br>  return index&gt;=0 &amp;&amp; index&lt;v.length ? v[index] : 0; }<br>static char get(String s, int index) {<br>  if (index &lt; 0) index += s.length();<br>  return index&gt;=0 &amp;&amp; index&lt;s.length() ? s.charAt(index) : '\u0000'; }<br>static String get(String[] v, int index) {<br>  if (index &lt; 0) index += v.length;<br>  return index&gt;=0 &amp;&amp; index&lt;v.length ? v[index] : ""; }<br>static int len(String s)  { return s.length(); }<br>static int len(Object[] v)  { return v.length; }<br>static int len(int[] v)  { return v.length; }<br>// stable sort matrix A by column col (row ordered by vector l), return new row order<br>static int[] sortby(int[][] A, int[] l, int col) {<br>  int i, j=0, k, L=l.length;<br>  int[] b = new int[L];<br>  TreeMap t = new TreeMap();<br>  Vector v;<br>  for (i=0; i&lt;L; i++) {<br>    Integer key = new Integer(A[l[i]][col]);<br>    v = (Vector)t.get(key);<br>    if (v==null) t.put(key, v=new Vector());<br>    v.add(new Integer(i)); }<br>  for (Iterator r=t.values().iterator(); r.hasNext(); ) {<br>    v = (Vector)r.next();<br>    for (k=0; k&lt;v.size(); k++, j++) {<br>      b[j] = l[((Integer)v.get(k)).intValue()]; }}<br>  return b; }<br>static int[] sortby(int[][] A, int col) { return sortby(A, list(A.length), col); }<br>static int[] uniq(int[] a) {<br>  int i;<br>  TreeSet s = new TreeSet();<br>  for (i=0; i&lt;a.length; i++) {<br>    s.add(new Integer(a[i])); }<br>  int[] b = new int[s.size()]; i=0;<br>  for (Iterator r=s.iterator(); r.hasNext(); ) {<br>    b[i++] = ((Integer)r.next()).intValue(); }<br>  return b; }<br>static class strcmp implements Comparator {<br>  public int compare(Object a, Object b) {<br>    return val((String)a)-val((String)b); }<br>  public boolean equals(Object a) {<br>    return a == this; }<br>  // change as necessary<br>  int val(String s) {<br>    String[] f = s.split(" "); // regexp, be careful of .<br>    int a=0, b=0, c=0;<br>    return (a&lt;&lt;16)+(b&lt;&lt;8)+c; }}<br>// The library ends here - see copyright at the top<br>//////////////////////////////////////////////////////////////////////////<br> <br>}<br> <br>// Powered by PopsEdit<br>// Powered by CodeProcessor<br></td>