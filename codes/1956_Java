<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br>import java.math.*;<br>import java.io.*;<br>import java.text.*;<br><br>public class ScriptLanguage {<br>  static final double inf = Double.MAX_VALUE / 11;<br>  int kvad(int a) {return a*a;}<br>  double kvad(double a) {return a*a;}<br>  int gcd(int a, int b) {int c;while (a!=0) {c = a;a = b%a;b = c;}return b;}<br>  private HashMap memo = new HashMap();<br>  static final int antInd = 4;<br>  <br>  int ind = 0;<br>  String[] kode;<br>  ArrayList W = new ArrayList();<br>  <br>  TreeSet parse(String s) {<br>    TreeSet svar = new TreeSet();<br>    StringTokenizer st = new StringTokenizer(s);<br>    while (st.hasMoreTokens()) {<br>      String neste = st.nextToken();<br>      if (isVar(neste)) {<br>        svar.add(new Character(neste.charAt(0)));<br>      }<br>    }<br>    return svar;<br>  }<br>  <br>  boolean isVar(String s) {<br>    if (s.length()!=1) return false;<br>    char c = s.charAt(0);<br>    return 'A'&lt;=c &amp;&amp; c&lt;='Z';<br>  }<br>  <br>  TreeSet rek(final TreeSet init, boolean naaelig, boolean[] returnerer) {<br>    println("rek "+naaelig+" "+ind);<br>    TreeSet lok = (TreeSet)init.clone();<br>    for ( ; ind&lt;kode.length; ++ind) {<br>      String cmd = new StringTokenizer(kode[ind]).nextToken();<br>      String rest = kode[ind].substring(cmd.length());<br>      TreeSet vars = parse(rest);<br>      println(ind+" "+cmd+" "+rest);<br>      if (cmd.equals("PARAM")) {<br>        lok.addAll(vars);<br>      } else if (cmd.equals("ELSE")) {<br>        break;<br>      } else if (cmd.equals("END")) {<br>        break;<br>      }<br>      if (!naaelig) {<br>        W.add("Line "+(ind+1)+": unreachable code");<br>      } else {<br>        TreeSet klone = (TreeSet)vars.clone();<br>        klone.removeAll(lok);<br>        for (Iterator it=klone.iterator(); it.hasNext(); ) {<br>          W.add("Line "+(ind+1)+": variable "+it.next()+" might not have been initialized");<br>        }<br>      }<br>      <br>      if (cmd.equals("IF")) {<br>        ++ind;<br>        boolean[] b1ret = new boolean[1], b2ret = new boolean[1];<br>        TreeSet branch1 = rek(lok,naaelig,b1ret);<br>        String slutt = kode[ind];<br>        TreeSet branch2 = lok;<br>        if (slutt.equals("ELSE")) {<br>          ++ind;<br>          branch2 = rek(lok,naaelig,b2ret);<br>        }<br>        if (b1ret[0]&amp;&amp;b2ret[0]) {<br>          returnerer[0] = true;<br>          naaelig = false;<br>        } else if (b1ret[0]) {<br>          lok = branch2;<br>        } else if (b2ret[0]) {<br>          lok = branch1;<br>        } else {<br>          branch1.retainAll(branch2);<br>          lok = branch1;<br>        }<br>      } else if (cmd.equals("RETURN")) {<br>        naaelig = false;<br>        returnerer[0] = true;<br>      } else if (isVar(cmd)) {<br>        lok.add(new Character(cmd.charAt(0)));<br>      }<br>    }<br>    return lok;<br>  }<br><br>  public String[] warnings(String[] code) {<br>    long startTime=0;<br>    if (measureTime) startTime = System.currentTimeMillis();<br>    kode = code;<br>    <br>    rek(new TreeSet(),true,new boolean[1]);<br>    String[] svar = new String[W.size()];<br>    W.toArray(svar);<br><br>    if (measureTime) ut.println("Time consumption " + (System.currentTimeMillis()-startTime) + " ms.");<br>    return svar;<br>  }<br><br><br>  public class Index implements Comparable {<br>    static final int ant = antInd;<br>    static final int sha = 32/(ant+1);<br>    int[] ind;<br>    public Index(int[] ind) {<br>      this.ind = ind;<br>    }<br>    public boolean equals(Object o) {<br>      Index oo = (Index)o;<br>      for (int i=0; i&lt;ant; ++i) {<br>        if (ind[i]!=oo.ind[i]) return false;<br>      }<br>      return true;<br>    }<br>    public int hashCode() {<br>      int akk1=1, akk2=1;<br>      for (int i=0; i&lt;ant; ++i) {<br>        akk1 ^= ind[i]&lt;&lt;(sha*(i+1));<br>        akk2 ^= ind[i];<br>      }<br>      return akk1^akk2;<br>    }<br>    public boolean negative() {<br>      for (int i=0; i&lt;ant; ++i) {<br>        if (ind[i]&lt;0) return true;<br>      }<br>      return false;<br>    }<br>    public int compareTo(Object o) {<br>      if (o==null) return -1;<br>      Index oo = (Index)o;<br>      for (int i=0; i&lt;ant; ++i) {<br>        if (ind[i]&lt;oo.ind[i]) return -1;<br>        if (ind[i]&gt;oo.ind[i]) return  1;<br>      }<br>      return 0;<br>    }<br>    public String toString() {<br>      StringBuffer sb = new StringBuffer("(");<br>      for (int i=0; i&lt;ant; ++i) sb.append(ind[i]+" ");<br>      sb.append(") ");<br>      return new String(sb);<br>    }<br>  }<br><br>  void printMemo(Index grense) {<br>    if (!debug) return;<br>    int[] ind = new int[antInd];<br>    Index key = new Index(ind);<br>    ind[0]=-1;<br>    for (int i=1; i&lt;antInd; ++i) {<br>      ind[i]=grense.ind[i];<br>    }<br>    ytre: while (true) {<br>      int ch = antInd-1;<br>      while (ind[ch]==grense.ind[ch]) {<br>        ind[ch] = 0;<br>        --ch;<br>        if (ch&lt;0) break ytre;<br>      }<br>      ++ind[ch];<br>      int dim = antInd-1-ch;<br>      if (dim&gt;=1) ut.println();<br>      if (dim&gt;=2) {<br>        StringBuffer sb = new StringBuffer(" memo(");<br>        for (int i=0; i&lt;antInd-2; ++i) {<br>          sb.append(ind[i]+",");<br>        }<br>        sb.append("X,X):");<br>        ut.println(sb);<br>      }<br>      if (dim&gt;=2 &amp;&amp; indexes) {<br>        print("");<br>        header(grense.ind[antInd-1]+1);<br>      }<br>      if (dim&gt;=1 &amp;&amp; indexes) {<br>        print(""+ind[antInd-2]);<br>      }<br>      print(memo.get(key));<br>    }<br>    println("");<br>  }<br><br>  static void print(Object o) {<br>    print(o+"");<br>  }<br>  static void println(Object o) {<br>    println(o+"");<br>  }<br>  static void print(String s) {<br>    if (!debug) return;<br>    int l = s.length();<br>    if (l&gt;=tabsize) l = tabsize-1;<br>    ut.print(space.substring(l,tabsize) + s);<br>  }<br>  static void println(String s) {<br>    if (!debug) return;<br>    print(s);<br>    ut.println();<br>  }<br>  static void header(int n) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;n; ++i) {<br>      print(""+i);<br>    }<br>    ut.println();<br>  }<br>  static void print(double d) {<br>    if (!debug) return;<br>    if (d&gt;=inf) {<br>      print("inf");<br>      return;<br>    }<br>    DecimalFormat DF;<br>    if (Math.abs(d)&lt;0.00000001 || d&gt;=0.01 &amp;&amp; d&lt;100000) {<br>      DF = new DecimalFormat("####0.00");<br>    } else {<br>      DF = new DecimalFormat("0.##E0");<br>    }<br>    print(DF.format(d));<br>  }<br>  static void print(boolean[] V) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;V.length; ++i) {<br>      ut.print(V[i]?'1':'0');<br>    }<br>    ut.println();<br>  }<br>  static void print(char[] V) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;V.length; ++i) {<br>      ut.print(V[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(int[] V) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;V.length; ++i) {<br>      print(""+V[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(long[] V) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;V.length; ++i) {<br>      print(""+V[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(double[] V) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;V.length; ++i) {<br>      print(V[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(Object[] V) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;V.length; ++i) {<br>      print(""+V[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(boolean[][] M) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;M.length; ++i) {<br>      print(M[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(char[][] M) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;M.length; ++i) {<br>      print(M[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(int[][] M) {<br>    if (!debug || M.length==0) return;<br>    if (indexes) {<br>      print("");<br>      header(M[0].length);<br>    }<br>    for (int i=0; i&lt;M.length; ++i) {<br>      if (indexes) {<br>        print(""+i);<br>      }<br>      print(M[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(long[][] M) {<br>    if (!debug || M.length==0) return;<br>    if (indexes) {<br>      print("");<br>      header(M[0].length);<br>    }<br>    for (int i=0; i&lt;M.length; ++i) {<br>      if (indexes) {<br>        print(""+i);<br>      }<br>      print(M[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(double[][] M) {<br>    if (!debug || M.length==0) return;<br>    if (indexes) {<br>      print("");<br>      header(M[0].length);<br>    }<br>    for (int i=0; i&lt;M.length; ++i) {<br>      if (indexes) {<br>        print(""+i);<br>      }<br>      print(M[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(Object[][] M) {<br>    if (!debug || M.length==0) return;<br>    if (indexes) {<br>      print("");<br>      header(M[0].length);<br>    }<br>    for (int i=0; i&lt;M.length; ++i) {<br>      if (indexes) {<br>        print(""+i);<br>      }<br>      print(M[i]);<br>    }<br>    ut.println();<br>  }<br>  static void print(Object[][][] M) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;M.length; ++i) {<br>      println("("+i+",X,X):");<br>      print(M[i]);<br>    }<br>  }<br>  static void print(Object[][][][] M) {<br>    if (!debug) return;<br>    for (int i=0; i&lt;M.length; ++i) {<br>      for (int j=0; j&lt;M[i].length; ++j) {<br>        println("("+i+","+j+",X,X):");<br>        print(M[i][j]);<br>      }<br>    }<br>  }<br><br>  Index getInd(int a, int b) {if (antInd!=2) throw new Error(); return new Index(new int[]{a,b});}<br>  Index getInd(int a, int b, int c) {if (antInd!=3) throw new Error(); return new Index(new int[]{a,b,c});}<br>  Index getInd(int a, int b, int c, int d) {if (antInd!=4) throw new Error(); return new Index(new int[]{a,b,c,d});}<br><br>/*<br>  X get() {<br>    Index ind = getInd();<br>    if (ind.negative()) return 0;<br>    Long val = (Long)memo.get(ind);<br>    if (val!=null) return val.XValue();<br>    X svar = 0;<br><br>    memo.put(ind,new X(svar));<br>    return svar;<br>  }<br>*/<br><br>  static final PrintStream ut = System.out;<br>  static final String space = "                    ";<br>  static final int tabsize = 9; // 1 for ikke tabulasjon, 9 for flytverdier, 17 for longs<br>  static final boolean indexes = true;<br>  static final boolean debug = false;<br>  static final boolean measureTime = false;<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>