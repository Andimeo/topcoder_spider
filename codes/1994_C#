<td class="problemText" colspan="8" valign="middle" align="left">
            using System; using System.Collections; public class PipePath {<br>public double capCost(string[] caps, string[] costs, int A, int B) {<br>Hashtable map = MAP;<br>int N = caps.Length;<br>foreach (String s in caps) foreach (String t in s.Split()) if (t != "")<br> map[Convert.ToInt32(t.Split(',')[1])] = true;<br> <br>ArrayList From=AR,To=AR,ACost=AR,ACap=AR;<br>for (int i=0; i&lt;N; i++) if (caps[i].Length &gt; 0)<br> {<br> string[] ss = caps[i].Split();<br> string[] tt = costs[i].Split();<br> for (int j=0; j&lt;ss.Length; j++)<br>  {<br>  From.Add(i);<br>  To.Add(Convert.ToInt32(ss[j].Split(',')[0]));<br>  ACap.Add(Convert.ToInt32(ss[j].Split(',')[1]));<br>  ACost.Add(Convert.ToInt32(tt[j].Split(',')[1]));<br>  }<br> }<br> <br>double best = 0;<br>int[,] COST = new int[N,N];<br>foreach (int curCap in map.Keys)<br> {<br> for (int i=0; i&lt;N; i++)<br>  for (int j=0; j&lt;N; j++)<br>   COST[i,j] = 999999999;<br> <br> for (int i=0; i&lt;From.Count; i++)<br>  {<br>  if ((int) ACap[i] &gt;= curCap)<br>   COST[(int)From[i],(int)To[i]] = Math.Min(COST[(int)From[i],(int)To[i]], (int)ACost[i]);<br>  }<br> <br> for (int i=0; i&lt;N; i++)<br>  for (int j=0; j&lt;N; j++)<br>   for (int k=0; k&lt;N; k++)<br>    COST[j,k] = Math.Min(COST[j,k], COST[j,i] + COST[i,k]);<br> <br> if (COST[A,B] &lt; 999999999)<br>  best = Math.Max(best, (double)curCap / (double)COST[A,B]);<br> }<br> <br>return best;<br>}<br> <br> <br> <br>int[] IA(ArrayList a) { return (int[]) a.ToArray(typeof(int)); }<br>string[] SA(ArrayList a) { return (string[]) a.ToArray(typeof(string)); }<br> <br>ArrayList AR { get { return new ArrayList(); }}<br>Hashtable MAP { get { return new Hashtable(); }}<br> <br>long GCD(long x, long y) { while (y != 0) {long t=x; x=y; y=t%y;} return x; <br>}<br> <br>int Flood(char[,] g, int sx, int sy, char expect, char fill, int[] xs, int[] <br>ys)<br>{<br>int X = g.GetLength(0), Y=g.GetLength(1), todo=1;<br>xs[0]=sx; ys[0]=sy; g[sx,sy]=fill;<br>for (int done=0; done&lt;todo; done++) for (int dir=0; dir&lt;4; dir++)<br> {<br> int x = xs[done]+dxy[dir], y=ys[done]+dxy[dir+1];<br> if (x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;X &amp;&amp; y&lt;Y &amp;&amp; g[x,y]==expect)<br>  { g[x,y]=fill; xs[todo]=x; ys[todo++]=y; }<br> }<br>return todo;<br>}<br> <br>int[] dxy = new int[9]{1,0,-1,0,1,1,-1,-1,1};<br> <br>bool NextPerm(int[] x)<br>{<br>int N=x.Length;<br>for (int i=N-2; i&gt;=0; i--)<br> if (x[i] &lt; x[i+1])<br>  {<br>  Array.Reverse(x, i+1, N-i-1);<br>  for (int j=i+1; ; j++)<br>   if (x[j] &gt; x[i]) { int t=x[i]; x[i]=x[j]; x[j]=t; return true; }<br>  }<br>return false;<br>}<br> <br>int Compare(IEnumerable a, IEnumerable b)<br>{<br>IEnumerator A = a.GetEnumerator(); IEnumerator B = b.GetEnumerator();<br>while (true)<br> {<br> int del = (A.MoveNext() ? 100 : 0) - (B.MoveNext() ? 99 : 0);<br> if (del != 1) return del;<br> del = ((IComparable)A.Current).CompareTo(B.Current);<br> if (del != 0) return del;<br> }<br>}<br> <br>char[,] ToCharArray(string[] s)<br>{<br>if (s.Length == 0) return new char[0,0];<br>int X = s[0].Length, Y=s.Length;<br>char[,] g = new char[X,Y];<br>for (int x=0; x&lt;X; x++) for (int y=0; y&lt;Y; y++) g[x,y] = s[y][x];<br>return g;<br>}<br> <br>static void WR(Object f, params Object[] p) { Console.Write(f.ToString(), <br>p); }<br>static void WL(Object f, params Object[] p) { <br>Console.WriteLine(f.ToString(), p); }<br>static void WL() { WL(""); }<br>static void WS(params Object[] a) { foreach (Object x in a) <br>WR(x.ToString()+" "); }<br>static void WS(Array a, int X) { for (int x=0; x&lt;X; x++) WS(a.GetValue(x)); <br>WL(); }<br>static void WS(Array a, int X, int Y) { for (int y=0; y&lt;Y; y++) {for (int <br>x=0; x&lt;X; x++) WS(a.GetValue(x,y)); WL();} }<br> <br>static void Match(String lbl, Object x, Object y) { if (!x.Equals(y)) throw <br>new Exception(String.Format("{0}: expected [{1}], got [{2}]", lbl, x, y)); }<br>static void Match(ICollection A, ICollection B)<br>{<br>Match("Count", A.Count, B.Count);<br>int i=0; ArrayList bb = new ArrayList(B);<br>foreach (Object x in A) { Match(i.ToString(), x, bb[i]); i++; }<br>}<br> <br>}<br></td>