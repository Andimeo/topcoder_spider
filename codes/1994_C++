<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br> <br>vector&lt; string &gt; tokenize( string a, string b ) {<br>  const char *q = a.c_str();<br>  while( count( b.begin(), b.end(), *q ) ) {<br>    q++;<br>  }<br>  vector&lt; string &gt; oot;<br>  while( *q ) {<br>    const char *e = q;<br>    while( *e &amp;&amp; !count( b.begin(), b.end(), *e ) ) {<br>      e++;<br>    }<br>    oot.push_back( string( q, e ) );<br>    q = e;<br>    while( count( b.begin(), b.end(), *q ) ) {<br>      q++;<br>    }<br>  }<br>  return oot;<br>}<br> <br>vector&lt; int &gt; sti( const vector&lt; string &gt; &amp;a ) {<br>  vector&lt; int &gt; oot;<br>  for( int i = 0; i &lt; a.size(); i++ ) {<br>    oot.push_back( atoi( a[ i ].c_str() ) );<br>  }<br>  return oot;<br>}<br> <br>int gcd( int a, int b ) {<br>  if( !b ) return a;<br>  return gcd( b, a % b );<br>}<br> <br>int ncr[ 51 ][ 51 ];<br> <br>void ncrg() {<br>  memset( ncr, 0, sizeof( ncr ) );<br>  for( int i = 0; i &lt; 51; i++ ) {<br>    ncr[ i ][ 0 ] = 1;<br>  }<br>  for( int i = 1; i &lt; 51; i++ ) {<br>    for( int j = 1; j &lt; 51; j++ ) {<br>      int targ = ncr[ i - 1 ][ j ] + ncr[ i - 1 ][ j - 1 ];<br>      if( ncr[ i - 1 ][ j ] == -1 || targ &lt; ncr[ i - 1 ][ j ] ) {<br>        ncr[ i ][ j ] = -1;<br>      } else {<br>        ncr[ i ][ j ] = targ;<br>      }<br>    }<br>  }<br>};<br> <br>struct tt { };<br>tt zz;<br> <br>tt &amp;operator,( tt &amp;x, tt &amp;y ) {<br>  printf( "\n" );<br>  y=y;<br>  return x;<br>}<br> <br>tt &amp;operator,( tt &amp;x, const string &amp;y ) {<br>  printf( "\"%s\"", y.c_str() );<br>  return x;<br>}<br> <br>tt &amp;operator,( tt &amp;x, int y ) {<br>  printf( "%d", y );<br>  return x;<br>}<br> <br>tt &amp;operator,( tt &amp;x, double y ) {<br>  printf( "%lf", y );<br>  return x;<br>}<br> <br>template&lt; typename q, typename z &gt;<br>tt &amp;operator,( tt &amp;x, const pair&lt; q, z &gt; &amp;y ) {<br>  printf( "( " );<br>  x,y.first;<br>  printf( ", " );<br>  x,y.second;<br>  printf( " )" );<br>  return x;<br>}<br> <br>template&lt; typename q &gt;<br>tt &amp;operator,( tt &amp;x, const vector&lt; q &gt; &amp;y ) {<br>  printf( "{ " );<br>  for( int i = 0; i &lt; y.size(); i++ ) {<br>    if( i ) {<br>      printf( ", " );<br>    }<br>    x,y[ i ];<br>  }    <br>  printf( " }" );<br>  return x;<br>}<br> <br>/*<br>template&lt; typename q &gt;<br>tt &amp;operator,( tt &amp;x, const set&lt; q &gt; &amp;y ) {<br>  printf( "{ " );<br>  for( set&lt; q &gt;::const_iterator itr = y.begin(); itr != y.end(); itr++ ) {<br>    if( itr != y.begin() ) {<br>      printf( ", " );<br>    }<br>    x,*itr;<br>  }    <br>  printf( " }" );<br>  return x;<br>}<br> <br>template&lt; typename q, typename z &gt;<br>tt &amp;operator,( tt &amp;x, const map&lt; q, z &gt; &amp;y ) {<br>  printf( "{ " );<br>  for( map&lt; q, z &gt;::const_iterator itr = y.begin(); itr != y.end(); itr++ ) {<br>    if( itr != y.begin() ) {<br>      printf( ", " );<br>    }<br>    x,*itr;<br>  }    <br>  printf( " }" );<br>  return x;<br>}<br>*/<br> <br>typedef long long i64;<br> <br>struct path {<br>  int dest;<br>  int cost;<br>  int flow;<br>};<br> <br>vector&lt; path &gt; cc[ 50 ];<br>int flon;<br>i64 ccost[ 50 ];<br>bool dun[ 50 ];<br> <br>class PipePath {<br>  public:<br>  double capCost(vector &lt;string&gt; incaps, vector &lt;string&gt; incosts, int source, int sink) {<br>    set&lt; int &gt; cp;<br>    for( int i = 0; i &lt; incaps.size(); i++ ) {<br>      vector&lt; string &gt; ica = tokenize( incaps[ i ], " " );<br>      vector&lt; string &gt; cca = tokenize( incosts[ i ], " " );<br>      for( int j = 0; j &lt; ica.size(); j++ ) {<br>        vector&lt; int &gt; icb = sti( tokenize( ica[ j ], "," ) );<br>        vector&lt; int &gt; ccb = sti( tokenize( cca[ j ], "," ) );<br>        path foo;<br>        foo.dest = icb[ 0 ];<br>        foo.flow = icb[ 1 ];<br>        foo.cost = ccb[ 1 ];<br>//        printf( "%d-&gt;%d, %d, %d\n", i, foo.dest, foo.flow, foo.cost );<br>        cc[ i ].push_back( foo );<br>        cp.insert( foo.flow );<br>      }<br>    }<br>    int got = 0;<br>    long double bst = 0;<br>    for( set&lt; int &gt;::iterator itr = cp.begin(); itr != cp.end(); itr++ ) {<br>      flon = *itr;<br>      memset( dun, 0, sizeof( dun ) );<br>      memset( ccost, 0x30, sizeof( ccost ) );<br>      ccost[ source ] = 0;<br>      multimap&lt; int, int &gt; sk;<br>      sk.insert( make_pair( 0, source ) );<br>      while( sk.size() ) {<br>        pair&lt; int, int &gt; ts = *sk.begin();<br>        sk.erase( sk.begin() );<br>        if( dun[ ts.second ] )<br>        continue;<br>        dun[ ts.second ] = true;<br>        if( ts.second == sink )<br>        break;<br>//        printf( "at %d, is %lf\n", ts.second, (double)ccost[ ts.second ] );<br>        for( int i = 0; i &lt; cc[ ts.second ].size(); i++ ) {<br>          if( cc[ ts.second ][ i ].flow &gt;= flon ) {<br>            if( ccost[ cc[ ts.second ][ i ].dest ] &gt; ccost[ ts.second ] + cc[ ts.second ][ i ].cost ) {<br>              ccost[ cc[ ts.second ][ i ].dest ] = ccost[ ts.second ] + cc[ ts.second ][ i ].cost;<br>              sk.insert( make_pair( ccost[ cc[ ts.second ][ i ].dest ], cc[ ts.second ][ i ].dest ) );<br>            }<br>          }<br>        }<br>      }<br>//      printf( "%lf, %lf\n", (double)ccost[ sink ], (double)flon );<br>      long double tst = flon / (long double)ccost[ sink ];<br>      if( !got ) {<br>        got = 1;<br>        bst = tst;<br>      };<br>      bst = max( bst, tst );<br>    }<br>    return bst;<br>  }                                  <br>};<br> <br>// Powered by PopsEdit<br></td>