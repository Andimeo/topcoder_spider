<td class="problemText" colspan="8" valign="middle" align="left">
            // Includes<br> <br>#include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;string&gt;<br>#include &lt;sstream&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>// Macros<br> <br>typedef long double ld;<br>typedef long long ll;<br>template &lt;class T&gt; T MIN(const T &amp;x, const T &amp;y) {return x&lt;y? x:y;}<br>template &lt;class T&gt; T MAX(const T &amp;x, const T &amp;y) {return x&gt;y? x:y;}<br>template &lt;class T&gt; T ABS(const T &amp;x) {return x&gt;0? x:-x;}<br>template &lt;class T&gt; void SWAP(T &amp;x, T &amp;y) {T z=x; x=y; y=z;}<br>const ld PI = 3.14159265358979323846;<br>const ld EPSILON = 0.000000000001;<br> <br>// General parsing/formatting<br> <br>ll toInt(string s) {stringstream in(s, ios_base::in); ll result; in &gt;&gt; result; return result;}<br>ld toDouble(string s) {stringstream in(s, ios_base::in); ld result; in &gt;&gt; result; return result;}<br>string toString(ll n) {stringstream out(ios_base::out); out &lt;&lt; n; return out.str();}<br>string toString(ld d, int precision = -1) {stringstream out(ios_base::out); if (precision &gt;= 0) {out.precision(precision); out.setf(ios::fixed);} out &lt;&lt; d; string s=out.str();<br>  bool nonZero=false; for(int i=0;i&lt;s.size();i++) if (s[i]!='0' &amp;&amp; s[i]!='-' &amp;&amp; s[i]!='.') nonZero=true; if (s[0]=='-' &amp;&amp; !nonZero) return s.substr(1); else return s;}<br>string toString(int n) {return toString((ll)(n));}<br>string toString(char ch) {string s="?"; s[0]=ch; return s;}<br>string toString(const string &amp;s) {return s;}<br>template &lt;class U, class V&gt; string toString(pair&lt;U,V&gt; u) {return toString("(") + toString(u.first) + "," + toString(u.second) + ")";}<br>template &lt;class T&gt; string toString(const vector&lt;T&gt; &amp;v, string delim=",") {string s="("; for(int i=0;i&lt;v.size();i++) {if(i!=0)s+=delim; s += toString(v[i]);} return s+")";}<br>template &lt;class T&gt; string toString(const set&lt;T&gt; &amp;t, string delim=",") {string s="{"; for(typename set&lt;T&gt;::const_iterator it=t.begin(); it!=t.end(); it++) {if(it!=t.begin())s+=delim+" "; s += toString(*it);} return s+"}";}<br>template &lt;class U, class V&gt; string toString(const map&lt;U,V&gt; &amp;m, string delim=",") {string s="{"; for(typename map&lt;U,V&gt;::const_iterator it=m.begin(); it!=m.end(); it++) {if(it!=m.begin())s+=delim+" "; s += toString(it-&gt;first) + "-&gt;" + toString(it-&gt;second);} return s+"}";}<br>int getNumWords(string s, string delim=" ") {int count=0; for(int i=0; i&lt;s.size(); i++) if ( (i==0 || delim.find(s[i-1])!=-1) &amp;&amp; delim.find(s[i]) == -1) count++; return count;}<br>string getWord(string s, int j, string delim=" ") {int count=0; string t; for(int i=0; i&lt;s.size(); i++) {if (delim.find(s[i])==-1) t += s[i]; else {if (i!=0 &amp;&amp; delim.find(s[i-1]) == -1) count++; if(count&gt;j) return t; t="";}} return t;}<br>string getDelimiter(string s, int j, string delim=" ") {int count=0; string t; for(int i=0; i&lt;s.size(); i++) {if (delim.find(s[i])!=-1) t += s[i]; else {if (i==0 || delim.find(s[i-1]) != -1) count++; if(count&gt;j) return t; t="";}} return t;}<br> <br>// Basic math<br> <br>bool isEqual(ld v1, ld v2) {return ABS(v1-v2)&lt;EPSILON;}<br>bool isLess(ld v1, ld v2) {return v1-v2&lt;-EPSILON;}<br>ll gcd(ll n1, ll n2) {return n2==0? ABS(n1) : gcd(n2,n1%n2);}<br>ll lcm(ll n1, ll n2) {return n1==0 &amp;&amp; n2==0? 0 : ABS(n1*n2)/gcd(n1,n2);}<br> <br>// Real code<br> <br>class MiniPaint <br>{<br>  public:<br>  <br>  vector&lt;string&gt; picture;<br>  map&lt;int,int&gt; picCost;<br>  map&lt;int,int&gt; lineCost;<br>  int maxx,maxy;<br>  <br>  int bestLineCost(int l, int x, int n)<br>  {<br>    int index = l * 60*60 + x*60 + n;<br>    if (lineCost.count(index)) return lineCost[index];<br>    if (n == 0) return x+1;<br>    if (x &lt;= 0) return 0;<br>    int wc = 0, bc = 0;<br>    <br>    int best = 1000;<br>    for (int x2 = x; x2 &gt;= 0; x2--)<br>    {<br>      if (picture[l][x2] == 'B') bc++; else wc++;<br>      best &lt;?= (bestLineCost(l, x2-1, n-1) + MIN(wc,bc));<br>    }<br>    lineCost[index] = best;<br>    return best;<br>  }<br>  <br>  int bestCost(int l, int n)<br>  {<br>    int index = l*10000+n;<br>    if (picCost.count(index)) return picCost[index];<br>    <br>    int best = 100*100;<br>    if (l &lt; 0) return 0;<br>    <br>    for (int n2 = n; n2 &gt;=n-50 &amp;&amp; n2&gt;=0; n2--)<br>    {<br>      int t1 = bestLineCost(l,maxx-1,n-n2);<br>      int t2 = bestCost(l-1,n2);<br>      best &lt;?= (t1+t2);<br>    }<br>    <br>    picCost[index] = best;<br>    return best;<br>  }<br>  <br>  int leastBad(vector &lt;string&gt; _picture, int maxStrokes) <br>  {<br>    picture = _picture;<br>    maxy = picture.size();<br>    maxx = picture[0].size();<br>    <br>    return bestCost(maxy-1, maxStrokes);<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>