<td class="problemText" colspan="8" valign="middle" align="left">
            //program framework generated with WishingBone's parser :)-<br> <br>//common header<br>#ifdef WIN32<br>#  pragma warning(disable:4786)<br>#  define for if (0); else for<br>#endif<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;deque&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cmath&gt;<br>using namespace std;<br> <br>//64 bit integer definition<br>#ifdef WIN32<br>#define in_routine(type,spec) \<br>istream&amp; operator&gt;&gt;(istream&amp; s,type &amp;d){char b[30];s&gt;&gt;b;sscanf(b,spec,&amp;d);return s;}<br>#define out_routine(type,spec) \<br>ostream&amp; operator&lt;&lt;(ostream&amp; s,type d){char b[30];sprintf(b,spec,d);s&lt;&lt;b;return s;}<br>typedef signed __int64 i64; in_routine(i64,"%I64d") out_routine(i64,"%I64d")<br>typedef unsigned __int64 u64; in_routine(u64,"%I64u") out_routine(u64,"%I64u")<br>#else<br>typedef signed long long i64;<br>typedef unsigned long long u64;<br>#endif<br> <br>//common routines<br>#ifdef WIN32<br>#define min(a,b) _cpp_min(a,b)<br>#define max(a,b) _cpp_max(a,b)<br>#endif<br>#define abs(a) ((a)&gt;0?(a):-(a))<br>#define s2d(s,d) {istringstream(s)&gt;&gt;d;}<br>#define d2s(d,s) {ostringstream t;t&lt;&lt;d;s=t.str();}<br>int gcd(int a,int b){for(int c;b;c=a,a=b,b=c%b);return a;}<br>int lcm(int a,int b){return a/gcd(a,b)*b;}<br> <br>//remove routine<br>template &lt;class T&gt;<br>void remove(vector&lt;T&gt;&amp; v,const T&amp;e){<br>  v.resize(remove(v.begin(),v.end(),e)-v.begin());<br>}<br>template &lt;class T&gt;<br>vector&lt;T&gt; remove_copy(vector&lt;T&gt;&amp; v,const T&amp;e){<br>  vector&lt;T&gt; result;<br>  remove_copy(v.begin(),v.end(),back_inserter(result),e);<br>  return result;<br>}<br> <br>//output routine<br>ostream&amp; operator&lt;&lt;(ostream&amp; s,string d){<br>  s&lt;&lt;'\"'&lt;&lt;d.c_str()&lt;&lt;'\"';<br>  return s;<br>}<br>template &lt;class T&gt;<br>ostream&amp; operator&lt;&lt;(ostream&amp; s,vector&lt;T&gt; d){<br>  s&lt;&lt;"{";<br>  for (typename vector&lt;T&gt;::iterator i=d.begin();i!=d.end();i++)<br>    s&lt;&lt;(i!=d.begin()?",":"")&lt;&lt;*i;<br>  s&lt;&lt;"}";<br>  return s;<br>}<br> <br>//parsing routine<br>template &lt;class T&gt;<br>vector&lt;basic_string&lt;T&gt; &gt; parse(const basic_string&lt;T&gt; &amp;s,const basic_string&lt;T&gt; &amp;delim){<br>  vector&lt;basic_string&lt;T&gt; &gt; ret(0);<br>  for (int b,e=0;;ret.push_back(s.substr(b,e-b)))<br>    if ((b=s.find_first_not_of(delim,e))==(e=s.find_first_of(delim,b)))<br>      return ret;<br>}<br>vector&lt;int&gt; intparse(const string &amp;s,const string &amp;delim=" \t\n"){<br>  vector&lt;string&gt; tmp=parse(s,delim);<br>  vector&lt;int&gt; ret(0);<br>  int t;<br>  for (vector&lt;string&gt;::iterator i=tmp.begin();i!=tmp.end();i++)<br>    sscanf(i-&gt;c_str(),"%d",&amp;t),ret.push_back(t);<br>  return ret;<br>}<br> <br>//name mapper<br>class mapper{<br>public:<br>  map&lt;string,int&gt; m;<br>  vector&lt;string&gt; v;<br>  void reset(){<br>    v.clear();<br>    m.clear();<br>  }<br>  int size(){<br>    return v.size();<br>  }<br>  int get(const string str){<br>    if (m.find(str)==m.end()){<br>      m[str]=v.size();<br>      v.push_back(str);<br>    }<br>    return m[str];<br>  }<br>  string get(int i){<br>    return v[i];<br>  }<br>  vector&lt;int&gt; get(const vector&lt;string&gt;&amp; strs){<br>    vector&lt;int&gt; ret;<br>    ret.reserve(strs.size()+2);<br>    for(int i=0;i&lt;strs.size();i++)<br>      ret.push_back(get(strs[i]));<br>    return ret;<br>  }<br>  vector&lt;string&gt; get(const vector&lt;int&gt;&amp; is){<br>    vector&lt;string&gt; ret;<br>    ret.reserve(is.size()+2);<br>    for(int i=0;i&lt;is.size();i++)<br>      ret.push_back(get(is[i]));<br>    return ret;<br>  }<br>};<br> <br>#define MAXN 100<br>#define eps 1e-8<br>#define zero(x) (((x)&gt;0?(x):-(x))&lt;eps)<br>struct point{<br>  double x,y;<br>  point(){}<br>  point(double x,double y):x(x),y(y){}<br>};<br> <br>double xmult(point p1,point p2,point p0){<br>  return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);<br>}<br> <br>int same_side(point p1,point p2,point l1,point l2){<br>  return xmult(l1,p1,l2)*xmult(l1,p2,l2)&gt;eps;<br>}<br> <br>point intersection(point u1,point u2,point v1,point v2){<br>  point ret=u1;<br>  double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))<br>      /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));<br>  ret.x+=(u2.x-u1.x)*t;<br>  ret.y+=(u2.y-u1.y)*t;<br>  return ret;<br>}<br> <br>//?????l1,l2????????side???,??l1,l2,side???<br>void polygon_cut(int&amp; n,point* p,point l1,point l2,point side){<br>  point pp[100];<br>  int m=0,i;<br>  for (i=0;i&lt;n;i++){<br>    if (same_side(p[i],side,l1,l2))<br>      pp[m++]=p[i];<br>    if (!same_side(p[i],p[(i+1)%n],l1,l2)&amp;&amp;!(zero(xmult(p[i],l1,l2))&amp;&amp;zero(xmult(p[(i+1)%n],l1,l2))))<br>      pp[m++]=intersection(p[i],p[(i+1)%n],l1,l2);<br>  }<br>  for (n=i=0;i&lt;m;i++)<br>    if (!i||!zero(pp[i].x-pp[i-1].x)||!zero(pp[i].y-pp[i-1].y))<br>      p[n++]=pp[i];<br>  if (zero(p[n-1].x-p[0].x)&amp;&amp;zero(p[n-1].y-p[0].y))<br>    n--;<br>  if (n&lt;3)<br>    n=0;<br>}<br> <br> <br>double area_polygon(int n,point* p){<br>  double s1=0,s2=0;<br>  int i;<br>  for (i=0;i&lt;n;i++)<br>    s1+=p[(i+1)%n].y*p[i].x,s2+=p[(i+1)%n].y*p[(i+2)%n].x;<br>  return fabs(s1-s2)/2;<br>}<br> <br>class Watchtower{<br>public:<br>  int n;<br>  point p[100], pp[100];<br>  pair&lt;double, int&gt; a[100];<br>  double calc(int target) {<br>    int m = 4;<br>    pp[0] = point(0, 0);<br>    pp[1] = point(0, 100);<br>    pp[2] = point(100, 100);<br>    pp[3] = point(100, 0);<br>    for (int i = 0; i &lt; n; ++i) if (i != target) {<br>      point mid;<br>      mid.x = (p[i].x + p[target].x) / 2;<br>      mid.y = (p[i].y + p[target].y) / 2;<br>      point to = mid;<br>      to.x += p[i].y - p[target].y;<br>      to.y += p[target].x - p[i].x;<br>      polygon_cut(m, pp, mid, to, p[target]);<br>    }<br>    return area_polygon(m, pp);<br>  }<br>  vector&lt;int&gt; orderByArea(vector&lt;int&gt; x,vector&lt;int&gt; y){<br>    n = x.size();<br>    for (int i = 0; i &lt; n; ++i) {<br>      p[i].x = x[i];<br>      p[i].y = y[i];<br>    }<br>    for (int i = 0; i &lt; n; ++i) {<br>      a[i] = make_pair(-calc(i), i);<br>    }<br>    sort(a, a + n);<br>    vector&lt;int&gt; ret;<br>    for (int i = 0; i &lt; n; ++i) ret.push_back(a[i].second);<br>    return ret;<br>  }<br>};<br></td>