<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Text;<br>using System.Drawing;<br>using System.Collections;<br> <br>public class SpamDetector {<br>    public int countKeywords(string subjectLine, string[] keywords) {<br>    string[] words = subjectLine.Split(' ');<br>    int res = 0;<br>    foreach (string w in words){<br>      if (match(w, keywords)) ++res;<br>    }<br>    return res;<br>  }<br>  <br>  public bool match(string w, string[] ws){<br>    foreach (string w2 in ws){<br>      if (match(w2, w)) return true;<br>    }<br>    return false;<br>  }<br>  <br>  public bool match(string a, string b){<br>    a = a.ToLower();<br>    b = b.ToLower();<br>    int i, j;<br>    for (i = 0, j = 0; i &lt; a.Length; ++i, ++j){<br>      if (j &gt;= b.Length) return false;<br>      if (a[i] != b[j]) return false;<br>      if (i &lt; a.Length - 1 &amp;&amp; a[i] == a[i+1]) continue;<br>      while (j &lt; b.Length - 1 &amp;&amp; b[j] == b[j+1]) ++j;<br>    }<br>    return j == b.Length;<br>  }<br> <br>    private int doit(){<br>        return -1;<br>    }<br> <br>    //  COMMON USEFUL STUFF<br>    // TimeSpan timeOut<br>    // int LCSSeqLength(string, string)<br>    // string LCSSeq(string, string)<br>    // int LCSStrLength(string, string)<br>    // string LCSStr(string, string)<br>    // void stableSort(IComparable[])  // bug in here somewhere.  will fix later.  workaround in place which is probably good enough for TC anyway<br>    // long gcd(long, long)<br>    // long gcd2(long, long, 1)<br>    // class Graph (int[,]) | (string[])<br>    // int Graph.ShortestPathLength(int, int)<br>    // int[] Graph.ShortestPath(int, int)<br>    // min, max, abs methods for int, long and double.  sqrt(double)<br>    // sum and average methods for int, long and double arrays.<br>    // long nCr(int n, int r) to calculate combinations<br>    // long mississippi(int[]) permutations of a collection containing identical elements (array is frequencies)<br>    // long factorial(int x) returns x!<br> <br>    private TimeSpan timeOut = new TimeSpan(0,0,0,7,500);<br> <br>    int max(int a, int b){<br>        return a &gt; b ? a : b;<br>    }<br>    long max(long a, long b){<br>        return a &gt; b ? a : b;<br>    }<br>    double max(double a, double b){<br>        return Math.Max(a,b);<br>    }<br>    int min(int a, int b){<br>        return a &lt; b ? a : b;<br>    }<br>    long min(long a, long b){<br>        return a &lt; b ? a : b;<br>    }<br>    double min(double a, double b){<br>        return Math.Min(a,b);<br>    }<br>    int abs(int a){<br>        return a &lt; 0 ? -a : a;<br>    }<br>    long abs(long a){<br>        return a &lt; 0 ? -a : a;<br>    }<br>    double abs(double a){<br>        return Math.Abs(a);<br>    }<br>    double sqrt(double a){<br>        return Math.Sqrt(a);<br>    }<br>    long sum(int[] arr){<br>        long res = 0;<br>        foreach (int i in arr) res += i;<br>        return res;<br>    }<br>    long sum(long[] arr){<br>        long res = 0;<br>        foreach (long l in arr) res += l;<br>        return res;<br>    }<br>    double sum(double[] arr){<br>        double res = 0.0;<br>        foreach (double d in arr) res += d;<br>        return res;<br>    }<br>    double average(int[] arr){<br>        return sum(arr) / (double)arr.Length;<br>    }<br>    double average(long[] arr){<br>        return sum(arr) / (double)arr.Length;<br>    }<br>    double average(double[] arr){<br>        return sum(arr) / arr.Length;<br>    }<br> <br>    long nCr(int n, int r){<br>        long res = 1;<br>        for (int i = 1; i &lt;= r; ++i){<br>            res *= n-i+1;<br>            res /= i;<br>        }<br>        return res;<br>    }<br> <br>    long mississippi(int[] arr){<br>        long res = factorial(sum(arr));<br>        foreach (int i in arr)<br>            if (i &gt; 1) res /= factorial(i);<br>        return res;<br>    }<br> <br>    long factorial(long x){<br>        long res = 1;<br>        for (int i = 2; i &lt;= x; ++i) res *= i;<br>        return res;<br>    }<br> <br>    // String Methods<br>    int LCSSeqLength(string x, string y)<br>    {<br>        int[,] b = new int[x.Length, y.Length];<br>        int[] cnow = new int[y.Length];<br>        int[] cprev = new int[y.Length];<br>        for (int i = 0; i &lt; x.Length; ++i)<br>        {<br>            for (int j = 0; j &lt; y.Length; ++j)<br>            {<br>                if (x[i] == y[j])<br>                {<br>                    if (j == 0) cnow[j] = 1;<br>                    else cnow[j] = cprev[j-1]+1;<br>                    b[i,j] = 3;<br>                }<br>                else if (cprev[j] &gt;= cnow[j-1])<br>                {<br>                    cnow[j] = cprev[j];<br>                    b[i,j] = 1;<br>                }<br>                else<br>                {<br>                    if (j == 0) cnow[j] = 0;<br>                    else cnow[j] = cnow[j-1];<br>                    b[i,j] = 2;<br>                }<br>            }<br>            cprev = cnow;<br>            cnow = new int[y.Length];<br>        }<br>        return c[x.Length,y.Length];<br>    }<br> <br>    string LCSSeq(string x, string y)<br>    {<br>        lcsseql(x,y);<br>        string s = lcsseq(x, x.Length-1,y.Length-1);<br>        b = c = null;<br>        return s;<br>    }<br> <br>    private int[,] b;<br>    private int[,] c;<br> <br>    private int lcsseql(string x, string y)<br>    {<br>        b = new int[x.Length, y.Length];<br>        c = new int[x.Length, y.Length];<br>        for (int i = 0; i &lt; x.Length; ++i)<br>        {<br>            for (int j = 0; j &lt; y.Length; ++j)<br>            {<br>                if (x[i] == y[j])<br>                {<br>                    if (i == 0 || j == 0) c[i,j] = 1;<br>                    else c[i,j] = c[i-1,j-1]+1;<br>                    b[i,j] = 3;<br>                }<br>                else if (c[i-1,j] &gt;= c[i,j-1])<br>                {<br>                    if (i == 0) c[i,j] = 0;<br>                    else c[i,j] = c[i-1,j];<br>                    b[i,j] = 1;<br>                }<br>                else<br>                {<br>                    if (j == 0) c[i,j] = 0;<br>                    else c[i,j] = c[i,j-1];<br>                    b[i,j] = 2;<br>                }<br>            }<br>        }<br>        return c[x.Length-1,y.Length-1];<br>    }<br> <br>    string lcsseq(string x, int i, int j)<br>    {<br>        if (i &lt; 0 || j &lt; 0) return "";<br>        if (b[i,j] == 3) return lcsseq(x, i-1, j-1) + x[i];<br>        if (b[i,j] == 1) return lcsseq(x, i-1, j);<br>        if (b[i,j] == 2) return lcsseq(x, i, j-1);<br>        return "";<br>    }<br> <br>    string LCSStr(string a, string b)<br>    {<br>        int m = a.Length, n = b.Length;<br>        int[,] dp = new int[m,n];<br>        int mi = 0, mj = 0;<br>        for (int i = 0; i &lt; m; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>                if (a[i] == b[j])<br>                {<br>                    if (i == 0 || j == 0) dp[i,j] = 1;<br>                    else dp[i,j] = dp[i-1,j-1] + 1;<br>                    if (dp[i,j] &gt; dp[mi,mj])<br>                    {<br>                        mi = i;<br>                        mj = j;<br>                    }<br>                }<br>                else dp[i,j] = 0;<br>        int l = dp[mi,mj];<br>        return a.Substring(m-l,l);<br>    }<br> <br>    int LCSStrLength(string a, string b)<br>    {<br>        return LCSStr(a,b).Length;<br>    }<br> <br>    // Array Sorting<br>    private int compare(IComparable a, IComparable b)<br>    {<br>        return a.CompareTo(b);<br>    }<br> <br>    private void swap(object[] arr, int a, int b)<br>    {<br>        object o = arr[a];<br>        arr[a] = arr[b];<br>        arr[b] = o;<br>    }<br>    private void swap(int[] arr, int a, int b)<br>    {<br>        arr[a] ^= arr[b];<br>        arr[b] ^= arr[a];<br>        arr[a] ^= arr[b];<br>    }<br> <br>    private void stableSort(IComparable[] arr)<br>    {<br>        stableSort(arr, 0, arr.Length - 1);<br>    }<br> <br>    private void stableSort(IComparable[] arr, int start, int end)<br>    {<br>        if (end - start &lt; 200)<br>        {<br>            insSort(arr, start, end);<br>        }<br>        else<br>        {<br>            int middle = (start + end - 1) / 2;<br>            stableSort(arr, start, middle);<br>            stableSort(arr, middle + 1, end);<br>            merge(arr, start, middle + 1, end);<br>        }<br>    }<br> <br>    private void insSort(IComparable[] arr, int start, int end)<br>    {<br>        int sentPos = start;<br>        IComparable sentVal = arr[start];<br>        for (int i = start + 1; i &lt; end + 1; ++i)<br>            if (compare(arr[i], sentVal) &lt; 0)<br>            {<br>                sentPos = i;<br>                sentVal = arr[i];<br>            }<br>        for (int i = sentPos; i &gt; 0; --i)<br>            arr[i] = arr[i - 1];<br>        arr[start] = sentVal;<br>        for (int i = start + 2; i &lt; end + 1; ++i)<br>        {<br>            int j = i;<br>            IComparable ic = arr[j];<br>            while (compare(arr[j - 1], ic) &gt; 0)<br>            {<br>                arr[j] = arr[j - 1];<br>                --j;<br>            }<br>            arr[j] = ic;<br>        }<br>    }<br> <br>    private void merge(IComparable[] arr, int start, int middle, int end)<br>    {<br>        IComparable[] temp = new IComparable[arr.Length];<br>        int index = start;<br>        int i = start, j = middle;<br>        while (i &lt; middle &amp;&amp; j &lt;= end)<br>            temp[index++] = compare(arr[i], arr[j]) &gt; 0 ? arr[j++] : arr[i++];<br>        while (i &lt; middle)<br>            temp[index++] = arr[i++];<br>        while (j &lt;= end)<br>            temp[index++] = arr[j++];<br>        Array.Copy(temp, start, arr, start, end - start + 1);<br>    }<br> <br>    // GCD<br>    private long gcd(long a, long b){<br>        long c = a % b;<br>        while (c != 0){<br>            a = b;<br>            b = c;<br>            c = a % b;<br>        }<br>        return b;<br>    }<br> <br>    private long gcd2(long a, long b, long prev){<br>        if (((a|b)&amp;1) == 0) return gcd2(a&gt;&gt;1,b&gt;&gt;1,prev&lt;&lt;1);<br>        return prev;<br>    }<br>}<br> <br>// Untested<br>public class Graph<br>{<br>    private int[,] weights;<br>    private int[,,] shortest;<br>    private int n;<br> <br>    public Graph(int[,] weights)<br>    {<br>        n = weights.GetLength(0);<br>        this.weights = weights;<br>        shortest = new int[n,n,2];<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            shortest[i,i,0] = 0;<br>            shortest[i,i,1] = i;<br>            weights[i,i] = 0;<br>        }<br>    }<br> <br>    public Graph(string[] graph)<br>    {<br>        n = graph.Length;<br>        weights = new int[n,n];<br>        shortest = new int[n,n,2];<br> <br>        for (int start = 0; start &lt; n; ++start)<br>        {<br>            string[] edges = graph[start].Split(' ');<br>            foreach (string edge in edges)<br>            {<br>                string[] nums = edge.Split('-');<br>                weights[start,int.Parse(nums[0])] = int.Parse(nums[1]);<br>            }<br>        }<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            shortest[i,i,0] = 0;<br>            shortest[i,i,1] = i;<br>            weights[i,i] = 0;<br>        }<br>    }<br> <br>    public int ShortestPathLength(int start, int end)<br>    {<br>        if (start == end)<br>        {<br>            return 0;<br>        }<br>        if (shortest[start,end,0] != 0)<br>        {<br>            calcShortest(start);<br>        }<br>        return shortest[start,end,0];<br>    }<br> <br>    public int[] ShortestPath(int start, int end)<br>    {<br>        if (start == end)<br>        {<br>            return new int[0];<br>        }<br>        if (shortest[start,end,0] != 0)<br>        {<br>            calcShortest(start);<br>        }<br>        ArrayList list = new ArrayList();<br>        int t = shortest[start,end,1];<br>        while (t != start)<br>        {<br>            list.Insert(0,t);<br>            t = shortest[start,t,1];<br>        }<br>        return (int[])list.ToArray(typeof(int));<br>    }<br> <br>    private void calcShortest(int start)<br>    {<br>        int minidx = 0;<br>        bool[] done = new bool[n];<br>        done[start] = true;<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            shortest[start,i,0] = weights[start,i];<br>            shortest[start,i,1] = start;<br>            if (weights[start,i] &lt; weights[start,minidx])<br>            {<br>                minidx = i;<br>            }<br>        }<br>        calcShortest(start, minidx, done);<br>    }<br> <br>    private void calcShortest(int start, int current, bool[] done)<br>    {<br>        int minidx = -1;<br>        done[current] = true;<br>        int t = shortest[start,current,0];<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            if (done[current])<br>            {<br>                continue;<br>            }<br>            if (t + weights[current,i] &lt; shortest[start,i,0])<br>            {<br>                shortest[start,i,0] = t + weights[current,i];<br>                shortest[start,i,1] = current;<br>            }<br>            if (minidx == -1 || shortest[start,i,0] &lt; shortest[start,minidx,0])<br>            {<br>                minidx = i;<br>            }<br>        }<br>        if (minidx != -1)<br>        {<br>            calcShortest(start,minidx,done);<br>        }<br>    }<br>}<br> <br>// Powered by PopsEdit<br></td>