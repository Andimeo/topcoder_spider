<td class="problemText" colspan="8" valign="middle" align="left">
            using System.Collections;<br> <br>  public class Range {<br>    ArrayList vs=new ArrayList();<br>    <br>    public Range (string s) {<br>      string[] ss=s.Split(new char[] {' '});<br>      foreach (string t in ss) {<br>        string[] ts=t.Split('-');<br>        if (ts.Length==1) {<br>          vs.Add(int.Parse(ts[0]));<br>          vs.Add(int.Parse(ts[0]));<br>        } else {<br>          vs.Add(int.Parse(ts[0]));<br>          vs.Add(int.Parse(ts[1]));<br>        }<br>        RangeGame.ns.Add(int.Parse(ts[0]));<br>      }<br>    }<br>    <br>    public bool Includes(int n) {<br>      for (int i=0; i&lt;vs.Count; i+=2) {<br>        if ((n&gt;=(int)vs[i])&amp;&amp;(n&lt;=(int)vs[i+1]))<br>          return true;<br>      }<br>      return false;<br>    }<br>    <br>    public bool OverLap(Range r) {<br>      int i=0;<br>      int j=0;<br>      while ((i&lt;vs.Count)&amp;&amp;(j&lt;r.vs.Count)) {<br>        int a1=(int)vs[i];<br>        int a2=(int)vs[i+1];<br>        int b1=(int)r.vs[j];<br>        int b2=(int)r.vs[j+1];<br>        if (a1&lt;=b1) {<br>          if (a2&gt;=b1) return true;<br>          i+=2;<br>        } else {<br>          if (b2&gt;=a1) return true;<br>          j+=2;<br>        }<br>      }<br>      return false;<br>    }<br>    <br>    <br>  }<br>  <br>  public class RangeGame {<br>    public static ArrayList ns=new ArrayList();<br>    <br>    <br>    public int[] bestDoors(string[] possible, string[] hints){<br>      int hc=hints.Length;<br>      int pc=possible.Length;<br>      Range[] ps=new Range[pc];<br>      Range[] hs=new Range[hc];<br>      for (int i=0; i&lt;pc; i++) ps[i]=new Range(possible[i]);<br>      for (int i=0; i&lt;hc; i++) hs[i]=new Range(hints[i]);<br>      ns.Sort();<br>      int[] result=new int[hc+1];<br> <br>        int tbc=0;<br>        int tbest=0;<br>        foreach (int n in ns) {<br>          int c=0;<br>          for (int p=0; p&lt;pc; p++) {<br>            if (ps[p].Includes(n)) c++;<br>            <br>          }<br>          if (c&gt;tbc) {<br>            tbc=c;<br>            tbest=n;<br>            <br>          }<br>        }<br>        result[0]=tbest;<br> <br>      bool[] killed=new bool[pc];<br>      for (int i=0; i&lt;hc; i++) {<br>        for (int p=0; p&lt;pc; p++) if (!killed[p]) {<br>            if (hs[i].OverLap(ps[p])) killed[p]=true;<br>          <br>        }<br>        <br>        int bc=-1;<br>        int best=-1;<br>        foreach (int n in ns) {<br>          int c=0;<br>          for (int p=0; p&lt;pc; p++) {<br>            if ((!killed[p])&amp;&amp;ps[p].Includes(n)) c++;<br>            <br>          }<br>          if (c&gt;bc) {<br>            bc=c;<br>            best=n;<br>            <br>          }<br>        }<br>        result[i+1]=best;<br>      }<br>      return result;<br>    }<br>  }<br></td>