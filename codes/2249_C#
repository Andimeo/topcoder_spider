<td class="problemText" colspan="8" valign="middle" align="left">
            using System; using System.Collections; using System.Text; public class Matching {<br>public string[] findMatch(string[] first, string[] second)<br>{<br>string[] res = new String[4];<br>res[0] = F(first[0], second[0], "CIRCLE", "SQUIGGLE", "DIAMOND");<br>res[1] = F(first[1], second[1], "RED", "BLUE", "GREEN");<br>res[2] = F(first[2], second[2], "SOLID", "STRIPED", "EMPTY");<br>res[3] = F(first[3], second[3], "ONE", "TWO", "THREE");<br>return res;<br>}<br> <br>String F(String a, String b, params String[] ar)<br>{<br>if (a==b) return a;<br>foreach (string s in ar) if (s != a &amp;&amp; s != b) return s;<br>return "?";<br>}<br> <br> <br> <br> <br>static int BC(int x) { int tot = 0; while (x &gt; 0) { tot += (x&amp;1); x &gt;&gt;= 1; } return tot; }<br>static long[,] ch = new long[51,51];<br>Object foo = new Initer();<br>class Initer { public Initer() {<br>for (int i=0; i&lt;=50; i++) ch[i,0] = 1;<br> for (int i=1; i&lt;=50; i++)<br>  for (int j=1; j&lt;=i; j++)<br>   ch[i,j] = ch[i-1,j-1] + ch[i-1,j];<br>}}<br> <br>static bool NextPerm(int[] a)<br>{<br>int N = a.Length;<br>for (int i=N-2; i&gt;=0; i--)<br> if (a[i] &lt; a[i+1])<br>  {<br>  Array.Reverse(a, i+1, N-i-1);<br>  for (int j=i+1; j&lt;N; j++)<br>   if (a[i] &lt; a[j])<br>    { int t = a[i]; a[i] = a[j]; a[j] = t; return true; }<br>  }<br>return false;<br>}<br> <br>static int Compare(IEnumerable a, IEnumerable b)<br>{<br>IEnumerator aa = a.GetEnumerator();<br>IEnumerator bb = b.GetEnumerator();<br>while (true)<br> {<br> if (aa.MoveNext())<br>  if (bb.MoveNext())<br>   {<br>   int temp = ((IComparable)aa.Current).CompareTo((IComparable)bb.Current);<br>   if (temp != 0) return temp;<br>   }<br>  else<br>   return 1; // a is longer, hence "larger"<br> else<br>  if (bb.MoveNext())<br>   return -1; // a is shorter, hence "smaller"<br>  else<br>   break;<br> }<br> <br>return 0;<br>}<br> <br>static ArrayList AR { get { return new ArrayList(); }}<br>static Hashtable MAP { get { return new Hashtable(); }}<br> <br>static int   [] IA(ArrayList ar) { return (int   []) ar.ToArray(typeof(int   )); }<br>static string[] SA(ArrayList ar) { return (string[]) ar.ToArray(typeof(string)); }<br> <br>int    INT   (Object x) { return Convert.ToInt32 (x.ToString()); }<br>long   LONG  (Object x) { return Convert.ToInt64 (x.ToString()); }<br>double DOUBLE(Object x) { return Convert.ToDouble(x.ToString()); }<br> <br>int         MinI(IEnumerable a) { int    m = int.MaxValue;    foreach (int         x in a) m = Math.Min(m, x); return m; }<br>long        MinL(IEnumerable a) { long   m = long.MaxValue;   foreach (long        x in a) m = Math.Min(m, x); return m; }<br>double      MinD(IEnumerable a) { double m = double.MaxValue; foreach (double      x in a) m = Math.Min(m, x); return m; }<br>string      MinS(IEnumerable a) { string m = null;            foreach (string      x in a) m = (m == null || m.CompareTo(x)&gt;0) ? x : m; return m; }<br>IEnumerable MinC(IEnumerable a) { IEnumerable m = null;       foreach (IEnumerable x in a) m = (m == null || Compare(m,x)&gt;0)   ? x : m; return m; }<br> <br>int         MaxI(IEnumerable a) { int    m = int.MinValue;    foreach (int         x in a) m = Math.Max(m, x); return m; }<br>long        MaxL(IEnumerable a) { long   m = long.MinValue;   foreach (long        x in a) m = Math.Max(m, x); return m; }<br>double      MaxD(IEnumerable a) { double m = double.MinValue; foreach (double      x in a) m = Math.Max(m, x); return m; }<br>string      MaxS(IEnumerable a) { string m = null;            foreach (string      x in a) m = (m == null || m.CompareTo(x)&lt;0) ? x : m; return m; }<br>IEnumerable MaxC(IEnumerable a) { IEnumerable m = null;       foreach (IEnumerable x in a) m = (m == null || Compare(m,x)&lt;0)   ? x : m; return m; }<br> <br>int    SumI(IEnumerable a) { int    m = 0;  foreach (int    x in a) m += x; return m; }<br>long   SumL(IEnumerable a) { long   m = 0;  foreach (long   x in a) m += x; return m; }<br>double SumD(IEnumerable a) { double m = 0;  foreach (double x in a) m += x; return m; }<br>string SumS(IEnumerable a) { string m = ""; foreach (string x in a) m += x; return m; }<br> <br>void Add1(Hashtable map, Object x) { Object ct = map[x]; map[x] = 1 + (ct==null ? 0 : (int)ct); }<br>void Add(Hashtable map, Object x, int y) { Object ct = map[x]; map[x] = y + (ct==null ? 0 : (int)ct); }<br> <br>char[,] ToCharArray(String[] ss)<br>{<br>if (ss.Length == 0) return new char[0,0];<br>int X = ss[0].Length;<br>int Y = ss.Length;<br>char[,] a = new char[X,Y];<br>for (int x=0; x&lt;X; x++)<br> for (int y=0; y&lt;Y; y++)<br>  a[x,y] = ss[y][x];<br>return a;<br>}<br> <br>// Flood expects from sx,sy with fill; return # of squares flooded; those<br>// squares will be in xs and ys.<br>int Flood(char[,] ar, int sx, int sy, char expect, char fill, int[] xs, int[] ys)<br>{<br>int X = ar.GetLength(0), Y = ar.GetLength(1), todo=0;<br>xs[todo]=sx; ys[todo]=sy; ar[sx,sy]=fill; todo++;<br>for (int done=0; done &lt; todo; done++)<br> {<br> int dx=1, dy=0;<br> for (int dir=0; dir&lt;4; dir++)<br>  {<br>  int x2=xs[done]+dx; int y2=ys[done]+dy;<br>  if (x2&gt;=0 &amp;&amp; x2&lt;X &amp;&amp; y2&gt;=0 &amp;&amp; y2&lt;Y)<br>   if (ar[x2,y2] == expect)<br>   { xs[todo]=x2; ys[todo]=y2; ar[x2,y2]=fill; todo++; }<br>  int t=dx; dx=dy; dy=-t;<br>  }<br> }<br> <br>return todo;<br>}<br> <br>static void WR(Object x, params object[] p) { Console.Write(x.ToString(), p); }<br>static void WL(Object x, params object[] p) { Console.WriteLine(x.ToString(), p); }<br>static void WL() { WL(""); }<br>static void WS(params Object[] c) { foreach (Object x in c) WR(x.ToString() + " "); }<br>static void WS(Array ar, int X) { for (int x=0; x&lt;X; x++) WS(ar.GetValue(x)); WL(); }<br>static void WS(Array ar, int X, int Y) { for (int y=0; y&lt;Y; y++) { for (int x=0; x&lt;X; x++) WS(ar.GetValue(x,y)); WL(); }}<br>void MATCH(String lbl, Object x, Object y)<br> { if (!x.Equals(y)) throw new Exception(lbl + String.Format(" expected [{0}], got [{1}]", x, y)); }<br>void MATCH(ICollection x, ICollection y) {<br> MATCH("count", x.Count, y.Count);<br> int i=0; ArrayList ay = new ArrayList(y);<br> foreach (Object ox in x) { MATCH(i.ToString(), ox, ay[i]); i++; }<br>}}<br></td>