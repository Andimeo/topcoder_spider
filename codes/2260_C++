<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;stdio.h&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;string.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;string&gt;<br>#include &lt;math.h&gt;<br> <br>using namespace std;<br> <br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt;VI&gt; VII;<br> <br>#define DFLOAT 1E-6<br> <br>struct TPoint<br>{<br>    double x, y;<br>};<br> <br>struct TPoly {<br>    int N;<br>TPoint * points;<br>  void NewPoly(int n) { points = new TPoint[n];N=n; }<br>  ~TPoly() { delete[] points; }<br>};<br> <br>int GetCenter(TPoint * targ, TPoint a, TPoint b, TPoint c)<br>{ double A = b.x-a.x, B = b.y-a.y, C = c.x-a.x, D = c.y-a.y;<br>double E = A*(a.x + b.x) + B*(a.y+b.y);<br>  double F = C*(a.x + c.x) + D*(a.y+c.y); <br>  double G = 2*(A*(c.y - b.y) - B*(c.x - b.x));<br>  if(G == 0)<br>    return 0;<br>  targ-&gt;x = (D*E - B*F) / G;<br>  targ-&gt;y = (A*F - C*E) / G;<br>  return 1;<br>}<br> <br>void computePermutation(int * array, int N)<br>{<br>  int t, index;<br>  for(int i=0;i&lt;N;i++)<br>    array[i] = i;<br>  for(int i=N-1;i&gt;0;i--)<br>  {<br>    index = random() % (i+1);<br>    t = array[index];<br>    array[index] = array[i];<br>    array[i] = t;<br>  }<br>}<br> <br>int puntInCirkel(TPoint p, TPoint center, double size)<br>{<br>    return hypot(p.x - center.x, p.y - center.y) - size &lt; DFLOAT;<br>}<br>double randomizedCircle(TPoly * p, TPoint * center)<br>{<br>  int N = p-&gt;N;<br> <br>  int * order = new int[N];<br>  computePermutation(order, N);<br> <br>  double circlesize = 0;<br>  center-&gt;x = 0; center-&gt;y = 0;<br> <br>  TPoint points[3];<br> <br>  for(int i=0;i&lt;N;i++)<br>  {<br>    if(!puntInCirkel(p-&gt;points[ order[i] ], *center, circlesize))<br>    {<br>      // bereken cirkel opnieuw, met dit punt op de border<br>      points[0] = p-&gt;points[ order[i] ];<br>      *center = points[0];circlesize = 0;<br> <br>      for(int j=0;j&lt;i;j++)<br>        if(!puntInCirkel(p-&gt;points[ order[j] ], *center, circlesize))<br>        {<br>          // bereken cirkel opnieuw, met dit punt ook op de border.<br>          points[1] = p-&gt;points[ order[j] ];<br>          center-&gt;x = (points[0].x + points[1].x) / 2;<br>          center-&gt;y = (points[0].y + points[1].y) / 2;<br>          circlesize = hypot(points[0].x-points[1].x, points[0].y-points[1].y) / 2;<br> <br>          for(int k=0;k&lt;j;k++)<br>            if(!puntInCirkel(p-&gt;points[ order[k] ], *center, circlesize))<br>            {<br>              GetCenter(center, points[0], points[1], p-&gt;points[ order[k] ]);<br>              circlesize = hypot(points[0].x - center-&gt;x, points[0].y-center-&gt;y);<br>            }<br>        }<br>    }<br>  }<br> <br>  delete[] order;<br>  return circlesize;<br>}<br> <br>class TVTower {<br> <br>  public:<br>  double minRadius(vector &lt;int&gt; x, vector &lt;int&gt; y) {<br> <br>      TPoly p;<br>      TPoint dummy;<br>      p.NewPoly(x.size());<br>      for(int i =0;i&lt;x.size();i++)<br>      {<br>    p.points[i].x = x[i];<br>    p.points[i].y = y[i];<br>      }<br>      return randomizedCircle(&amp;p, &amp;dummy);<br>  }<br>};<br> <br> <br>// Powered by FileEdit<br></td>