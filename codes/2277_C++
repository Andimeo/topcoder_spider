<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;iostream&gt;<br>using namespace std;<br> <br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt;unsigned&gt; VU;<br>typedef long long LL;<br>typedef unsigned UI;<br>typedef unsigned long long UL;<br>#define FU(var, lo, hi)  for (unsigned var = (lo); var &lt; (hi); ++var)<br>#define FI(var, lo, hi)  for (int var = (lo); var &lt; (hi); ++var)<br>int mdays[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};<br>int primes100[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,<br>       59, 61, 67, 71, 73, 79, 83, 89, 97};<br>long long pow2[] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096,<br>        8192, 16384, 32768, 65536};<br>vector&lt;string&gt; split(string food, string separators=" \t") {<br>  bool active = false;  int begin = -1;  vector&lt;string&gt; ret;<br>  for (size_t i = 0; i &lt; food.size(); ++i)<br>    if (active) {<br>      if (strchr(separators.c_str(), food[i]) != NULL)<br>  { ret.push_back(food.substr(begin, i-begin));  active = false; }<br>    }<br>    else if (strchr(separators.c_str(), food[i]) == NULL)<br>      { begin = i;  active = true; }<br>  if (active)  ret.push_back(food.substr(begin));<br>  return ret;<br>}<br>string toString(int d) { char ret[30];  sprintf(ret, "%d", d);  return ret; }<br>int toInt(string str) { int ret;  sscanf(str.c_str(), "%d", &amp;ret);  return ret; }<br>long double toLD(string str) { long double ret;  sscanf(str.c_str(), "%Lf", &amp;ret);  return ret; }<br>bool strin(string s, char c) { return s.find(c) != s.npos; }<br>string substr(string s, size_t n) { return (n &gt;= s.size())?"":s.substr(n); }<br> <br> <br>class Rec {<br>public:<br>  string s;<br>  bool nonzero;<br>  bool operator&lt;(const class Rec &amp;b) const {<br>    if (s &lt; b.s) return true;<br>    if (s &gt; b.s) return false;<br>    return nonzero &lt; b.nonzero;<br>  }<br>};<br> <br>class Data {<br>public:<br>  int cost;<br>  string ans;<br> <br>  bool operator&lt;(const class Data &amp;b) const {<br>    if (cost &lt; b.cost)  return true;<br>    if (cost &gt; b.cost)  return false;<br>    if (ans.size() &gt; b.ans.size())  return true;<br>    if (ans.size() &lt; b.ans.size())  return false;<br>    return ans &lt; b.ans;<br>  }<br>};<br> <br> <br>class Ambigram {<br>public:<br>  map&lt;Rec, Data&gt; memo;<br>  string m1, m2;<br>  string unchg;<br> <br>  int kill(char c) {<br>    return min(c - 'A' + 1, 'Z' - c + 1);<br>  }<br>  <br> <br>  Data solve(string in, bool nonzero) {<br>    Rec rin;<br>    rin.s = in;  rin.nonzero = nonzero;<br>    if (memo.count(rin) &gt; 0)<br>      return memo[rin];<br> <br>    Data result, comp;<br> <br>    if (in.size() == 0) {<br>      result.cost = nonzero?1000000000:0;<br>      result.ans = in;<br>      memo[rin] = result;<br>      return result;<br>    }<br>    if (in.size() == 1) {<br>      int lowcost = 100000;<br>      int idx = -1;<br>      string a;<br>      FU (k, 0, unchg.size()) {<br>  int now = abs(in[0] - unchg[k]);<br>  if (now &lt; lowcost) {<br>    lowcost = now;<br>    idx = k;<br>    a = unchg[idx];<br>  }<br>      }<br>      if (!nonzero) {<br>  if (kill(in[0]) &lt; lowcost) {<br>    lowcost = kill(in[0]);<br>    a = "";<br>  }<br>      }<br>      result.cost = lowcost;<br>      result.ans = a;<br>      memo[rin] = result;<br>      return result;<br>    }<br> <br>    char f = in[0];<br>    char l = in[in.size()-1];<br>    <br>    // find cost of removing front<br>    Data dt = solve(in.substr(1), true);<br>    result.cost = kill(f) + dt.cost;<br>    result.ans = dt.ans;<br>    // find cost of removing end<br>    dt = solve(in.substr(0, in.size()-1), true);<br>    dt.cost += kill(l);<br>    if (dt &lt; result)<br>      result = dt;<br>    // find cost of removing both f/e<br>    <br>    // find cost of matching f/l<br>    dt = solve(in.substr(1, in.size()-2), false);<br>    int lowest = 1000;<br>    int idx = -1;<br>    // make equal<br>    FU (k, 0, m1.size()) {<br>      int now = abs(f - m1[k]) + abs(l - m2[k]);<br>      if (now &lt; lowest) {<br>  idx = k;<br>  lowest = now;<br>      }<br>    }<br>    dt.cost += lowest;<br>    dt.ans = m1[idx] + dt.ans + m2[idx];<br>    if (dt &lt; result)<br>      result = dt;<br> <br>    memo[rin] = result;<br>    return result;<br>  }<br>  <br>  string ambiword(string word) {<br>    // start here<br>    m1 = "HIMNOSWXZ";<br>    m2 = "HIWNOSMXZ";<br>    unchg = "HINOSXZ";<br>    return solve(word, true).ans;<br>  }<br>};<br> <br> <br>// #include "cppio.h"<br>// #include &lt;sys/time.h&gt;<br>// #include &lt;unistd.h&gt;<br> <br>// int main(void) {<br>//   struct timeval tv1, tv2;<br>//   struct timezone tz;<br>//   CppInput i("Ambigram.in", "ss");<br>  <br>//   while (i.read()) {<br>//     cout &lt;&lt; "CPPIO: inputs:" &lt;&lt; endl;<br>//     cout &lt;&lt; "       " + o.print(i.strings[0]) &lt;&lt; endl;<br>//     cout &lt;&lt; "CPPIO: complete." &lt;&lt; endl;<br>//     Ambigram x;<br>//     gettimeofday(&amp;tv1, &amp;tz);<br>//     string ret = x.ambiword(i.strings[0]);<br>//     gettimeofday(&amp;tv2, &amp;tz);<br>    <br>//     cout &lt;&lt; "ans: " &lt;&lt; o.print(i.strings[1]) &lt;&lt; endl;<br>//     cout &lt;&lt; "ret: " &lt;&lt; o.print(ret) &lt;&lt; endl;<br>//     cout &lt;&lt; "execution time: " &lt;&lt; tv2.tv_sec - tv1.tv_sec + 1e-6*(tv2.tv_usec - tv1.tv_usec) &lt;&lt; " sec." &lt;&lt; endl;<br>    <br>//     if (i.gotOutputCheck)<br>//       if (i.strings[1] == ret)<br>//         cout &lt;&lt; "answer checks OK!" &lt;&lt; endl;<br>//       else {<br>//         cout &lt;&lt; "answer INCORRECT INCORRECT INCORRECT INCORRECT INCORRECT INCORRECT INCORRECT!" &lt;&lt; endl;<br>//        for (int k = 0; k &lt; 5; ++k)  { cout &lt;&lt; '\a';  cout.flush();  usleep(200000); }<br>//       }<br>//     cout &lt;&lt; "=================================================" &lt;&lt; endl;<br>//   }<br>//   return 0;<br>// }<br> <br> <br>// Powered by FileEdit<br></td>