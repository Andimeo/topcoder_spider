<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;stdio.h&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;string.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;string&gt;<br>#include &lt;math.h&gt;<br> <br>using namespace std;<br> <br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt;VI&gt; VII;<br> <br> <br>vector&lt;string&gt; split(string s1, string s2)<br>{<br>  vector&lt;string&gt; result;<br>  int lastInd = -1;<br>  for(int i=0;i&lt;=s1.length();i++)<br>    {<br>      bool isSplitter = false;<br>      if(i == s1.length())<br>  isSplitter = true;<br>      else<br>  for(int j=0;j&lt;s2.length();j++)<br>    if(s1[i] == s2[j])<br>      isSplitter = true;<br> <br>      if(isSplitter)<br>  {<br>    if(lastInd != i-1)<br>      {<br>        result.push_back(s1.substr(lastInd + 1, i - lastInd - 1));<br>      }<br> <br>      lastInd = i;<br>  }<br>    }<br>  return result;<br>      }<br> <br>class RandomFA {<br> <br>  public:<br>  double getProbability(vector &lt;string&gt; rulesa, vector &lt;string&gt; rulesb, vector &lt;string&gt; rulesc, int finalState, int maxLength) {<br> <br>      int N = rulesa.size();<br> <br>      double prob[51];<br>      double endprob[51];<br>      endprob[0] = prob[0] = 1;<br>      for(int i=1;i&lt;=N;i++)<br>endprob[i] =     prob[i] = 0;<br> <br>      double oldprob[51];<br> <br>      for(int n=0;n&lt;maxLength;n++)<br>      {<br>    memcpy(oldprob, prob, sizeof(prob));<br> <br>    memset(prob, 0, sizeof(prob));<br> <br>    for(int olds=0;olds&lt;N;olds++)<br>    {<br>        int totprob;<br>        VS rl;<br>        <br>        rl = split(rulesa[olds], " ");<br>        totprob=0;<br>        for(int j=0;j&lt;rl.size();j++)<br>        {<br>      int st, pro;<br>      sscanf(rl[j].c_str(), "%d:%d", &amp;st, &amp;pro);<br>      totprob += pro;<br>      prob[st] += pro / 300.0 * oldprob[olds];<br>        }<br>        prob[N] += (100-totprob) / 300.0 * oldprob[olds];<br> <br>        rl = split(rulesb[olds], " ");<br>        totprob=0;<br>        for(int j=0;j&lt;rl.size();j++)<br>        {<br>      int st, pro;<br>      sscanf(rl[j].c_str(), "%d:%d", &amp;st, &amp;pro);<br>      totprob += pro;<br>      prob[st] += pro / 300.0 * oldprob[olds];<br>        }<br>        prob[N] += (100-totprob) / 300.0 * oldprob[olds];<br> <br>        rl = split(rulesc[olds], " ");<br>        totprob=0;<br>        for(int j=0;j&lt;rl.size();j++)<br>        {<br>      int st, pro;<br>      sscanf(rl[j].c_str(), "%d:%d", &amp;st, &amp;pro);<br>      totprob += pro;<br>      prob[st] += pro / 300.0 * oldprob[olds];<br>        }<br>        prob[N] += (100-totprob) / 300.0 * oldprob[olds];        <br>    }<br> <br>    prob[N] += oldprob[N];<br> <br>    for(int i=0;i&lt;=N;i++)<br>    {<br>        endprob[i] /= 3;<br>        endprob[i] += prob[i];<br>    }<br>      }<br> <br>      double sum = 0;<br>      for(int i=0;i&lt;=N;i++)<br>    sum += endprob[i];<br>      for(int i=0;i&lt;=N;i++)<br>    endprob[i] /= sum;<br> <br>      if(finalState == 999)<br>      return endprob[N];<br>      else<br>    return endprob[finalState];<br>  }<br>};<br> <br> <br>// Powered by FileEdit<br></td>