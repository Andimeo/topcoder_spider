<td class="problemText" colspan="8" valign="middle" align="left">
            /* imp &lt;cg-&gt; */ <br>/*&lt;-cg-&gt;*/import java.awt.*;<br>/*&lt;-cg-&gt;*/import java.util.*;<br>/*&lt;-cg-&gt;*/import java.math.*;<br>/*&lt;-cg-&gt;*/import java.util.regex.*;<br>/*&lt;-cg-&gt;*/  // &lt;-cg&gt;<br>public class ImageCompress {<br>    char[][] c;<br>    <br>    /* onehash H X String &lt;cg-&gt; */ HashMap hashH = new HashMap();<br>    /*&lt;-cg-&gt;*/final String getH(X key) {<br>      /*&lt;-cg-&gt;*/Object o = hashH.get(key);<br>      /*&lt;-cg-&gt;*/return o==null ? null : (String)(o); }<br>    /*&lt;-cg-&gt;*/final void putH(X key, String value) {<br>      /*&lt;-cg-&gt;*/hashH.put(key, value); }  // &lt;-cg&gt;<br> <br>    int rec=0;<br>    String mangle(int x0, int y0, int w,int h, int xs, int ys) {<br>  String s = getH(mX(x0,y0,w,h,xs,ys));<br>  if(s!=null) return s;<br>  rec++;<br>  s = m0(x0,y0,w,h,xs,ys);<br>  rec--;<br> <br>  putH(mX(x0,y0,w,h,xs,ys), s);<br>  return s;<br>    }<br>    String m0(int x0, int y0, int w,int h, int xs, int ys) {<br>  int ant=0;<br>  String poss[] = new String[7];<br>  char only = 0;<br>  for(int i = 0; i&lt;h; i++) {<br>      for(int j = 0; j&lt;w; j++) {<br>    char ch = c[y0 + i*ys][x0 + j*xs];<br>    if(only==0) only=ch;<br>    else if(only!=ch) only='u';<br>      }<br>  }<br>  if(only!='u') return ""+only;<br>  if(w&gt;=2) {<br>      int o = (w+1)/2;<br>      poss[ant++] = "L" + mangle(x0, y0, o, h, xs, ys)<br>    + mangle(x0 + xs*o, y0, w-o, h, xs, ys);<br>      poss[ant++] = "C" + mangle(x0, y0, o, h, xs*2, ys)<br>    + mangle(x0 + xs, y0, w-o, h, xs*2, ys);<br>  }<br>  if(h&gt;=2) {<br>      int o = (h+1)/2;<br>      poss[ant++] = "U" + mangle(x0,y0,w,o,xs,ys)<br>    + mangle(x0, y0+ys*o, w, h-o, xs, ys);<br>      poss[ant++] = "R" + mangle(x0, y0, w, o, xs, ys*2)<br>    + mangle(x0, y0+ys, w, h-o, xs, ys*2);<br>  }<br>  String best = poss[0];<br>  while(ant--&gt;1) {<br>      String s = poss[ant];<br>      if(s.length()&lt;best.length()) best=s;<br>      else if(s.length()==best.length() &amp;&amp; best.compareTo(s)&gt;0) best=s;<br>  }<br>  return best;<br>    }<br>  <br>    /* wrap X int.x0 int.y0 int.w int.h int.xs int.ys &lt;cg-&gt; */ // -- standard 'struct' class -- <br>    /*&lt;-cg-&gt;*/static final class X implements Comparable {int x0; int y0; int w; int h; int xs; int ys;<br>      /*&lt;-cg-&gt;*/public boolean equals(Object _o) { if(!(_o instanceof X)) return false;<br>        /*&lt;-cg-&gt;*/X _t = (X)_o; return x0==_t.x0 &amp;&amp; y0==_t.y0 &amp;&amp; w==_t.w &amp;&amp; h==_t.h &amp;&amp; xs==_t.xs &amp;&amp; ys==_t.ys; }<br>      /*&lt;-cg-&gt;*/public int compareTo(Object _o) { <br>        /*&lt;-cg-&gt;*/X _t = (X)_o; int _r; <br>        /*&lt;-cg-&gt;*/if(x0&lt;_t.x0) return -1; if(x0&gt;_t.x0) return 1;<br>        /*&lt;-cg-&gt;*/if(y0&lt;_t.y0) return -1; if(y0&gt;_t.y0) return 1;<br>        /*&lt;-cg-&gt;*/if(w&lt;_t.w) return -1; if(w&gt;_t.w) return 1;<br>        /*&lt;-cg-&gt;*/if(h&lt;_t.h) return -1; if(h&gt;_t.h) return 1;<br>        /*&lt;-cg-&gt;*/if(xs&lt;_t.xs) return -1; if(xs&gt;_t.xs) return 1;<br>        /*&lt;-cg-&gt;*/if(ys&lt;_t.ys) return -1; if(ys&gt;_t.ys) return 1;; return 0; }<br>      /*&lt;-cg-&gt;*/public int hashCode() { <br>        /*&lt;-cg-&gt;*/return x0 ^ (y0 &lt;&lt; 5) ^ (w &lt;&lt; 10) ^ (h &lt;&lt; 15) ^ (xs &lt;&lt; 20) ^ (ys &lt;&lt; 25); } }<br>    /*&lt;-cg-&gt;*/static final X mX(int _2, int _3, int _4, int _5, int _6, int _7) { X it = new X(); it.x0 = _2; it.y0 = _3; it.w = _4; it.h = _5; it.xs = _6; it.ys = _7; return it;}<br>    /*&lt;-cg-&gt;*/static final int x0X(Object o) { return ((X)o).x0; }<br>    /*&lt;-cg-&gt;*/static final int y0X(Object o) { return ((X)o).y0; }<br>    /*&lt;-cg-&gt;*/static final int wX(Object o) { return ((X)o).w; }<br>    /*&lt;-cg-&gt;*/static final int hX(Object o) { return ((X)o).h; }<br>    /*&lt;-cg-&gt;*/static final int xsX(Object o) { return ((X)o).xs; }<br>    /*&lt;-cg-&gt;*/static final int ysX(Object o) { return ((X)o).ys; }<br>    /*&lt;-cg-&gt;*/static final int x0X(X o) { return o.x0; }<br>    /*&lt;-cg-&gt;*/static final int y0X(X o) { return o.y0; }<br>    /*&lt;-cg-&gt;*/static final int wX(X o) { return o.w; }<br>    /*&lt;-cg-&gt;*/static final int hX(X o) { return o.h; }<br>    /*&lt;-cg-&gt;*/static final int xsX(X o) { return o.xs; }<br>    /*&lt;-cg-&gt;*/static final int ysX(X o) { return o.ys; }  // &lt;-cg&gt;<br> <br>public String compress(String[] image) {<br>    c = str2c(image);<br>    int ys=c.length;<br>    int xs=c[0].length;<br>    return mangle(0, 0, xs, ys, 1, 1);<br>}<br>/* std &lt;cg-&gt; */ <br>    /*&lt;-cg-&gt;*/static char[] str2c(String s) { return s.toCharArray(); }<br>    /*&lt;-cg-&gt;*/static String c2str(char[] c) { return new String(c); }<br>    /*&lt;-cg-&gt;*/static char[][] str2c(String[] s) { <br>  /*&lt;-cg-&gt;*/char a[][] = new char[s.length][];<br>  /*&lt;-cg-&gt;*/for(int i=a.length;i--&gt;0;) a[i] = s[i].toCharArray();<br>  /*&lt;-cg-&gt;*/return a;<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/static String[] c2str(char[][] s) {<br>  /*&lt;-cg-&gt;*/String a[] = new String[s.length];<br>  /*&lt;-cg-&gt;*/for(int i=a.length;i--&gt;0;) a[i] = c2str(s[i]);<br>  /*&lt;-cg-&gt;*/return a;<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/static int s2i(String s) { try { return Integer.parseInt(s); } catch(Exception e) { return -1; } }<br>    /*&lt;-cg-&gt;*/static int[] s2i(String[] s) { <br>  /*&lt;-cg-&gt;*/int[] n = new int[s.length]; <br>  /*&lt;-cg-&gt;*/for(int i=n.length;i--&gt;0;) n[i] = s2i(s[i]);<br>  /*&lt;-cg-&gt;*/return n;<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/static int[][] s2i(String[][] s) { <br>  /*&lt;-cg-&gt;*/int[][] n = new int[s.length][]; <br>  /*&lt;-cg-&gt;*/for(int i=n.length;i--&gt;0;) n[i] = s2i(s[i]);<br>  /*&lt;-cg-&gt;*/return n;<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/static long s2l(String s) { try { return Long.parseLong(s); } catch(Exception e) { return -1; } }<br>    /*&lt;-cg-&gt;*/static long[] s2l(String[] s) { <br>  /*&lt;-cg-&gt;*/long[] n = new long[s.length]; <br>  /*&lt;-cg-&gt;*/for(int i=n.length;i--&gt;0;) n[i] = s2l(s[i]);<br>  /*&lt;-cg-&gt;*/return n;<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/static long[][] s2l(String[][] s) { <br>  /*&lt;-cg-&gt;*/long[][] n = new long[s.length][]; <br>  /*&lt;-cg-&gt;*/for(int i=n.length;i--&gt;0;) n[i] = s2l(s[i]);<br>  /*&lt;-cg-&gt;*/return n;<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/static BigInteger big(long i) { return BigInteger.valueOf(i); }<br>    /*&lt;-cg-&gt;*/static int b2i(BigInteger b) { return b.intValue(); }<br>    /*&lt;-cg-&gt;*/static long b2l(BigInteger b) { return b.longValue(); }<br>    /*&lt;-cg-&gt;*/static Hashtable _rex = new Hashtable();<br>    /*&lt;-cg-&gt;*/static Pattern comp_(String s) {<br>  /*&lt;-cg-&gt;*/Object o; if(null==(o=_rex.get(s))) _rex.put(s,o=Pattern.compile(s)); <br>  /*&lt;-cg-&gt;*/return (Pattern)o; }<br>    /*&lt;-cg-&gt;*/static String match1(String s, String p) {<br>  /*&lt;-cg-&gt;*/Matcher m = comp_(p).matcher(s); if(!m.find()) return null;<br>  /*&lt;-cg-&gt;*/return m.group();<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/static String[] matchN(String s, String p) {<br>  /*&lt;-cg-&gt;*/ArrayList l=  new ArrayList();<br>  /*&lt;-cg-&gt;*/Matcher m = comp_(p).matcher(s); <br>  /*&lt;-cg-&gt;*/while(m.find()) l.add(m.group());<br>  /*&lt;-cg-&gt;*/return (String[])l.toArray(new String[0]);<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/static String[] groups(Matcher m) { <br>  /*&lt;-cg-&gt;*/String s[] = new String[m.groupCount()+1];<br>  /*&lt;-cg-&gt;*/for(int i=s.length;i--&gt;0;) s[i] = m.group(i);<br>  /*&lt;-cg-&gt;*/return s;<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/static String[] matchP(String s, String p) {<br>  /*&lt;-cg-&gt;*/Matcher m = comp_(p).matcher(s); if(!m.find()) return null;<br>  /*&lt;-cg-&gt;*/return groups(m);<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/static String[][] matchNP(String s, String p) {<br>  /*&lt;-cg-&gt;*/ArrayList l=  new ArrayList();<br>  /*&lt;-cg-&gt;*/Matcher m = comp_(p).matcher(s); <br>  /*&lt;-cg-&gt;*/while(m.find()) l.add(groups(m));<br>  /*&lt;-cg-&gt;*/return (String[][])l.toArray(new String[0][]);<br>    /*&lt;-cg-&gt;*/}<br>    /*&lt;-cg-&gt;*/  // &lt;-cg&gt;<br>}<br></td>