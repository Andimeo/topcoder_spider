<td class="problemText" colspan="8" valign="middle" align="left">
            /*/*///*/*/ Powered by radedit!            /*/*/*/*/*/ ;<br>/*/*//*/*/  import java . util .           /*/*/*/*/*/ ;<br>/*/*//*/*/  import java . lang . reflect . /*/*/*/*/*/ ;<br>public class RecursiveGraph {<br>   boolean ddd = false ;<br>String[] s2sa(String s) {<br>  StringTokenizer t=new StringTokenizer(s.trim());<br>  String[]r=new String[t.countTokens()];<br>  int i=0;<br>  while(t.hasMoreTokens())try{<br>     r[i++]=t.nextToken();<br>  }catch(Exception e){};<br>  return r;<br>}<br>  int INF = 1001001001 ;<br>  int nn(String s) {<br>    int t = s.charAt(0) - 'A' ;<br>    if (s.length() &gt; 1) {<br>      t = (s.charAt(1) - '0') * 10 + t ;<br>    }<br>    return t ;<br>  }<br>  public int shortestPath(String[] edges, char start, char end) {<br>    int i, j, k ;<br>    start -= 'A' ;<br>    end -= 'A' ;<br>    int[][] wt = new int[100][100] ;<br>    for (i=0; i&lt;100; i++) {<br>      for (j=0; j&lt;100; j++) {<br>  wt[i][j] = INF ;<br>      }<br>      wt[i][i] = 0 ;<br>    }<br>    for (i=0; i&lt;edges.length; i++) {<br>      String[] f = s2sa(edges[i]) ;<br>      int a = nn(f[0]) ;<br>      int b = nn(f[1]) ;<br>      int t = Integer.parseInt(f[2]) ;<br>      wt[a][b] = wt[b][a] = t ;<br>    }<br>    int[][] curw = new int[100][100] ;<br>    for (i=0; i&lt;100; i++) {<br>      for (j=0; j&lt;100; j++) {<br>  if (wt[i][j] == INF) {<br>    curw[i][j] = INF ;<br>  } else {<br>    curw[i][j] = 0 ;<br>  }<br>      }<br>    }<br>    for (int s=20; s&gt;=0; s--) {<br>      int[][] neww = new int[100][100] ;<br>      for (i=0; i&lt;100; i++) {<br>  for (j=0; j&lt;100; j++) {<br>    neww[i][j] = INF ;<br>  }<br>  neww[i][i] = 0 ;<br>      }<br>      for (i=0; i&lt;100; i++) {<br>  for (j=0; j&lt;100; j++) {<br>    if (i / 10 == j / 10 &amp;&amp; i &gt;= 10 &amp;&amp; j &gt;= 10) {<br>      neww[i][j] = curw[i%10][j%10] ;<br>    } else if (wt[i][j] == INF) {<br>      neww[i][j] = wt[i][j] ;<br>    } else {<br>      neww[i][j] = wt[i][j] &gt;&gt; s ;<br>    }<br>  }<br>      }<br>      for (k=0; k&lt;100; k++) {<br>  for (i=0; i&lt;100; i++) {<br>    for (j=0; j&lt;100; j++) {<br>      neww[i][j] = Math.min(neww[i][j], neww[i][k] + neww[k][j]) ;<br>    }<br>  }<br>      }<br>      curw = neww ;<br>    }<br>    if (curw[start][end] == INF) {<br>      return -1 ;<br>    }<br>    return curw[start][end] ;<br>  }<br> <br>  static void pp(Object o) { System.out.println(o) ; }<br>}<br></td>