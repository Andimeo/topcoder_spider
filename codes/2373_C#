<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br><br>public class EulerianRace {<br>  public int[] planRoute(string[] bridges) {<br>        char[][] b = new char[bridges.Length][];<br>        for(int i=0;i&lt;b.Length;i++) <br>            b[i] = bridges[i].ToCharArray();<br><br>        ArrayList path = new ArrayList();<br>        /* You begin by laying out a tentative route that begins and ends at checkpoint 0. <br>        */<br>        path.Add(0);<br><br>        /*<br>        At every step along the way, this initial route leaves the current checkpoint <br>        via the unused bridge that leads to the lowest numbered checkpoint. <br>        When the tentative route returns to checkpoint 0, <br>        it may or may not have used all the bridges. <br>        */<br>        int start = 0;<br>        bool done = false;<br>        while (!done)<br>        {<br>            int cur = (int)path[start];<br>            int finish = cur;<br>            do<br>            {<br>                for (int i = 0; i &lt; b.Length; i++)<br>                {<br>                    if (b[cur][i] == '1')<br>                    {<br>                        b[cur][i] = '0';<br>                        b[i][cur] = '0';<br>                        cur = i;<br>                        break;<br>                    }<br>                }<br><br>                start++;<br>                path.Insert(start, cur);<br>            } while (cur != finish);<br><br>            /*If it has, you are done. <br>        Otherwise, you need to extend the route to use more bridges as follows. <br>        Beginning at checkpoint 0, you follow the tentative route until you reach <br>        a checkpoint--call it checkpoint K--that has an unused bridge leading <br>        out from it. <br>        (Note that K could be 0.) <br>        */<br>            done = true;<br>            for (int i = 0; i &lt; path.Count &amp;&amp; done; i++)<br>                for (int ii = 0; ii &lt; b.Length &amp;&amp; done; ii++)<br>                {<br>                    if (b[(int)path[i]][ii] == '1')<br>                    {<br>                        done = false;<br>                        start = i;<br>                    }<br>                }<br>        }<br>        return (int[])path.ToArray(typeof(int));<br>  }<br>}<br><br><br>// Powered by FileEdit<br></td>