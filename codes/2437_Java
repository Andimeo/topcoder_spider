<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>public class IslandFerries {<br>    static class State implements Comparable {<br>  int island;<br>  int tickets;<br>  int cost;<br>  public State(int i,int t,int c) {<br>      island = i;<br>      tickets = t;<br>      cost = c;<br>  }<br> <br>  public int compareTo(Object o) {<br>      State that = (State)o;<br>      if (this.cost != that.cost) return this.cost-that.cost;<br>      if (this.island != that.island) return this.island-that.island;<br>      return this.tickets-that.tickets;<br>  }<br>    }<br> <br>    public static final int INF = 400000;<br>  public int[] costs(String[] legs, String[] prices) {<br>      int I = prices.length;<br>      int F = legs.length;<br>      boolean[][][] edge = new boolean[F][I][I];<br>      for (int i=0; i &lt; F; ++i) {<br>    StringTokenizer t = new StringTokenizer(legs[i],"- ");<br>    while (t.hasMoreTokens()) {<br>        int a = Integer.parseInt(t.nextToken());<br>        int b = Integer.parseInt(t.nextToken());<br>        edge[i][a][b] = true;<br>    }<br>      }<br>      int[][] prize = new int[F][I];<br>      for (int i=0; i &lt; I; ++i) {<br>    StringTokenizer t = new StringTokenizer(prices[i]);<br>    for (int f=0; f &lt; F; ++f) {<br>        prize[f][i] = Integer.parseInt(t.nextToken());<br>    }<br>      }<br>      int[][] cost = new int[I][1&lt;&lt;F];<br>      for (int i=0; i &lt; I; ++i) {<br>    Arrays.fill(cost[i],INF);<br>      }<br>      //cost[0][0] = 0;<br>      TreeSet q = new TreeSet();<br>      q.add(new State(0,0,0));<br>      while (!q.isEmpty()) {<br>    State s = (State)q.first();<br>    q.remove(s);<br>    if (cost[s.island][s.tickets] &lt;= s.cost) continue;<br>    cost[s.island][s.tickets] = s.cost;<br>    // buy ticket<br>    if (count(s.tickets) &lt; 3) {<br>        for (int f=0; f &lt; F; ++f) {<br>      if (cost[s.island][s.tickets|(1&lt;&lt;f)] &gt;= INF) {<br>          q.add(new State(s.island,s.tickets|(1&lt;&lt;f),<br>              s.cost+prize[f][s.island]));<br>      }<br>        }<br>    }<br>    // take ride<br>    for (int i=0; i &lt; I; ++i) {<br>        if (i == s.island) continue;<br>        for (int f=0; f &lt; F; ++f) {<br>      if ((s.tickets &amp; (1&lt;&lt;f)) != 0 &amp;&amp;<br>          edge[f][s.island][i]) {<br>          int tt = s.tickets-(1&lt;&lt;f);<br>          if (cost[i][tt] &gt; s.cost) {<br>        q.add(new State(i,tt,s.cost));<br>          }<br>      }<br>        }<br>    }<br>      }<br>      int[] result = new int[I-1];<br>      Arrays.fill(result,-1);<br>      for (int i=1; i &lt; I; ++i) {<br>    int best = INF;<br>    for (int t=0; t &lt; cost[i].length; ++t) {<br>        best = Math.min(best,cost[i][t]);<br>    }<br>    if (best &lt; INF) result[i-1] = best;<br>      }<br>      return result;<br>  }<br> <br>    public int count(int v) {<br>  int result = 0;<br>  while (v != 0) {<br>      result += v&amp;1;<br>      v &gt;&gt;= 1;<br>  }<br>  return result;<br>    }<br>         <br>  <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>