<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cctype&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br> <br>using namespace std;<br> <br>vector&lt; string &gt; tokenize( const string &amp;in, const string &amp;tok ) {<br>  const char *cs = in.c_str();<br>  vector&lt; string &gt; oot;<br>  while( *cs ) {<br>    while( count( tok.begin(), tok.end(), *cs ) ) cs++;<br>    const char *nd = cs;<br>    while( *nd &amp;&amp; !count( tok.begin(), tok.end(), *nd ) ) nd++;<br>    if( nd != cs ) oot.push_back( string( cs, nd ) );<br>    cs = nd;<br>  }<br>  return oot;<br>}<br> <br>vector&lt; int &gt; sti( const vector&lt; string &gt; &amp;in ) {<br>  vector&lt; int &gt; oot;<br>  for( int i = 0; i &lt; in.size(); i++ ) oot.push_back( atoi( in[ i ].c_str() ) );<br>  return oot;<br>}<br> <br>class zzz { } zz;<br> <br>zzz operator,( zzz a, zzz b ) {<br>  a = b;<br>  cout &lt;&lt; endl;<br>  return a;<br>}<br>zzz operator,( zzz a, int y ) {<br>  cout &lt;&lt; y &lt;&lt; " ";<br>  return a;<br>}<br>zzz operator,( zzz a, double y ) {<br>  cout &lt;&lt; y &lt;&lt; " ";<br>  return a;<br>}<br>zzz operator,( zzz a, const string &amp;y ) {<br>  cout &lt;&lt; "\"" &lt;&lt; y &lt;&lt; "\" ";<br>  return a;<br>}<br> <br>template&lt; typename T, typename U &gt;<br>zzz operator,( zzz a, const pair&lt; T, U &gt; &amp;y ) {<br>  cout &lt;&lt; "[ ";<br>  a,y.first;<br>  cout &lt;&lt; ", ";<br>  a,y.second;<br>  cout &lt;&lt; "] ";<br>  return a;<br>}<br>template&lt; typename T &gt;<br>zzz operator,( zzz a, const vector&lt; T &gt; &amp;y ) {<br>  cout &lt;&lt; "{ ";<br>  for( int i = 0; i &lt; y.size(); i++ ) {<br>    a,y[ i ];<br>    cout &lt;&lt; ", ";<br>  }<br>  cout &lt;&lt; "} ";<br>  return a;<br>}<br>/*<br>template&lt; typename T &gt;<br>zzz operator,( zzz a, const set&lt; T &gt; &amp;y ) {<br>  cout &lt;&lt; "{ ";<br>  for( set&lt; T &gt;::const_iterator itr = y.begin(); itr != y.end(); itr++ ) {<br>    a,*itr;<br>    cout &lt;&lt; ", ";<br>  }<br>  cout &lt;&lt; "} ";<br>  return a;<br>}<br>template&lt; typename T, typename U &gt;<br>zzz operator,( zzz a, const map&lt; T, U &gt; &amp;y ) {<br>  cout &lt;&lt; "{ ";<br>  for( map&lt; T, U &gt;::const_iterator itr = y.begin(); itr != y.end(); itr++ ) {<br>    a,*itr;<br>    cout &lt;&lt; ", ";<br>  }<br>  cout &lt;&lt; "} ";<br>  return a;<br>}<br>*/<br> <br>int ncr[ 50 ][ 50 ];<br>void mncr( int m ) {<br>  for( int i = 0; i &lt; m; i++ ) {<br>    ncr[ 0 ][ i ] = 0;<br>    ncr[ i ][ 0 ] = 1;<br>  }<br>  for( int y = 1; y &lt; m; y++ ) {<br>    for( int x = 1; x &lt; m; x++ ) {<br>      ncr[ y ][ x ] = ncr[ y - 1 ][ x ] + ncr[ y - 1 ][ x - 1 ];<br>    }<br>  }<br>}<br> <br>#define gcd __gcd // HA!<br>#define i64 long long<br> <br>struct clust {<br>  vector&lt; pair&lt; int, int &gt; &gt; pts;<br>  string str;<br>  int lop;<br>};<br> <br>int isquar( int x ) {<br>  return x*x;<br>}<br> <br>bool disp = false;<br> <br>long double glen( const clust &amp;lhs, const clust &amp;rhs ) {<br>  long double accum = 0.0;<br>  for( int i = 0; i &lt; lhs.pts.size(); i++ ) {<br>    for( int j = 0; j &lt; rhs.pts.size(); j++ ) {<br>      //if( disp )<br>//      printf( "        %d, %d is %lf\n", i, j, (double)sqrt( (long double)( isquar( lhs.pts[ i ].first - rhs.pts[ i ].first ) + <br>//        isquar( lhs.pts[ i ].second - rhs.pts[ i ].second ) ) ) );<br>      accum += sqrt( (long double)( isquar( lhs.pts[ i ].first - rhs.pts[ j ].first ) + <br>      isquar( lhs.pts[ i ].second - rhs.pts[ j ].second ) ) ); // idiot.<br>    }<br>  }<br>//        if( disp )<br>//  printf( "        div by %d\n", lhs.pts.size() * rhs.pts.size() );<br>  accum /= lhs.pts.size() * rhs.pts.size();<br>  return accum;<br>};<br> <br>class PointClustering {<br>  public:<br>  string cluster(vector &lt;int&gt; x, vector &lt;int&gt; y) {<br>    vector&lt; clust &gt; clusts;<br>    for( int i = 0; i &lt; x.size(); i++ ) {<br>      clust nc;<br>      nc.lop = i;<br>      nc.pts.push_back( make_pair( x[ i ], y[ i ] ) );<br>      char bf[ 100 ];<br>      sprintf( bf, "[(%d,%d)]", x[ i ], y[ i ] );<br>      nc.str = bf;<br>      clusts.push_back( nc );<br>    }<br>    while( clusts.size() &gt; 1 ) {<br>      if( clusts.size() &lt;= 3 )<br>      disp = true;<br>      long double bdst = 1e10;<br>      int ida = -1;<br>      int idb = -1;<br>      for( int i = 0; i &lt; clusts.size(); i++ ) {<br>        for( int j = i + 1; j &lt; clusts.size(); j++ ) {<br>          long double tdst = glen( clusts[ i ], clusts[ j ] );<br>      //    printf( "    testing %d,%d, %d,%d, %d+%d, %lf\n", i, j, clusts[ i ].lop, clusts[ j ].lop, clusts[ i ].pts.size(), clusts[ j ].pts.size(), (double)tdst );<br>          if( tdst &lt; bdst ) {<br>            bdst = tdst;<br>            ida = i;<br>            idb = j;<br>          }<br>        }<br>      }<br>  //    printf( "merging %d,%d, %d,%d, %d+%d, %lf\n", ida, idb, clusts[ ida ].lop, clusts[ idb ].lop,clusts[ ida ].pts.size(), clusts[ idb ].pts.size(), (double)bdst );<br>      clust nc;<br>      nc.lop = min( clusts[ ida ].lop, clusts[ idb ].lop );<br>      nc.pts = clusts[ ida ].pts;<br>      nc.pts.insert( nc.pts.end(), clusts[ idb ].pts.begin(), clusts[ idb ].pts.end() );<br>      if( clusts[ ida ].lop &lt; clusts[ idb ].lop ) {<br>        nc.str = string() + "[" + clusts[ ida ].str + clusts[ idb ].str + "]";<br>      } else {<br>        nc.str = string() + "[" + clusts[ idb ].str + clusts[ ida ].str + "]";<br>      }<br>      clusts.erase( clusts.begin() + idb );<br>      clusts.erase( clusts.begin() + ida );<br>      clusts.push_back( nc );<br>    }<br>    return clusts[ 0 ].str;<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>