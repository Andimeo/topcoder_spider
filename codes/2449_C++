<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;deque&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stdarg.h&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>#define Forc(i, c) for(typeof(c.begin()) i(c.begin()); i != c.end(); ++i)<br>#define In(c, x) (c.find(x) != c.end())<br>#define Inv(v, x) (find(v, x) &gt;= 0)<br>#define X first<br>#define Y second<br>#define Pair(x, y) make_pair(x, y)<br>#define SetPair(a, x, y) pair&lt;typeof(x), typeof(y)&gt; a(x, y)<br>#define mkvecint makeVec&lt;int, int&gt;<br>#define mkvecstring makeVec&lt;string, char *&gt;<br>typedef pair&lt;int, int&gt; point; typedef long long ll;<br> <br>template &lt;class T&gt; T strToInt(string); template &lt;class T&gt; string intToStr(T);<br>int strToInt(string str) { return strToInt&lt;int&gt;(str); }<br>string intToStr(int x) { return intToStr&lt;int&gt;(x); }<br>vector&lt;string&gt; tokenize(string, string = " ", bool = false);<br>vector&lt;int&gt; tokenizeInt(string, string = " ", bool = false);<br>template &lt;class A, class B&gt; int find(const vector&lt;A&gt;&amp;, B);<br>template &lt;class T&gt; T nth(const set&lt;T&gt;&amp;, int);<br>template &lt;class A, class B&gt; void hookSort(vector&lt;A&gt;&amp;, vector&lt;B&gt;&amp;, bool = false);<br>template &lt;class T&gt; ostream &amp;operator &lt;&lt;(ostream&amp;, const vector&lt;T&gt;&amp;);<br>template &lt;class A, class B&gt; ostream &amp;operator &lt;&lt;(ostream&amp;, const pair&lt;A, B&gt;&amp;);<br>template &lt;class A, class B&gt; vector&lt;A&gt; makeVec(int, ...);<br> <br>/**************************************************************************************/<br>/************************** Begin Priority Queue / BFS Class **************************/<br>/**************************************************************************************/<br> <br>template &lt;class P, class V = int&gt; struct PQ {<br>    map&lt;P, V&gt; minValue;<br>    set&lt;pair&lt;V, P&gt; &gt; q;<br>    PQ() {}<br>    PQ(P pos, V val = 0) { push_back(pos, val); }<br>    bool empty() { return q.empty(); }<br>    pair&lt;P, V&gt; pop_front();<br>    void push_back(P, V);<br>};<br> <br>template &lt;class P, class V&gt;<br>pair&lt;P, V&gt; PQ&lt;P, V&gt;::pop_front() {<br>    P curr(q.begin()-&gt;Y);<br>    q.erase(q.begin());<br>    return Pair(curr, minValue[curr]);<br>}<br> <br>template &lt;class P, class V&gt;<br>void PQ&lt;P, V&gt;::push_back(P pos, V val) {<br>    if (!In(minValue, pos)) {<br>        minValue[pos] = val;<br>        q.insert(Pair(val, pos));<br>        return;<br>    }<br>    if (minValue[pos] &lt;= val) return;<br>    q.erase(Pair(minValue[pos], pos));<br>    minValue[pos] = val;<br>    q.insert(Pair(val, pos));<br>}<br> <br>/**************************************************************************/<br> <br>int MyCode(vector &lt;string&gt; up, vector &lt;string&gt; down, vector &lt;string&gt; east, vector &lt;string&gt; west, int startLevel, int startEasting) {<br>  int r(up.size()), c(up[0].length());<br>  PQ&lt;point&gt; pq(point(startLevel, startEasting));<br>  while (!pq.empty()) {<br>    pair&lt;point, int&gt; curr(pq.pop_front());<br>    if (curr.X.X &lt; 0) return curr.Y;<br>    if (curr.Y &gt;= c * (r - curr.X.X)) continue;<br>    char dn(up[curr.X.X][curr.X.Y]), ds(down[curr.X.X][curr.X.Y]), dw(west[curr.X.X][curr.X.Y]), de(east[curr.X.X][curr.X.Y]);<br>    if (dn != 'x') pq.push_back(point(curr.X.X-1, curr.X.Y), curr.Y + dn - '0');<br>    if (ds != 'x' &amp;&amp; curr.X.X &lt; r-1) pq.push_back(point(curr.X.X+1, curr.X.Y), curr.Y + ds - '0');<br>    if (dw != 'x' &amp;&amp; curr.X.Y &gt; 0) pq.push_back(point(curr.X.X, curr.X.Y-1), curr.Y + dw - '0');<br>    if (de != 'x' &amp;&amp; curr.X.Y &lt; c-1) pq.push_back(point(curr.X.X, curr.X.Y+1), curr.Y + de - '0');<br>  }<br>  return -1;<br>}<br> <br>/**************************************************************************/<br> <br>struct DungeonEscape {<br>  int exitTime(vector &lt;string&gt; up, vector &lt;string&gt; down, vector &lt;string&gt; east, vector &lt;string&gt; west, int startLevel, int startEasting) {<br>    static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }<br>    return MyCode(up,down,east,west,startLevel,startEasting);<br>  }<br>  <br>// BEGIN CUT HERE<br>  public:<br>  void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }<br>  private:<br>  template &lt;typename T&gt; string print_array(const vector&lt;T&gt; &amp;V) { ostringstream os; os &lt;&lt; "{ "; for (typename vector&lt;T&gt;::const_iterator iter = V.begin(); iter != V.end(); ++iter) os &lt;&lt; '\"' &lt;&lt; *iter &lt;&lt; "\","; os &lt;&lt; " }"; return os.str(); }<br>  void verify_case(int Case, const int &amp;Expected, const int &amp;Received) { cerr &lt;&lt; "Test Case #" &lt;&lt; Case &lt;&lt; "..."; if (Expected == Received) cerr &lt;&lt; "PASSED" &lt;&lt; endl; else { cerr &lt;&lt; "FAILED" &lt;&lt; endl; cerr &lt;&lt; "\tExpected: \"" &lt;&lt; Expected &lt;&lt; '\"' &lt;&lt; endl; cerr &lt;&lt; "\tReceived: \"" &lt;&lt; Received &lt;&lt; '\"' &lt;&lt; endl; } }<br>  void test_case_0() { string Arr0[] = {"0x4",<br> "0x3",<br> "0x3"}; vector &lt;string&gt; Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arr1[] = {"0x9",<br> "009",<br> "0x9"}; vector &lt;string&gt; Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); string Arr2[] = {"0x9",<br> "1x9",<br> "009"}; vector &lt;string&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); string Arr3[] = {"0x9",<br> "0x0",<br> "009"}; vector &lt;string&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 2; int Arg5 = 2; int Arg6 = 10; verify_case(0, Arg6, exitTime(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5)); }<br>  void test_case_1() { string Arr0[] = {"xxxxxxxxx1",<br> "1xxxxxxxxx",<br> "xxxxxxxxx1"}; vector &lt;string&gt; Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arr1[] = {"xxxxxxxxxx",<br> "xxxxxxxxxx",<br> "xxxxxxxxxx"}; vector &lt;string&gt; Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); string Arr2[] = {"1111111111",<br> "xxxxxxxxxx",<br> "1111111111"}; vector &lt;string&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); string Arr3[] = {"xxxxxxxxxx",<br> "1111111111",<br> "xxxxxxxxxx"}; vector &lt;string&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 2; int Arg5 = 0; int Arg6 = 30; verify_case(1, Arg6, exitTime(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5)); }<br>  void test_case_2() { string Arr0[] = {"xxxxxxxxx1",<br> "xxxx999991",<br> "x999999991"}; vector &lt;string&gt; Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arr1[] = {"1111111111",<br> "1111111111",<br> "1111111111"}; vector &lt;string&gt; Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); string Arr2[] = {"1111122242",<br> "2222222241",<br> "2111111111"}; vector &lt;string&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); string Arr3[] = {"xxxxxxxxx1",<br> "1111111111",<br> "xxxxxxxxx1"}; vector &lt;string&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 2; int Arg5 = 0; int Arg6 = -1; verify_case(2, Arg6, exitTime(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5)); }<br>  void test_case_3() { string Arr0[] = {"1x2x3x4x5x6x7x8x9",<br> "00000000000000000",<br> "98765432223456789",<br> "12345678987654321"}; vector &lt;string&gt; Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); string Arr1[] = {"00000000000000000",<br> "00000000000000000",<br> "00000000000000000",<br> "00000000000000000"}; vector &lt;string&gt; Arg1(Arr1, Arr1 + (sizeof(Arr1) / sizeof(Arr1[0]))); string Arr2[] = {"xxxxxxxxxxxxxxxxx",<br> "xxxxxxxxxxxxxxxxx",<br> "22222222222222222",<br> "33333333333333333"}; vector &lt;string&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); string Arr3[] = {"xxxxxxxxxxxxxxxxx",<br> "xxxxxxxxxxxxxxxxx",<br> "22222222222222222",<br> "33333333333333333"}; vector &lt;string&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 3; int Arg5 = 12; int Arg6 = 17; verify_case(3, Arg6, exitTime(Arg0, Arg1, Arg2, Arg3, Arg4, Arg5)); }<br> <br>// END CUT HERE<br>};<br> <br>template &lt;class T&gt; T strToInt(string str) {<br>  stringstream ss(str);<br>  T answer;<br>  ss &gt;&gt; answer;<br>  return answer;<br>}<br> <br>template &lt;class T&gt; string intToStr(T x) {<br>  stringstream s;<br>  s &lt;&lt; x;<br>  return s.str();<br>}<br> <br>vector&lt;string&gt; tokenize(string str, string delim, bool returnDelims) {<br>  vector&lt;string&gt; answer;<br>  string temp;<br>  for (int i(0); i &lt; str.length(); ++i) {<br>    bool isDelim(false);<br>    for (int j(0); j &lt; delim.length(); ++j)<br>      if (str[i] == delim[j]) isDelim = true;<br>    if (!isDelim) {<br>      temp += str[i];<br>      continue;<br>    }<br>    if (temp != "") answer.push_back(temp);<br>    temp = "";<br>    if (returnDelims) answer.push_back(string(1, str[i]));<br>  }<br>  if (temp != "") answer.push_back(temp);<br>  return answer;<br>}<br> <br>vector&lt;int&gt; tokenizeInt(string str, string delim, bool returnDelims) {<br>  vector&lt;string&gt; tokens(tokenize(str, delim, returnDelims));<br>  vector&lt;int&gt; answer(tokens.size());<br>  for (int i(0); i &lt; tokens.size(); ++i)<br>    answer[i] = strToInt(tokens[i]);<br>  return answer;<br>}<br> <br>template &lt;class A, class B&gt; int find(const vector&lt;A&gt; &amp;vec, B item) {<br>  for (int i(0); i &lt; vec.size(); ++i)<br>    if (vec[i] == item) return i;<br>  return -1;<br>}<br> <br>template &lt;class T&gt; T nth(const set&lt;T&gt; &amp;s, int x) {<br>  typename set&lt;T&gt;::iterator answer(s.begin());<br>  for (int i(0); i &lt; x; ++i) ++answer;<br>  return *answer;<br>}<br> <br>template &lt;class A, class B&gt; void hookSort(vector&lt;A&gt; &amp;a, vector&lt;B&gt; &amp;b, bool complete) {<br>  vector&lt;pair&lt;A, int&gt; &gt; toSort(a.size());<br>  for (int i(0); i &lt; a.size(); ++i)<br>    toSort[i] = Pair(a[i], i);<br>  sort(toSort.begin(), toSort.end());<br>  vector&lt;B&gt; old(b);<br>  for (int i(0); i &lt; b.size(); ++i)<br>    b[i] = old[toSort[i].Y];<br>  if (complete)<br>    sort(a.begin(), a.end());<br>}<br> <br>template &lt;class T&gt; ostream &amp;operator &lt;&lt;(ostream &amp;os, const vector&lt;T&gt; &amp;vec) {<br>  if (vec.empty()) return os;<br>  for (int i(0); i &lt; vec.size() - 1; ++i) os &lt;&lt; vec[i] &lt;&lt; ',';<br>  return os &lt;&lt; vec[vec.size() - 1];<br>}<br> <br>template &lt;class A, class B&gt; ostream &amp;operator &lt;&lt;(ostream &amp;os, const pair&lt;A, B&gt; &amp;p) {<br>  return os &lt;&lt; '(' &lt;&lt; p.X &lt;&lt; ',' &lt;&lt; p.Y &lt;&lt; ')';<br>}<br> <br>template &lt;class A, class B&gt; vector&lt;A&gt; makeVec(int n, ...) {<br>  vector&lt;A&gt; answer(n);<br>  va_list vl;<br>  va_start(vl, n);<br>  for (int i(0); i &lt; n; ++i) answer[i] = va_arg(vl, B);<br>  va_end(vl);<br>  return answer;<br>}<br> <br>// Powered by PopsEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>