<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>public class DungeonEscape {<br>  static class Entry {<br>    public int key;<br>    public Object value;<br> <br>    public Entry(int key, Object value) {<br>      this.key = key;<br>      this.value = value;<br>    }<br>  }<br>  static class PQ {<br>    ArrayList q = new ArrayList();<br>  <br>    public boolean isEmpty() {<br>      return q.isEmpty();<br>    }<br>  <br>    int parent(int i) {<br>      return (i+1)/2-1;<br>    }<br>    int left(int i) {<br>      return (i+1)*2-1;<br>    }<br>    int right(int i) {<br>      return (i+1)*2;<br>    }<br>    public void add(int key, Object value) {<br>      q.add(null);<br>      int i = q.size() - 1;<br>      while (i &gt; 0 &amp;&amp; ((Entry) q.get(parent(i))).key &gt; key) {<br>        q.set(i, q.get(parent(i)));<br>        i = parent(i);<br>      }<br>      q.set(i, new Entry(key, value));<br>    }<br>    public Entry popEntry() {<br>      Entry e = (Entry) q.get(0);<br>      q.set(0, q.get(q.size() - 1));<br>      q.remove(q.size() - 1);<br>    <br>      int i = 0;<br>      boolean done = false;<br>      while (!done) {<br>        int l = left(i), r = right(i);<br>        int min = i;<br>        if (l &lt; q.size() &amp;&amp; ((Entry) q.get(l)).key &lt; ((Entry) q.get(min)).key) {<br>          min = l;<br>        }<br>        if (r &lt; q.size() &amp;&amp; ((Entry) q.get(r)).key &lt; ((Entry) q.get(min)).key) {<br>          min = r;<br>        }<br>        if (min != i) {<br>          Object temp = q.get(min);<br>          q.set(min, q.get(i));<br>          q.set(i, temp);<br>          i = min;<br>        } else {<br>          done = true;<br>        }<br>      }<br>      return e;<br>    }<br>    public Object popValue() {<br>      Entry e = popEntry();<br>      return e.value;<br>    }<br>  }<br>  static class Point {<br>    int x, y;<br>    public Point(int x, int y) {<br>      this.x = x;<br>      this.y = y;<br>    }<br>  }<br>  public int exitTime(String[] up, String[] down, String[] east, String[] west, int startLevel, int startEasting) {<br>    int h = up.length;<br>    int w = up[0].length();<br>    boolean[][] v = new boolean[h][w];<br>    PQ q = new PQ();<br>    q.add(0, new Point(startEasting, startLevel));<br>    while (!q.isEmpty()) {<br>      Entry e = q.popEntry();<br>      Point p = (Point) e.value;<br>      int y = p.y;<br>      int x = p.x;<br>      if (y &lt; 0) return e.key;<br>      if (v[y][x]) continue;<br>      v[y][x] = true;<br>      if (up[y].charAt(x) != 'x') {<br>        int t = e.key + up[y].charAt(x) - '0';<br>        if (y &lt;= 0 || y - 1 &lt; h - t / w) q.add(t, new Point(x, y - 1));<br>      }<br>      if (y &lt; h - 1 &amp;&amp; down[y].charAt(x) != 'x') {<br>        int t = e.key + down[y].charAt(x) - '0';<br>        if (y + 1 &lt; h - t / w) q.add(t, new Point(x, y + 1));<br>      }<br>      if (x &lt; w - 1 &amp;&amp; east[y].charAt(x) != 'x') {<br>        int t = e.key + east[y].charAt(x) - '0';<br>        if (y &lt; h - t / w) q.add(t, new Point(x + 1, y));<br>      }<br>      if (x &gt; 0 &amp;&amp; west[y].charAt(x) != 'x') {<br>        int t = e.key + west[y].charAt(x) - '0';<br>        if (y &lt; h - t / w) q.add(t, new Point(x - 1, y));<br>      }<br>    }<br>    return -1;<br>  }<br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>