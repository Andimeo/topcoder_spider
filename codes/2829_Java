<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>public class QuickSums {<br>  <br>  int minPlus = Integer.MAX_VALUE;<br>  public int minSums(String numbers, int sum) {<br>    go (numbers,"",sum,0);<br>    if (minPlus == Integer.MAX_VALUE) return -1;<br>    return minPlus-1;<br>  }<br> <br>  public void go (String num, String s, int sum, int i) {<br>    if (i&gt;=num.length()) {<br>      int t = 0;<br>      long rs = 0;<br>      StringTokenizer st = new StringTokenizer(s,"+");<br>      t = st.countTokens();<br>      while (st.hasMoreTokens()) {<br>        rs+=Long.parseLong((String)st.nextToken());<br>      }<br>      if (rs == sum) minPlus = Math.min(minPlus,t);<br>    } else {<br>      if (i == 0) go (num,""+num.charAt(i), sum, i+1);<br>      else {<br>        go (num,s+"+"+num.charAt(i),sum,i+1);<br>        go (num,s+num.charAt(i),sum,i+1);<br>      }<br> <br>    }<br>        <br> <br>  }<br>}<br> <br>/****************** HELPFUL FUNCTIONS ************************************/<br>class TCMath {<br>  <br>  public static double EPSILON = 1.0E-9;<br>  <br>  public static long gcd (long a, long b) {<br>    long a1 = Math.max(a,b);<br>    long b1 = Math.min(a,b);<br>    while(true) {<br>      if (a1%b1==0) return b1;<br>      b1=a1%b1;<br>      a1=b1;<br>    }<br>  }<br>  <br>    <br>  public static char[][] stringArrayToCharMap(String[] str) {<br>    char[][] map = new char[str.length][str[0].length()];<br>    for (int i = 0; i&lt;str.length; i++) {<br>      for (int j = 0; j&lt;str[0].length(); j++) {<br>        map[i][j] = str[i].charAt(j);<br>        <br>      }      <br>      <br>    }  <br>    return map;<br>  }<br> <br>  <br>  public static long getFactorial(int n) {<br>    long ret = 1;<br>    for (int i = 1; i&lt;=n; i++) {<br>      ret*=i;  <br>    }<br>    return ret;<br>    <br>  }<br>  <br>  public static int[][] stringArrayToIntMap(String[] str) {<br>    int[][] map = new int[str.length][str[0].length()];<br>    for (int i = 0; i&lt;str.length; i++) {<br>      for (int j = 0; j&lt;str[0].length(); j++) {<br>        map[i][j] = str[i].charAt(j)-'0';<br>        <br>      }      <br>      <br>    }  <br>    return map;<br>  }<br>  <br>  public static int[] getNextPermutation (int[] a) {<br>      int temp;<br>      // Find largest index j with a[j] &lt; a[j+1]<br>      int j = a.length - 2;<br>      while (j&gt;-1 &amp;&amp; a[j] &gt;= a[j+1]) {<br>        j--;<br>      }<br>      //cant generate next lexographical permutation<br>      if (j&lt;=-1) return null;<br>      // Find index k such that a[k] is smallest integer<br>      // greater than a[j] to the right of a[j]<br>      int k = a.length - 1;<br>      while (a[j] &gt; a[k]) {<br>        k--;<br>      }<br>      // Interchange a[j] and a[k]<br>      temp = a[k];<br>      a[k] = a[j];<br>      a[j] = temp;<br>      // Put tail end of permutation after jth position in increasing order<br>      int r = a.length - 1;<br>      int s = j + 1;<br>      while (r &gt; s) {<br>        temp = a[s];<br>        a[s] = a[r];<br>        a[r] = temp;<br>        r--;<br>        s++;<br>      }<br>      return a;<br>    }<br> <br>  public static int compareDoubles(double a, double b) {<br>    if (Math.abs(a-b)&lt;=EPSILON) return 0;<br>    if (a-b &gt; 0 &amp;&amp; Math.abs(a-b) &gt; EPSILON) return 1;<br>    if (a-b &lt; 0 &amp;&amp; Math.abs(a-b) &gt; EPSILON) return -1;      <br>    //error return<br>    return -2;<br>  }<br>  <br>  public double planeDistance(double x1,double y1,double x2,double y2) {<br>    return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));  <br>  }<br> <br>  <br>}<br></td>