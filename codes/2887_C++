<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br>#define VAR(a,b) typeof(b) a=(b)<br>#define REP(i,n) for(int _n=n, i=0;i&lt;_n;++i)<br>#define FOR(i,a,b) for(int i=(a),_b=(b);i&lt;=_b;++i)<br>#define FORD(i,a,b) for(int i=(a),_b=(b);i&gt;=_b;--i)<br>#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)<br>#define ALL(f,w) ({ bool _ok=true; f _ok=_ok &amp;&amp; (w); _ok; })<br>#define EXISTS(f,w) (!ALL(f,!(w)))<br>typedef long long LL;<br>const int INF = 1000000000;<br>typedef vector&lt;int&gt; VI;<br>template&lt;class T&gt; inline int size(const T&amp;c) { return c.size(); }<br>template&lt;class T&gt; inline vector&lt;T&gt; makeV(const T&amp;x) { return vector&lt;T&gt;(1,x); }<br>template&lt;class T&gt; inline vector&lt;T&gt; makeV(const T&amp;x,const T&amp;y) {<br>  vector&lt;T&gt; v(2); v[0] = x; v[1] = y; return v;<br>}<br>template&lt;class T&gt; inline vector&lt;T&gt; makeV(const T&amp;x,const T&amp;y,const T&amp;z) {<br>  vector&lt;T&gt; v(3); v[0] = x; v[1] = y; v[2]=z; return v;<br>}<br>template&lt;class A,class B&gt; inline bool contains(const A&amp;a, const B&amp;b) {<br>  return find(a.begin(),a.end(),b)!=a.end();<br>}<br>template&lt;class T&gt; string i2s(T x) { ostringstream o; o&lt;&lt;x; return o.str(); }<br>vector&lt;string&gt; split(string s,string del=" ") {<br>  s+=del[0];<br>  string w;<br>  vector&lt;string&gt; res;<br>  FOREACH(it,s) {<br>    if(!contains(del,*it)) w+=*it;<br>    else if(w!="") { res.push_back(w); w=""; }<br>  }<br>  return res;<br>}<br>typedef double coord;<br> <br>struct Point {<br>  coord x,y;<br>  Point() {}<br>  Point(coord x,coord y):x(x),y(y) {}<br>};<br> <br>Point operator+(const Point &amp;A,const Point&amp;B) { return Point(A.x+B.x,A.y+B.y); }<br>Point operator-(const Point &amp;A,const Point&amp;B) { return Point(A.x-B.x,A.y-B.y); }<br>Point operator*(coord c, const Point &amp;A) { return Point(c*A.x,c*A.y); }<br>coord operator^(const Point&amp;A,const Point&amp;B) { return A.x*B.y-A.y*B.x; }<br>coord operator*(const Point&amp;A,const Point&amp;B) { return A.x*B.x+A.y*B.y; }<br>coord len2(const Point&amp;A) { return A*A; }<br> <br>double len(const Point&amp;A) { return sqrt(len2(A)); }<br>//<br>// line AB with CD<br>Point linecut(Point A,Point B,Point C,Point D) {<br>  double t = - ( ((A-D)^(C-D)) / ((B-A)^(C-D)) );<br>  return A + t*(B-A);<br>}<br> <br> <br>///////////////////////////////////////////////////////////////////<br> <br>double PI = atan(1.0)*4.0;<br> <br>double EPSILON = 1e-9;<br> <br>struct Circle {<br>  double x,y,r;<br>};<br> <br>vector&lt;Circle&gt; circles;<br> <br>double dist;<br>Point poz;<br> <br>void intersect(double r1, Circle c, Point &amp;p1, Point&amp;p2) {<br>  double r0 = c.r;<br>  double x0 = c.x;<br>  double y0 = c.y;<br> <br>  double d = x0*x0+y0*y0;<br>  double p = sqrt(((r0+r1)*(r0+r1) - d) * (d-(r1-r0)*(r1-r0)));<br>  <br>  p1.x = x0/2 - x0*(r0*r0 - r1*r1)/(2*d) + y0*p/(2*d);<br>  p1.y = y0/2 - y0*(r0*r0 - r1*r1)/(2*d) - x0*p/(2*d);<br> <br>  p2.x = x0/2 - x0*(r0*r0 - r1*r1)/(2*d) - y0*p/(2*d);<br>  p2.y = y0/2 - y0*(r0*r0 - r1*r1)/(2*d) + x0*p/(2*d);<br>}<br> <br>double cdist(Point a, Point b) {<br>  double d = len(a);<br>  double ca = (b*a)/d/d;<br>  double sa = (b^a)/d/d;<br>  if(sa&gt;=0.0) return acos(ca) * d;<br>  else return (2*PI - acos(ca)) * d;<br>}<br> <br>bool go() {<br>  double R = len(poz);<br>  Circle bestc;<br>  Point bestp;<br>  double bestv = 1e100;<br>  FOREACH(it,circles) {<br>    Circle c = *it;<br>    double d2 = sqrt(c.x*c.x + c.y*c.y);<br>    if(d2 + c.r &gt; R + EPSILON &amp;&amp; d2 - c.r &lt; R - EPSILON) {<br>      Point p1,p2;<br>      intersect(R,c,p1,p2);<br>      double d = cdist(poz,p1);<br>      if(d &lt; bestv) { bestc=c; bestp = p1; bestv=d; }<br>      d = cdist(poz,p2);<br>      if(d &lt; bestv) { bestc=c; bestp = p2; bestv=d; }<br>    }<br>  }<br>  if(bestv &gt; 1e99) throw 0;<br>  dist += bestv;<br>  poz = bestp;<br>  Point center = Point(bestc.x,bestc.y);<br>  if(len(center) - bestc.r &gt; 10.0) {<br>    Point p2 = (len(center)-bestc.r)/len(center) * center;<br>    dist += cdist(p2 - center, poz - center);<br>    poz = p2;<br>    return false;<br>  }<br>  else {<br>    Point p1,p2;<br>    intersect(10.0, bestc, p1,p2);<br>    double d1 = cdist(p1 - center, poz-center);<br>    double d2 = cdist(p2-center, poz-center);<br>    if(d1&lt;d2) { dist+=d1; poz = p1; }<br>    else { dist+=d2; poz=p2; }<br>    return true;<br>  }<br>}<br> <br>struct DogWoods {<br>  // MAIN<br>  double howFar(vector &lt;int&gt; x, vector &lt;int&gt; y, vector &lt;int&gt; diameter, int startx, int starty) {<br>    Point p(startx,starty);<br>    if(len(p) &lt;= 10.0+EPSILON) return 0.0;<br>    circles.clear();<br>    REP(i,size(x)) {<br>      Circle c;<br>      c.x = x[i]; c.y=y[i]; c.r=diameter[i]*0.5;<br>      circles.push_back(c);<br>    }<br>    poz = p;<br>    dist = 0.0;<br>    try {<br>      while(!go()) ;<br>      return dist;<br>    }<br>    catch(int) { return -1; }<br>    return -2;<br>  }<br> <br> <br>  <br>///////////////////////////////////////////////////////////////////<br> <br> <br> <br> <br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>