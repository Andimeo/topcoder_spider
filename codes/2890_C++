<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt; // find insert erase make_pair<br>#include &lt;set&gt;<br>#include &lt;cassert&gt; // assert<br>//#include &lt;list&gt;<br>//#include &lt;deque&gt;<br>//#include &lt;iomanip&gt;<br>//#include &lt;cstring&gt;<br>//#include &lt;cmath&gt;<br>//#include &lt;cstdio&gt;<br>//#include &lt;cctype&gt; // isalpha isdigit isalnum isupper islower tolower toupper<br>#include &lt;string&gt; // size<br>#include &lt;vector&gt; // push_back pop_back front back<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt; // istringstream ostringstream<br>#include &lt;algorithm&gt; // next_permutation reverse count<br>#include &lt;numeric&gt; // accumulate<br>#include &lt;functional&gt;<br><br>using namespace std;<br><br>#ifdef HOME_RUN // this is debug output code<br>int NTR = 1000;struct UU{~UU(){cerr&lt;&lt;endl;}<br>template&lt;class X&gt;UU&amp;operator|(const X&amp;x){cerr&lt;&lt;' '&lt;&lt;x;return*this;}};<br>UU uu(const char*f,int l,const char*v){<br>for(cerr&lt;&lt;f&lt;&lt;':'&lt;&lt;l&lt;&lt;' ';*v;++v)cerr&lt;&lt;(*v-'|'?*v:' ');return UU();}<br>#define TR(v) if(--NTR&lt;0);else uu(__FILE__,__LINE__,#v)|'='|v<br>#else<br>#define TR(v) do{}while(0)<br>#endif // end of debug output code<br>#define ALL(C) (C).begin(), (C).end()<br>#define forIter(I, C) for(typeof((C).begin()) I=(C).begin(); I!=(C).end(); ++I)<br>#define forN(I, C) for ( int I = 0; I &lt; (C); ++(I) )<br>#define forEach(I, C) forN(I,int((C).size()))<br>#define forEach2(I, J, C) forEach(I, C)forEach(J, (C)[I])<br>typedef long long i64; typedef unsigned long long u64;<br>typedef vector&lt;int&gt; VI; typedef vector&lt;VI&gt; VVI; typedef vector&lt;string&gt; VS;<br><br>struct Point<br>{<br>    int x;<br>    int y;<br>    int z;<br><br>    int dist(const Point&amp; p) const<br>    {<br>        i64 r = 0;<br>        r += i64(x-p.x)*(x-p.x);<br>        r += i64(y-p.y)*(y-p.y);<br>        r += i64(z-p.z)*(z-p.z);<br>        r &lt;?= 1000000000;<br>        return r;<br>    }<br>};<br><br>struct LL<br>{<br>    bool operator()(const Point&amp; p, const Point&amp; q) const<br>    {<br>        if ( p.x != q.x )<br>            return p.x &lt; q.x;<br>        if ( p.y != q.y )<br>            return p.y &lt; q.y;<br>        return p.z &lt; q.z;<br>    }<br>};<br>struct ByX<br>{<br>    bool operator()(const Point&amp; p, const Point&amp; q) const<br>    {<br>        return p.x &lt; q.x;<br>    }<br>};<br>typedef vector&lt;Point&gt; VP;<br><br>#define METHOD ClosestPoints::distance<br>class ClosestPoints<br>{<br>public:<br>    int best;<br>    int get(int range, int&amp; seed)<br>    {<br>        seed = int((seed*16807LL) % ((1LL &lt;&lt; 31)-1));<br>        return (seed % (2 * range)) - range;<br>    }<br><br>    VI goByX(const VP&amp; pp)<br>    {<br>        int minx = 1000000, maxx = -1000000;<br>        forEach ( i, pp ) {<br>            minx &lt;?= pp[i].x;<br>            maxx &gt;?= pp[i].x;<br>        }<br>        VP pp1, pp2;<br>        int N = pp.size();<br>        int div = (minx+maxx)/2;<br>        forN ( i, N ) {<br>            if ( pp[i].x &lt; div )<br>                pp1.push_back(pp[i]);<br>            else<br>                pp2.push_back(pp[i]);<br>        }<br>        VI r1 = go(pp1);<br>        VI r2 = go(pp2);<br>        int d = r1[0] &lt;? r2[0];<br>        d &lt;?= best;<br>        int c = 0;<br>        if ( r1[0] == d )<br>            c += r1[1];<br>        if ( r2[0] == d )<br>            c += r2[1];<br>        minx = div-int(sqrt(double(d+1)));<br>        maxx = div-1+int(sqrt(double(d+1)));<br>        VP q1, q2;<br>        forEach ( i, pp1 ) {<br>            if ( pp1[i].x &gt;= minx )<br>                q1.push_back(pp1[i]);<br>        }<br>        forEach ( i, pp2 ) {<br>            if ( pp2[i].x &lt;= maxx )<br>                q2.push_back(pp2[i]);<br>        }<br>        forEach ( i, q1 ) {<br>            forEach ( j, q2 ) {<br>                int q = q1[i].dist(q2[j]);<br>                if ( q &lt; d ) {<br>                    c = 0;<br>                    d = q;<br>                }<br>                if ( q == d )<br>                    c++;<br>            }<br>        }<br>        best &lt;?= d;<br>        VI ret;<br>        ret.push_back(d);<br>        ret.push_back(c);<br>        return ret;<br>    }<br><br>    VI goByY(VP pp)<br>    {<br>        forEach ( i, pp )<br>            swap(pp[i].x, pp[i].y);<br>        return goByX(pp);<br>    }<br><br>    VI goByZ(VP pp)<br>    {<br>        forEach ( i, pp )<br>            swap(pp[i].x, pp[i].z);<br>        return goByX(pp);<br>    }<br><br>    VI go(const VP&amp; pp)<br>    {<br>        vector &lt;int&gt; ret;<br>        int N = pp.size();<br>        if ( N &lt; 1000 ) {<br>            int bestd = 1000000000;<br>            int count = 0;<br>            forN ( i, N ) {<br>                forN ( j, i ) {<br>                    int d = pp[i].dist(pp[j]);<br>                    if ( d == 0 ) continue;<br>                    if ( d &lt; bestd ) {<br>                        count = 0;<br>                        bestd = d;<br>                    }<br>                    if ( d == bestd )<br>                        count++;<br>                }<br>            }<br>            ret.push_back(bestd);<br>            ret.push_back(count);<br>        }<br>        else {<br>            int minx = 1000000, maxx = -1000000;<br>            int miny = 1000000, maxy = -1000000;<br>            int minz = 1000000, maxz = -1000000;<br>            forN ( i, N ) {<br>                minx &lt;?= pp[i].x;<br>                maxx &gt;?= pp[i].x;<br>                miny &lt;?= pp[i].y;<br>                maxy &gt;?= pp[i].y;<br>                minz &lt;?= pp[i].z;<br>                maxz &gt;?= pp[i].z;<br>            }<br>            int dx = maxx-minx;<br>            int dy = maxy-miny;<br>            int dz = maxz-minz;<br>            if ( dx &gt;= dy &amp;&amp; dx &gt;= dz )<br>                return goByX(pp);<br>            else if ( dy &gt;= dz )<br>                return goByY(pp);<br>            else<br>                return goByZ(pp);<br>        }<br>        return ret;<br>    }<br>    vector &lt;int&gt; distance(int N, int range, int seed) <br>    {<br>        VP pp(N);<br>        forN ( i, N ) {<br>            pp[i].x = get(range, seed);<br>            pp[i].y = get(range, seed);<br>            pp[i].z = get(range, seed);<br>        }<br>        set&lt;Point, LL&gt; ss(ALL(pp));<br>        pp.assign(ALL(ss));<br>        best = 1000000000;<br>        return go(pp);<br>    }<br>};<br><br><br>// Powered by FileEdit<br></td>