<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;deque&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stdarg.h&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>#define Forc(i, c) for(typeof(c.begin()) i(c.begin()); i != c.end(); ++i)<br>#define In(c, x) (c.find(x) != c.end())<br>#define Inv(v, x) (find(v, x) &gt;= 0)<br>#define X first<br>#define Y second<br>#define Pair(x, y) make_pair(x, y)<br>#define SetPair(a, x, y) pair&lt;typeof(x), typeof(y)&gt; a(x, y)<br>#define mkvecint makeVec&lt;int, int&gt;<br>#define mkvecstring makeVec&lt;string, char *&gt;<br>typedef pair&lt;int, int&gt; point; typedef long long ll;<br> <br>template &lt;class T&gt; T strToInt(string); template &lt;class T&gt; string intToStr(T);<br>int strToInt(string str) { return strToInt&lt;int&gt;(str); }<br>string intToStr(int x) { return intToStr&lt;int&gt;(x); }<br>vector&lt;string&gt; tokenize(string, string = " ", bool = false);<br>vector&lt;int&gt; tokenizeInt(string, string = " ", bool = false);<br>template &lt;class A, class B&gt; int find(const vector&lt;A&gt;&amp;, B);<br>template &lt;class T&gt; T nth(const set&lt;T&gt;&amp;, int);<br>template &lt;class A, class B&gt; void hookSort(vector&lt;A&gt;&amp;, vector&lt;B&gt;&amp;, bool = false);<br>template &lt;class T&gt; ostream &amp;operator &lt;&lt;(ostream&amp;, const vector&lt;T&gt;&amp;);<br>template &lt;class A, class B&gt; ostream &amp;operator &lt;&lt;(ostream&amp;, const pair&lt;A, B&gt;&amp;);<br>template &lt;class A, class B&gt; vector&lt;A&gt; makeVec(int, ...);<br> <br>/**************************************************************************/<br> <br>int MyCode(int maxRank, int maxFile, vector &lt;int&gt; rank, vector &lt;int&gt; file) {<br>  int answer(maxRank * maxFile / 2);<br>  for (int i(0); i &lt; rank.size(); ++i) {<br>    if ((rank[i] + maxFile - file[i]) % 2 == 0) --answer;<br>  }<br>  return answer;<br>}<br> <br>/**************************************************************************/<br> <br>struct RedSquare {<br>  int countTheEmptyReds(int maxRank, int maxFile, vector &lt;int&gt; rank, vector &lt;int&gt; file) {<br>    static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }<br>    return MyCode(maxRank, maxFile, rank, file);<br>  }<br>  <br>// BEGIN CUT HERE<br>  public:<br>  void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); if ((Case == -1) || (Case == 6)) test_case_6(); }<br>  private:<br>  template &lt;typename T&gt; string print_array(const vector&lt;T&gt; &amp;V) { ostringstream os; os &lt;&lt; "{ "; for (typename vector&lt;T&gt;::const_iterator iter = V.begin(); iter != V.end(); ++iter) os &lt;&lt; '\"' &lt;&lt; *iter &lt;&lt; "\","; os &lt;&lt; " }"; return os.str(); }<br>  void verify_case(int Case, const int &amp;Expected, const int &amp;Received) { cerr &lt;&lt; "Test Case #" &lt;&lt; Case &lt;&lt; "..."; if (Expected == Received) cerr &lt;&lt; "PASSED" &lt;&lt; endl; else { cerr &lt;&lt; "FAILED" &lt;&lt; endl; cerr &lt;&lt; "\tExpected: \"" &lt;&lt; Expected &lt;&lt; '\"' &lt;&lt; endl; cerr &lt;&lt; "\tReceived: \"" &lt;&lt; Received &lt;&lt; '\"' &lt;&lt; endl; } }<br>  void test_case_0() { int Arg0 = 3; int Arg1 = 5; int Arr2[] = {1, 2, 2}; vector &lt;int&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {4, 1, 2}; vector &lt;int&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 5; verify_case(0, Arg4, countTheEmptyReds(Arg0, Arg1, Arg2, Arg3)); }<br>  void test_case_1() { int Arg0 = 3; int Arg1 = 3; int Arr2[] = {1,2,3,1,2,3,1,2,3}; vector &lt;int&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {1,1,1,2,2,2,3,3,3}; vector &lt;int&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 0; verify_case(1, Arg4, countTheEmptyReds(Arg0, Arg1, Arg2, Arg3)); }<br>  void test_case_2() { int Arg0 = 5; int Arg1 = 5; int Arr2[] = {1,1,2,2,2,3,3,4,4,4,5,5}; vector &lt;int&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {2,4,1,3,5,2,4,1,3,5,2,4}; vector &lt;int&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 0; verify_case(2, Arg4, countTheEmptyReds(Arg0, Arg1, Arg2, Arg3)); }<br>  void test_case_3() { int Arg0 = 5; int Arg1 = 6; int Arr2[] = {1,1,2,2,2,3,3,4,4,4,5,5}; vector &lt;int&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {2,4,1,3,5,2,4,1,3,5,2,4}; vector &lt;int&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 15; verify_case(3, Arg4, countTheEmptyReds(Arg0, Arg1, Arg2, Arg3)); }<br>  void test_case_4() { int Arg0 = 1; int Arg1 = 1; int Arr2[] = {}; vector &lt;int&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {}; vector &lt;int&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 0; verify_case(4, Arg4, countTheEmptyReds(Arg0, Arg1, Arg2, Arg3)); }<br>  void test_case_5() { int Arg0 = 50; int Arg1 = 50; int Arr2[] = {1}; vector &lt;int&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {1}; vector &lt;int&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 1249; verify_case(5, Arg4, countTheEmptyReds(Arg0, Arg1, Arg2, Arg3)); }<br>  void test_case_6() { int Arg0 = 50; int Arg1 = 50; int Arr2[] = {1,2,3,4,5,6,7,8,9,10,<br> 1,2,3,4,5,6,7,8,9,10,<br> 1,2,3,4,5,6,7,8,9,10,<br> 1,2,3,4,5,6,7,8,9,10,<br> 1,2,3,4,5,6,7,8,9,10}; vector &lt;int&gt; Arg2(Arr2, Arr2 + (sizeof(Arr2) / sizeof(Arr2[0]))); int Arr3[] = {1,1,1,1,1,1,1,1,1,1,<br> 2,2,2,2,2,2,2,2,2,2,<br> 3,3,3,3,3,3,3,3,3,3,<br> 4,4,4,4,4,4,4,4,4,4,<br> 5,5,5,5,5,5,5,5,5,5}; vector &lt;int&gt; Arg3(Arr3, Arr3 + (sizeof(Arr3) / sizeof(Arr3[0]))); int Arg4 = 1225; verify_case(6, Arg4, countTheEmptyReds(Arg0, Arg1, Arg2, Arg3)); }<br> <br>// END CUT HERE<br>};<br> <br>template &lt;class T&gt; T strToInt(string str) {<br>  stringstream ss(str);<br>  T answer;<br>  ss &gt;&gt; answer;<br>  return answer;<br>}<br> <br>template &lt;class T&gt; string intToStr(T x) {<br>  stringstream s;<br>  s &lt;&lt; x;<br>  return s.str();<br>}<br> <br>vector&lt;string&gt; tokenize(string str, string delim, bool returnDelims) {<br>  vector&lt;string&gt; answer;<br>  string temp;<br>  for (int i(0); i &lt; str.length(); ++i) {<br>    bool isDelim(false);<br>    for (int j(0); j &lt; delim.length(); ++j)<br>      if (str[i] == delim[j]) isDelim = true;<br>    if (!isDelim) {<br>      temp += str[i];<br>      continue;<br>    }<br>    if (temp != "") answer.push_back(temp);<br>    temp = "";<br>    if (returnDelims) answer.push_back(string(1, str[i]));<br>  }<br>  if (temp != "") answer.push_back(temp);<br>  return answer;<br>}<br> <br>vector&lt;int&gt; tokenizeInt(string str, string delim, bool returnDelims) {<br>  vector&lt;string&gt; tokens(tokenize(str, delim, returnDelims));<br>  vector&lt;int&gt; answer(tokens.size());<br>  for (int i(0); i &lt; tokens.size(); ++i)<br>    answer[i] = strToInt(tokens[i]);<br>  return answer;<br>}<br> <br>template &lt;class A, class B&gt; int find(const vector&lt;A&gt; &amp;vec, B item) {<br>  for (int i(0); i &lt; vec.size(); ++i)<br>    if (vec[i] == item) return i;<br>  return -1;<br>}<br> <br>template &lt;class T&gt; T nth(const set&lt;T&gt; &amp;s, int x) {<br>  typename set&lt;T&gt;::iterator answer(s.begin());<br>  for (int i(0); i &lt; x; ++i) ++answer;<br>  return *answer;<br>}<br> <br>template &lt;class A, class B&gt; void hookSort(vector&lt;A&gt; &amp;a, vector&lt;B&gt; &amp;b, bool complete) {<br>  vector&lt;pair&lt;A, int&gt; &gt; toSort(a.size());<br>  for (int i(0); i &lt; a.size(); ++i)<br>    toSort[i] = Pair(a[i], i);<br>  sort(toSort.begin(), toSort.end());<br>  vector&lt;B&gt; old(b);<br>  for (int i(0); i &lt; b.size(); ++i)<br>    b[i] = old[toSort[i].Y];<br>  if (complete)<br>    sort(a.begin(), a.end());<br>}<br> <br>template &lt;class T&gt; ostream &amp;operator &lt;&lt;(ostream &amp;os, const vector&lt;T&gt; &amp;vec) {<br>  if (vec.empty()) return os;<br>  for (int i(0); i &lt; vec.size() - 1; ++i) os &lt;&lt; vec[i] &lt;&lt; ',';<br>  return os &lt;&lt; vec[vec.size() - 1];<br>}<br> <br>template &lt;class A, class B&gt; ostream &amp;operator &lt;&lt;(ostream &amp;os, const pair&lt;A, B&gt; &amp;p) {<br>  return os &lt;&lt; '(' &lt;&lt; p.X &lt;&lt; ',' &lt;&lt; p.Y &lt;&lt; ')';<br>}<br> <br>template &lt;class A, class B&gt; vector&lt;A&gt; makeVec(int n, ...) {<br>  vector&lt;A&gt; answer(n);<br>  va_list vl;<br>  va_start(vl, n);<br>  for (int i(0); i &lt; n; ++i) answer[i] = va_arg(vl, B);<br>  va_end(vl);<br>  return answer;<br>}<br> <br>// Powered by PopsEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>