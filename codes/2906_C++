<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;queue&gt;<br>#include &lt;functional&gt;<br>using namespace std;<br> <br>typedef long long ll;<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;vector&lt;int&gt; &gt; vii;<br>typedef vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; viii;<br>typedef vector&lt;bool&gt; vb;<br>typedef vector&lt;vb&gt; vbb;<br>typedef vector&lt;double&gt; vd;<br>typedef vector&lt;ll&gt; vll;<br>typedef vector&lt;string&gt; vs;<br>typedef vector&lt;vs&gt; vss;<br> <br>typedef pair&lt;int,int&gt; pii;<br>typedef pair&lt;int,bool&gt; pib;<br>typedef pair&lt;int,pii&gt; piii;<br>typedef pair&lt;int,pib&gt; piib;<br>typedef pair&lt;int,piii&gt; piiii;<br>typedef pair&lt;int,piib&gt; piiib;<br>typedef pair&lt;int,piiii&gt; piiiii;<br>typedef pair&lt;int,piiib&gt; piiiib;<br>#define prr(a,b) make_pair((a),(b))<br>#define prrr(a,b,c) make_pair((a),make_pair((b),(c)))<br>#define prrrr(a,b,c,d) make_pair((a),make_pair((b),make_pair((c),(d))))<br>#define prrrrr(a,b,c,d,e) make_pair((a),make_pair((b),make_pair((c),make_pair((d),(e)))))<br>#define pss(a,b) make_pair((a),(b))<br> <br>#define fo(x,y) for((x)=0; (x)&lt;(y); (x)++)<br>#define fi(n) for(int i=0; i&lt;n; i++)<br>#define fj(n) for(int j=0; j&lt;n; j++)<br>#define fk(n) for(int k=0; k&lt;n; k++)<br>#define fl(n) for(int l=0; l&lt;n; l++)<br>#define fir(a,b) for(int i=(a); i&lt;=(b); i++)<br>#define fjr(a,b) for(int j=(a); j&lt;=(b); j++)<br>#define fkr(a,b) for(int k=(a); k&lt;=(b); k++)<br>#define pb push_back<br>#define sz size()<br> <br>class SensorGrid {<br>  //CODE BEGINS HERE<br> <br>  public:<br>  vector &lt;int&gt; largestRectangle(int width, int height, vector &lt;int&gt; x, vector &lt;int&gt; y) {<br>    int besty=INT_MAX; int bestx=INT_MAX; int bestw=-1; int besth=-1; int bestarea=-1;<br>    x.pb(-1); x.pb(width);<br>    y.pb(-1); y.pb(height);<br>    fi(y.sz) {<br>      int top = y[i] + 1;<br>      fj(y.sz) {<br>        int bottom = y[j] - 1;<br>        fk(x.sz) {<br>          int left = x[k] + 1;<br>          fl(x.sz) {<br>            int right = x[l] - 1;<br>            if(left&gt;right || top&gt;bottom) continue;<br>            bool bad=false;<br>            for(int m = 0; m &lt; x.sz; m++) {<br>              if(x[m] &gt;= left &amp;&amp; x[m] &lt;= right &amp;&amp; y[m]&gt;=top &amp;&amp; y[m]&lt;=bottom) bad=true;<br>            }<br>            if(bad);<br>              else {<br>                int w = right-left+1; int h=bottom-top+1;<br>                int area=w*h;<br>                if(area&gt;bestarea) {<br>                  besty = top; bestx=left; bestw=w; besth=h; bestarea=area;<br>                } else if(area == bestarea) {<br>                  if(top &lt; besty) {<br>                    besty = top; bestx=left; bestw=w; besth=h; bestarea=area;<br>                  }<br>                  else if(top == besty) {<br>                    if(left &lt; bestx) {<br>                      besty = top; bestx=left; bestw=w; besth=h; bestarea=area;<br>                    }<br>                    else if(left==bestx){<br>                      if(w &gt; bestw){<br>                        besty = top; bestx=left; bestw=w; besth=h; bestarea=area;<br>                      }<br>                    }<br>                  }<br>                }<br>              }<br>              <br>            }<br>          }<br>        }<br>      <br>    }<br>    vi ans(4);<br>    ans[0] = bestx; ans[1]=besty; ans[2]=bestw; ans[3]=besth;<br>            return ans;<br>  }<br> <br>  //NON-TEMPLATE CODE ENDS HERE<br>  map&lt;pair&lt;string, string&gt;, vs&gt; tokcache;<br>  vs tok(string s, string d){<br>    if(tokcache.count(pss(s,d))) return tokcache[pss(s,d)];<br>    vs ans;<br>    int laststart=0;<br>    fi(s.sz+1){<br>      bool isd=false;<br>      if(i==s.sz) isd=true;<br>      else fj(d.sz){<br>        if(s[i]==d[j]){<br>          isd=true; break;<br>        }<br>      }<br>      if(isd){<br>        if(laststart==i){<br>          laststart=i+1;<br>          continue;<br>        }<br>        ans.pb(s.substr(laststart,i-laststart));<br>        laststart=i+1;<br>      }<br>    }<br>    return tokcache[pss(s,d)]=ans;<br>  }<br>  vs tok(string s){<br>    return tok(s," ");<br>  }<br> <br>  template&lt;class T&gt;<br>  void swap(T &amp;a, T &amp;b){<br>    T temp=a;<br>    a=b;<br>    b=temp;<br>  }<br> <br>  ll lmod(ll a, ll b) {<br>    return a-a/b*b;<br>  }<br>  <br>  int gcd(int a, int b) {<br>    return (b) ? gcd(b,a%b) : a;<br>  }<br> <br>  int lcm(int a, int b){<br>    return a/gcd(a,b)*b;<br>  }<br> <br>  ll lgcd(ll a, ll b){<br>    return (b) ? gcd(b,lmod(a,b)) : a;<br>  }<br> <br>  ll lcm(ll a, ll b){<br>    return a/lgcd(a,b)*b;<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>