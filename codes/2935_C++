<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt; // find insert erase make_pair first second<br>#include &lt;set&gt;<br>#include &lt;cassert&gt; // assert<br>//#include &lt;queue&gt;<br>//#include &lt;cctype&gt; // isalpha isdigit isalnum isupper islower tolower toupper<br>#include &lt;string&gt; // size<br>#include &lt;vector&gt; // push_back pop_back front back<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt; // istringstream ostringstream<br>#include &lt;algorithm&gt; // next_permutation reverse count<br>#include &lt;numeric&gt; // accumulate<br>#include &lt;functional&gt;<br><br>using namespace std;<br><br>#ifndef TR // DEBUG OUTPUT MACRO<br>#  define TR(v) do{}while(0)<br>#  undef assert<br>#  define assert(expr) (void)(expr)<br>#endif<br>#define ALL(C) (C).begin(), (C).end()<br>#define forIter(I, C) for(typeof((C).begin()) I=(C).begin(); I!=(C).end(); ++I)<br>#define forN(I, C) for ( int I = 0; I &lt; (C); ++(I) )<br>#define forEach(I, C) forN(I,int((C).size()))<br>#define forEach2(I, J, C) forEach(I, C)forEach(J, (C)[I])<br>typedef long long i64; typedef unsigned long long u64;<br>typedef vector&lt;int&gt; VI; typedef vector&lt;VI&gt; VVI; typedef vector&lt;string&gt; VS;<br><br>#define METHOD QueenInterference::numSteps<br>struct QueenInterference<br>{<br>    i64 a;<br>    int random(int up)<br>    {<br>        int ret = a % up;<br>        a = 16807 * a % 2147483647;<br>        return ret;<br>    }<br><br>    int numSteps(int n) <br>    {<br>        a = 1;<br>        VI b;<br>        b.assign(n, -1);<br>        forN ( i, n )<br>            b[i] = random(n);<br>        VI reach, cnt;<br>        for ( int t = 0; ; ++t ) {<br>            TR(t|b);<br>            reach.clear();<br>            forN ( i, n ) {<br>                forN ( j, n ) {<br>                    if ( j == i ) continue;<br>                    if ( b[i] == b[j] || abs(b[i]-b[j]) == abs(i-j) ) {<br>                        reach.push_back(i);<br>                        break;<br>                    }<br>                }<br>            }<br>            if ( reach.empty() )<br>                return t;<br>            int c = reach[random(reach.size())];<br>            cnt.assign(n, 0);<br>            forN ( r, n ) {<br>                forN ( i, n ) {<br>                    if ( i == c ) continue;<br>                    if ( b[i] == r || abs(b[i]-r) == abs(i-c) ) {<br>                        ++cnt[r];<br>                    }<br>                }<br>            }<br>            int min_cnt = *min_element(ALL(cnt));<br>            int tied = count(ALL(cnt), min_cnt);<br>            int index = tied == 1? 0: random(tied);<br>            forN ( r, n ) {<br>                if ( cnt[r] == min_cnt ) {<br>                    if ( index-- == 0 ) {<br>                        b[c] = r;<br>                        break;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>};<br><br><br>// Powered by FileEdit<br></td>