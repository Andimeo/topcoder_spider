<td class="problemText" colspan="8" valign="middle" align="left">
            using namespace std;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;math.h&gt;<br>#include &lt;map&gt;<br>//#include &lt;istringstream&gt;<br><br>double mem[27][27];<br>const int HASH = 10001;<br>int nm;<br>struct state {<br>    int m[6];<br>};<br>struct entry {<br>    state s;<br>    double ans;<br>};<br><br>vector&lt;entry&gt; ht[HASH];<br><br>int int_comp( const void *a, const void *b )<br>{<br>    int x = *(const int *)a;<br>    int y = *(const int *)b;<br>    if (x &lt; y)<br>  return 1;<br>    else if (x &gt; y)<br>  return -1;<br>    else<br>  return 0;<br>}<br><br>class SureThing {<br>    public:<br>    <br>#if 0<br>    double test( int a, int b ) {<br>  if (a &gt; b)<br>      return test( b, a );<br>  if (a == 0)<br>      return pow( 2., b );<br>  if (mem[a][b] &gt; 0.1)<br>      return mem[a][b];<br>  double g1 = test( a-1, b );<br>  double g2 = test( a, b-1 );<br>  double x = (g1 - g2) / (g1 + g2);<br>  mem[a][b] = (1-x) * g1;<br>  printf( "%d %d -&gt; %f\n", a, b, mem[a][b] );<br>  return mem[a][b];<br>    }<br>#endif<br>    <br>    void sortit( state &amp;q ) {<br>  qsort( q.m, nm, sizeof(int), int_comp );<br>    }<br><br>    int hashit( state &amp;q ) {<br>  int h = 0;<br>  for (int i = 0; i &lt; nm; i++) {<br>      h = 137 * h + q.m[i];<br>      h %= HASH;<br>  }<br>  return h;<br>    }<br><br>    double lookup( state &amp;q ) {<br>  int z = hashit( q );<br>  for (int i = 0; i &lt; ht[z].size(); i++) {<br>      for (int j = 0; j &lt; nm; j++)<br>    if (ht[z][i].s.m[j] != q.m[j])<br>        goto bad;<br>      return ht[z][i].ans;<br>      bad:;}<br>  return 0;<br>    }<br>    <br>    void store( state &amp;q, double y ) {<br>  int z = hashit( q );<br>  entry e; e.s = q; e.ans = y;<br>  ht[z].push_back( e );<br>#if 0<br>  for (int i = 0; i &lt; nm; i++)<br>      fprintf( stderr, "%d ", q.m[i] );<br>  fprintf( stderr, "-&gt; %f\n", y );<br>#endif<br>    }<br><br>    double g( state s ) {<br>  state q = s;<br>#if 0<br>  for (int i = 0; i &lt; nm; i++)<br>      fprintf( stderr, "%d ", q.m[i] );<br>  fprintf( stderr, "\n" );<br>#endif<br>  sortit( q ); // non-increasing  order<br>  if (nm == 1 || q.m[1] == 0)<br>      return pow( 2., q.m[0] );<br>  double foo;<br>  if ((foo = lookup( q )) &gt; 0)<br>      return foo;<br>  q.m[1]--;<br>  double g1 = g( q );<br>  q.m[1]++;<br>  q.m[0]--;<br>  double g2 = g( q );<br>  q.m[0]++;<br>  double x = (g1 - g2) / (g1 + g2);<br>  double ans = (1-x) * g1;<br>  store( q, ans );<br>  return ans;<br>    }<br><br>    double maximum(vector &lt;int&gt; marbles) {<br>  state s;<br>  nm = marbles.size();<br>  for (int i = 0; i &lt; nm; i++)<br>      s.m[i] = marbles[i];<br>  return g( s );<br>    }<br>};<br><br><br><br>// Powered by FileEdit<br></td>