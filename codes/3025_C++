<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br> <br>using namespace std;<br> <br>typedef long long int64;<br> <br>#define FOR(i,n) for (int i=0; i&lt;n; i++)<br>#define FOREACH(i,c) for (typeof((c).begin()) i=(c).begin() ; i!=(c).end(); i++)<br>#define ALL(t) t.begin(),t.end()<br>#define D(i) cout&lt;&lt;(i)&lt;&lt;endl<br> <br>template&lt;typename T&gt; string str(const T &amp;t) { ostringstream s; s&lt;&lt;(t); return s.str(); }<br>int64 val(const string &amp;s) { istringstream t(s); int64 i; t&gt;&gt;i; return i; }<br> <br>vector&lt;string&gt; split(string s,string w=" ") {<br>  vector&lt;string&gt; a;<br>  s+=w;<br>  for (int p=0,pp; (p=s.find_first_not_of(w,p))+1; p=pp)<br>    a.push_back(s.substr(p,(pp=s.find_first_of(w,p))-p));<br>  return a;<br>}<br> <br>template&lt;typename T,typename TT&gt; ostream &amp;operator&lt;&lt;(ostream &amp;s,pair&lt;T,TT&gt; t) {<br>  return s&lt;&lt;"("&lt;&lt;t.first&lt;&lt;","&lt;&lt;t.second&lt;&lt;")";<br>}<br> <br>template&lt;typename T&gt; ostream &amp;operator&lt;&lt;(ostream &amp;s,vector&lt;T&gt; t) { <br>  s&lt;&lt;"["; <br>  FOR(i,t.size())<br>    s&lt;&lt;t[i]&lt;&lt;(i==t.size()-1?"":",");<br>  return s&lt;&lt;"]"&lt;&lt;endl; <br>}<br> <br>///////////////////////////////////////////////////////////////////////////////////<br> <br>string s;<br>int next;<br>void eat() {<br>  while (next&lt;s.length() &amp;&amp; s[next]!='&lt;')<br>    next++;<br>}<br> <br>struct Tree {<br>  string tag;<br>  vector&lt;Tree&gt; children;<br>  Tree(int x) {<br>    eat();<br>    tag="";<br>    next++;<br>    while (s[next]!='&gt;')<br>      tag+=s[next++];<br>    eat();<br>    while (s[next+1]!='/') {<br>      children.push_back(Tree(x+1));<br>      eat();<br>    }<br>    while (s[next]!='&gt;')<br>      next++;<br>    next++;<br>  }<br>  bool sub(Tree &amp;tree) {<br>    if (tag!=tree.tag || tree.children.size()&gt;children.size())<br>      return false;<br>    int i=0;<br>    FOR(j,children.size())<br>      if (i&lt;tree.children.size() &amp;&amp; children[j].sub(tree.children[i]))<br>        i++;<br>    return i==tree.children.size();<br>  }<br>  int size() {<br>    int r=1;<br>    FOR(i,children.size())<br>      r+=children[i].size();<br>    return r;<br>  }<br>};<br> <br>class bloggoDocStructure {<br>public:<br>  string compare(vector &lt;string&gt; docA, vector &lt;string&gt; docB) {<br>    s="";<br>    FOR(i,docA.size())<br>      s+=docA[i];<br>    next=0;<br>    Tree tA(1);<br>    s="";<br>    FOR(i,docB.size())<br>      s+=docB[i];<br>    next=0;<br>    Tree tB(1); <br>    if (tA.sub(tB) &amp;&amp; tB.sub(tA))<br>      return "equivalent";<br>    if (tA.sub(tB))<br>      return "outtree "+str(tA.size()-tB.size());<br>    if (tB.sub(tA))<br>      return "intree "+str(tB.size()-tA.size());<br>    return "incompatible";<br>  }<br>};<br> <br> <br>// Powered by PopsEdit<br></td>