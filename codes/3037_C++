<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cassert&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;limits&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;numeric&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br><br>using namespace std;<br><br>#define VAR(i,e) __typeof(e) i = (e)<br>#define FOREACH(i,___C) for (VAR(i, (___C).begin()); i != (___C).end(); ++i)<br><br>#define ALL(___C) (___C).begin(), (___C).end()<br>#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())<br><br>/* LIBRARY */<br><br>/* DEF START SUM */<br>template&lt;typename ___C&gt;<br>int SUM(const ___C &amp; c){<br>        return accumulate(ALL(c), 0);<br>}<br>/* DEF END SUM */<br><br>/* DEF START MIN */<br>template&lt;typename ___C&gt;<br>int MIN(const ___C &amp; c){<br>        return *min_element(ALL(c));<br>}<br>/* DEF END MIN */<br><br><br>/* DEF START MAX */<br>template&lt;typename ___C&gt;<br>int MAX(const ___C &amp; c){<br>        return *max_element(ALL(c));<br>}<br>/* DEF END MAX */<br><br>/* DEF START DEBUG */<br>template &lt;typename ___C&gt;<br>void DEBUG(const ___C &amp; c, const string &amp; beg = "", const string &amp; delim = " "){<br>        cout &lt;&lt; beg;<br>        FOREACH(it, c)cout &lt;&lt; *it &lt;&lt; delim;<br>        cout &lt;&lt; endl;<br>}<br>/* DEF END DEBUG */<br><br>#define ISL(x) ((x &gt;= 'a' &amp;&amp; x &lt;= 'z') || (x &gt;= 'A' &amp;&amp;x &lt;= 'Z'))<br>#define FOR(a,b,c) for(int a = b; a &lt; c; ++a)<br>#define FORI(p, x) for(int i = p; i &lt; x; ++i)<br>#define FORJ(p, x) for(int j = p; j &lt; x; ++j)<br>#define FORK(p, x) for(int k = p; k &lt; x; ++k)<br>#define FORL(p, x) for(int l = p; l &lt; x; ++l)<br>#define PB push_back<br>#define MP make_pair<br>#define X first<br>#define Y second<br>#define S size()<br><br>#define C cout<br>#define LL long long<br>#define ISS istringstream<br>#define OSS ostringstream<br>#define VI vector&lt;int&gt;<br>#define VVI vector&lt;vector&lt;int&gt; &gt;<br>#define VS vector&lt;string&gt;<br>#define VD vector&lt;double&gt;<br>#define VVD vector&lt;vector&lt;double&gt; &gt;<br>#define VVS vector&lt;vector&lt;string&gt; &gt;<br>#define SI set&lt;int&gt;<br>#define SS set&lt;string&gt;<br>#define SVI set&lt;vector&lt;int&gt; &gt;<br>#define SVD set&lt;vector&lt;double&gt; &gt;<br>#define SVS set&lt;vector&lt;string&gt; &gt;<br><br>#define INF numeric_limits&lt;int&gt;::max()<br>#define MINF numeric_limits&lt;int&gt;::min()<br><br>/* DEF START MAP */<br>#define MAP(CONTAINER, CTYPE, NAME, SOURCE, FUN) \<br>CONTAINER&lt;CTYPE&gt; NAME;\<br>{\<br>        vector&lt;CTYPE&gt; ___map_tmp_helper;\<br>        FOREACH(___it, SOURCE){\<br>                ___map_tmp_helper.push_back(FUN);\<br>        }\<br>        NAME = CONTAINER&lt;CTYPE&gt;(ALL(___map_tmp_helper));\<br>}<br>/* DEF END MAP */<br><br>/* DEF START REMAP */<br>#define REMAP(NAME, SOURCE, FUN) \<br>{\<br>        typedef __typeof(NAME) ___NAME_TYPE;\<br>        vector&lt;___NAME_TYPE::value_type&gt; ___map_tmp_helper;\<br>        FOREACH(___it, SOURCE){\<br>                ___map_tmp_helper.push_back(FUN);\<br>        }\<br>        NAME = __typeof(NAME)(ALL(___map_tmp_helper));\<br>}<br>/* DEF END REMAP */<br><br>/* DEF START CAST */<br>template&lt;typename ___T1, typename ___T2&gt;<br>___T1 CAST(___T2 t2){<br>        OSS oss;<br>        oss &lt;&lt; t2;<br>        ISS iss(oss.str());<br>        ___T1 t1;<br>        iss &gt;&gt; t1;<br>        return t1;<br>}<br>/* DEF END CAST */<br><br>/* DEF START CAST */<br>template&lt;typename ___C1, typename ___C2, typename ___T1, typename ___T2&gt;<br>___C1 CAST(___C2 c2, ___T1 (* fun) (___T2)){<br>        ___C1 c1;<br>        transform(ALL(c2), back_inserter(c1), fun);<br>        return c1;<br>}<br>/* DEF END CAST */<br><br>/* DEF START tokenize */<br>VS tokenize(string s, string delim = " "){<br>        VS vs;<br>        if(s.S == 0)return vs;<br>        int beg = 0;<br>        while(true){<br>                int end = s.find(delim, beg);<br>                vs.PB(s.substr(beg, end - beg));<br>                if(end == string::npos)return vs;<br>                beg = end + 1;<br>        }<br>}<br>/* DEF END tokenize */<br><br>/* DEF START gcd */<br>template&lt;typename ___T&gt;<br>___T gcd(___T t1, ___T t2){<br>        while(t2 &gt; 0){<br>                ___T t = t2;<br>                t2 = t1 % t2;<br>                t1 = t;<br>        }<br>        return t1;<br>}<br>/* DEF END gcd */<br><br>/* MAIN CODE */<br><br><br>class Thesaurus{<br>public:<br><br>bool match(const set&lt;string&gt; &amp; s1, const set&lt;string&gt; &amp; s2){<br>  set&lt;string&gt; s;<br>  FOREACH(it, s1)if(s2.find(*it) != s2.end())s.insert(*it);<br>  return (s.S &gt; 1);<br>}<br><br>void unify(set&lt;string&gt; &amp; s1, set&lt;string&gt; &amp; s2){<br>  FOREACH(it, s2)<br>    s1.insert(*it);<br>  s2 = set&lt;string&gt;();<br>}<br><br>vector &lt;string&gt; edit(vector &lt;string&gt; entry){<br>  vector&lt;set&lt;string&gt; &gt; vss;<br>  FOREACH(it, entry){<br>    VS vs = tokenize(*it);<br>    vss.PB(set&lt;string&gt;(vs.begin(), vs.end()));<br>  }<br><br>  bool progress = true;<br><br>  while(progress){<br>    progress = false;<br>    FORI(0, vss.S){<br>      FORJ(0, vss.S){<br>        if(i == j)continue;<br>        if(match(vss[i], vss[j])){<br>          unify(vss[i], vss[j]);<br>          progress = true;<br>          break;<br>        }<br>      }<br>      if(progress)break;<br>    }<br>  }<br>  sort(ALL(vss));<br>  VS res;<br>  FOREACH(it, vss){<br>    if(it -&gt; empty())continue;<br>    OSS oss;<br>    bool space = false;<br>    FOREACH(jt, *it){<br>      if(space)oss &lt;&lt; ' ';<br>      space = true;<br>      oss &lt;&lt; *jt;<br>    }<br>    res.PB(oss.str());<br>  }<br>  return res;<br>}<br><br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>