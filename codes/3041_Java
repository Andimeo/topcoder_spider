<td class="problemText" colspan="8" valign="middle" align="left">
            // PROBLEM STATEMENT<br>// <br>// XML documents are widely used today to describe many different kinds<br>// of data. The primary purpose of XML is to allow people to share<br>// textual and numerical data in a structured format across the Internet.<br>// Note that the XML document format described in this problem is a simplified version<br>// of the actual XML format.<br>// <br>// <br>// <br>// An XML document contains tags and plain text. Tags are used to define blocks within<br>// the XML document. A block always begins with a start-tag and ends with a<br>// corresponding end-tag. The format of these tags are &lt;tag-name&gt;<br>// and &lt;/tag-name&gt;, respectively.<br>// The tag-name for an end-tag is the same (including case) as the start-tag<br>// for the block it closes. All plain text data must be inside at least one block.<br>// The plain text will not contain the characters '&lt;', '&gt;' and '/'.<br>// <br>// <br>// Blocks may be nested, but cannot overlap. So for instance, <br>// "&lt;root&gt;&lt;data&gt;Hello world&lt;/data&gt;&lt;/root&gt;"<br>// and<br>// "&lt;root&gt;Hello&lt;/root&gt;&lt;root&gt;world&lt;/root&gt;"<br>// are valid XML documents, while<br>// "&lt;root&gt;&lt;data&gt;Hello world&lt;/root&gt;&lt;/data&gt;"<br>// and<br>// "&lt;root&gt;Hello&lt;/root&gt; &lt;root&gt;world&lt;/root&gt;"<br>// are not; the first one has overlapping blocks (the tag &lt;data&gt; must end<br>// before the outer tag &lt;root&gt; ends), the second has text - a space - outside<br>// all blocks (in this problem, spaces are treated just like any other character, see example 2).<br>// <br>// <br>// Your task is to write a program which formats an XML document, according to the following<br>// rules: If a block contains other blocks, the start- and end-tags for that block should<br>// be on lines by themselves, and all tags and text inside this block should be indented<br>// by 3 spaces per open tag. Otherwise the start- and end-tags should be on the same line, with the <br>// textual<br>// content of the block (if any) between the tags (and nothing else, except indentation,<br>// may appear on this line). See example 0 for clarifications.<br>// <br>// <br>// <br>// Create a class BadXML containing the method<br>// format which takes a String[] doc, the XML document,<br>// and returns a String[] containing the properly indented XML document.<br>// Concatenate the elements in doc to get the full XML document.<br>// <br>// <br>// <br>// DEFINITION<br>// Class:BadXML<br>// Method:format<br>// Parameters:String[]<br>// Returns:String[]<br>// Method signature:String[] format(String[] doc)<br>// <br>// <br>// NOTES<br>// -Spaces are treated like any other character, see example 2.<br>// <br>// <br>// CONSTRAINTS<br>// -doc will contain between 1 and 50 elements, inclusive.<br>// -Each element in doc will contain between 0 and 50 characters, inclusive.<br>// -The characters in the elements of doc will have ASCII values between 32 and 126, inclusive.<br>// -The characters '&lt;', '&gt;' and '/' will only be used in tags.<br>// -A tag-name will not contain any of the characters '&lt;', '&gt;', '/' or space.<br>// -A tag-name will contain at least one character.<br>// -doc will describe a valid XML document according to the description above, and will contain at <br>// least one block.<br>// -The return value will contain at most 100 elements, and no element will contain more than 80 <br>// characters.<br>// <br>// <br>// EXAMPLES<br>// <br>// 0)<br>// {"&lt;article&gt;",<br>//  "&lt;author&gt;writer&lt;/author&gt;",<br>//  "&lt;headline&gt;TopCoder",<br>//  " ",<br>//  "Open 2004&lt;/headline&gt;",<br>//  "&lt;ingress&gt;",<br>//  "&lt;/ingress&gt;",<br>//  "&lt;paragraph&gt;",<br>//  "TopCoder Open is being held at &lt;st:hotel&gt;",<br>//  "Santa Clara Marriott&lt;/st:hotel&gt;",<br>//  "which lies in the northern part of ",<br>//  "&lt;st:state&gt;California&lt;/st:state&gt;.",<br>//  "&lt;/paragraph&gt;",<br>//  "&lt;paragraph&gt;",<br>//  "&amp;lbr;Image&amp;rbr;",<br>//  "&lt;/paragraph&gt;",<br>//  "&lt;/article&gt;"}<br>// <br>// <br>// Returns: { "&lt;article&gt;",  "   &lt;author&gt;writer&lt;/author&gt;",  "   &lt;headline&gt;TopCoder Open <br>// 2004&lt;/headline&gt;",  "   &lt;ingress&gt;&lt;/ingress&gt;",  "   &lt;paragraph&gt;",  "      TopCoder Open is being <br>// held at ",  "      &lt;st:hotel&gt;Santa Clara Marriott&lt;/st:hotel&gt;",  "      which lies in the northern <br>// part of ",  "      &lt;st:state&gt;California&lt;/st:state&gt;",  "      .",  "   &lt;/paragraph&gt;",  "   <br>// &lt;paragraph&gt;&amp;lbr;Image&amp;rbr;&lt;/paragraph&gt;",  "&lt;/article&gt;" }<br>// <br>// The block surrounded by the paragraph tags contain two nested blocks as well as three plain text <br>// strings. All these end up on separate lines. The other plain text strings end up on the same line <br>// as the tags in the blocks they are surrounded by.<br>// <br>// 1)<br>// {"&lt;ro","ot&gt;A roo","","t node&lt;/r","oot&gt;&lt;","root&gt;Anot","her root node&lt;/ro","ot&gt;",""}<br>// <br>// Returns: { "&lt;root&gt;A root node&lt;/root&gt;",  "&lt;root&gt;Another root node&lt;/root&gt;" }<br>// <br>// An XML document may contain several blocks at the top level.<br>// <br>// 2)<br>// {"&lt;outer_tag&gt;",<br>//  "   &lt;inner_tag&gt;",<br>//  "      Some text",<br>//  "   &lt;/inner_tag&gt;",<br>//  "&lt;/outer_tag&gt;"}<br>// <br>// <br>// Returns: { "&lt;outer_tag&gt;",  "      ",  "   &lt;inner_tag&gt;      Some text   &lt;/inner_tag&gt;",  <br>// "&lt;/outer_tag&gt;" }<br>// <br>// The indentation in the input is treated as space characters and is not removed.<br>// <br>// <br>import java.util.*;<br>public class BadXML {<br>  static class Tree {<br>    boolean f;<br>    String t;<br>    List c;<br>    Tree(String t) {<br>      f = true;<br>      this.t = t;<br>      c = new ArrayList();<br>    }<br>    Tree(String t, List c) {<br>      f = false;<br>      this.t = t;<br>      this.c = c;<br>    }<br>    void print(List l, String i) {<br>      if (f) {<br>  l.add(i + t);<br>      } else if (c.size() &lt; 2 &amp;&amp; (c.size() == 0 || ((Tree) c.get(0)).f)) {<br>  String s = i + "&lt;" + t + "&gt;";<br>  if (c.size() &gt; 0) s += ((Tree) c.get(0)).t;<br>  s += "&lt;/" + t + "&gt;";<br>  l.add(s);<br>      } else {<br>  l.add(i + "&lt;" + t + "&gt;");<br>  String s = i + "   ";<br>  for (Iterator j = c.iterator(); j.hasNext(); ) {<br>    Tree t = (Tree) j.next();<br>    t.print(l, s);<br>  }<br>  l.add(i + "&lt;/" + t + "&gt;");<br>      }<br>    }<br>  }<br>  int idx;<br>  Tree parse(String m) {<br>    if (m.charAt(idx) == '&lt;') {<br>      int p = m.indexOf('&gt;', idx);<br>      String n = m.substring(idx + 1, p);<br>      idx = p + 1;<br>      ArrayList l = new ArrayList();<br>      while (m.charAt(idx + 1) != '/') {<br>  l.add(parse(m));<br>      }<br>      p = m.indexOf('&gt;', idx);<br>      idx = p + 1;<br>      return new Tree(n, l);<br>    } else {<br>      int p = m.indexOf('&lt;', idx);<br>      Tree t =  new Tree(m.substring(idx, p));<br>      idx = p;<br>      return t;<br>    }<br>  }<br>  public String[] format(String[] doc) {<br>    StringBuffer b = new StringBuffer();<br>    for (int i = 0; i &lt; doc.length; i++) b.append(doc[i]);<br>    String m = b.toString();<br>    idx = 0;<br>    ArrayList l = new ArrayList();<br>    while (idx &lt; m.length()) {<br>      Tree t = parse(m);<br>      t.print(l, "");<br>    }<br>    return (String[]) l.toArray(new String[0]);<br>  }<br>}<br><br><br>// Powered by FileEdit<br></td>