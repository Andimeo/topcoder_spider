<td class="problemText" colspan="8" valign="middle" align="left">
            using System; using System.Collections; using System.Text; using System.Text.RegularExpressions;<br>public class LeftmostDerivation { public string[] getDeriv(string S, string F) {<br>for (int i=0; i&lt;51; i++) for (int j=0; j&lt;51; j++) best[i,j] = AR;<br>int sl = S.Length, fl = F.Length;<br>Empty.Add("");<br> <br>for (int a=0; a&lt;S.Length; a++) for (int b=-1; b&lt;F.Length; b++)<br> {<br> if (a == b &amp;&amp; String.CompareOrdinal(S, sl-a-1, F, fl-a-1, a+1) == 0)<br>  {<br>  best[a+1,b+1].Add(S.Substring(sl-a-1));<br>  continue;<br>  }<br> <br> int nt = sl-a-1;<br> while (nt &lt; sl &amp;&amp; Char.IsLower(S[nt])) nt++;<br> <br> if (nt &gt;= sl)<br>  {<br>  if (a != b) continue;<br>  if (String.CompareOrdinal(S, sl-a-1, F, fl-a-1, a+1) != 0) continue;<br>  best[a+1,b+1].Add(S.Substring(sl-a-1));<br>  continue;<br>  }<br> <br> // verify left of nt is match<br> int leftLen = nt-(sl-a-1);<br> if (!Match(S, sl-a-1, F, fl-b-1, leftLen)) continue;<br> <br> for (int rep=0; rep&lt;=(b+1)-leftLen; rep++)<br>  {<br>  //WSL(a,b,leftLen,rep);<br>  // verify right of nt is match<br>  // if (!Match(S, nt+1, F, fl-b-1+leftLen+rep)) continue;<br>  <br>  String repTarget = F.Substring(fl-b-1+leftLen, rep);<br>  <br>  // if rep includes any NTs, must include all NTs UNLESS rest matches<br>  bool any = false;<br>  foreach (char c in repTarget) if (Char.IsUpper(c)) { any = true; break; }<br>  bool ok = true;<br>  if (any)<br>   for (int i=nt+1; i&lt;sl; i++) if (Char.IsUpper(S[i])) { ok = false; break; }<br>   //for (int i=fl-b-1+leftLen+rep; i&lt;fl; i++) if (Char.IsUpper(F[i])) { ok = false; break; }<br>  <br>  bool aDone=(nt == sl-1), bDone =(b-leftLen-rep &lt; 0);<br>  ArrayList sub;<br>  if (aDone &amp;&amp; bDone)<br>   sub = Empty;<br>  else if (aDone)<br>   continue;<br>  else<br>   { sub = best[sl-nt-1,b-leftLen-rep+1]; if (sub == null || sub.Count == 0) continue; }<br>  <br>  if (!ok &amp;&amp; sub.Count&gt;1) continue;<br>  <br>  String prefix = S.Substring(sl-a-1, nt-(sl-a-1)) + repTarget;<br>  if (best[a+1,b+1].Count == 0 || Better(sub, best[a+1,b+1], prefix))<br>   {<br>   best[a+1,b+1] = AR;<br>   best[a+1,b+1].Add(S.Substring(sl-a-1));<br>   foreach (String s in sub)<br>    best[a+1,b+1].Add(prefix + s);<br>   }<br> <br>  }<br> <br> }<br> <br> <br>foreach (String sss in SA(best[S.Length, F.Length])) WSL(sss);<br> <br>return SA(best[S.Length, F.Length]);<br>}<br> <br>// best[A,B]: derivation from last A of S to last B of F<br>ArrayList[,] best = new ArrayList[51,51];<br>ArrayList Empty = AR;<br> <br>bool Match(String s, int sp, String f, int fp, int len)<br>{<br>if (fp+len&gt;f.Length) return false;<br>return String.CompareOrdinal(s, sp, f, fp, len) == 0;<br>}<br> <br>bool Better(ArrayList sub, ArrayList sup, String prefix)<br>{<br>if (sub.Count &lt; sup.Count-1) return true;<br>if (sub.Count &gt; sup.Count-1) return false;<br> <br>int a=0, b=1, x=0, y=0;<br>String p=(String)sub[a], q=(String)sup[b];<br>while (true)<br> {<br> while (p != null &amp;&amp; x&gt;=p.Length+prefix.Length) { x=0; a++; p=(a&lt;sub.Count) ? (String)sub[a] : null; }<br> while (q != null &amp;&amp; y&gt;=q.Length) { y=0; b++; q=(b&lt;sup.Count) ? (String)sup[b] : null; }<br> if (p==null) return true;<br> if (q==null) return false;<br> char c = (x&lt;prefix.Length) ? prefix[x] : p[x-prefix.Length];<br> if (c != q[y]) return (int)c &lt; (int)q[y];<br> x++; y++;<br> }<br> <br>}<br> <br> <br> <br> <br>bool Test(int x, int y) { return (x &amp; (1&lt;&lt;y)) != 0; }<br> <br>static ArrayList AR { get { return new ArrayList(); }}<br>Hashtable MAP { get { return new Hashtable(); }}<br> <br>int[] IA(ArrayList ar) { return (int[]) ar.ToArray(typeof(int)); }<br>string[] SA(ArrayList ar) { return (string[]) ar.ToArray(typeof(string)); }<br> <br>int INT(Object o) { return Convert.ToInt32(o.ToString()); }<br>long LONG(Object o) { return Convert.ToInt64(o.ToString()); }<br>double DOUBLE(Object o) { return Convert.ToDouble(o.ToString()); }<br> <br>void WL() { Console.WriteLine(); }<br>void WS(params Object[] a) { foreach (Object o in a) Console.Write("{0} ", o); }<br>void WSL(params Object[] a) { WS(a); WL(); }<br>void WS(Array a, int X) { for (int i=0; i&lt;X; i++) WS(a.GetValue(i)); WL(); }<br>void WS(Array a, int X, int Y) { for (int y=0; y&lt;Y; y++) { for (int x=0; x&lt;X; x++) WS(a.GetValue(x,y)); WL(); }}<br> <br>bool NextPerm(int[] a)<br>{<br>int N=a.Length;<br>for (int i=N-2; i&gt;=0; i--) if (a[i] &lt; a[i+1])<br> {<br> Array.Reverse(a, i+1, N-i-1);<br> for (int j=i+1; ; j++) if (a[i] &lt; a[j]) { int t=a[i]; a[i]=a[j]; a[j]=t; return true; }<br> }<br>return false;<br>}<br> <br>}<br></td>