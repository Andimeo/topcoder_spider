<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br>import java.text.*;<br> <br>public class Reconstruct {<br>  private int P;<br>  private int[][] ps;<br>  private int distance(int[] p1, int[] p2) {<br>    int i, A=0;<br>    for (i=0; i&lt;3; i++)<br>      A+=(p1[i]-p2[i])*(p1[i]-p2[i]);<br>    return A;<br>  }<br>  private boolean ok(int p, int[] cs, int[][] mx) {<br>    if (p==P) return true;<br>    int i, x, y, z;<br>    for (i=0; i&lt;p; i++)<br>      if (distance(ps[i], cs)!=mx[i][p]) break;<br>    if (i&lt;p) return false;<br>    ps[i]=cs;<br>    for (x=-32; x&lt;=32; x++)<br>      for (y=-32; y&lt;=32; y++)<br>        for (z=-32; z&lt;=32; z++)<br>          if (ok(p+1, new int[] {x, y, z}, mx))<br>            return true;<br>    return false;<br>  }<br>  public String[] findPoints(String[] ds) {<br>    if ((P=ds.length)==1) return new String[] {"0 0 0"};<br>    int i, j, x, y, z;<br>    ps=new int[P][3];<br>    int[][] mx=new int[P][P];<br>    for (i=0; i&lt;P; i++) {<br>      StringTokenizer st=new StringTokenizer(ds[i]);<br>      for (j=0; j&lt;P; j++)<br>        mx[i][j]=Integer.parseInt(st.nextToken());<br>    }<br>    for (x=0; x&lt;=50; x++)<br>      for (y=0; y&lt;=50; y++)<br>        for (z=0; z&lt;=50; z++)<br>          if (ok(1, new int[] {x, y, z}, mx)) {<br>            String[] A=new String[P];<br>            for (i=0; i&lt;P; i++)<br>              A[i]=ps[i][0]+" "+ps[i][1]+" "+ps[i][2];<br>            return A;<br>          }<br>    return new String[] {};<br>  }<br>}<br></td>