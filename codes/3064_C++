<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;deque&gt;<br>#include &lt;vector&gt;<br> <br>using namespace std;<br> <br>int dist[55][55][1&lt;&lt;10];<br>int otacam[55][55];<br>int ho[55][55];<br>int ve[55][55];<br>int dx[]={1,-1,0,0};<br>int dy[]={0,0,1,-1};<br>class RevolvingDoors {<br>public:<br>  int turns(vector &lt;string&gt; map) {<br>    for (int i=0;i&lt;map.size();i++) {<br>      map[i]='#'+map[i]+'#';<br>    }<br>    memset(otacam,-1,sizeof(otacam));<br>    string s(map[0].size(),'#');<br>    map.push_back(s);<br>    map.insert(map.begin(),s);<br>    memset(dist,-1,sizeof(dist));<br>    memset(ho,-1,sizeof(ho));<br>    memset(ve,-1,sizeof(ve));<br>    vector&lt;pair&lt;int,int&gt; &gt; dvere;<br>    int si=0,sj=0,ei=0,ej=0;<br>    int poc=0;<br>    for (int i=0;i&lt;map.size();i++) {<br>      for (int j=0;j&lt;map[0].size();j++) {<br>        if (map[i][j]=='O') {<br>          if (map[i-1][j]=='|' || map[i+1][j]=='|') {<br>            poc|=1&lt;&lt;dvere.size();<br>          }<br>          otacam[i+1][j+1]=dvere.size();<br>          otacam[i+1][j-1]=dvere.size();<br>          otacam[i-1][j+1]=dvere.size();<br>          otacam[i-1][j-1]=dvere.size();<br>          <br>          ve[i-1][j]=dvere.size();<br>          ve[i+1][j]=dvere.size();<br>          <br>          ho[i][j-1]=dvere.size();<br>          ho[i][j+1]=dvere.size();<br>          <br>          dvere.push_back(make_pair(i,j));<br>        }<br>        if (map[i][j]=='S') {<br>          si=i; sj=j;<br>          map[i][j]=' ';<br>        }<br>        if (map[i][j]=='E') {<br>          ei=i; ej=j;<br>          map[i][j]=' ';<br>        }<br>      }<br>    }<br>    for (int i=0;i&lt;map.size();i++) {<br>      for (int j=0;j&lt;map[0].size();j++) {<br>        if (map[i][j]=='-' || map[i][j]=='|') <br>          map[i][j]=' ';<br>      }<br>    }<br>    dist[si][sj][poc]=0;<br>    deque&lt;pair&lt;pair&lt;char,char&gt;,int&gt; &gt; q;<br>    q.push_back(make_pair(make_pair(si,sj),poc));<br>    while (!q.empty()) {<br>      int ai=q.front().first.first;<br>      int aj=q.front().first.second;<br>      int as=q.front().second;<br>      if (ai==ei &amp;&amp; aj==ej) return dist[ai][aj][as];<br>      q.pop_front();<br>      for (int d=0;d&lt;4;d++) {<br>        int ni=ai+dx[d];<br>        int nj=aj+dy[d];<br>        if (ho[ni][nj]!=-1 &amp;&amp; ((1&lt;&lt;ho[ni][nj])&amp;as)==0) continue;<br>        if (ve[ni][nj]!=-1 &amp;&amp; ((1&lt;&lt;ve[ni][nj])&amp;as)) continue;<br>        if (map[ni][nj]==' ' &amp;&amp; (dist[ni][nj][as]==-1 || dist[ni][nj][as]&gt;dist[ai][aj][as])) {<br>          q.push_front(make_pair(make_pair(ni,nj),as));<br>          dist[ni][nj][as]=dist[ai][aj][as];<br>        }<br>      }<br> <br>      if (otacam[ai][aj]!=-1) {<br>        if (dist[ai][aj][as^(1&lt;&lt;otacam[ai][aj])]==-1 || dist[ai][aj][as^(1&lt;&lt;otacam[ai][aj])]&gt;dist[ai][aj][as]+1) {<br>          q.push_back(make_pair(make_pair(ai,aj),as^(1&lt;&lt;otacam[ai][aj])));<br>          dist[ai][aj][as^(1&lt;&lt;otacam[ai][aj])]=dist[ai][aj][as]+1;<br>        }<br>      }<br>      <br> <br>    }<br> <br>    return -1;<br>  }<br>  <br> <br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>