<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>public class RevolvingDoors {<br>  int h;<br>  int w;<br>  int nd;<br>  char[][] m;<br>  boolean[][][] v;<br>  PQ q;<br>  static class Entry {<br>    public int key;<br>    public int x, y, d;<br>    public Entry(int key, int a, int b, int c) {<br>      this.key = key;<br>      x = a;<br>      y = b;<br>      d = c;<br>    }<br>  }<br>  static class PQ {<br>    ArrayList q = new ArrayList();<br>  <br>    public boolean isEmpty() {<br>      return q.isEmpty();<br>    }<br>  <br>    int parent(int i) {<br>      return (i+1)/2-1;<br>    }<br>    int left(int i) {<br>      return (i+1)*2-1;<br>    }<br>    int right(int i) {<br>      return (i+1)*2;<br>    }<br>    public void add(int key, int x, int y, int d) {<br>      q.add(null);<br>      int i = q.size() - 1;<br>      while (i &gt; 0 &amp;&amp; ((Entry) q.get(parent(i))).key &gt; key) {<br>        q.set(i, q.get(parent(i)));<br>        i = parent(i);<br>      }<br>      q.set(i, new Entry(key, x, y, d));<br>    }<br>    public Entry popEntry() {<br>      Entry e = (Entry) q.get(0);<br>      q.set(0, q.get(q.size() - 1));<br>      q.remove(q.size() - 1);<br>    <br>      int i = 0;<br>      boolean done = false;<br>      while (!done) {<br>        int l = left(i), r = right(i);<br>        int min = i;<br>        if (l &lt; q.size() &amp;&amp; ((Entry) q.get(l)).key &lt; ((Entry) q.get(min)).key) {<br>          min = l;<br>        }<br>        if (r &lt; q.size() &amp;&amp; ((Entry) q.get(r)).key &lt; ((Entry) q.get(min)).key) {<br>          min = r;<br>        }<br>        if (min != i) {<br>          Object temp = q.get(min);<br>          q.set(min, q.get(i));<br>          q.set(i, temp);<br>          i = min;<br>        } else {<br>          done = true;<br>        }<br>      }<br>      return e;<br>    }<br>  }<br>  void add(Entry e, int dx, int dy) {<br>    int x = e.x + dx;<br>    int y = e.y + dy;<br>    if (x &lt; 0 || y &lt; 0 || x &gt;= w || y &gt;= h || m[y][x] == '#') return;<br>    int k = e.key;<br>    int s = e.d;<br>    if (m[y][x] &gt;= 150) {<br>      int d = m[y][x] - 150;<br>      if ((s &amp; 1 &lt;&lt; d) == 0) {<br>        if (dy == 0) return;<br>        k++;<br>        s ^= 1 &lt;&lt; d;<br>      }<br>    } else if (m[y][x] &gt;= 130) {<br>      int d = m[y][x] - 130;<br>      if ((s &amp; 1 &lt;&lt; d) != 0) {<br>        if (dx == 0) return;<br>        k++;<br>        s ^= 1 &lt;&lt; d;<br>      }<br>    }<br>    q.add(k, x, y, s);<br>  }<br>  void add2(Entry e, int dx, int dy) {<br>    int x = e.x + dx;<br>    int y = e.y + dy;<br>    if (x &lt; 0 || y &lt; 0 || x &gt;= w || y &gt;= h || m[y][x] == '#') return;<br>    q.add(e.key, x, y, 0);<br>  }<br>  boolean safe(int sx, int sy, int ex, int ey) {<br>    q = new PQ();<br>    q.add(0, sx, sy, 0);<br>    boolean[][] v = new boolean[h][w];<br>    while (!q.isEmpty()) {<br>      Entry e = (Entry) q.popEntry();<br>      if (v[e.y][e.x]) continue;<br>      v[e.y][e.x] = true;<br>      if (ey == e.y &amp;&amp; e.x == ex) return true;<br>      add2(e, 1, 0);<br>      add2(e, 0, 1);<br>      add2(e, -1, 0);<br>      add2(e, 0, -1);<br>    }<br>    return false;<br>  }<br>  public int turns(String[] map) {<br>    h = map.length;<br>    w = map[0].length();<br>    m = new char[h][];<br>    int sx = -1, sy = -1, sd = 0, ex = -1, ey = -1;<br>    nd = 0;<br>    for (int i = 0; i &lt; h; i++)<br>      m[i] = map[i].toCharArray();<br>    for (int i = 0; i &lt; h; i++)<br>      for (int j = 0; j &lt; w; j++)<br>        if (m[i][j] == 'S') {<br>          sx = j;<br>          sy = i;<br>        } else if (m[i][j] == 'E') {<br>          ex = j;<br>          ey = i;<br>        }<br>    for (int i = 0; i &lt; h; i++)<br>      for (int j = 0; j &lt; w; j++)<br>        if (m[i][j] == 'O') {<br>          if (m[i - 1][j] == '|') sd |= 1 &lt;&lt; nd;<br>          m[i - 1][j] = (char) (130 + nd);<br>          m[i + 1][j] = (char) (130 + nd);<br>          m[i][j - 1] = (char) (150 + nd);<br>          m[i][j + 1] = (char) (150 + nd);<br>          m[i][j] = '#';<br>          nd++;<br>        }<br>    v = new boolean[h][w][1 &lt;&lt; nd];<br>    if (!safe(sx, sy, ex, ey)) return -1;<br>    q = new PQ();<br>    q.add(0, sx, sy, sd);<br>    while (!q.isEmpty()) {<br>      Entry e = (Entry) q.popEntry();<br>      if (v[e.y][e.x][e.d]) continue;<br>      v[e.y][e.x][e.d] = true;<br>      if (ey == e.y &amp;&amp; e.x == ex) return e.key;<br>      add(e, 1, 0);<br>      add(e, 0, 1);<br>      add(e, -1, 0);<br>      add(e, 0, -1);<br>    }<br>    return -1;<br>  }<br>}<br></td>