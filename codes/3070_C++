<td class="problemText" colspan="8" valign="middle" align="left">
            // another fine solution by misof<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;strings.h&gt;<br>using namespace std;<br> <br>// Zakladna praca s foldmi:<br>// 'zo' na prislusnej ciare fold otvori, 'zc' zavrie, &lt;Ins&gt; otvori a zapne i mod<br>// 'zR', 'zM' otvori/zavrie uplne vsetko<br> <br>vector&lt;string&gt; split( const string&amp; s, const string&amp; delim =" " )<br>// Tato fcia rozbije string na kopu malych stringov: {{{<br>{<br>    vector&lt;string&gt; res;<br>    string t;<br>    for ( unsigned int i = 0 ; i != s.size() ; i++ ) {<br>        if ( delim.find( s[i] ) != string::npos ) {<br>            if ( !t.empty() ) {<br>                res.push_back( t );<br>                t = "";<br>            }<br>        } else {<br>            t += s[i];<br>        }<br>    }<br>    if ( !t.empty() ) {<br>        res.push_back(t);<br>    }<br>    return res;<br>}<br>// }}}<br> <br>vector&lt;int&gt; splitInt( const string&amp; s, const string&amp; delim =" " )<br>// Tato fcia rozbije string na kopu intov: {{{<br>{<br>    vector&lt;string&gt; tok = split( s, delim );<br>    vector&lt;int&gt; res;<br>    for ( unsigned int i = 0 ; i != tok.size(); i++ )<br>        res.push_back( atoi( tok[i].c_str() ) );<br>    return res;<br>}<br>// }}}<br> <br>string doublesyl(string s) {<br>  int i=0;<br>  while (1) {<br>    if (tolower(s[i])=='a') break;<br>    if (tolower(s[i])=='e') break;<br>    if (tolower(s[i])=='i') break;<br>    if (tolower(s[i])=='o') break;<br>    if (tolower(s[i])=='u') break;<br>    i++;<br>  }<br>  return s.substr(0,i+1) + s;<br>}<br> <br>class TaglishTranslator {<br>public:<br>    string translate(string sentence) {<br>        string res;<br> <br>        vector&lt;string&gt; slova = split(sentence);<br>        int subject, verb, object;<br>        int mam_object = 0;<br>        int mam_will = 0;<br>        int mam_the_subject = 0;<br>        int mam_to_object = 0;<br>        int mam_the_object = 0;<br>        int tense = 0; // 0 past 1 present 2 future<br> <br>        if (!strcasecmp(slova[0].c_str(),"the")) {<br>          mam_the_subject = 1;<br>          subject = 1;<br>        } else subject = 0;<br>        <br>        if (!strcasecmp(slova[subject+1].c_str(),"will")) {<br>          mam_will = 1;<br>          verb = subject + 2;<br>        } else verb = subject + 1;<br> <br>        if (verb+1 &lt; slova.size() ) { // este mame object<br>          mam_object = 1;<br>          object = verb+1;<br>          if (!strcasecmp(slova[object].c_str(),"to")) { mam_to_object=1; object++; }<br>          if (!strcasecmp(slova[object].c_str(),"the")) { mam_the_object=1; object++; }<br>        }<br> <br>        int vl = slova[verb].length();<br>        if (mam_will) tense=2; else {<br>          tense=1;<br>          if ( vl &gt;= 2) <br>            if (tolower(slova[verb][vl-2])=='e')<br>            if (tolower(slova[verb][vl-1])=='d')<br>              tense=0;<br>        }<br> <br>        string newverb;<br>        switch (tense) {<br>          case 0: <br>            newverb = "nag" + slova[verb].substr(0,vl-2);<br>            break;<br>          case 1:<br>            newverb = "nag" + doublesyl(slova[verb]);<br>            break;<br>          case 2:<br>            newverb = "mag" + doublesyl(slova[verb]);<br>        }<br> <br>        res = newverb + " ";<br> <br>        if (mam_the_subject) {<br>          res += "ang " + slova[subject];<br>        } else {<br>          res += "si " + slova[subject];<br>        }<br> <br>        if (mam_object) {<br>          res += " ";<br>          if (mam_to_object) {<br>            if (mam_the_object) {<br>              res += "sa " + slova[object];<br>            } else {<br>              res += "kay " + slova[object];<br>            }<br>          } else {<br>            if (mam_the_object) {<br>              res += "ng " + slova[object];<br>            } else {<br>              res += "ni " + slova[object];<br>            }<br>          }<br>        }<br>        <br>        return res;<br>    }<br>// Tu su zbalene definicie jednotlivych testcasov: {{{<br> <br> <br>// }}}<br>};<br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>