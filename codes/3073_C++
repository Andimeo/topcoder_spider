<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;list&gt;<br>#include &lt;regex.h&gt; <br>using namespace std;<br><br>#define INF 0x7fffffff<br>#define FOR(i,a,b) for(int i=(a),_i=(b);i&lt;_i;++i)<br>#define FORD(i,a,b) for(int i=(a);i&gt;=(b);--i)<br>#define REP(i,n) FOR(i,0,n)<br>#define REPD(i,n) FORD(i,n,0)<br>#define REPSZ(i,v) REP(i,(v).SZ)<br>#define VAR(a,b) __typeof(b) a=b<br>#define IT(a,v) VAR(a,v.end())<br>#define FORIT(it,v) for(VAR(it,(v).begin());it!=(v).end();++(it))<br>#define FORITREM(it,v,rem) for(VAR(it,(v).begin());it!=(v).end();(rem)?(v).erase(it++):++it)<br>#define ALL(x) (x).begin(),(x).end()<br>#define MAX(a,b) ((a)&gt;(b)?(a):(b))<br>#define MIN(a,b) ((a)&lt;(b)?(a):(b))<br>#define ABS(a) MAX((a),-(a))<br>#define DIST(a,b) ABS((a)-(b))<br>#define SQR(x) ((x)*(x))<br>#define NORM(x,y) sqrt(SQR(x)+SQR(y))<br>#define FIND(a,v) find(ALL(v),(a))<br>#define FOUND(a,v) (FIND(a,v)!=(v).end())<br>#define INDEX(a,v) (FOUND(a,v)?(FIND(a,v)-(v).begin()):-1)<br>#define MP(a,b) make_pair(a,b)<br>#define FST(a) (a).first<br>#define SCD(a) (a).second<br>#define KEY(a) FST(*a)<br>#define VAL(a) SCD(*a)<br>#define PB push_back<br>#define SZ size()<br>#define EOL printf("\n")<br><br>typedef string str; typedef double dbl; typedef long long ll;<br>typedef unsigned int uint; typedef unsigned long long ull;<br>typedef vector&lt;str&gt; VS; typedef vector&lt;VS&gt; VVS;<br>typedef vector&lt;int&gt; VI; typedef vector&lt;VI&gt; VVI;<br>typedef vector&lt;dbl&gt; VD; typedef vector&lt;VD&gt; VVD;<br>typedef vector&lt;ll&gt; VLL; typedef vector&lt;VLL&gt; VVLL;<br>typedef pair&lt;int,int&gt; PII; typedef vector&lt;PII&gt; VPII;<br><br>inline ll fac(int n) { ll ret=1; while(n&gt;1) ret*=n--; return ret; }<br>inline ll gcd(ll a,ll b) { if(b==0) return a; return gcd(b,a%b); }<br>inline ll lcm(ll a,ll b) { return a*b/gcd(a,b); }<br>inline ll choose(int n,int k) {<br>  int x=n,y=1; ll ret;<br>  if(k&lt;0||k&gt;n) return 0;<br>  if(k==0||k==n) return 1;<br>  while(x!=n-k) { ret*=x; --x; while(y!=k+1&amp;&amp;(ret%y)==0) { ret/=y; ++y; } }<br>  return ret;<br>}<br><br>template&lt;class T&gt; string tostr(T a) { ostringstream s; s&lt;&lt;a; return s.str(); }<br><br>template &lt;class T1, class T2&gt; T1 cast (T2 x) { T1 y; ostringstream oss; oss&lt;&lt;x; istringstream iss(oss.str()); iss&gt;&gt;y; return y; }<br><br>template&lt;class T&gt; vector&lt;T&gt; split(const string&amp; s,const string&amp; delim=" ") {<br>    vector&lt;T&gt; ret; str cur;<br>    REPSZ(i,s) if(FOUND(s[i],delim)) { if(cur.SZ) ret.PB(cast&lt;T&gt;(cur)); cur=str(""); } else cur+=s[i];<br>    if(cur.SZ) ret.PB(cast&lt;T&gt;(cur));<br>    return ret;<br>}<br><br>class HeartsGame {<br>public:<br>    vector &lt;string&gt; score(vector &lt;string&gt; tricks) {<br>      VI onlyPoints(4,0);<br>      VVI nietbekend(4,VI(4,0));<br>      VI onlyhearts(4,0);<br>      int player=0;<br>      VI points(4,0);<br>      VI valid(4,1);<br>      bool heartsplayed=false;<br>      REPSZ(i,tricks) {<br>        int card,suit,leadcard,leadsuit,win,p=0;<br>        REP(j,4) {<br>          switch(tricks[i][j*3]) {<br>            case 'C': suit=0; break;<br>            case 'D': suit=1; break;<br>            case 'H': suit=2; break;<br>            case 'S': suit=3; break;<br>          }<br>          switch(tricks[i][j*3+1]) {<br>            case '2': card=0; break;<br>            case '3': card=1; break;<br>            case '4': card=2; break;<br>            case '5': card=3; break;<br>            case '6': card=4; break;<br>            case '7': card=5; break;<br>            case '8': card=6; break;<br>            case '9': card=7; break;<br>            case 'T': card=8; break;<br>            case 'J': card=9; break;<br>            case 'Q': card=10; break;<br>            case 'K': card=11; break;<br>            case 'A': card=12; break;<br>          }<br>          if(j==0) {<br>            leadcard=card; leadsuit=suit; win=player;<br>            if(!heartsplayed&amp;&amp;suit==2) onlyhearts[player]=1;<br>          } else {<br>            if(suit!=leadsuit) nietbekend[(player+j)%4][leadsuit]=1;<br>            else if(card&gt;leadcard) { win=(player+j)%4; leadcard=card; }<br>            if(suit==2) heartsplayed=true;<br>          }<br>          if(suit==2) p++; if(suit==3&amp;&amp;card==10) p+=13;<br>           if(i==0) if(suit==2||suit==3&amp;&amp;card==10) onlyPoints[(player+j)%4]=1;<br>        if(onlyhearts[(player+j)%4]&amp;&amp;suit!=2) valid[(player+j)%4]=false;<br>        if(nietbekend[(player+j)%4][suit]) valid[(player+j)%4]=false;<br>        if(onlyPoints[(player+j)%4]&amp;&amp;suit!=2&amp;&amp;(suit!=3||card!=10)) valid[(player+j)%4]=false;<br>        }<br>        player=win;<br>        points[win]+=p;<br>      }<br>      bool mars=points[0]==26||points[1]==26||points[2]==26||points[3]==26;<br>      VS ret;<br>      REP(i,4) if(valid[i]) ret.PB(tostr(mars?26-points[i]:points[i])); else ret.PB(str("CHEATER!"));<br>      return ret;<br>      <br>    }<br><br>};<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>