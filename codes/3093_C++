<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;math.h&gt;<br>#include &lt;map&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br> <br>using namespace std;<br> <br>#define ll long long<br>#define debug(x) cout &lt;&lt; #x &lt;&lt; ": " &lt;&lt; x &lt;&lt; "\n";<br> <br>#define max(x, y) x&gt;?y<br>#define min(x, y) x&lt;?y<br> <br>#define pb(x)  push_back(x)<br>#define sz  size()<br>#define cstr  c_str()<br> <br>#define FOR(i,end) for(int i=0; i&lt;end; i++)<br>#define RFOR(i,begin) for(int i=(begin)-1; i&gt;=0; i--)<br>#define FE(v,it) for(typeof(v.begin()) it=v.begin(); it != v.end(); it++)<br>#define PRINT(v) {cout&lt;&lt;"---\n"; FE(v,it){cout&lt;&lt;*it&lt;&lt;"\n";}}<br> <br>#define FIND(v, x) (v.find(x) != v.end())<br>#define FINDS(s, c) (s.find(c) != string::npos)<br>#define SORT(v) sort(v.begin(), v.end())<br>#define SUBTO(s, c) (s.substr(0, s.find(c)))<br>#define SUBFROM(s, c) (s.substr(s.find(c)+1, s.sz))<br> <br>const double eps=1E-10;<br> <br>#define LETTER(c) (c&gt;='a'&amp;&amp;c&lt;='z' || c&gt;='A'&amp;&amp;c&lt;='Z')<br>#define DIGIT(c) (c&gt;='0'&amp;&amp;c&lt;='9')<br>#define NOTDIGIT(c) (!(c&gt;='0'&amp;&amp;c&lt;='9'))<br> <br>#define SUM(v,sum) FOR(i, v.sz){sum+=v[i];}<br>#define PROD(v,prod) FOR(i, v.sz){prod*=v[i];}<br>#define MIN(v, min) FOR(i, v.sz){min=min&lt;?v[i];}<br>#define MAX(v, max) FOR(i, v.sz){max=max&gt;?v[i];}<br> <br>//#define INF 2000000<br> <br>//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>class PermissionTree <br>{<br>public:<br>  vector &lt;int&gt; findHome(vector &lt;string&gt; folders, vector &lt;string&gt; users);<br>  <br> <br>};<br>int atoi(string s)<br>{<br>  int res;<br>  sscanf(s.c_str(),"%d",&amp;res);  <br>  return res;<br>}<br> <br>vector &lt;string&gt; split (string as, string delim=" ")<br>{  <br>  vector &lt;string&gt; res;<br>  string s="";<br>  for(int i=0; i&lt;as.size(); i++)<br>  {    <br>    if(!FINDS(delim, as[i])) s+=as[i];<br>    else if(s!="") {res.push_back(s); s="";};<br>  }    <br>  if(s!="") res.push_back(s);<br>  <br>  return res;    <br>}<br> <br>map &lt;int, int&gt; m;<br> <br>int findparent(int x1, int x2)<br>{<br>  vector &lt;int&gt; st;<br>  while(x1!=0)<br>  {<br>    st.pb(x1);<br>    x1=m[x1];<br>  }<br>  <br>  while(x2!=0)<br>  {<br>    FOR(i, st.sz)<br>    {<br>      if(st[i]==x2) return x2;<br>    }<br>    <br>    x2=m[x2];<br>  }<br>  <br>  return 0;<br>}<br> <br>vector &lt;int&gt; PermissionTree::findHome(vector &lt;string&gt; fold, vector &lt;string&gt; users)<br>{<br>  <br> <br>map &lt;string, int&gt; mm;<br>FOR(i, fold.sz)<br>{<br>  vector &lt;string&gt; vs=split(fold[i]);<br>  int par=atoi(vs[0]);<br>  m[i]=par;<br>}<br>FOR(i, fold.sz)<br>{<br>  vector &lt;string&gt; vs=split(fold[i]);<br>  vector &lt;string&gt; names=split(vs[1], ",");<br>  <br>  FOR(j, names.sz)<br>  {<br>    if(!FIND(mm, names[j])) mm[names[j]]=i;<br>    else<br>    {<br>      mm[names[j]]=findparent(i, mm[names[j]]);<br>    }<br>    <br>  }<br>}<br> <br>vector &lt;int&gt; res;<br>FOR(i, users.sz)<br>{<br>  if(!FIND(mm, users[i])) res.pb(-1);<br>  else<br>    res.pb(mm[users[i]]);<br>}<br> <br>return res;<br> <br>}//end<br> <br>// Powered by PopsEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>