<td class="problemText" colspan="8" valign="middle" align="left">
            // WARNING: HUGE USELESS TEMPLATE, GO TO: "TEMPLATE END"<br>// Winners dont use mouse (?)<br><br>#include &lt;algorithm&gt;<br>#include &lt;cctype&gt;<br>#include &lt;climits&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdarg&gt; <br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt; <br>#include &lt;ctime&gt;<br>#include &lt;deque&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iterator&gt; <br>#include &lt;list&gt; <br>#include &lt;map&gt;<br>#include &lt;numeric&gt; <br>#include &lt;queue&gt;<br>#include &lt;regex.h&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br><br>using namespace std;<br><br>// comodidad en tipos simples<br>typedef long long ll;<br>typedef unsigned long long ull;<br>typedef long double ld; <br>typedef double db; <br>typedef pair&lt;int,int&gt; pii;<br><br>// comodidad en sets<br>typedef set&lt;int&gt; si;<br>typedef set&lt;string&gt; ss; <br>typedef set&lt;char&gt; sc;<br>typedef set&lt;pii&gt; spii; <br><br>// comodidad en vectors<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;vi&gt; vvi;<br>typedef vector&lt;ll&gt; vll;<br>typedef vector&lt;vll&gt; vvll; <br>typedef vector&lt;string&gt; vs;<br>typedef vector&lt;vs&gt; vvs; <br>typedef vector&lt;bool&gt; vb;<br>typedef vector&lt;vb&gt; vvb;<br>typedef vector&lt;char&gt; vc;<br>typedef vector&lt;db&gt; vd;<br>typedef vector&lt;vd&gt; vvd; <br>typedef vector&lt;ld&gt; vld;<br>typedef vector&lt;vld&gt; vvld; <br>typedef vector&lt;pii&gt; vpii; <br><br><br>// variables<br>#define var(a,b) typeof(b) a=(b) //solo en gcc<br><br>// debug<br>#define debug(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl<br><br><br>// ciclos con variables locales<br>#define forn(i,n) for(int i=0;i&lt;(n);i++)<br>#define rforn(i,n) for(int i=((n)-1);i&gt;=(0);i--)<br>#define forv(i,v) for(int i=0;i&lt;(int)(v).size();i++) <br>#define rforv(i,v) for(int i=((int)(v).size()-1);i&gt;=0;i--) <br><br>#define fi forn(i,n)<br>#define fj forn(j,n)<br>#define fk forn(k,n)<br>#define fl forn(l,n)<br><br>#define fir rforn(i,n)<br>#define fjr rforn(j,n)<br>#define fkr rforn(k,n)<br>#define flr rforn(l,n)<br><br>#define fvi forv(i,n)<br>#define fvj forv(j,n)<br>#define fvk forv(k,n)<br>#define fvl forv(l,n)<br><br>#define fvir rforv(i,n)<br>#define fvjr rforv(j,n)<br>#define fvkr rforv(k,n)<br>#define fvlr rforv(l,n)<br><br>// hacia arriba desde s (n exclusive)<br>#define fornu(i,s,n) for(int i=(s);i&lt;(n);i++) <br>#define forvu(i,s,v) for(int i=(s);i&lt;(int)(v).size();i++) <br>// desde a hasta v inclusive<br>#define foru(i,a,b) for(int i=(a);i&lt;=(b);i++) <br>#define ford(i,a,b) for(int i=(a);i&gt;=(b);i--) <br><br>// ciclos con variables que perduran<br>#define fornp(i,n) int i;for(i=0;i&lt;(n);i++) <br>#define forvp(i,v) int i;for(i=0;i&lt;(int)(v).size();i++) <br><br>#define fip(n) fornp(i,n)<br>#define fjp(n) fornp(j,n)<br>#define fkp(n) fornp(k,n)<br>#define flp(n) fornp(l,n)<br><br>// con n tocable<br>#define rep(i,n) for(int _n=n, i=0;i&lt;_n;++i)<br>#define repu(i,a,b) for(int i=(a),_b=(b);i&lt;=_b;++i)<br>#define repd(i,a,b) for(int i=(a),_b=(b);i&gt;=_b;--i)<br><br>//ciclos con variables declaradas afuera<br>#define fo(x,y) for((x)=0;(x)&lt;(y);(x)++)<br><br>// ciclo iterador<br>#define fore(it,c) for(var(it,(c).begin());it!=(c).end();++it)<br>// luciano dice que esto se hace con reverse iterators<br>#define rfore(it,c) for(var(it,(c).begin()), it=(x).end();it!=(x).begin() &amp;&amp; (--it,1);) <br><br>// comodidades boludas<br>#define pb(x) push_back((x)); <br>#define sz size()<br>#define cs c_str()<br>#define cdb (double)<br>#define db double<br><br><br>// cosas de vectores<br>#define all(x) (x).begin(), (x).end() <br>#define rall(x) (x).rbegin(), (x).rend() <br>#define un(A) std::unique(all(A))<br>#define rev(v) std::reverse(all(v))<br>#define ins(x) insert(x)<br>#define st(v) sort(all(v))<br>#define stf(v,f) sort(all(v),f)<br>#define sst(v) std::stable_sort(all(v))<br>#define sstf(v,f) std::stable_sort(all(v),f)<br><br>// infinitos<br>const int inf = 1000000000; <br>const ll infll = ll(inf) * ll(inf);<br><br>// locura absoluta<br>#define todo(f,w) ({ bool _ok=true; f { _ok=_ok &amp;&amp; (w);if(!_ok) break;} _ok; })<br>#define exis(f,w) (!todo(f,!(w)))<br>#define mini(f,w) ({ int _mm=(1&lt;&lt;31)-1; f _mm&lt;?=(w); _mm; })<br>#define maxi(f,w) ({ int _mm=(1&lt;&lt;31); f _mm&gt;?=(w); _mm; })<br><br>// creo vectores<br>template&lt;class T&gt; inline vector&lt;T&gt; makeV(const T&amp;x) { return vector&lt;T&gt;(1,x); }<br>template&lt;class T&gt; inline vector&lt;T&gt; makeV(const T&amp;x,const T&amp;y) { vector&lt;T&gt; v(2); v[0] = x; v[1] = y; return v;}<br>template&lt;class T&gt; inline vector&lt;T&gt; makeV(const T&amp;x,const T&amp;y,const T&amp;z) { vector&lt;T&gt; v(3); v[0] = x; v[1] = y; v[2]=z; return <br>v;}<br><br>// busqueda<br>template&lt;class A,class B&gt; inline bool contains(const A&amp;a, const B&amp;b) {return find(a.begin(),a.end(),b)!=a.end();}<br><br>// funciones de enteros<br>int ipow(int a, int b) {return (int) (std::pow((double) (a), (double) (b)));}<br>ll gcd(ll a, ll b) {if (a&lt;0||b&lt;0) return gcd(abs(a),abs(b)); if (a==0) return b; if (b==0) return a; if (a &gt; b) return gcd(b, <br>a); if (!(b % a)) return a; return gcd(a, b % a);}<br><br>template&lt;class T&gt; inline int tam(const T&amp;c) { return c.size(); }<br><br>// string e ints<br>int stoi(string s) { istringstream i(s); int x; i&gt;&gt;x; return x; }<br>ll stoll(string s) { istringstream i(s); ll x; i&gt;&gt;x; return x; }<br>string itos (int i) {stringstream s; s &lt;&lt; i; return s.str();}<br>string lltos (long long i) {stringstream s; s &lt;&lt; i; return s.str();}<br><br>template&lt;class T&gt; string xtos(T x) { ostringstream o; o&lt;&lt;x; return o.str(); }<br>template&lt;class T&gt; T strtox(const string&amp; s){istringstream str(s);T x;str&gt;&gt;x;return x;} <br><br>template&lt;class it&gt; string vtostr(it it1,it it2){ostringstream s;s&lt;&lt;"(";for(it <br>i=it1;i!=it2;++i){if(i!=it1)s&lt;&lt;",";s&lt;&lt;*i;}s&lt;&lt;")";return s.str();} <br>template&lt;class t&gt; string vtostr(const t&amp; x){return vtostr(x.begin(),x.end());}<br><br><br>// tokenizadores con separador puesto como parametro o " " default<br>vs stovs(const string&amp; s,const string&amp; t=" "){vs res; for(int p=0;;){p=s.find_first_not_of(t,p);if (p&lt;0) return res;int <br>p2=s.find_first_of(t,p);res.push_back(s.substr(p,p2-p));if (p2&lt;0) return res;else p=p2;}} <br>vi stovi(string s,string del=" ") {vs v = stovs(s,del);vi res;fore(it,v) res.push_back(stoi(*it));return res;}<br>vvs vstovvs(const vs&amp; v,const string&amp; t=" "){vvs res;forv(i,v) res.push_back(stovs(v[i],t));return res;} <br>vvi vstovvi(const vs&amp; v,const string&amp; t=" "){vvi res;forv(i,v) res.push_back(stovi(v[i],t));return res;} <br><br><br>// impresion pares<br>template&lt;class t,class u&gt; ostream&amp; operator&lt;&lt;(ostream&amp; o,const pair&lt;t,u&gt;&amp; x){return o&lt;&lt;"("&lt;&lt;x.first&lt;&lt;","&lt;&lt;x.second&lt;&lt;")";} <br>// impresion vector<br>template&lt;class T,class T2&gt; T&amp; operator&lt;&lt;(T&amp; a,vector&lt;T2&gt; b){ a&lt;&lt;'{';forv(i,b) a&lt;&lt;(i?",":"")&lt;&lt;b[i]; a&lt;&lt;'}';return a; } <br>// impresion vv<br>template&lt;class T,class T2&gt; T&amp; operator&lt;&lt;(T&amp; a,vector&lt;vector&lt;T2&gt; &gt; b){ a&lt;&lt;endl;forv(i,b) a&lt;&lt;b[i]&lt;&lt;endl; return a; } <br>// impresion vs poniendo enters<br>template&lt;class T&gt; T&amp; operator&lt;&lt;(T&amp; a,vs b){ a&lt;&lt;endl;forv(i,b) a&lt;&lt;b[i]&lt;&lt;endl; return a; } <br>// impresion sets<br>template&lt;class T,class T2&gt; T&amp; operator&lt;&lt;(T&amp; a,set&lt;T2&gt; b){ a&lt;&lt;'{';fore(i,b) a&lt;&lt;(i!=b.begin()?",":"")&lt;&lt;*i; a&lt;&lt;'}';return a; } <br>// impresion maps<br>template&lt;class T,class T1,class T2&gt; T&amp; operator&lt;&lt;(T&amp; a,map&lt;T1,T2&gt; b){ a&lt;&lt;'{';fore(i,b) <br>a&lt;&lt;(i!=b.begin()?",":"")&lt;&lt;'['&lt;&lt;b-&gt;first&lt;&lt;','&lt;&lt;b-&gt;second&lt;&lt;']'; a&lt;&lt;'}';return a; } <br><br>//UN CHABON SERIO TENIA ESTO Y NO COMPRENDI UN SOTO, parece ser un chiste... preguntar<br>//przz<br>/*<br>struct przz{}; przz zz; <br>template&lt;class T&gt; przz operator,(const przz&amp; a,T b){ cout&lt;&lt;" "&lt;&lt;b; return a;} <br>template&lt;class T&gt; T&amp; operator&lt;&lt;(T&amp; a,przz&amp; b){ a&lt;&lt;endl;b=b;return a; } <br>*/<br>// TEMPLATE END<br><br><br><br><br><br>class PayBill {<br>  public:<br>  vector &lt;int&gt; whoPaid(vector &lt;int&gt; meals, int totalMoney) {<br>    vb llegue(500005, false);<br>    vi ultpago(500005, -1);<br>    llegue[0] =true;<br>    forv(i, meals) {<br>      forv(j, llegue) {<br>        if (llegue[j] &amp;&amp; ultpago[j] != i &amp;&amp; j+meals[i] &lt; 500002 &amp;&amp; !llegue[j+meals[i]]) <br>        {  llegue[j+meals[i]] = true;<br>          ultpago[j+meals[i]] = i;<br>        }<br>      }<br>    <br>    }<br>    vi ret;<br>    while (totalMoney != 0) {<br>      ret.pb(ultpago[totalMoney]);<br>      totalMoney -= meals[ultpago[totalMoney]];<br>    }<br>    st(ret);<br>    return ret;<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>