<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.io.*;<br>import java.math.*;<br>import java.awt.geom.*;<br>public class Birds {<br>  int mon_len[] = {<br>    0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31<br>  }<br>  ;<br>  public int daysum(int m, int d) {<br>    int s = 0, i;<br>    for(i=1;i&lt;m;i++) s+= mon_len[i];<br>    return s+d;<br>  }<br>  public int dist(int a, int b, int c, int d) {<br>    long t = 0;<br>    t = ((long)a-c)*((long)a-c) + ((long)b-d)*((long)b-d);<br>    return (int) Math.min(t, (long)2000000000);<br>  }<br>  public int[] parse(String s) {<br>    StringTokenizer st = new StringTokenizer(s, ",");<br>    int[] x = new int[5];<br>    for (int i=0;i&lt;4;i++)<br>    x[i] = Integer.parseInt(st.nextToken());<br>    return x;<br>  }<br>  public int isMigratory(String[] birdMoves) {<br>    int i, j, k, m, N=birdMoves.length;<br>    int parsed[][] = new int[N+2][5];<br>    String temp;<br>    for (i=0;i&lt;N;i++) parsed[i] = parse(birdMoves[i]);<br>      <br>    for (i=0;i&lt;N;i++)<br>    for (j=i+1;j&lt;N;j++) {<br>      int[] a = parsed[i];<br>      int[] b = parsed[j];<br>      if (a[2] &gt; b[2] || (a[2]==b[2] &amp;&amp; a[3]&gt;b[3])) {<br>        temp = birdMoves[i];birdMoves[i] = birdMoves[j];birdMoves[j] = temp;<br>        int te[];<br>        te = parsed[i]; parsed[i] = parsed[j]; parsed[j] = te;<br>      }<br>    }<br>    for (i=0;i&lt;N;i++) System.out.println(parsed[i][0]+" "+parsed[i][1]);<br>    <br>    parsed[N][2] = 13; parsed[N][3] = 1;<br>    parsed[N][0] = parsed[N-1][0];<br>    parsed[N][1] = parsed[N-1][1];<br>    N++;<br>    <br>    for (i=0;i&lt;N;i++) parsed[i][4] = daysum(parsed[i][2], parsed[i][3]);<br>    for (i=0;i&lt;N;i++) System.out.println(parsed[i][0]+" "+parsed[i][1]+" "+parsed[i][4]);<br>    <br>    int t1, t2;<br>    for (i=0;i&lt;N;i++)<br>    for (j=i+1;j&lt;N;j++)<br>    for (k=j;k&lt;N;k++)<br>    for (m=k+1;m&lt;N;m++) {<br>      if (parsed[j][4]-parsed[i][4]&gt;=90 &amp;&amp; parsed[m][4]-parsed[k][4]&gt;=90){<br>        boolean good = true;<br>        for (t1=i;t1&lt;j &amp;&amp; good;t1++)<br>        for (t2=k;t2&lt;m &amp;&amp; good;t2++)<br>        if (dist(parsed[t1][0], parsed[t1][1], parsed[t2][0], parsed[t2][1]) &lt; 1000000)<br>        good = false;<br>        if (good) return 1;<br>      }<br>    }<br>    return 0;<br>  }<br>}<br> <br>// Powered by PopsEdit<br></td>