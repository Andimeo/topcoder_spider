<td class="problemText" colspan="8" valign="middle" align="left">
            // Warning: less successful challenges against me than against tomek.<br>// I'm now automatically removing unused stuff.<br><br>#include &lt;algorithm&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>using namespace std;<br><br>typedef long long ll;<br>typedef vector&lt;int&gt; vi;<br><br>#define LS &lt;<br>#define Size(x) (int(x.size()))<br>#define LET(k,val) typeof(val) k = (val)<br>// execute "act", and return "val" as an expression result<br>#define CLC(act,val) (*({act; static typeof(val) CLCR; CLCR = (val); &amp;CLCR;}))<br><br>// All macros with parameters "k,a,b" run the "k" variable in range [a,b)<br>#define FOR(k,a,b) for(typeof(a) k=(a); k LS (b); ++k)<br><br>// Standard mathematical quantifiers, plus tools to implement them<br>#define FOLD0(k,a,b,init,act) CLC(LET(k, a); LET(R##k, init); for(; k LS (b); ++k) {act;}, R##k)<br>#define SUMTO(k,a,b,init,x)  FOLD0(k,a,b,init,R##k += (x))<br>#define SUM(k,a,b,x) SUMTO(k,a,b,(typeof(x)) (0), x)<br><br>// parse a space-delimited string into a vi<br>vi parsevi(string s) {<br>  s = s + " ";<br>  int q = 0;<br>  vi res;<br>  FOR(l,0, Size(s)) {<br>    if(s[l] == ' ') { res.push_back(q); q = 0;}<br>    else { q = q * 10 + s[l] - '0'; }<br>    }<br>  return res;<br>  }<br><br>#line 3 "DFAReversal.cc"<br><br>vi sigma[10];<br><br>int aut[1024][10];<br><br>bool inset(int el, int set) {<br>  return (1&lt;&lt;el) &amp; set;<br>  }<br><br>vi rch;<br><br>class DFAReversal {<br>  public:<br>  int reverse(vector &lt;string&gt; dfa, vector &lt;int&gt; accept) {<br>    // !FDI<br>    int Q = Size(dfa);<br><br>    FOR(q,0,Q) sigma[q] = parsevi(dfa[q]);<br><br>    int K = Size(sigma[0]);<br><br>    FOR(qs,0,1&lt;&lt;Q) FOR(k,0,K) <br>      aut[qs][k] = SUM(q,0,Q, inset(sigma[q][k], qs) ? 1&lt;&lt;q : 0);<br><br>    int acc = SUM(a,0,Size(accept), 1&lt;&lt;accept[a]);<br><br>    bool reach[1024];<br>    <br>    rch.clear();<br>    <br>    rch.push_back(acc);<br><br>    int ri = 0;<br>    <br>    FOR(b,0,1&lt;&lt;Q) reach[b] = false;<br>    <br>    while(ri &lt; Size(rch)) {<br>      int a = rch[ri];<br><br>      ri++;<br><br>//    printf("%d: %d\n", ri, a); fflush(stdout);<br><br>      if(reach[a]) continue;<br>      <br>      reach[a] = true;<br>      FOR(k,0,K) rch.push_back(aut[a][k]);<br>      }<br>    <br>    int P = 2000000011;<br><br>    int group[1024];<br>    int group2[1024];<br>    <br>    FOR(qs,0,1&lt;&lt;Q) group[qs] = qs&amp;1 ? 1 : 0;<br>    <br>    srand(time(NULL));<br><br>    int ks[10];<br>    <br>    FOR(p,0,10) ks[p] = 2 + rand() % 1000000;<br>    <br>    FOR(m,0,3&lt;&lt;Q) {<br>//    FOR(qs,0,1&lt;&lt;Q) if(reach[qs]) printf("%d: %d [%d]\n", m, qs, group[qs]);<br><br>      FOR(qs,0,1&lt;&lt;Q) if(reach[qs])<br>        group2[qs] = (group[qs] + SUM(k,0,10, ll(ks[k]) * group[aut[qs][k]])) % P;<br>      FOR(qs,0,1&lt;&lt;Q) group[qs] = group2[qs];<br>      }<br>    <br>//  FOR(qs,0,1&lt;&lt;Q) FOR(k,0,K) printf("%d,%d: %d\n", qs, k, aut[qs][k]);<br>    <br>    vi grps;<br>    <br>    FOR(qs,0,1&lt;&lt;Q) if(reach[qs]) grps.push_back(group[qs]);<br>    <br>    sort(grps.begin(), grps.end());<br>    <br>    int c = 1;<br>    FOR(t,1,Size(grps)) if(grps[t] != grps[t-1]) c++;<br>    return c;<br>    }<br>  };<br><br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>