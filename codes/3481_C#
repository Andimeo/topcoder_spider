<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br> <br>public class PackageShipping<br>{<br>  public double ship(string[] routes, string origin, string destination, int maxtime, int packageCost)<br>  {<br>    ArrayList cities = new ArrayList();<br>    foreach (string s in routes){<br>      string[] ss = s.Split();<br>      if (!cities.Contains(ss[0])) cities.Add(ss[0]);<br>      if (!cities.Contains(ss[1])) cities.Add(ss[1]);<br>    }<br>    int N = cities.Count;<br>    double[][] costs = new double[N][];<br>    double[][] costs2 = new double[N][];<br>    double[][] probs = new double[N][];<br>    int[][] times = new int[N][];<br>    for (int i = 0; i &lt; N; ++i){<br>      costs[i] = new double[N];<br>      costs2[i] = new double[N];<br>      probs[i] = new double[N];<br>      times[i] = new int[N];<br>      for (int j = 0; j &lt; N; ++j){<br>        costs[i][j] = double.PositiveInfinity;<br>        costs2[i][j] = double.PositiveInfinity;<br>        probs[i][j] = double.PositiveInfinity;<br>        times[i][j] = int.MaxValue;<br>      }<br>    }<br>    foreach (string s in routes){<br>      string[] ss = s.Split();<br>      int i = cities.IndexOf(ss[0]);<br>      int j = cities.IndexOf(ss[1]);<br>      int t = int.Parse(ss[2]);<br>      int c = int.Parse(ss[3]);<br>      double p = double.Parse(ss[4]);<br>      times[i][j] = t;<br>      costs[i][j] = p * packageCost / 100.0;<br>      costs2[i][j] = c;<br>      probs[i][j] = 1.0 - p / 100.0;<br>    }<br>    int start = cities.IndexOf(origin);<br>    int end = cities.IndexOf(destination);<br>    Node n = new Node(start, 0, 0.0, 1.0);<br>    Queue q = new Queue();<br>    q.Enqueue(n);<br>    ArrayList[] best = new ArrayList[cities.Count];<br>    for (int i = 0; i &lt; best.Length; ++i) best[i] = new ArrayList();<br>    while (q.Count &gt; 0){<br>      n = (Node)q.Dequeue();<br>      for (int i = 0; i &lt; cities.Count; ++i){<br>        if (n.City == i) continue;<br>        if (times[n.City][i] == int.MaxValue) continue;<br>        int time = times[n.City][i] + n.Time;<br>        if (time &gt; maxtime) continue;<br>        double cost = costs2[n.City][i] + n.Cost + (n.Prob * costs[n.City][i]);<br>        double prob = n.Prob * probs[n.City][i];<br>        bool need = true;<br>        for (int j = 0; need &amp;&amp; j &lt; best[i].Count; ++j){<br>          Node n2 = (Node)best[i][j];<br>          if (n2.Time &lt;= time &amp;&amp; n2.Cost &lt;= cost) need = false;<br>          if (n2.Time &gt; time &amp;&amp; n2.Cost &gt; cost){<br>            best[i].RemoveAt(j);<br>            --j;<br>          }<br>        }<br>        if (!need) continue;<br>        Node n3 = new Node(i, time, cost, prob);<br>        q.Enqueue(n3);<br>        best[i].Add(n3);<br>      }<br>    }<br>    double res = double.PositiveInfinity;<br>    for (int i = 0; i &lt; best[end].Count; ++i){<br>      n = (Node)best[end][i];<br>      res = Math.Min(res, n.Cost);<br>    }<br>    return res;<br>  }<br>  <br>  struct Node{<br>    public int City, Time;<br>    public double Cost, Prob;<br>    public Node(int c, int t, double p, double pr){ City = c; Time = t; Cost = p; Prob = pr; }<br>  }<br> <br>}<br>//Powered by [KawigiEdit]<br></td>