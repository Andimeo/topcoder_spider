<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;functional&gt;<br>#include &lt;cctype&gt;<br>#include &lt;complex&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cassert&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;list&gt;<br>#include &lt;iomanip&gt;<br>using namespace std;<br>class PackageShipping {public: double ship(vector &lt;string&gt; routes, string origin, string destination, int time, int packageCost); };<br> <br>struct edge<br>{<br>  int to, time, cost;<br>  double prob;<br> <br>  edge(int to, int time, int cost, double prob) : to(to), time(time), cost(cost), prob(prob) {}<br>};<br> <br>typedef vector&lt;edge&gt;  VE;<br>typedef vector&lt;VE&gt;    VVE;<br> <br>struct state<br>{<br>  int pos, time, cost;<br>  double prob;<br> <br>  state(int pos, int time, int cost, double prob) : pos(pos), time(time), cost(cost), prob(prob) {}<br>};<br> <br>struct reached<br>{<br>  int cost;<br>  double prob;<br>  reached(int cost, double prob) : cost(cost), prob(prob) {}<br>};<br> <br>double value;<br> <br>bool operator&lt; (const state &amp;a, const state &amp;b)<br>{<br>  return (a.cost + (1.0 - a.prob) * value) &gt; (b.cost + (1.0 - b.prob) * value);<br>}<br> <br>double PackageShipping::ship(vector &lt;string&gt; routes, string origin, string destination, int time, int packageCost)<br>{<br>  value = packageCost;<br>  map&lt;string,int&gt; ind;<br>  int n = 0;<br>  VVE adj;<br>  for (int i = 0; i &lt; routes.size(); i++)<br>  {<br>    stringstream buf(routes[i]);<br>    string x, y;<br>    int t, c;<br>    double p;<br>    buf &gt;&gt; x &gt;&gt; y &gt;&gt; t &gt;&gt; c &gt;&gt; p;<br>    if (ind.find(x) == ind.end())<br>    {<br>      ind[x] = n++;<br>      adj.push_back(VE());<br>    }<br>    if (ind.find(y) == ind.end())<br>    {<br>      ind[y] = n++;<br>      adj.push_back(VE());<br>    }<br>    adj[ind[x]].push_back(edge(ind[y], t, c, 1.0 - p / 100.0));<br>  }<br> <br>  vector&lt;vector&lt;reached&gt; &gt; there(n);<br>  int end = ind[destination];<br>  priority_queue&lt;state&gt; pq;<br>  pq.push(state(ind[origin], 0, 0, 1.0));<br>  while (!pq.empty())<br>  {<br>    state act = pq.top();<br>    pq.pop();<br> <br>    if (act.time &gt; time)<br>      continue;<br>    bool skip = false;<br>    for (vector&lt;reached&gt;::iterator jt = there[act.pos].begin(); jt != there[act.pos].end(); ++jt)<br>      if (jt-&gt;cost &lt;= act.cost &amp;&amp; jt-&gt;prob &gt;= act.prob)<br>      {<br>        skip = true;<br>        break;<br>      }<br>    if (skip)<br>      continue;<br>    there[act.pos].push_back(reached(act.cost, act.prob));<br> <br>    if (act.pos == end)<br>      return act.cost + (1.0 - act.prob) * value;<br>    for (VE::iterator it = adj[act.pos].begin(); it != adj[act.pos].end(); ++it)<br>    {<br>      state next(it-&gt;to, act.time + it-&gt;time, act.cost + it-&gt;cost, act.prob * it-&gt;prob);<br>      if (next.time &gt; time)<br>        continue;<br>      pq.push(next);<br>    }<br>  }<br>  return -1.0;<br>}<br> <br> <br>// Powered by FileEdit<br></td>