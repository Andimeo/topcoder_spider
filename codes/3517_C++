<td class="problemText" colspan="8" valign="middle" align="left">
            using namespace std;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;stack&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;queue&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>typedef long long I64;<br>typedef pair&lt;int,int&gt; PII;<br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt;double&gt; VD;<br>typedef vector&lt;PII&gt; VPII;<br>#define FOR(i,n) for(int i=0;i&lt;(n);i++)<br>#define VAR(a,b) __typeof(b) a=b<br>#define FORIT(it,c) for(VAR(it,(c).begin());it!=(c).end();it++)<br>#define ALL(x) (x).begin(),(x).end()<br> <br>struct LoopyImpl {<br>    vector &lt;string&gt; code;<br>    LoopyImpl(vector &lt;string&gt; _code) {<br>        code = _code;<br>    }<br> <br>    VI succ[60];<br>    VI pred[60];<br>    bool isret[60];<br>    bool isreach[60];<br>    bool returns[60];<br>    int n;<br> <br>    void reach(int i) {<br>        if(isreach[i]) return;<br>        isreach[i] = true;<br>        FOR(j,succ[i].size()) reach(succ[i][j]);<br>    }<br>    void doreturns(int i) {<br>        if(returns[i]) return;<br>        returns[i] = true;<br>        FOR(j,pred[i].size()) doreturns(pred[i][j]);<br>    }<br> <br>    int minLoop() {<br>        n = code.size();<br>        FOR(i,code.size()) {<br>            if(code[i][0]=='R') {<br>                isret[i] = 1;<br>            } else {<br>                isret[i] = 0;<br>                int a,b;<br>                sscanf(code[i].c_str(),"%*s %d %*s %d",&amp;a,&amp;b);<br>                succ[i].push_back(a);<br>                pred[a].push_back(i);<br>                if(a != b) {<br>                    succ[i].push_back(b);<br>                    pred[b].push_back(i);<br>                }<br>            }<br>        }<br> <br>        memset(isreach,0,sizeof(isreach));<br>        reach(0);<br>        memset(returns,0,sizeof(returns));<br>        FOR(i,n) if(isret[i]) doreturns(i);<br> <br>        FOR(i,n) {<br>            FOR(j,succ[i].size()) if(!returns[succ[i][j]]) {<br>                succ[i][j] = succ[i][succ[i].size()-1];<br>                succ[i].pop_back();<br>            }<br>            FOR(j,pred[i].size()) if(!isreach[pred[i][j]]) {<br>                pred[i][j] = pred[i][pred[i].size()-1];<br>                pred[i].pop_back();<br>            }<br>        }<br> <br>        if(!returns[0]) return 0;<br> <br>        int ret = 1000000;<br> <br>        FOR(start,n) {<br>            if(!isreach[start] || !returns[start]) continue;<br> <br>            FOR(nexti,pred[start].size()) {<br>                int next = pred[start][nexti];<br>                set&lt;int&gt; elems;<br>                elems.insert(start);<br>                elems.insert(next);<br>                if(makeloop(elems,start,next)) {<br>                    FORIT(it,pred[start]) {<br>                        int tp = *it;<br>                        if(tp != start &amp;&amp; tp != next &amp;&amp; elems.count(tp)) goto skip;<br>                    }<br>                    if(elems.count(0) &amp;&amp; start != 0) goto skip;<br>                    /*<br>                    if(elems.size() &lt; ret) {<br>                        printf("start at %d, pred %d\n",start,next);<br>                        printf("set of size %d: ",elems.size());<br>                        FORIT(it,elems) printf("%d ",*it);<br>                        printf("\n");<br>                    }<br>                    */<br>                    ret &lt;?= elems.size();<br>                }<br>skip:;<br>            }<br>        }<br> <br>        return ret == 1000000 ? 0 : ret;<br>    };<br> <br>    bool makeloop(set&lt;int&gt; &amp; elems,int start,int at) {<br>        if(at == start) return true;<br>        if(pred[at].size() == 0) return false;<br>        bool ok = true;<br>        FOR(p,pred[at].size()) {<br>            int prev = pred[at][p];<br> <br>            if(!elems.count(prev)) {<br>                elems.insert(prev);<br>                ok = ok &amp;&amp; makeloop(elems,start,prev);<br>            }<br>        }<br>        return ok;<br>    }<br>};<br> <br> <br>struct Loopy {<br>    int minLoop(vector &lt;string&gt; code) {<br>        LoopyImpl impl(code);<br>        return impl.minLoop();<br>    }<br> <br>};<br> <br> <br> <br> <br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>