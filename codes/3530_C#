<td class="problemText" colspan="8" valign="middle" align="left">
            using System; using System.Collections; using System.Text; using System.Text.RegularExpressions;<br>public class Parking<br>   {<br>   int X,Y;<br>   int C,P;<br>   int [,] dist;<br>   public int minTime(string[] G)<br>      {<br>      X=G[0].Length; Y = G.Length;<br>      int[,] pnum = new int[X,Y];<br>      int[] cx = new int[100], cy = new int[100], px = new int[100], py = new int[100];<br>      for (int x=0; x &lt; X; x++) for (int y=0; y &lt; Y; y++)<br>         if (G[y][x] == 'P') { px[P]=x; py[P]=y; pnum[x,y] = P; P++; }<br>         else if (G[y][x] == 'C') { cx[C]=x; cy[C]=y; C++; }<br>      if (C==0) return 0;<br>      int[] dx = new int[]{0,1,0,-1};<br>      int[] dy = new int[]{1,0,-1,0};<br>      dist = new int[C,P];<br>      for (int c=0; c &lt; C; c++) for (int p=0; p &lt; P; p++) dist[c,p] = 999999;<br>      int[] xs = new int[X*Y], ys = new int[X*Y], ts = new int[X*Y];<br>      for (int c=0; c &lt; C; c++)<br>         {<br>         bool[,] flag = new bool[X,Y];<br>         int done=0, todo=1;<br>         xs[0] = cx[c]; ys[0] = cy[c]; flag[xs[0],ys[0]] = true;<br>         while (done &lt; todo)<br>            {<br>            int x=xs[done], y=ys[done], t=ts[done];<br>            done++;<br>            for (int dir=0; dir &lt; 4; dir++)<br>               {<br>               int x2=x+dx[dir], y2=y+dy[dir];<br>               if (x2&lt;0 || y2&lt;0 || x2&gt;=X || y2&gt;=Y) continue;<br>               if (flag[x2,y2] || G[y2][x2] == 'X') continue;<br>               flag[x2,y2] = true;<br>               xs[todo] = x2; ys[todo] = y2; ts[todo] = t+1; todo++;<br>               if (G[y2][x2] == 'P')<br>                  dist[c,pnum[x2,y2]] = t+1;  <br>               }<br>            }<br>         }<br>      int minT=1, maxT=2501;<br>      while (maxT &gt; minT)<br>         {<br>         int curT = (maxT+minT)/2;<br>         bool can = Can(curT);<br>         if (can)<br>            maxT = curT;<br>         else<br>            minT = curT+1;<br>         }<br>      if (maxT &gt;= 2500)<br>         return -1;<br>      else<br>         return maxT;<br>      }<br>   bool Can(int T)<br>      {<br>      int[] CP = new int[C];<br>      int[] PC = new int[P];<br>      for (int p=0; p &lt; P; p++) PC[p]=-1;<br>      for (int c=0; c &lt; C; c++)<br>         {<br>         bool[] tried = new bool[P];<br>         if (!CanPlace(CP, PC, tried, c, T)) return false;<br>         }<br>      return true;<br>      }<br>   bool CanPlace(int[] CP,int[] PC, bool[] tried, int c, int T)<br>      {<br>      for (int p=0; p &lt; P; p++)<br>         {<br>         if (tried[p] || dist[c,p] &gt; T)<br>            continue;<br>         tried[p] = true;<br>         int oldC = PC[p];<br>         CP[c] = p; PC[p] = c;<br>         if (oldC &gt;= 0)<br>            {<br>            if (CanPlace(CP, PC, tried, oldC, T))<br>               return true;<br>            else<br>               PC[p] = oldC;<br>            }<br>         else<br>            return true;<br>         }<br>      return false;<br>      }<br><br><br>} // TopC#der<br><br><br>// Powered by FileEdit<br></td>