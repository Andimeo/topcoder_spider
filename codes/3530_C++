<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>using namespace std;<br>#define REP(i,n) for(int _n=n, i=0;i&lt;_n;++i)<br>#define FOR(i,a,b) for(int i=(a),_b=(b);i&lt;=_b;++i)<br>const int INF = 1000000000;<br>template&lt;class T&gt; inline int size(const T&amp;c) { return c.size(); }<br> <br>int sx,sy;<br>char board[64][64];<br> <br>int parknr[64][64];<br> <br>int ncars;<br>int npark;<br>int dist[128][128]; // INF<br>int edge[128][128];<br> <br>int ddd[64][64];<br> <br>void bfs(int startx,int starty,int d[]) {<br>  FOR(x,0,sx+1) FOR(y,0,sy+1) ddd[x][y]=INF;<br>  ddd[startx][starty] = 0;<br>  queue&lt;int&gt; q; q.push(startx*100 + starty);<br>  while(!q.empty()) {<br>    int qf = q.front(); q.pop();<br>    int x = qf / 100; int y = qf%100;<br>    int d = ddd[x][y];<br>#define AAA(x2,y2) { \<br>  if(board[x2][y2]!='X' &amp;&amp; ddd[x2][y2]==INF) {\<br>    ddd[x2][y2] = d+1; q.push((x2)*100 + (y2)); \<br>  } \<br>}<br>    AAA(x-1,y); AAA(x,y-1); AAA(x+1,y); AAA(x,y+1);<br>#undef AAA<br>  }<br>  FOR(x,1,sx) FOR(y,1,sy) if(board[x][y]=='P') d[parknr[x][y]] = ddd[x][y];<br>}<br> <br>int match1[128],match2[128];<br>int vis1[128], vis2[128];<br>int nmatch = 0;<br> <br>bool dfs(int c) {<br>  vis1[c] = 1;<br>  REP(p,npark) if(edge[c][p] &amp;&amp; !vis2[p]) {<br>    vis2[p] = true;<br>    int c2 = match2[p];<br>    if(c2==-1) {<br>      match2[p] = c; match1[c]=p; return true;<br>    }<br>    else {<br>      if(!vis1[c2] &amp;&amp; dfs(c2)) {<br>        match2[p] = c; match1[c]=p; return true;<br>      }<br>    }<br>  }<br>  return false;<br>}<br> <br>bool pushflow() {<br>  REP(c,ncars) vis1[c]=0;<br>  REP(p,npark) vis2[p]=0;<br>  REP(c,ncars) if(match1[c]==-1 &amp;&amp; !vis1[c] &amp;&amp; dfs(c)) return true;<br>  return false;<br>}<br> <br>int calc() {<br>  vector&lt;int&gt; edges;<br>  REP(c,ncars) REP(p,npark) if(dist[c][p]&lt;INF)<br>    edges.push_back((dist[c][p]&lt;&lt;16) + (c&lt;&lt;8) + p);<br>  sort(edges.begin(),edges.end());<br> <br>  REP(c,ncars) REP(p,npark) edge[c][p]=0;<br>  REP(c,ncars) match1[c]=-1;<br>  REP(p,npark) match2[p]=-1;<br>  nmatch = 0;<br>  <br>  int poz = 0;<br>  while(poz &lt; size(edges)) {<br>    int d = edges[poz]&gt;&gt;16;<br>    int q = poz;<br>    while(q&lt;size(edges) &amp;&amp; (edges[q]&gt;&gt;16)==d) ++q;<br>    for(int i=poz;i&lt;q;++i) {<br>      int a = edges[i]&amp;0xFFFF;<br>      edge[a&gt;&gt;8][a&amp;255] = 1;<br>    }<br>    while(pushflow()) ++nmatch;<br>    if(nmatch==ncars) return d;<br>    poz = q;<br>  }<br>  return -1;<br>}<br> <br>struct Parking {<br> <br>  // MAIN<br>  int minTime(vector &lt;string&gt; parkmap) {<br>    sy = size(parkmap); sx = size(parkmap[0]);<br>    FOR(x,0,sx+1) FOR(y,0,sy+1) board[x][y]='X';<br>    FOR(x,1,sx) FOR(y,1,sy) board[x][y] = parkmap[y-1][x-1];<br>    npark = 0;<br>    FOR(x,1,sx) FOR(y,1,sy) if(board[x][y]=='P') parknr[x][y]=npark++;<br>    ncars = 0;<br>    FOR(x,1,sx) FOR(y,1,sy) if(board[x][y]=='C') {<br>      bfs(x,y,dist[ncars]);<br>      ++ncars;<br>    }<br>    if(ncars==0) return 0;<br>    if(ncars&gt;npark) return -1;<br>    return calc();<br>  }<br> <br>};<br> <br>// Powered by FileEdit<br> <br>// Powered by TomekAI<br>// Powered by TZTester 1.01 [25-Feb-2003]<br> <br>// Powered by CodeProcessor<br></td>