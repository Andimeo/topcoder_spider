<td class="problemText" colspan="8" valign="middle" align="left">
            #line 2 "ConnectingPoints.cpp"<br>#include &lt;algorithm&gt;<br><br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;queue&gt;<br><br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cctype&gt;<br><br>using namespace std;<br><br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt; vector&lt;int&gt; &gt; VVI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt; vector&lt;string&gt; &gt; VVS;<br><br>typedef long long LL;<br>typedef pair&lt;int,int&gt; PII;<br>typedef pair&lt;int,PII&gt; TRI;<br>typedef map&lt;string,int&gt; MSI;<br><br>#define REP(i,n) for (int i=0; i&lt;(n); ++i)<br>#define FOR(i,l,u) for (int i=(l); i&lt;=(u); ++i)<br>#define FORD(i,u,l) for (int i=(u); i&gt;=(l); --i)<br>#define FOREACH(it,c) for (typeof((c).begin()) it = (c).begin() ; it != (c).end() ; ++it )<br>#define CLEAR(ar) memset((ar),0,sizeof(ar));<br><br>VS split(const string &amp;co, const string &amp;delim = " ") {<br>  VS res;<br>  string t="";<br>  REP(i,co.size()) {<br>    if (delim.find(co[i]) != string::npos) {<br>      if (!t.empty()) res.push_back(t);<br>      t = "";<br>    } else {<br>      t += co[i];<br>    }<br>  }<br>  if (!t.empty()) res.push_back(t);<br>  return res;<br>}<br><br>void vloz( set&lt;int&gt; &amp;S, int x, int N) {<br>  if (x&lt;0) return;<br>  if (x&gt;=N) return;<br>  S.insert(x);<br>}<br><br>int px[20], py[20];<br>int nx, ny;<br><br>int a1x, a1y, a2x, a2y;<br>int b1x, b1y, b2x, b2y;<br>int asize;<br><br>int apath[10][2];<br>int bpath[10][2];<br><br>int contains(int a, int b, int c) {<br>  if (c&lt;min(a,b)) return 0;<br>  if (c&gt;max(a,b)) return 0;<br>  return 1;<br>}<br><br>int intersect( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {<br>  int ux = x2-x1, uy = y2-y1;<br>  int vx = x4-x3, vy = y4-y3;<br>  if (ux * vx + uy * vy == 0) {<br>    // kolme<br>    if (ux == 0) {<br>      if (!contains(y1,y2,y3)) return 0;<br>      if (!contains(x3,x4,x1)) return 0;<br>      return 1;<br>    } else {<br>      if (!contains(x1,x2,x3)) return 0;<br>      if (!contains(y3,y4,y1)) return 0;<br>      return 1;<br>    }<br>  } else {<br>    // rovnobezne<br>    int a,b,c,d;<br>    if (ux == 0) {<br>      if (x1 != x3) return 0;<br>      a=y1; b=y2; c=y3; d=y4;<br>    } else {<br>      if (y1 != y3) return 0;<br>      a=x1; b=x2; c=x3; d=x4;<br>    }<br>    if (contains(a,b,c)) return 1;<br>    if (contains(a,b,d)) return 1;<br>    if (contains(c,d,a)) return 1;<br>    if (contains(c,d,b)) return 1;<br>    return 0;<br>  }<br>}<br><br>int trybpath(int co) {<br>  int best = 1000000000;<br>  if (co==1 || bpath[co-1][0] == bpath[co-2][0])<br>  REP(i,nx) {<br>    bpath[co][0] = px[i];<br>    bpath[co][1] = bpath[co-1][1];<br>    // check<br>    int ok=1;<br>    REP(i,asize) <br>      if (intersect( apath[i][0], apath[i][1], apath[i+1][0], apath[i+1][1], bpath[co-1][0], bpath[co-1][1], bpath[co][0], bpath[co][1] )) ok=0;<br>    if (!ok) continue;<br>    <br>    if (bpath[co][0] == b2x  &amp;&amp; bpath[co][1] == b2y) {<br>      int toto = 0;<br>      REP(j,co) toto += abs(bpath[j][0] - bpath[j+1][0]);<br>      REP(j,co) toto += abs(bpath[j][1] - bpath[j+1][1]);<br>      best &lt;?= toto;<br>    } else {<br>      if (co&lt;4) best &lt;?= trybpath(co+1);<br>    }<br>  }<br>  if (co==1 || bpath[co-1][1] == bpath[co-2][1])<br>  REP(i,ny) {<br>    bpath[co][0] = bpath[co-1][0];<br>    bpath[co][1] = py[i];<br>    // check<br>    int ok=1;<br>    REP(i,asize) <br>      if (intersect( apath[i][0], apath[i][1], apath[i+1][0], apath[i+1][1], bpath[co-1][0], bpath[co-1][1], bpath[co][0], bpath[co][1] )) ok=0;<br>    if (!ok) continue;<br>    <br>    if (bpath[co][0] == b2x  &amp;&amp; bpath[co][1] == b2y) {<br>      int toto = 0;<br>      REP(j,co) toto += abs(bpath[j][0] - bpath[j+1][0]);<br>      REP(j,co) toto += abs(bpath[j][1] - bpath[j+1][1]);<br>      best &lt;?= toto;<br>    } else {<br>      if (co&lt;4) best &lt;?= trybpath(co+1);<br>    }<br>  }<br>  return best;<br>}<br><br>int tryapath(int co) {<br>  int best = 1000000000;<br>  if (co==1 || apath[co-1][0] == apath[co-2][0])<br>  REP(i,nx) {<br>    apath[co][0] = px[i];<br>    apath[co][1] = apath[co-1][1];<br>    if (apath[co][0] == a2x  &amp;&amp; apath[co][1] == a2y) {<br>      asize = co;<br>      int bee = trybpath(1);<br>      int toto = 0;<br>      REP(j,co) toto += abs(apath[j][0] - apath[j+1][0]);<br>      REP(j,co) toto += abs(apath[j][1] - apath[j+1][1]);<br>      best &lt;?= bee + toto;<br>    } else {<br>      if (co&lt;4) best &lt;?= tryapath(co+1);<br>    }<br>  }<br>  if (co==1 || apath[co-1][1] == apath[co-2][1])<br>  REP(i,ny) {<br>    apath[co][0] = apath[co-1][0];<br>    apath[co][1] = py[i];<br>    if (apath[co][0] == a2x  &amp;&amp; apath[co][1] == a2y) {<br>      asize = co;<br>      int bee = trybpath(1);<br>      int toto = 0;<br>      REP(j,co) toto += abs(apath[j][0] - apath[j+1][0]);<br>      REP(j,co) toto += abs(apath[j][1] - apath[j+1][1]);<br>      best &lt;?= bee + toto;<br>    } else {<br>      if (co&lt;4) best &lt;?= tryapath(co+1);<br>    }<br>  }<br>  return best;<br>}<br><br>class ConnectingPoints {<br>  public:<br>  int shortestWires(int N, vector &lt;int&gt; X, vector &lt;int&gt; Y) {<br>    set &lt;int&gt; SX;<br>    set &lt;int&gt; SY;<br>    REP(i,4) FOR(d,-1,1) { vloz(SX,X[i]+d,N); vloz(SY,Y[i]+d,N); }<br><br>    nx = ny = 0; <br>    FOREACH(it,SX) px[nx++]=*it;<br>    FOREACH(it,SY) py[ny++]=*it;<br><br>    cout &lt;&lt; nx &lt;&lt; " " &lt;&lt; ny &lt;&lt; endl;<br><br>    a1x = X[0]; a1y = Y[0];<br>    a2x = X[1]; a2y = Y[1];<br>    b1x = X[2]; b1y = Y[2];<br>    b2x = X[3]; b2y = Y[3];<br><br>    apath[0][0] = a1x; apath[0][1] = a1y;<br>    bpath[0][0] = b1x; bpath[0][1] = b1y;<br><br>    int best = 1000000000;<br><br>    best &lt;?= tryapath(1);<br><br>    if (best == 1000000000) return -1;<br>    return best;<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>