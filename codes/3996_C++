<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;algorithm&gt;<br>#include&lt;ctype.h&gt;<br>#include&lt;iostream&gt;<br>#include&lt;math.h&gt;<br>#include&lt;set&gt;<br>#include&lt;sstream&gt;<br>#include&lt;stdio.h&gt;<br>#include&lt;string&gt;<br>#include&lt;utility&gt;<br>#include&lt;vector&gt;<br><br>using namespace std;<br><br><br>#define sqr(x) ((x)*(x))<br><br>struct point {<br>  double x,y;<br>  point(double x1, double y1){x=x1;y=y1;}<br>};<br>typedef vector&lt;point&gt; VP;<br>inline point operator+(point p1, point p2){point p(p1.x+p2.x,p1.y+p2.y); return p;}<br>inline point operator-(point p1, point p2){point p(p1.x-p2.x,p1.y-p2.y); return p;}<br>inline double operator*(point p1, point p2){return p1.x*p2.x+p1.y*p2.y;}<br>inline double operator^(point p1, point p2){return p1.x*p2.y-p1.y*p2.x;}<br>inline double mag(point p1){return hypot(p1.x,p1.y);}<br>point inf(1e99,1e99);<br><br>vector&lt;point&gt; giftwrap(vector&lt;point&gt; p) {<br>  vector&lt;point&gt; hull;<br>  int i,m=0,n=p.size();<br>  double c;<br>  for(i=1;i&lt;n;i++)<br>    if(p[i].x&lt;p[m].x)m=i;<br>  swap(p[0],p[m]);<br>  hull.push_back(p[0]);<br>  for(;;) {<br>    point b=hull.back();<br>    m=0;<br>    for(i=0;i&lt;n;i++) {<br>      c=(p[i]-b)^(p[m]-b);<br>      if(c&lt;-1e-9){m=i;continue;}<br>      if(fabs(c)&lt;1e-9&amp;&amp;mag(p[i]-b)&gt;mag(p[m]-b))m=i;<br>    }<br>    if(m==0)return hull;<br>    hull.push_back(p[m]);<br>    swap(p[m],p[n-1]);<br>    p.pop_back();<br>    n--;<br>  }<br>}<br><br>// Area of a polygon<br>double area(vector&lt;point&gt; p) {<br>  double ret=0;<br>  int i;<br>  p.push_back(p[0]);<br>  for(i=0;i&lt;p.size()-1;i++)<br>    ret+=p[i].x*p[i+1].y-p[i+1].x*p[i].y;<br>  return fabs(ret)/2.0;<br>}<br><br><br>class CultureGrowth {<br>  public:<br>  double finalTray(vector &lt;int&gt; xs, vector &lt;int&gt; ys) {<br>    VP p;<br>    for(int i = 0; i &lt; xs.size(); i++) {<br>      p.push_back(point(xs[i],ys[i]));<br>    }<br>    for(int i = 0; i+1 &lt; xs.size(); i++) {<br>      p.push_back(point((xs[i]+xs[i+1])/2.0,(ys[i]+ys[i+1])/2.0));<br>    }<br>    p = giftwrap(p);<br>    return area(p);<br>  }<br>};<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>