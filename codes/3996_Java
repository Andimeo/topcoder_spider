<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br> <br>public class CultureGrowth {<br> <br>    final double INF_DOUBLE = 1e+200;<br>    final double epsilon = 1e-11;<br> <br>    int N;<br>    int convexHull(double [][] point, boolean withEdgePoints, double [][] hullRet) {<br>  int N = point.length;<br>  if (N == 0)<br>      return 0;<br> <br>  int oi = 0;<br>  for (int i=1; i&lt;N; i++)<br>      if (point[i][1] &lt; point[oi][1] ||<br>    point[i][1] == point[oi][1] &amp;&amp; point[i][0] &lt; point[oi][0])<br>    oi = i;<br>  int rv = 0;<br> <br>  int idx = oi;<br>  int previdx = -1;<br>  double cp = 0;<br> <br>  do {<br>      hullRet[rv][0] = point[idx][0];<br>      hullRet[rv][1] = point[idx][1];<br>      rv++;<br> <br>      int ni = -1;<br>      double dsq = withEdgePoints ? INF_DOUBLE : 0;<br>      for (int i=0; i&lt;N; i++) {<br>    int ci = (idx+i)%N;<br>    if (ci == idx)<br>        continue;<br>    double curdsq =<br>        (point[ci][0]-point[idx][0])*(point[ci][0]-point[idx][0]) +<br>        (point[ci][1]-point[idx][1])*(point[ci][1]-point[idx][1]);<br>    if (ni &gt;= 0) {<br>        cp =<br>      (point[ni][0]-point[idx][0])*(point[ci][1]-point[idx][1])<br>      - (point[ni][1]-point[idx][1])*(point[ci][0]-point[idx][0]);<br>        if (cp &lt; 0) {<br>      continue;<br>        } else if (Math.abs(cp) &lt; epsilon) {<br>      if (previdx &gt;= 0 &amp;&amp;<br>          (Math.abs((point[previdx][0]-point[idx][0])*(point[ci][1]-point[idx][1])-<br>              (point[previdx][1]-point[idx][1])*(point[ci][0]-point[idx][0])) &lt; epsilon))<br>          if ((point[ci][0]-point[idx][0])*(point[previdx][0]-point[idx][0])<br>        + (point[ci][1]-point[idx][1])*(point[previdx][0]-point[idx][1]) &lt; epsilon)<br>        continue;<br>      if (!(withEdgePoints &amp;&amp; curdsq &lt; dsq ||<br>            !withEdgePoints &amp;&amp; curdsq &gt; dsq))<br>          continue;<br>        }<br>    }<br>    ni = ci;<br>    dsq = curdsq;<br>      }<br> <br>      if (ni &lt; 0)<br>    return rv;<br>      previdx = idx;<br>      idx = ni;<br>  } while (idx != oi);<br> <br>  return rv;<br>    }<br>    double polygonArea(Iterator it) {<br>  if (!it.hasNext())<br>      return 0;<br>  double [] p0 = (double [])it.next();<br>  double [] o = p0;<br>  double [] prev = p0;<br> <br>  double rv = 0;<br>  boolean contf = true;<br>  while (contf) {<br>      double [] p;<br>      if (it.hasNext()) {<br>    p = (double [])it.next();<br>      } else {<br>    p = p0;<br>    contf = false;<br>      }<br>      rv += (p[0]-o[0])*(prev[1]-o[1]) - (p[1]-o[1])*(prev[0]-o[0]);<br>      prev = p;<br>  }<br> <br>  return Math.abs(rv)/2;<br>    }<br>    class ArrayIterator implements Iterator {<br>  Object [] a;<br>  int pos;<br>  int base;<br>  int len;<br>  public ArrayIterator(Object [] oa, int base, int len) {<br>      a = oa;<br>      pos = 0;<br>      this.base = base;<br>      this.len = len;<br>      proceedPos();<br>  }<br> <br>  public ArrayIterator(Object [] oa) {<br>      this(oa, 0, oa.length);<br>  }<br> <br>  void proceedPos() {<br>      while (pos &lt; len &amp;&amp;<br>       !elemOk())<br>    pos++;<br>  }<br> <br>  public boolean hasNext() {<br>      return pos &lt; len;<br>  }<br> <br>  public Object next() {<br>      Object rv = a[base + pos++];<br>      proceedPos();<br>      return rv;<br>  }<br> <br>  public boolean elemOk() {<br>      return true;<br>  }<br> <br>  public void remove() {<br>      throw new UnsupportedOperationException();<br>  }<br>    }<br> <br>    public double finalTray(int[] xs, int[] ys) { <br>  N = xs.length;<br>  double [][] P = new double[N][2];<br>  for (int i=0; i&lt;N; i++) {<br>      P[i][0] = xs[i];<br>      P[i][1] = ys[i];<br>  }<br>  double [][] hull = new double[N][2];<br>  int numPointsInHull = convexHull(P, false, hull);<br>        return polygonArea(new ArrayIterator(hull, 0, numPointsInHull));<br>    }<br> <br>}<br> <br>// Powered by CodeProcessor<br></td>