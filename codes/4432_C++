<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;sstream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br><br>using namespace std;<br><br>typedef long long ll;<br>typedef pair&lt;int,int&gt; pii;<br>typedef pair&lt;double,double&gt; pdd;<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef map&lt;string,int&gt; msi;<br>typedef unsigned int uint;<br>typedef map&lt;int, uint&gt; mii;<br><br>int init1[30], init2[30], park1[30], park2[30];<br>mii ways;<br>int tot;<br><br>uint lim = 2000000000;<br><br>uint Ways(int M) {<br>  if (!M) return 1;<br>  uint &amp;res = ways[M];<br>  if (!res) {<br>    for (int i = 0; (1&lt;&lt;i) &lt;= M; ++i)<br>      if (M &amp; (1&lt;&lt;i)) {<br>  if (!(init1[i] &amp; M) &amp;&amp; !(park1[i] &amp; ~M) ||<br>      !(init2[i] &amp; M) &amp;&amp; !(park2[i] &amp; ~M)) {<br>    res += Ways(M &amp; ~(1&lt;&lt;i));<br>    if (res &gt; lim) {<br>      res = lim+1;<br>      break;<br>    }<br>  }<br>      }<br>    ++res;<br>  }<br>  return res-1;<br>}<br><br>struct CircleCount {<br>  int countOrder(string circle) {<br>    int n = circle.length();<br>    int have = 0;<br>    int free = 0;<br>    for (int i = 0; i &lt; n; ++i)<br>      if (tolower(circle[i]) == circle[i]) {<br>  int x = circle[i]-'a';<br>  init1[x] = init2[x] = park1[x] = park2[x] = 0;<br>  for (int j = 1; j &lt; n; ++j) {<br>    char c = circle[(i+j)%n];<br>    if (tolower(c) == circle[i])<br>      break;<br>    if (tolower(c) == c)<br>      init1[x] |= 1&lt;&lt;(c-'A');<br>    else<br>      park1[x] |= 1&lt;&lt;(c-'A');<br>  }<br>  for (int j = 1; j &lt; n; ++j) {<br>    char c = circle[(i-j+n)%n];<br>    if (tolower(c) == circle[i])<br>      break;<br>    if (tolower(c) == c)<br>      init2[x] |= 1&lt;&lt;(c-'a');<br>    else<br>      park2[x] |= 1&lt;&lt;(c-'A');<br>  }<br>  if (!init1[x] &amp;&amp; !park1[x] || !init2[x] &amp;&amp; !park2[x])<br>    ++free;<br>  else<br>    have |= 1&lt;&lt;x;<br>      }<br>    ways.clear();<br>    ll res = Ways(have);<br>    for (int i = 0; i &lt; free; ++i) {<br>      if (res &gt; lim) break;<br>      res *= n/2-i;<br>    }<br>    if (res &gt; lim) res = -1;<br>    return res;<br>  }<br>  <br>};<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>