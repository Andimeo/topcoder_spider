<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class AntiChess {<br>  struct Position<br>  {<br>    public int row;<br>    public int col;<br><br>    public Position(string p)<br>    {<br>      row = p[1] - '1';<br>      col = p[0] - 'a';<br>    }<br>  }<br><br>  Position[] pawn;<br>  Position queen;<br>  bool[] alive;<br>  int taken;<br><br>  int playPawns(int alpha, int beta)<br>  {<br>    if (alpha == beta)<br>      return alpha;<br><br>    if (taken &gt;= beta)<br>      return beta;<br><br>    if (taken &gt; alpha)<br>      alpha = taken;<br><br>    for (int i = 0; i &lt; pawn.Length; ++i)<br>      if (alive[i])<br>        if (pawn[i].row == queen.row - 1 &amp;&amp; Math.Abs(pawn[i].col - queen.col) == 1)<br>          return Math.Min(Math.Max(taken, alpha), beta);<br><br>    for (int i = 0; i &lt; pawn.Length; ++i)<br>      if (alive[i])<br>      {<br>        if (pawn[i].row == 7 || (pawn[i].row == queen.row - 1 &amp;&amp; pawn[i].col == queen.col))<br>          continue;<br><br>        ++pawn[i].row;<br>        alpha = playQueen(alpha, beta);<br>        if (alpha &lt; beta &amp;&amp; pawn[i].row == 2 &amp;&amp; (pawn[i].row != queen.row - 1 || pawn[i].col != queen.col))<br>        {<br>          ++pawn[i].row;<br>          alpha = playQueen(alpha, beta);<br>          --pawn[i].row;<br>        }<br>        --pawn[i].row;<br><br>        if (alpha == beta)<br>          return alpha;<br>      }<br><br>    return alpha;<br>  }<br><br>  int playQueen(int alpha, int beta)<br>  {<br>    if (alpha == beta)<br>      return alpha;<br><br>    if (taken &gt;= beta)<br>      return beta;<br><br>    if (taken &gt; alpha)<br>      alpha = taken;<br><br>    bool any = false;<br><br>    for (int dc = -1; dc &lt;= 1; ++dc)<br>      for (int dr = -1; dr &lt;= 1; ++dr)<br>        if (dc != 0 || dr != 0)<br>        {<br>          int k = int.MaxValue;<br>          int ki = -1;<br><br>          for (int i = 0; i &lt; pawn.Length; ++i)<br>            if (alive[i])<br>            {<br>              int r = pawn[i].row - queen.row;<br>              int c = pawn[i].col - queen.col;<br>              int ck;<br><br>              if (dr == 0)<br>                ck = c / dc;<br>              else<br>                ck = r / dr;<br><br>              if (ck &gt; 0 &amp;&amp; ck &lt; k &amp;&amp; c == ck * dc &amp;&amp; r == ck * dr)<br>              {<br>                k = ck;<br>                ki = i;<br>              }<br>            }<br><br>          if (ki &gt;= 0)<br>          {<br>            any = true;<br>            alive[ki] = false;<br>            Position tmp = queen;<br>            queen = pawn[ki];<br>            ++taken;<br>            beta = playPawns(alpha, beta);<br>            --taken;<br>            queen = tmp;<br>            alive[ki] = true;<br>            if (alpha == beta)<br>              return beta;<br>          }<br>        }<br><br>    if (any)<br>      return beta;<br>    else<br>      return Math.Min(Math.Max(taken, alpha), beta);<br>  }<br><br>  public int sacrifice(string[] white, string black) {<br>    pawn = new Position[white.Length];<br>    for (int i = 0; i &lt; white.Length; ++i)<br>      pawn[i] = new Position(white[i]);<br>    queen = new Position(black);<br><br>    alive = new bool[pawn.Length];<br>    for (int i = 0; i &lt; pawn.Length; ++i)<br>      alive[i] = true;<br><br>    taken = 0;<br><br>    return playPawns(0, pawn.Length);<br>  }<br><br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>