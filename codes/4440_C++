<td class="problemText" colspan="8" valign="middle" align="left">
            # include &lt;string&gt;<br># include &lt;vector&gt;<br># include &lt;iostream&gt;<br># include &lt;sstream&gt;<br># include &lt;cstdio&gt;<br># include &lt;cstdlib&gt;<br># include &lt;cmath&gt;<br># include &lt;cctype&gt;<br># include &lt;cstring&gt;<br># include &lt;map&gt;<br># include &lt;queue&gt;<br># include &lt;deque&gt;<br># include &lt;set&gt;<br># include &lt;algorithm&gt;<br># include &lt;utility&gt;<br># include &lt;functional&gt;<br># include &lt;stack&gt;<br># include &lt;bitset&gt;<br># include &lt;complex&gt;<br># include &lt;cassert&gt;<br># include &lt;ctime&gt;<br># include &lt;list&gt;<br># include &lt;valarray&gt;<br><br># ifdef WIN32<br>typedef __int64 int64 ;<br># define min __min<br># define max __max<br># define for if ( false ) ; else for<br># else<br>typedef long long int64 ;<br># endif<br><br>using namespace std ;<br><br>vector &lt; char &gt; cols ;<br><br>map &lt; pair &lt; vector &lt; int &gt; , pair &lt; int , int &gt; &gt; , int &gt; p1 ;<br>map &lt; pair &lt; vector &lt; int &gt; , pair &lt; int , int &gt; &gt; , int &gt; p2 ;<br><br>int process2 ( pair &lt; vector &lt; int &gt; , pair &lt; int , int &gt; &gt; pos ) ;<br><br>int process1 ( pair &lt; vector &lt; int &gt; , pair &lt; int , int &gt; &gt; pos )<br>{<br>  if ( p1 [ pos ] )<br>    return p1 [ pos ] - 1 ;<br>  for ( int i = 0 ; i &lt; pos . first . size ( ) ; ++ i )<br>    if ( pos . second . second - pos . first [ i ] == 1 &amp;&amp; abs ( pos . second . first - cols [ i ] ) == 1 )<br>    {<br>      p1 [ pos ] = 1 ;<br>      return 0 ;<br>    }<br>  int r = 0 ;<br>  for ( int i = 0 ; i &lt; pos . first . size ( ) ; ++ i )<br>    if ( pos . first [ i ] != - 1 &amp;&amp; pos . first [ i ] != 8 )<br>    {<br>      if ( pos . second . first == cols [ i ] &amp;&amp; pos . second . second == pos . first [ i ] + 1 )<br>        continue ;<br>      ++ pos . first [ i ] ;<br>      r = max ( process2 ( pos ) , r ) ;<br>      -- pos . first [ i ] ;<br>      if ( pos . first [ i ] == 2 &amp;&amp; ! ( pos . second . first == cols [ i ] &amp;&amp; pos . second . second == pos . first [ i ] + 2 ) )<br>      {<br>        pos . first [ i ] += 2 ;<br>        r = max ( process2 ( pos ) , r ) ;<br>        pos . first [ i ] -= 2 ;<br>      }<br>    }<br>  p1 [ pos ] = r + 1 ;<br>  return r ;<br>}<br><br>int process2 ( pair &lt; vector &lt; int &gt; , pair &lt; int , int &gt; &gt; pos )<br>{<br>  if ( p2 [ pos ] )<br>    return p2 [ pos ] - 1 ;<br>  int r = 1000000 ;<br>  for ( int i = 0 ; i &lt; pos . first . size ( ) ; ++ i )<br>  {<br>    if ( pos . first [ i ] == - 1 )<br>      continue ;<br>    pair &lt; int , int &gt; cur = pos . second ;<br>    int dx = cur . first - cols [ i ] ;<br>    int dy = cur . second - pos . first [ i ] ;<br>    if ( abs ( dx ) != abs ( dy ) &amp;&amp; dx &amp;&amp; dy )<br>      continue ;<br>    bool bad = false ;<br>    for ( int j = 0 ; j &lt; pos . first . size ( ) ; ++ j )<br>      if ( i != j )<br>      {<br>        int dx1 = cur . first - cols [ j ] ;<br>        int dy1 = cur . second - pos . first [ j ] ;<br>        if ( abs ( dx1 ) != abs ( dy1 ) &amp;&amp; dx1 &amp;&amp; dy1 )<br>          continue ;<br>        if ( abs ( dx1 ) + abs ( dy1 ) &gt;= abs ( dx ) + abs ( dy ) )<br>          continue ;<br>        if ( dx &amp;&amp; ! dx1 || dy &amp;&amp; ! dy1 || ! dx &amp;&amp; dx1 || ! dy &amp;&amp; dy1 )<br>          continue ;<br>        if ( dx * dx1 &lt; 0 || dy * dy1 &lt; 0 )<br>          continue ;<br>        bad = true ;<br>        break ;<br>      }<br>    if ( bad )<br>      continue ;<br>    pos . second . first = cols [ i ] ;<br>    pos . second . second = pos . first [ i ] ;<br>    pos . first [ i ] = - 1 ;<br>    r = min ( process1 ( pos ) + 1 , r ) ;<br>    pos . first [ i ] = pos . second . second ;<br>    pos . second = cur ;<br>  }<br>  if ( r == 1000000 )<br>    r = 0 ;<br>  p2 [ pos ] = r + 1 ;<br>  return r ;<br>}<br><br>class AntiChess<br>{<br>public :<br>  int sacrifice ( vector &lt;string&gt; white, string black )<br>  {<br>    int res ;<br>    int i , j , k ;<br>    int n ;<br>    cols . clear ( ) ;<br>    sort ( white . begin ( ) , white . end ( ) ) ;<br>    for ( int i = 0 ; i &lt; white . size ( ) ; ++ i )<br>      cols . push_back ( white [ i ] [ 0 ] - 'a' ) ;<br>    vector &lt; int &gt; pos ;<br>    for ( int i = 0 ; i &lt; white . size ( ) ; ++ i )<br>      pos . push_back ( white [ i ] [ 1 ] - '0' ) ;<br>    p1 . clear ( ) ;<br>    p2 . clear ( ) ;<br>    return process1 ( make_pair ( pos , make_pair ( black [ 0 ] - 'a' , black [ 1 ] - '0' ) ) ) ;<br>  }<br>  <br><br>} ;<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.1 [28-Sep-2005]<br>// Powered by CodeProcessor<br></td>