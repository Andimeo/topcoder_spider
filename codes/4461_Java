<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br>import java.text.*;<br>import java.math.*;<br>public class MirrorPlacement {<br>  public int mirrors(String[] map) {<br>    int gx = 0, gy = 0, gd = 0;<br>    boolean found = false;<br>    TreeSet que = new TreeSet();<br>    int[] dx = {-1,0,1,0};<br>    int[] dy = {0,-1,0,1};<br>    for(int i = 0; i &lt; map.length; i++){<br>      if(map[i].charAt(0)=='.'){<br>        if(found){<br>          gx = i;<br>          gy = 0;<br>          gd = 1;<br>        }else{<br>          found = true;<br>          que.add(new State(i,0,3,0));<br>        }<br>      }<br>      if(map[i].charAt(map[i].length()-1)=='.'){<br>        if(found){<br>          gx = i;<br>          gy = map[i].length()-1;<br>          gd = 3;<br>        }else{<br>          found = true;<br>          que.add(new State(i,map[i].length()-1,1,0));<br>        }        <br>      }<br>    }<br>    for(int i = 0; i &lt; map[0].length(); i++){<br>      if(map[0].charAt(i)=='.'){<br>        if(found){<br>          gx = 0;<br>          gy = i;<br>          gd = 0;<br>        }else{<br>          found = true;<br>          que.add(new State(0,i,2,0));<br>        }<br>      }<br>      if(map[map.length-1].charAt(i)=='.'){<br>        if(found){<br>          gx = map.length-1;<br>          gy = i;<br>          gd = 2;<br>        }else{<br>          found = true;<br>          que.add(new State(map.length-1,i,0,0));<br>        }<br>      }<br>    }<br>    int mx = map.length;<br>    int my = map[0].length();<br>    boolean[][][] been = new boolean[mx][my][4];<br>    while(que.size() &gt; 0){<br>      State s = (State)que.first();<br>      que.remove(s);<br>      if(been[s.x][s.y][s.d])continue;<br>  //    System.out.println("Can be at "+s.x+","+s.y+" with dir "+s.d+" and cost "+s.c);<br>      been[s.x][s.y][s.d] = true;<br>      if(s.x == gx &amp;&amp; s.y == gy){<br>        if(s.d == gd) return s.c;<br>        que.add(new State(s.x, s.y, gd, s.c+1));<br>      }<br>      if(map[s.x].charAt(s.y)=='#')continue;<br>      if(map[s.x].charAt(s.y) == '/'){<br>        int nd = 0;<br>        if(s.d==0) nd = 3;<br>        if(s.d==1) nd = 2;<br>        if(s.d==2) nd = 1;<br>        if(s.d==3) nd = 0;<br>        que.add(new State(s.x+dx[nd], s.y+dy[nd], nd, s.c));<br>        continue;<br>      }<br>//    int[] dx = {-1,0,1,0};<br>//    int[] dy = {0,-1,0,1};<br>      if(map[s.x].charAt(s.y) == '`'){<br>        int nd = 0;<br>        if(s.d==0) nd = 1;<br>        if(s.d==1) nd = 0;<br>        if(s.d==2) nd = 3;<br>        if(s.d==3) nd = 2;<br>        que.add(new State(s.x+dx[nd], s.y+dy[nd], nd, s.c));<br>        continue;<br>      }<br>      for(int i = 0; i &lt; dx.length; i++){<br>        int nx = s.x+dx[i];<br>        int ny = s.y+dy[i];<br>        if(nx &lt; 0 || ny &lt; 0 || nx &gt;= mx || ny &gt;= my)continue;<br>        if(map[nx].charAt(ny) == '#')continue;<br>        if(i==s.d) que.add(new State(nx, ny, i, s.c));<br>        else if(i%2 == s.d%2)continue;<br>        else que.add(new State(nx, ny, i, s.c+1));<br>      }<br>    }<br>    return -1;<br>  }<br>  class State implements Comparable{<br>    int x, y, d, c;<br>    State(int xx, int yy, int dd, int cc){ x = xx; y = yy; d = dd; c = cc;}<br>    public int compareTo(Object o){<br>      State s = (State)o;<br>      if(s.c != c) return c-s.c;<br>      if(s.x != x) return x-s.x;<br>      if(s.y != y) return y-s.y;<br>      return s.d - d;<br>    }<br>  }<br> <br>}<br> <br>// Powered by PopsEdit<br>// Powered by CodeProcessor<br></td>