<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cmath&gt;<br>using namespace std;<br> <br>#define REP(i,n)        for(int i=0,_n=(n);i&lt;_n;++i)<br> <br>class okrag {<br>  public:<br>    double x, y, r;<br>};<br>vector&lt;okrag&gt; okregi;<br>int ile_roznych = 0;<br> <br>bool cmp (okrag o1, okrag o2) {<br>  return o1.r &gt; o2.r;<br>}<br> <br>// k w j ?<br>bool zawiera_sie(int k, int j) {<br>  double odl = (okregi[k].x-okregi[j].x)*(okregi[k].x-okregi[j].x) + (okregi[k].y-okregi[j].y)*(okregi[k].y-okregi[j].y);<br>  return odl &lt;= (okregi[j].r-okregi[k].r)*(okregi[j].r-okregi[k].r);<br>}<br> <br>int poziom[100];<br> <br>double pole (int k) {<br>  return M_PI * okregi[k].r * okregi[k].r;<br>}<br> <br>class BlackWhitePlane{<br>      public:<br>            double area(vector &lt;string&gt; circles)  {<br>              REP(i,100) poziom[i] = 0;<br>              REP(i,circles.size()) {<br>                double x, y, r;<br>                sscanf (circles[i].c_str(), "%lf %lf %lf", &amp;x, &amp;y, &amp;r);<br>                okrag o;<br>                o.x = x;<br>                o.y = y;<br>                o.r = r;<br>                okregi.push_back(o);<br>              }<br>              double white = 0;<br>              sort(okregi.begin(), okregi.end(), cmp);<br>              poziom[0] = 0;<br>              for(int j = 0; j &lt; okregi.size(); j++) {<br>                for (int k = j-1; k &gt;= 0; --k) {<br>                  if (zawiera_sie(j,k)) {<br>                    poziom[j] = poziom[k] + 1;<br>                    break;<br>                  }<br>                }<br>                if (poziom[j] % 2 == 0) white += pole(j);<br>                else white -= pole(j);<br>              }<br>              return white;<br>              <br>            }<br>};<br></td>