<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br>import java.text.*;<br>import java.math.*;<br>import java.awt.geom.*;<br> <br>public class AirTravel<br>{<br>  public double shortestTrip(int[] latitude, int[] longitude, String[] canTravel, int origin, int destination)<br>  {<br>    int na = latitude.length;<br>    double dist[][] = new double[na][na];  // from..to<br>    double oo = 1e99;  // infinity. Thanks to athenachu71<br>    double radius = 4000.0;<br>    double lats[] = new double[na], longs[] = new double[na];<br>    for (int i = 0; i &lt; na; ++i)<br>    {<br>      lats[i] = latitude[i]*(Math.PI/180.0);<br>      longs[i] = longitude[i]*(Math.PI/180.0);<br>    }<br>    for (int i = 0; i &lt; na; ++i)<br>    {<br>      for (int j = 0; j &lt; na; ++j)<br>      {<br>        if (i != j) {<br>          dist[i][j] = radius * Math.acos(Math.sin(lats[i]) * Math.sin(lats[j]) + <br>                        Math.cos(lats[i]) * Math.cos(lats[j]) * <br>                        Math.cos(longs[i] - longs[j]));<br>        }<br>        else dist[i][j] = 0;<br>      }<br>    }<br>    // now block out invalid places<br>    for (int i = 0; i &lt; canTravel.length; ++i)<br>    {<br>      // these are the good destinations from 'i' to there.<br>      List gooddests = Arrays.asList(canTravel[i].split(" "));<br>      for (int j = 0; j &lt; na; ++j)<br>      {<br>        if (i != j &amp;&amp; !gooddests.contains(""+j)) {<br>          dist[i][j] = oo;<br>        }<br>      }<br>    }<br>    // Floyd here now!<br>    for (int k = 0; k &lt; na; ++k)<br>      for (int i = 0; i &lt; na; ++i)<br>        for (int j = 0; j &lt; na; ++j)<br>          dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);<br> <br>    if (dist[origin][destination] &gt;= oo) return -1;<br>    return dist[origin][destination];<br>  }<br>}<br> <br>//Powered by [KawigiEdit]<br></td>