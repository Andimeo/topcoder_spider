<td class="problemText" colspan="8" valign="middle" align="left">
            // another fine solution by misof<br>#include &lt;algorithm&gt;<br> <br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br> <br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>using namespace std;<br> <br>#define REP(i,n) for(int i=0;i&lt;(n);++i)<br>#define CLEAR(t) memset((t),0,sizeof(t))<br>typedef vector&lt;int&gt; VI;<br>vector&lt;string&gt; split( const string&amp; s, const string&amp; delim =" " ) { vector&lt;string&gt; res; string t; for ( unsigned int i = 0 ; i != s.size() ; i++ ) { if ( delim.find( s[i] ) != string::npos ) { if ( !t.empty() ) { res.push_back( t ); t = ""; } } else { t += s[i]; } } if ( !t.empty() ) { res.push_back(t); } return res; }<br>vector&lt;int&gt; splitInt( const string&amp; s, const string&amp; delim =" " ) { vector&lt;string&gt; tok = split( s, delim ); vector&lt;int&gt; res; for ( unsigned int i = 0 ; i != tok.size(); i++ ) res.push_back( atoi( tok[i].c_str() ) ); return res; }<br> <br>/////////////////// CODE WRITTEN DURING THE COMPETITION FOLLOWS ////////////////////////////////<br> <br>int kam[24][4];<br>int N;<br> <br>int bol[1234567];<br> <br>int wt(int x) { int res=0; while (x) { if (x%2) res++; x/=2; } return res; }<br> <br>class SequenceSync {<br>public:<br>  int getLength(vector &lt;string&gt; transitions) {<br>    N = transitions.size();<br>    REP(i,N) {<br>      VI V = splitInt( transitions[i] );<br>      REP(j,4) kam[i][j] = V[j];<br>    }<br> <br>    if (N==1) return 0;<br> <br>    CLEAR(bol);<br>    bol[ (1&lt;&lt;N) -1 ] = 1;<br> <br>    queue&lt;int&gt; Q;<br>    Q.push( (1&lt;&lt;N) - 1);<br> <br>    while (!Q.empty()) {<br>      int kde = Q.front();<br>      Q.pop();<br> <br>      REP(s,4) {<br>        int next = 0;<br>        REP(i,N) if (kde &amp; (1&lt;&lt;i)) next |= 1&lt;&lt;kam[i][s];<br>        if (bol[next]) continue;<br>        bol[next]=bol[kde]+1;<br>        if (wt(next)==1) return bol[next]-1;<br>        Q.push(next);<br>      }<br>    }<br>    <br>    return -1;<br>  }<br> <br> <br>};<br>// Unused code automatically removed, but the UCR still sucks<br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>