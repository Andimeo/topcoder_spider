<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Text;<br>using System.Text.RegularExpressions;<br>using System.Collections;<br><br>public class ConvexPolygons {<br>  int[] x1, y1, x2, y2;<br>  double[] cx, cy;<br><br>  void inp(string[] p, out int[] x, out int[] y)<br>  {<br>    x = new int[p.Length];<br>    y = new int[p.Length];<br><br>    for (int i = 0; i &lt; p.Length; i++)<br>    {<br>      string[] s = p[i].Split();<br><br>      x[i] = int.Parse(s[0]);<br>      y[i] = int.Parse(s[1]);<br>    }<br>  }<br><br>  bool pt_inside(int x, int y, int[] px, int[] py)<br>  {<br>    int cnt = 0;<br>    for (int i=0; i &lt; px.Length; i++)<br>    {<br>      int j = (i+1)%px.Length;<br><br>      if (px[i] &lt; x &amp;&amp; px[j] &lt; x) continue;<br>      if (py[i] &gt;= y &amp;&amp; py[j] &gt;= y) continue;<br>      if (py[i] &lt; y &amp;&amp; py[j] &lt; y) continue;<br><br>      double t = (double)(y - py[i])/(py[j] - py[i]);<br>      if (t &lt; -1E-6 || t &gt; 1+1E-6) continue;<br>      double xx = px[i] + (px[j]-px[i])*t;<br>      if (xx &lt; x - 1E-6) continue;<br>      cnt++;<br>    }<br><br>    return cnt%2 == 1;<br>  }<br><br>  void calcABC(int x1, int y1, int x2, int y2, out double A, out double B, out double C)<br>  {<br>    A = y2-y1;<br>    B = x1-x2;<br>    C = -x1*y2 + x2*y1;<br>  }<br><br>  bool cross(int x1, int y1, int x2, int y2, double A, double B, double C)<br>  {<br>    return (A*x1 + B*y1 + C)*(A*x2 + B*y2 + C) &lt; -1E-6;<br>  }<br><br>  bool cross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, out double x, out double y)<br>  {<br>    double A1, B1, C1, A2, B2, C2;<br><br>    calcABC(x1, y1, x2, y2, out A1, out B1, out C1);<br>    calcABC(x3, y3, x4, y4, out A2, out B2, out C2);<br><br>    if (cross(x1, y1, x2, y2, A2, B2, C2) &amp;&amp; cross(x3, y3, x4, y4, A1, B1, C1))<br>    {<br>      double d = A1*B2 - B1*A2;<br>      double dx = -C1*B2 + B1*C2;<br>      double dy = -A1*C2 + C1*A2;<br><br>      x = dx/d;<br>      y = dy/d;<br><br>      return true;<br>    }<br>    else<br>    {<br>      x = 0; y = 0;<br>      return false;<br>    }<br>  }<br><br>  bool cross(int i1, int j1, int i2, int j2, out double x, out double y)<br>  {<br>    return cross(  x1[i1], y1[i1], x1[j1], y1[j1],<br>            x2[i2], y2[i2], x2[j2], y2[j2],<br>            out x, out y);<br>  }<br><br>  void find_points()<br>  {<br>    ArrayList x = new ArrayList();<br>    ArrayList y = new ArrayList();<br><br>    for (int i=0; i &lt; x1.Length; i++)<br>      if (pt_inside(x1[i], y1[i], x2, y2))<br>      {<br>        x.Add((double)x1[i]);<br>        y.Add((double)y1[i]);<br>      }<br><br>    for (int i=0; i &lt; x2.Length; i++)<br>      if (pt_inside(x2[i], y2[i], x1, y1))<br>      {<br>        x.Add((double)x2[i]);<br>        y.Add((double)y2[i]);<br>      }<br><br>    for (int i=0; i &lt; x1.Length; i++)<br>      for (int j=0; j &lt; x2.Length; j++)<br>      {<br>        double px, py;<br><br>        if (cross(i, (i+1)%x1.Length, j, (j+1)%x2.Length, out px, out py))<br>        {<br>          x.Add(px);<br>          y.Add(py);<br>        }<br>      }<br><br>    cx = (double[])x.ToArray(typeof(double));<br>    cy = (double[])y.ToArray(typeof(double));<br>  }<br><br>  void swap(ref double a, ref double b)<br>  {<br>    double t = a;<br>    a = b;<br>    b = t;<br>  }<br><br>  public void sort_points()<br>  {<br>    double[] a = new double[cx.Length];<br><br>    double x0 = 0, y0 = 0;<br><br>    for (int i=0; i &lt; cx.Length; i++)<br>    {<br>      x0 = x0 + cx[i];<br>      y0 = y0 + cy[i];<br>    }<br><br>    x0/=cx.Length;<br>    y0/=cy.Length;<br><br>    for (int i=0; i &lt; cx.Length; i++)<br>    {<br>      a[i] = Math.Atan2(cx[i] - x0, cy[i] - y0);<br>    }<br><br>    for (int i=0; i &lt; cx.Length; i++)<br>    {<br>      int min = i;<br>      for (int j=i+1; j &lt; cx.Length; j++)<br>        if (a[j] &lt; a[min]) min = j;<br><br>      swap(ref a[i], ref a[min]);<br>      swap(ref cx[i], ref cx[min]);<br>      swap(ref cy[i], ref cy[min]);<br>    }<br>  }<br><br>  public double calc_area()<br>  {<br>    double s = 0;<br>    for (int i=0; i &lt; cx.Length; i++)<br>    {<br>      int j = (i+1)%cx.Length;<br>      s += (cx[j]-cx[i])*(cy[j]+cy[i]);<br>    }<br>    return Math.Abs(s/2);<br>  }<br><br>    public double overlap(string[] polygon1, string[] polygon2) <br>  {<br>    inp(polygon1, out x1, out y1);<br>    inp(polygon2, out x2, out y2);<br><br>    find_points();<br>    sort_points();<br><br>    return calc_area();<br>    }<br><br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>