<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;queue&gt;<br>using namespace std;<br><br>#include &lt;math.h&gt;<br>#include &lt;complex&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>#define oo                   1000000000<br>#define eps                  1.0e-9<br>#define SGN(x)               ((x)&lt;-eps?-1:(x)&gt;eps?1:0)<br>#define DET(a,b,c,d)         ((a)*(d)-(b)*(c))<br>#define CRAMER1(a,b,x,c,d,y) (DET(x,b,y,d)/DET(a,b,c,d))<br><br>typedef complex&lt;double&gt; tComp;<br><br>int ccw(tComp a, tComp b, tComp c) {<br>  double d = DET(real(b - a), real(c - a), imag(b - a), imag(c - a));<br>  return SGN(d);<br>}<br><br>int ccw5(tComp a, tComp b, tComp c) {<br>  tComp e = b - a;<br>  tComp f = c - a;<br>  double d = DET(real(e), real(f), imag(e), imag(f));<br>  if (d &gt;  eps)                                      // counterclockwise<br>    return 1;<br>  if (d &lt; -eps ||                                    // clockwise<br>      real(e) * real(f) &lt; 0 || imag(e) * imag(f) &lt; 0)// b a c<br>    return -1;<br>  if (abs(e) &lt; abs(f))                               // a b c<br>    return 1;<br>  return 0;                                          // b c a<br>}<br><br>int intersect(tComp a, tComp b, tComp c, tComp d) {<br>  return ccw5(a,b,c) * ccw5(a,b,d) &lt;= 0 &amp;&amp; ccw5(c,d,a) * ccw5(c,d,b) &lt;= 0;<br>}<br><br>tComp intersection(tComp a, tComp b, tComp c, tComp d) {<br>  return a + CRAMER1(real(b-a), real(c-d), real(c-a),<br>                     imag(b-a), imag(c-d), imag(c-a)) * (b-a);<br>}<br><br>int inside_cpoly(tComp p, int n, tComp a[]) {<br>  int left = 0;<br>  int right = 0;<br>  for (int i = 0; i &lt; n; i++)<br>    switch (ccw (p, a[i], a[(i + 1) % n])) {<br>    case  1: left  = 1; break;<br>    case -1: right = 1; break;<br>    }<br>  return !(left &amp; right);<br>}<br><br>int startpos(int n, tComp p[]){<br>  int j = 0;<br>  for (int k = 1; k &lt; n; k++)<br>    if (imag(p[k]) &lt; imag(p[j]) ||<br>  (imag(p[k]) == imag(p[j]) &amp;&amp; real(p[k]) &lt; real(p[j])))<br>      j = k;<br>  return j;<br>}<br><br>int nextpos(int n, tComp p[], int i) {<br>  int j = 0;<br>  for (int k = 1; k &lt; n; k++) {<br>    int c = ccw(p[i], p[j], p[k]);<br>    if (c == -1 || (c == 0 &amp;&amp; abs(p[i] - p[k]) &gt; abs(p[i] - p[j])))<br>      j = k;<br>  }<br>  return j;<br>}<br><br>// convex hull of (n, p[])<br>// yielding the m indices of the hull points saved in index<br>void convex_idx(int n, tComp p[], int &amp;m, int index[]) {<br>  index[0] = startpos(n, p);<br>  for (m = 0; index[m] != index[0] || m == 0; m++)<br>    index[m + 1] = nextpos(n, p, index[m]);<br>}<br><br>typedef struct { int n; tComp p[100]; } cpolygon;<br><br>// convex hull of (n, p[])<br>// returning a polygon<br>// Polygon should be non-empty !<br>// n &lt;= 100<br>cpolygon convex(int n, tComp p[]) {<br>  int i, index[100];<br>  cpolygon ch;<br><br>  convex_idx(n, p, ch.n, index);<br>  for (i = 0; i &lt; ch.n; i++)<br>    ch.p[i] = p[index[i]];<br>  return ch;<br>}<br><br>// area of an arbitrary polygon, n &gt;= 0<br>double polyarea(int n, tComp p[]) {<br>  double area = 0;<br>  for (int i = 0; i &lt; n; i++)<br>    area += 0.5 * imag(p[i] + p[(i+1)%n]) * real(p[(i+1)%n] - p[i]);<br>  return fabs(area);<br>}<br><br>double doit(int n,tComp *p, int m, tComp *q) {<br>  tComp r[100];<br>  cpolygon cx;<br>  int i,j,k;<br>  for (i=k=0;i&lt;n;i++) {<br>      if (inside_cpoly(p[i],m,q)) {<br>        r[k++] = p[i];<br>      }<br>      for (j=0;j&lt;m;j++) {<br>        if (i==0 &amp;&amp; inside_cpoly(q[j],n,p)) {<br>        r[k++] = q[j];<br>      }<br>      if (intersect(p[i],p[(i+1)%n],q[j],q[(j+1)%m])) {<br>        r[k++] = intersection(p[i],p[(i+1)%n],q[j],q[(j+1)%m]);<br>      }<br>    }<br>    }<br>    cx = convex(k,r);<br>  return polyarea(cx.n,cx.p);<br>}<br><br>class ConvexPolygons {<br>  public:<br>  double overlap(vector &lt;string&gt; polygon1, vector &lt;string&gt; polygon2) {<br>    tComp p[100],q[100];<br>    int n = polygon1.size();<br>    int m = polygon2.size();<br>    for (int i=0; i&lt;n; i++) {<br>      double x,y;<br>      sscanf(polygon1[i].c_str(),"%lf %lf",&amp;x,&amp;y);<br>      p[i] = tComp(x,y);<br>    }<br>    for (int i=0; i&lt;m; i++) {<br>      double x,y;<br>      sscanf(polygon2[i].c_str(),"%lf %lf",&amp;x,&amp;y);<br>      q[i] = tComp(x,y);<br>    }<br>    return doit(n,p,m,q);<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>