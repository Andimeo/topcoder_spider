<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include&lt;iostream&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;map&gt;<br>#include&lt;sstream&gt;<br> <br> <br>using namespace std;<br> <br>#define REP(i,n) for( int i = 0; i&lt;(n); i++) <br>#define FOR(i,a,b) for ( int i= (a); i&lt;=(b); i++)<br>#define FORD(i,a,b) for ( int i= (a); i&gt;=(b); i--) <br> <br>typedef long long LL;<br>typedef vector&lt;int&gt; VI;<br> <br>#define INF 1000000000<br> <br>#define LEWA 0<br>#define PRAWA 1<br> <br>int tab[2510][2510][2];<br> <br>void wyp(int z1, int z2, int z3) {<br>  cout &lt;&lt; z1 &lt;&lt; " x " &lt;&lt; z2 &lt;&lt; " x " &lt;&lt; z3 &lt;&lt; "  : " &lt;&lt; tab[z1][z2][z3] &lt;&lt; endl;<br>}<br> <br>class Postman {<br>  public:<br>  int minTime(vector &lt;string&gt; houseNumbers, int crossTime) {<br>    VI lewe;<br>    VI prawe;<br>    REP(i,houseNumbers.size()) {<br>      stringstream ww;<br>      ww &lt;&lt; houseNumbers[i];<br>      int gdzie;<br>      while (ww &gt;&gt; gdzie) {<br>        gdzie--;<br>        if (gdzie % 2 == 0) {<br>          lewe.push_back(gdzie/2);<br>        } else prawe.push_back(gdzie/2);<br>      }<br>    }<br>    lewe.push_back(0);<br>    prawe.push_back(0);<br>    sort(lewe.begin(),lewe.end());<br>    sort(prawe.begin(),prawe.end());<br>    <br>    REP(z1,lewe.size()) REP(z2,prawe.size()) REP(z3,2) tab[z1][z2][z3] = INF;<br>    tab[0][0][LEWA] = 0;<br>    REP(lewa,lewe.size()) REP(prawa,prawe.size()){<br>      REP(gdzie,2) {<br>      if (gdzie == LEWA) {<br>        if (lewa &gt; 0)  {<br>          tab[lewa][prawa][gdzie] = min(tab[lewa][prawa][gdzie],tab[lewa-1][prawa][gdzie]+(lewe[lewa]-lewe[lewa-1]));<br>          tab[lewa][prawa][gdzie] = <br>            min(tab[lewa][prawa][gdzie],tab[lewa-1][prawa][PRAWA]+ crossTime + abs(lewe[lewa]-prawe[prawa]));<br>        }<br>      } else {<br>        if (prawa &gt; 0) {<br>          tab[lewa][prawa][gdzie] = min(tab[lewa][prawa][gdzie],tab[lewa][prawa-1][gdzie]+(prawe[prawa]-prawe[prawa-1]));<br>          tab[lewa][prawa][gdzie] = <br>            min(tab[lewa][prawa][gdzie],tab[lewa][prawa-1][LEWA]+ crossTime + abs(lewe[lewa]-prawe[prawa]));<br> <br>        }<br>      }<br>      <br>      <br>    }<br>    // a teraz przeskok<br>    REP(gdzie,2) {<br>      tab[lewa][prawa][gdzie] = min(tab[lewa][prawa][gdzie],tab[lewa][prawa][(gdzie+1)%2] + crossTime + abs(lewe[lewa]-prawe[prawa])); <br>    }<br>    <br>  }<br>//  wyp(1,2,PRAWA);<br>//  wyp(2,2,LEWA);<br>  <br>  int odp = tab[lewe.size()-1][prawe.size()-1][0];<br>  odp = min(odp,tab[lewe.size()-1][prawe.size()-1][1]);<br>  REP(i,lewe.size()-1) {<br>    odp = min(odp,tab[i][prawe.size()-1][PRAWA] + crossTime + abs(prawe[prawe.size()-1]-lewe[lewe.size()-1]) + abs(lewe[i+1] - lewe[lewe.size()-1]));<br>  }<br>  REP(i,prawe.size()-1) {<br>    odp = min(odp,tab[lewe.size()-1][i][LEWA] + crossTime + abs(lewe[lewe.size()-1]-prawe[prawe.size()-1]) + abs(prawe[i+1] - prawe[prawe.size()-1]));<br>  }<br>  <br>  <br>  return odp;<br>  <br>    <br>    <br>    <br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>