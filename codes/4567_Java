<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br> <br>public class WatchTower {<br> <br>    final double epsilon = 1e-11;<br> <br>    boolean linesIntersection(double x1, double y1, double x2, double y2,<br>            double x3, double y3, double x4, double y4,<br>            double [] xyret) {<br>  double a1 = y1-y2;<br>  double b1 = x2-x1;<br>  double c1 = a1*x1+b1*y1;<br> <br>  double a2 = y3-y4;<br>  double b2 = x4-x3;<br>  double c2 = a2*x3+b2*y3;<br> <br>  return linesIntersection(a1, b1, c1,<br>         a2, b2, c2,<br>         xyret);<br>    }<br> <br>    boolean linesIntersection(double a1, double b1, double c1,<br>            double a2, double b2, double c2,<br>            double [] xyret) {<br>  double d = a1*b2-b1*a2;<br>  if (Math.abs(d) &lt; epsilon)<br>      return false;<br> <br>  xyret[0] = (b2*c1-b1*c2)/d;<br>  xyret[1] = (a1*c2-a2*c1)/d;<br> <br>  return true;<br>    }<br> <br>    int[] heights;<br>    int[] positions;<br>    int N;<br>    double [] xa = new double[3000];<br>    int nxa;<br>    int xmin, xmax;<br>    public double minHeight(int[] positions, int[] heights) {<br>  this.heights = heights;<br>  this.positions = positions;<br>  N = positions.length;<br>  xmin = positions[0];<br>  xmax = positions[N-1];<br> <br>  for (int i=0; i&lt;N; i++) {<br>      xa[i] = positions[i];<br>  }<br>  nxa = N;<br> <br>  double [] da = new double[2];<br>  for (int i=0; i&lt;N-1; i++) for (int j=i+1; j&lt;N-1; j++) {<br>      if (linesIntersection(positions[i], heights[i], positions[i+1], heights[i+1],<br>          positions[j], heights[j], positions[j+1], heights[j+1],<br>          da)) {<br>    if (xmin &lt;= da[0] &amp;&amp; da[0] &lt;= xmax) {<br>        xa[nxa++] = da[0];<br>    }<br>      }<br>  }<br>  double [] xa2 = new double[nxa];<br>  System.arraycopy(xa, 0, xa2, 0, nxa);<br>  Arrays.sort(xa2);<br>  xa = uniq(xa2);<br> <br>  double rv = 1e+100;<br>  for (int i=0; i &lt; xa.length; i++) {<br>      double maxh = -1e+100;<br>      double baseh = -1e+100;<br>      for (int j=0; j &lt; N-1; j++) {<br>    if (!linesIntersection(xa[i], 0, xa[i], 1,<br>               positions[j], heights[j], positions[j+1], heights[j+1],<br>               da)) {<br>        System.out.println( "Huh!?"  + " " + i  + " " + j );<br>    } else {<br>        maxh = Math.max(maxh, da[1]);<br>    }<br>    if (xa[i] &gt;= positions[j] &amp;&amp; xa[i] &lt;= positions[j+1]) {<br>        baseh = da[1];<br>    }<br>      }<br>      System.out.println( i  + " " + xa[i]  + " " + baseh  + " " + maxh  + " " + (maxh-baseh) );<br>      rv = Math.min(rv, maxh-baseh);<br>  }<br>        return rv;<br>    }<br> <br>    double [] uniq(double [] x) {<br>  int N = x.length;<br>  if (N &lt;= 1)<br>      return x;<br> <br>  int cnt = 1;<br>  for (int j=1; j&lt;N; j++)<br>      if (Math.abs(x[j] - x[j-1]) &gt;= epsilon)<br>    cnt++;<br>  if (cnt == N)<br>      return x;<br>  double [] rv = new double[cnt];<br> <br>  int idx = 1;<br>  rv[0] = x[0];<br>  for (int j=1; j&lt;N; j++)<br>      if (Math.abs(x[j] - x[j-1]) &gt;= epsilon) {<br>    rv[idx++] = x[j];<br>      }<br>  return rv;<br>    }<br> <br>}<br> <br>// Powered by CodeProcessor<br></td>