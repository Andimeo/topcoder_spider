<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>public class BikeLock {<br>  const int MAX_ADJACENT = 1000;<br>  int[,] minSimple = new int[MAX_ADJACENT, MAX_ADJACENT];<br>  Queue q;<br><br>  void reach(int start, int what, int by)<br>  {<br>    if (minSimple[start, what] &gt; by)<br>    {<br>      minSimple[start, what] = by;<br>      q.Enqueue(what);<br>    }<br>  }<br><br>  void fillSimple()<br>  {<br>    for (int start = 0; start &lt; MAX_ADJACENT / 10; ++start)<br>    {<br>      q = new Queue(MAX_ADJACENT);<br>      for (int i = 0; i &lt; MAX_ADJACENT; ++i)<br>        minSimple[start, i] = MAX_ADJACENT + 2;<br>      minSimple[start, start] = 0;<br>      q.Enqueue(start);<br>      while (q.Count &gt; 0)<br>      {<br>        int cur = (int) q.Dequeue();<br>        int clen = minSimple[start, cur];<br>        int dig0 = cur % 10;<br>        int dig1 = cur / 10 % 10;<br>        int dig2 = cur / 100;<br><br>        for (int delta = -3; delta &lt;= 3; ++delta)<br>        {<br>          reach(start, (dig2 + 10 + 0 * delta) % 10 * 100 + (dig1 + 10 + 0 * delta) % 10 * 10 + (dig0 + 10 + 1 * delta) % 10, clen + 1);<br>          reach(start, (dig2 + 10 + 0 * delta) % 10 * 100 + (dig1 + 10 + 1 * delta) % 10 * 10 + (dig0 + 10 + 0 * delta) % 10, clen + 1);<br>          reach(start, (dig2 + 10 + 0 * delta) % 10 * 100 + (dig1 + 10 + 1 * delta) % 10 * 10 + (dig0 + 10 + 1 * delta) % 10, clen + 1);<br>          reach(start, (dig2 + 10 + 1 * delta) % 10 * 100 + (dig1 + 10 + 0 * delta) % 10 * 10 + (dig0 + 10 + 0 * delta) % 10, clen + 1);<br>          reach(start, (dig2 + 10 + 1 * delta) % 10 * 100 + (dig1 + 10 + 1 * delta) % 10 * 10 + (dig0 + 10 + 0 * delta) % 10, clen + 1);<br>          reach(start, (dig2 + 10 + 1 * delta) % 10 * 100 + (dig1 + 10 + 1 * delta) % 10 * 10 + (dig0 + 10 + 1 * delta) % 10, clen + 1);<br>        }<br>      }<br>    }<br><br>    for (int start = MAX_ADJACENT / 10; start &lt; MAX_ADJACENT; ++start)<br>    {<br>      int delta = - (start / 100);<br>      int dig0 = start % 10;<br>      int dig1 = start / 10 % 10;<br>      int dig2 = start / 100;<br>      int src = (dig2 + 10 + 1 * delta) % 10 * 100 + (dig1 + 10 + 1 * delta) % 10 * 10 + (dig0 + 10 + 1 * delta) % 10;<br><br>      for (int cur = 0; cur &lt; MAX_ADJACENT; ++cur)<br>      {<br>        dig0 = cur % 10;<br>        dig1 = cur / 10 % 10;<br>        dig2 = cur / 100;<br>        minSimple[start, cur] = minSimple[src, (dig2 + 10 + 1 * delta) % 10 * 100 + (dig1 + 10 + 1 * delta) % 10 * 10 + (dig0 + 10 + 1 * delta) % 10];<br>      }<br>    }<br>  }<br><br>  public int minTurns(string current, string desired) {<br>    fillSimple();<br><br>    int n = current.Length;<br><br>    int[] dig = new int[n];<br>    int[] des = new int[n];<br>    for (int i = 0; i &lt; n; ++i) <br>    {<br>      dig[i] = current[i] - '0';<br>      des[i] = desired[i] - '0';<br>    }<br><br>    int[,] best = new int[n, MAX_ADJACENT];<br><br>    for (int i = 0; i &lt; MAX_ADJACENT; ++i)<br>      best[2, i] = minSimple[dig[0] * 100 + dig[1] * 10 + dig[2], i];<br><br>    for (int k = 3; k &lt; n; ++k)<br>    {<br>      for (int i = 0; i &lt; MAX_ADJACENT; ++i) {<br>        best[k, i] = int.MaxValue;<br><br>        for (int j = 0; j &lt; MAX_ADJACENT; ++j)<br>        {<br>          if (j / 100 == des[k - 3]) <br>          {<br>            int cur = best[k-1, j] + minSimple[j % 100 * 10 + dig[k], i];<br>            if (best[k, i] &gt; cur)<br>              best[k, i] = cur;<br>          }<br>        }<br>      }<br>    }<br><br>    return best[n - 1, des[n - 3] * 100 + des[n - 2] * 10 + des[n - 1]];<br>  }<br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>