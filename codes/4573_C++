<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br>#define REP(i,n) for(int _n=n, i=0;i&lt;_n;++i)<br>#define FOREACH(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)<br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br>template&lt;class T&gt; inline int size(const T&amp;c) { return c.size(); }<br>template&lt;class A,class B&gt; inline bool contains(const A&amp;a, const B&amp;b) {<br>  return find(a.begin(),a.end(),b)!=a.end();<br>}<br>int s2i(string s) { istringstream i(s); int x; i&gt;&gt;x; return x; }<br>VS split(string s,string del=" ") {<br>  s+=del[0];<br>  string w;<br>  VS res;<br>  FOREACH(it,s) {<br>    if(!contains(del,*it)) w+=*it;<br>    else if(w!="") { res.push_back(w); w=""; }<br>  }<br>  return res;<br>}<br>VI s2vi(string s,string del=" ") {<br>  VS v=split(s,del);<br>  VI res; FOREACH(it,v) res.push_back(s2i(*it));<br>  return res;<br>}<br> <br>vector&lt;pair&lt;int,int&gt; &gt; tiles;<br> <br>int cache[1&lt;&lt;10][8][8][2][2];<br> <br>int f(int avail, int a, int b, bool da, bool db) {<br>  int &amp;res = cache[avail][a][b][da][db];<br>  if(res!=-1) return res;<br>  res = 0;<br>  REP(i,size(tiles)) if(avail&amp;(1&lt;&lt;i)) {<br>    int avail2 = avail &amp;~ (1&lt;&lt;i);<br>    bool dd = tiles[i].first == tiles[i].second;<br>    REP(j,2) {<br>      if(tiles[i].second == a) {<br>        int a2 = tiles[i].first;<br>        int v = (1+dd) * a2 + (1+db) * b;<br>        if(v%5!=0) v=0;<br>        res &gt;?= v+f(avail2, a2, b, dd, db);<br>      }<br>      if(tiles[i].first == b) {<br>        int b2 = tiles[i].second;<br>        int v = (1+da) * a + (1+dd) * b2;<br>        if(v%5!=0) v=0;<br>        res &gt;?= v+f(avail2, a, b2, da, dd);<br>      }<br>      swap(tiles[i].first, tiles[i].second);<br>    }<br>  }<br>  return res;<br>}<br> <br>struct DominoesGame {<br> <br>  // MAIN<br>  int largestTotal(vector &lt;string&gt; tiles_) {<br>    tiles.clear();<br>    FOREACH(it,tiles_) {<br>      VI a = s2vi(*it, ":");<br>      sort(a.begin(),a.end());<br>      tiles.push_back(make_pair(a[0],a[1]));<br>    }<br>    memset(cache, -1, sizeof(cache));<br>    int res = 0;<br>    REP(i, size(tiles)) {<br>      int v = tiles[i].first + tiles[i].second;<br>      if(v%5!=0) v=0;<br>      bool dd = tiles[i].first == tiles[i].second;<br>      res &gt;?= v + f((1&lt;&lt;size(tiles))-1-(1&lt;&lt;i), tiles[i].first, tiles[i].second, dd, dd);<br>    }<br>    return res;<br>  }<br> <br>};<br> <br>// Powered by FileEdit<br> <br>// Powered by TomekAI<br>// Powered by TZTester 1.01 [25-Feb-2003]<br> <br>// Powered by CodeProcessor<br></td>