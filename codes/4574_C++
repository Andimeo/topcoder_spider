<td class="problemText" colspan="8" valign="middle" align="left">
            #define FR(i,a,b) for (int i = (a); i &lt; (b); i++)<br>#define FOR(i,n) FR(i,0,n)<br>#define FORI(i,n) FOR(i,n.size())<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#define MP make_pair<br>#define SZ size()<br>#define CS c_str()<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;math.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;setjmp.h&gt;<br>#include &lt;regex.h&gt;<br>#include &lt;utility&gt;<br>#define ll long long<br>#define ld long double<br>#define EPS 1e-9<br>using namespace std;<br> <br>#include &lt;queue&gt;<br> <br>struct BrokenCalculator {<br>int fewestKeys(vector &lt;int&gt; keys, string operators, int target) {<br> int can[2222] = {0};<br> int candig[22]={0};<br> int digs[2222];<br> FORI(i,keys)<br>  candig[keys[i]] = 1;<br> FOR(i,1000) {<br>  char foo[512]; sprintf(foo, "%i", i);<br>  digs[i] = 10000;<br>  for (int j=0;foo[j];j++) if (!candig[foo[j]-'0']) goto sadface;<br>  digs[i] = strlen(foo);<br>  can[i] = 1;<br>  sadface:;<br> }<br> int dis[2222];<br> memset(dis,1,sizeof(dis));<br>#define PII pair&lt;int,int&gt;<br> priority_queue&lt;PII&gt; q;<br> FOR(i,1000) if (can[i])<br>  dis[i] = digs[i], q.push(MP(-dis[i], i));<br> while (q.SZ) {<br>  int k = q.top().second; q.pop();<br>  if (k&lt;0 || k&gt;999) continue;<br>  FOR(i,1000) if (can[i]) {<br>   if (i+k&lt;1000&amp;&amp;strchr(operators.CS, '+')) if (dis[k]+1+digs[i] &lt; dis[k+i]) q.push(MP(-(dis[k+i] = dis[k]+1+digs[i]), k+i));<br>   if (i&gt;=k&amp;&amp;strchr(operators.CS, '-')) if (dis[k]+1+digs[i] &lt; dis[k-i]) q.push(MP(-(dis[k-i] = dis[k]+1+digs[i]), k-i));<br>   if (i*k&lt;1000&amp;&amp;strchr(operators.CS, '*')) if (dis[k]+1+digs[i] &lt; dis[k*i]) q.push(MP(-(dis[k*i] = dis[k]+1+digs[i]), k*i));<br>   if (i&amp;&amp;strchr(operators.CS, '/')) if (dis[k]+1+digs[i] &lt; dis[k/i]) q.push(MP(-(dis[k/i] = dis[k]+1+digs[i]), k/i));<br>  }<br> }<br> if (dis[target] &lt; 5000000) return (dis[target]+1) &lt;? digs[target];<br> return -1;<br>}};<br>// Powered by ted<br></td>