<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br> <br>public class BrokenCalculator {<br>    int N;<br>    int [] memo = new int[2000];<br>    int [][] tab = new int[2000][2];<br>    int tn = 0;<br>    public int fewestKeys(int[] keys, String operators, int target) { <br>  N = keys.length;<br>  for (int i=0; i&lt;N; i++) {<br>      tab[tn][0] = keys[i];<br>      tab[tn][1] = 1;<br>      tn++;<br>      for (int j=0; j&lt;N; j++) {<br>    int t = keys[i]*10+keys[j];<br>    tab[tn][0] = t;<br>    tab[tn][1] = 2;<br>    tn++;<br>    for (int k=0; k&lt;N; k++) {<br>        t = keys[i]*100+keys[j]*10 + keys[k];<br>        tab[tn][0] = t;<br>        tab[tn][1] = 3;<br>        tn++;<br>    }<br>      }<br>  }<br> <br>  for (int i=0; i &lt; tn; i++) {<br>      if (memo[tab[i][0]] == 0 ||<br>    memo[tab[i][0]] &gt; tab[i][1])<br>    memo[tab[i][0]] = tab[i][1];<br>  }<br> <br>  boolean [] upd = new boolean[1000];<br>  boolean [] opinced = new boolean[1000];<br>  boolean updatedf;<br>  int nop = operators.length();<br>  do {<br>      updatedf = false;<br>      for (int i=0; i &lt; 1000; i++) {<br>    if (memo[i] &gt; 0 &amp;&amp; !upd[i]) {<br>        upd[i] = true;<br>        for (int j=0; j &lt; tn; j++) {<br>          outer:<br>      for (int k=0; k &lt; nop; k++) {<br>          int n = 0;<br>          int t = tab[j][0];<br>          switch (operators.charAt(k)) {<br>          case '+':<br>        n = i + t; break;<br>          case '*':<br>        n = i * t; break;<br>          case '-':<br>        n = i - t; break;<br>          case '/':<br>        if (t == 0)<br>            continue outer;<br>        n = i / t; break;<br>          }<br>          if (n &lt; 0 || n &gt;= 1000)<br>        continue outer;<br>          int np = memo[i] + 1 + tab[j][1];<br>          if (memo[n] == 0 ||<br>        memo[n] &gt; np) {<br>        upd[n] = false;<br>        memo[n] = np;<br>        updatedf = true;<br>        opinced[n] = true;<br>          }<br>      }<br>        }<br>    }<br>      }<br>  } while (updatedf);<br>  <br>        return memo[target] &gt; 0 ? (memo[target] + (opinced[target] ? 1 : 0)) : -1;<br>    }<br> <br>}<br> <br>// Powered by CodeProcessor<br></td>