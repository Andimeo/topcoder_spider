<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>public class TwoKings {<br>  const int MAX_MOVES = 5;<br><br>  struct Point<br>  {<br>    public int x;<br>    public int y;<br><br>    public Point(int x, int y)<br>    {<br>      this.x = x;<br>      this.y = y;<br>    }<br>  }<br><br>  int rec(Point queen, Point king1, Point king2, int who, int numAlr)<br>  {<br>    if (numAlr &gt;= MAX_MOVES)<br>      return MAX_MOVES + 2;<br><br>    if (who == 0)<br>    {<br>      int min = MAX_MOVES + 2;<br>      for (int dx = -1; dx &lt;= 1; ++dx)<br>        for (int dy = -1; dy &lt;= 1; ++dy)<br>          if (dx != 0 || dy != 0)<br>          {<br>            int cx = queen.x + dx;<br>            int cy = queen.y + dy;<br>            int cur;<br><br>            while (cx &gt;= 0 &amp;&amp; cx &lt; 100 &amp;&amp; cy &gt;= 0 &amp;&amp; cy &lt; 100)<br>            {<br>              if (cx == king1.x &amp;&amp; cy == king1.y)<br>                cur = numAlr + 1;<br>              else if (cx == king2.x &amp;&amp; cy == king2.y)<br>                cur = numAlr + 1;<br>              else<br>                cur = rec(new Point(cx, cy), king1, king2, 1, numAlr + 1);<br><br>              if (cur &lt; min)<br>                min = cur;<br><br>              cx += dx;<br>              cy += dy;<br>            }<br>          }<br><br>      return min;<br>    }<br>    else<br>    {<br>      if (numAlr == MAX_MOVES - 2)<br>      {<br>        int j1 = 0, j2 = 0;<br><br>        int dx = Math.Abs(queen.x - king1.x);<br>        int dy = Math.Abs(queen.y - king1.y);<br>        int d = Math.Max(dx, dy);<br><br>        if ((dx == 0 || dx == d) &amp;&amp; (dy == 0 || dy == d))<br>          j1 = 1;<br><br>        dx = Math.Abs(queen.x - king2.x);<br>        dy = Math.Abs(queen.y - king2.y);<br>        d = Math.Max(dx, dy);<br><br>        if ((dx == 0 || dx == d) &amp;&amp; (dy == 0 || dy == d))<br>          j2 = 1;<br><br>        if (j1 &gt; 0 &amp;&amp; j2 &gt; 0)<br>          return numAlr + 2;<br><br>        if (j2 == 0)<br>        {<br>          for (int sx = -1; sx &lt;= 1; ++sx)<br>            for (int sy = -1; sy &lt;= 1; ++sy)<br>              if (sx != 0 || sy != 0)<br>              {<br>                int cx = king1.x + sx;<br>                int cy = king1.y + sy;<br><br>                if (cx &gt;= 0 &amp;&amp; cx &lt; 100 &amp;&amp; cy &gt;= 0 &amp;&amp; cy &lt; 100)<br>                  if (cx != king2.x || cy != king2.y)<br>                    if (cx != queen.x || cy != queen.y)<br>                    {<br>                      dx = Math.Abs(queen.x - cx);<br>                      dy = Math.Abs(queen.y - cy);<br>                      d = Math.Max(dx, dy);<br><br>                      if (!((dx == 0 || dx == d) &amp;&amp; (dy == 0 || dy == d)))<br>                        return MAX_MOVES + 2;<br>                    }<br>              }<br>        }<br><br>        if (j1 == 0)<br>        {<br>          for (int sx = -1; sx &lt;= 1; ++sx)<br>            for (int sy = -1; sy &lt;= 1; ++sy)<br>              if (sx != 0 || sy != 0)<br>              {<br>                int cx = king2.x + sx;<br>                int cy = king2.y + sy;<br><br>                if (cx &gt;= 0 &amp;&amp; cx &lt; 100 &amp;&amp; cy &gt;= 0 &amp;&amp; cy &lt; 100)<br>                  if (cx != king1.x || cy != king1.y)<br>                    if (cx != queen.x || cy != queen.y)<br>                    {<br>                      dx = Math.Abs(queen.x - cx);<br>                      dy = Math.Abs(queen.y - cy);<br>                      d = Math.Max(dx, dy);<br><br>                      if (!((dx == 0 || dx == d) &amp;&amp; (dy == 0 || dy == d)))<br>                        return MAX_MOVES + 2;<br>                    }<br>              }<br>        }<br><br>        return numAlr + 2;<br>      }<br>      else<br>      {<br>        int max = numAlr + 2;<br><br>        for (int dx = -1; dx &lt;= 1; ++dx)<br>          for (int dy = -1; dy &lt;= 1; ++dy)<br>            if (dx != 0 || dy != 0)<br>            {<br>              int cx = king1.x + dx;<br>              int cy = king1.y + dy;<br>              int cur;<br><br>              if (cx &gt;= 0 &amp;&amp; cx &lt; 100 &amp;&amp; cy &gt;= 0 &amp;&amp; cy &lt; 100)<br>                if (cx != king2.x || cy != king2.y)<br>                  if (cx != queen.x || cy != queen.y)<br>                  {<br>                    cur = rec(queen, new Point(cx, cy), king2, 0, numAlr + 1);<br>                    if (cur &gt; max)<br>                      max = cur;<br>                  }<br><br>              cx = king2.x + dx;<br>              cy = king2.y + dy;<br><br>              if (cx &gt;= 0 &amp;&amp; cx &lt; 100 &amp;&amp; cy &gt;= 0 &amp;&amp; cy &lt; 100)<br>                if (cx != king1.x || cy != king1.y)<br>                  if (cx != queen.x || cy != queen.y)<br>                  {<br>                    cur = rec(queen, king1, new Point(cx, cy), 0, numAlr + 1);<br>                    if (cur &gt; max)<br>                      max = cur;<br>                  }<br>            }<br>      <br>        return max;<br>      }<br>    }<br>  }<br><br>  public int captureKing(string queen, string king1, string king2) {<br>    string[] qs = queen.Split(' ');<br>    string[] k1s = king1.Split(' ');<br>    string[] k2s = king2.Split(' ');<br>    return rec(<br>      new Point(int.Parse(qs[0]), int.Parse(qs[1])), <br>      new Point(int.Parse(k1s[0]), int.Parse(k1s[1])), <br>      new Point(int.Parse(k2s[0]), int.Parse(k2s[1])),<br>      0,<br>      0) / 2 + 1;<br>  }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>