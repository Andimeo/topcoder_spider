<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>public class SandTimers {<br>  const int MAX_TIME = 360;<br>  const int MAX_AM = 20;<br><br>    int[] maxAm = new int[3];<br>  bool[] exists = new bool[3];<br>  bool[,,,] can = new bool[MAX_TIME + 1, 3, MAX_AM + 1, MAX_AM + 1];<br>  bool[,,,] res = new bool[MAX_TIME + 1, 3, MAX_AM + 1, MAX_AM + 1];<br>  bool[] a;<br><br>  void fillCan()<br>  {<br>    int[] am = new int[3];<br>    int[] nam = new int[3];<br><br>    for (int time = 0; time &lt;= MAX_TIME; ++time)<br>    {<br>      for (int zero = 0; zero &lt; 3; ++zero)<br>      {<br>        int first = (zero + 1) % 3;<br>        int second = (zero + 2) % 3;<br>        for (int am1 = 0; am1 &lt;= maxAm[first]; ++am1)<br>          for (int am2 = 0; am2 &lt;= maxAm[second]; ++am2)<br>          {<br>            if (!exists[zero])<br>            {<br>              can[time, zero, am1, am2] = false;<br>              continue;<br>            }<br>            if (time == 0)<br>            {<br>              can[time, zero, am1, am2] = true;<br>              continue;<br>            }<br>            am[zero] = 0;<br>            am[first] = am1;<br>            am[second] = am2;<br>            for (int f0 = 0; f0 &lt;= 1; ++f0)<br>            {<br>              for (int f1 = 0; f1 &lt;= 1; ++f1)<br>              {<br>                for (int f2 = 0; f2 &lt;= 1; ++f2)<br>                {<br>                  int next = time + 1;<br>                  for (int i = 0; i &lt; 3; ++i)<br>                    if (am[i] &gt; 0 &amp;&amp; am[i] &lt; next)<br>                      next = am[i];<br>                  if (next &lt;= time)<br>                  {<br>                    for (int i = 0; i &lt; 3; ++i)<br>                      if (am[i] &gt;= next)<br>                        nam[i] = am[i] - next;<br>                      else<br>                        nam[i] = 0;<br>                    for (int i = 0; i &lt; 3; ++i)<br>                      if (nam[i] == 0)<br>                        if (can[time - next, i, nam[(i + 1) % 3], nam[(i + 2) % 3]])<br>                          can[time, zero, am1, am2] = true;<br>                  }<br>                  am[2] = maxAm[2] - am[2];<br>                }<br>                am[1] = maxAm[1] - am[1];<br>              }<br>              am[0] = maxAm[0] - am[0];<br>            }<br>          }<br>      }<br>    }<br>  }<br><br>  void fillRes()<br>  {<br>    int[] am = new int[3];<br>    int[] nam = new int[3];<br><br>    for (int time = 0; time &lt;= MAX_TIME; ++time)<br>    {<br>      for (int zero = 0; zero &lt; 3; ++zero)<br>      {<br>        for (int am1 = 0; am1 &lt;= MAX_AM; ++am1)<br>          for (int am2 = 0; am2 &lt;= MAX_AM; ++am2)<br>            res[time, zero, am1, am2] = false;<br>      }<br>    }<br><br>    for (int time = 0; time &lt;= MAX_TIME; ++time)<br>    {<br>      for (int zero = 0; zero &lt; 3; ++zero)<br>      {<br>        int first = (zero + 1) % 3;<br>        int second = (zero + 2) % 3;<br>        for (int am1 = 0; am1 &lt;= maxAm[first]; ++am1)<br>          for (int am2 = 0; am2 &lt;= maxAm[second]; ++am2)<br>          {<br>            if (!exists[zero])<br>            {<br>              res[time, zero, am1, am2] = false;<br>              continue;<br>            }<br>            if (time == 0)<br>            {<br>              res[time, zero, am1, am2] = (am1 == 0 &amp;&amp; am2 == 0);<br>            }<br>            if (!res[time, zero, am1, am2])<br>              continue;<br>            am[zero] = 0;<br>            am[first] = am1;<br>            am[second] = am2;<br>            for (int f0 = 0; f0 &lt;= 1; ++f0)<br>            {<br>              for (int f1 = 0; f1 &lt;= 1; ++f1)<br>              {<br>                for (int f2 = 0; f2 &lt;= 1; ++f2)<br>                {<br>                  int next = int.MaxValue;<br>                  for (int i = 0; i &lt; 3; ++i)<br>                    if (am[i] &gt; 0 &amp;&amp; am[i] &lt; next)<br>                      next = am[i];<br>                  if (next &lt; int.MaxValue &amp;&amp; time + next &lt;= MAX_TIME)<br>                  {<br>                    for (int i = 0; i &lt; 3; ++i)<br>                      if (am[i] &gt;= next)<br>                        nam[i] = am[i] - next;<br>                      else<br>                        nam[i] = 0;<br>                    for (int i = 0; i &lt; 3; ++i)<br>                      if (nam[i] == 0)<br>                        res[time + next, i, nam[(i + 1) % 3], nam[(i + 2) % 3]] = true;<br>                  }<br>                  am[2] = maxAm[2] - am[2];<br>                }<br>                am[1] = maxAm[1] - am[1];<br>              }<br>              am[0] = maxAm[0] - am[0];<br>            }<br>          }<br>      }<br>    }<br>  }<br><br>  public int[] badIntervals(int[] timers, int maxInterval, int maxTime) {<br>    maxAm = new int[3];<br>    exists = new bool[3];<br>    can = new bool[MAX_TIME + 1, 3, MAX_AM + 1, MAX_AM + 1];<br>    res = new bool[MAX_TIME + 1, 3, MAX_AM + 1, MAX_AM + 1];<br><br>    for (int i = 0; i &lt; timers.Length; ++i) <br>    {<br>      maxAm[i] = timers[i];<br>      exists[i] = true;<br>    }<br>    for (int i = timers.Length; i &lt; 3; ++i) <br>    {<br>      maxAm[i] = 0;<br>      exists[i] = false;<br>    }<br>    a = new bool[maxTime + 1];<br>    for (int i = 0; i &lt;= maxTime; ++i)<br>      a[i] = false;<br><br>    fillCan();<br>    fillRes();<br><br>    for (int zero = 0; zero &lt; 3; ++zero)<br>      for (int am1 = 0; am1 &lt;= MAX_AM; ++am1)<br>        for (int am2 = 0; am2 &lt;= MAX_AM; ++am2)<br>        {<br>          int i;<br>          for (i = 0; i &lt;= maxTime; ++i)<br>            if (res[i, zero, am1, am2])<br>              break;<br>          if (i &gt; maxTime)<br>            continue;<br>          for (int j = 0; j &lt;= maxTime - i; ++j)<br>            if (can[j, zero, am1, am2]) <br>            {<br>              a[j] = true;<br>            }<br>        }<br><br>    int am = 0;<br>    for (int i = 1; i &lt;= maxInterval; ++i)<br>      if (!a[i])<br>        ++am;<br><br>    int[] r = new int[am];<br>    int at = 0;<br>    for (int i = 1; i &lt;= maxInterval; ++i)<br>      if (!a[i])<br>        r[at++] = i;<br><br>    return r;<br>  }<br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>