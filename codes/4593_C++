<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br><br>using namespace std;<br><br>typedef long long int64;<br>typedef unsigned long long uint64;<br>#define two(X) (1&lt;&lt;(X))<br>#define twoL(X) (((int64)(1))&lt;&lt;(X))<br>#define contain(S,X) (((S)&amp;two(X))!=0)<br>#define containL(S,X) (((S)&amp;twoL(X))!=0)<br>const double pi=acos(-1.0);<br>const double eps=1e-11;<br>template&lt;class T&gt; inline void checkmin(T &amp;a,T b){if(b&lt;a) a=b;}<br>template&lt;class T&gt; inline void checkmax(T &amp;a,T b){if(b&gt;a) a=b;}<br>template&lt;class T&gt; inline T sqr(T x){return x*x;}<br>typedef pair&lt;int,int&gt; ipair;<br><br>const int size=323537;<br>const int maxn=25000+5;<br><br>class ChipArea<br>{<br>public:<br>  int n;<br>  int X[maxn],Y[maxn],L[maxn];<br>  int64 result;<br>  void init(int skip,int n)<br>  {<br>    int R=1;<br>    for(int j = 0; j &lt; skip; j++) R = 111 * R % 323537;<br>    for(int pt = 0; pt &lt; n; pt++)<br>    {<br>      R = 111*R%323537;X[pt+1]=R;<br>      R = 111*R%323537;Y[pt+1]=R;<br>    }<br>  }<br>  void solve1()<br>  {<br>    ipair AP[maxn];<br>    for (int i=1;i&lt;=n;i++) AP[i]=make_pair(X[i],Y[i]);<br>    sort(AP+1,AP+n+1);<br>    for (int i=1;i&lt;=n;i++) X[i]=AP[i].first,Y[i]=AP[i].second;<br>    for (int i=1;i&lt;=n;i++)<br>    {<br>      int L=0,R=size,X0=X[i],Y0=Y[i];<br>      for (int k=i+1;k&lt;=n;k++)<br>      {<br>        checkmax(result,(int64)(R-L)*(int64)(X[k]-X0));<br>        if (Y[k]&lt;Y0) checkmax(L,Y[k]);<br>        if (Y[k]&gt;Y0) checkmin(R,Y[k]);<br>        if ((int64)(R-L)*(int64)(size-X0)&lt;=result) break;<br>      }<br>      checkmax(result,(int64)(R-L)*(int64)(size-X0));<br>    }<br>  }<br>  void solve2()<br>  {<br>    int Qsize=2;<br>    L[1]=0;<br>    L[2]=size;<br>    for (int i=1;i&lt;=n;i++)<br>    {<br>      int X0=X[i],Y0=Y[i];<br>      for (int k=1;k&lt;=Qsize;k++)<br>        if (Y0==L[k])<br>          break;<br>        else if (Y0&lt;L[k+1])<br>        {<br>          checkmax(result,(int64)(L[k+1]-L[k])*(int64)(X0));<br>          Qsize++;<br>          for (int v=Qsize;v&gt;k;v--) L[v]=L[v-1];<br>          L[k+1]=Y0;<br>          break;<br>        }<br>    }<br>    for (int k=1;k&lt;Qsize;k++)<br>      checkmax(result,(int64)(L[k+1]-L[k])*(int64)(size));<br>  }<br>  double maxArea(int skip, int _n)<br>  {<br>    n=_n;<br>    init(skip,n);<br>    result=0;<br>    solve1();<br>    solve2();<br>    return (double)(result)/(double)(size)/(double)(size);<br>  }<br>};<br></td>