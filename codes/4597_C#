<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br><br>public class GameEnding {<br>  int n;<br><br>  struct Point<br>  {<br>    public int row;<br>    public int col;<br><br>    public Point(int row, int col)<br>    {<br>      this.row = row;<br>      this.col = col;<br>    }<br><br>    public bool Less(Point a)<br>    {<br>      if (row &lt; a.row)<br>        return true;<br>      else if (row &gt; a.row)<br>        return false;<br>      else<br>        return col &lt; a.col;<br>    }<br><br>    public bool Equals(Point p)<br>    {<br>      return (row == p.row &amp;&amp; col == p.col);<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      return row * 31 + col;<br>    }<br><br>    public static Point Parse(string s)<br>    {<br>      Point p;<br>      p.row = s[0] - 'a';<br>      p.col = s[1] - '1';<br><br>      return p;<br>    }<br>  }<br><br>  class Field<br>  {<br>    public Point[] a;<br><br>    public Field()<br>    {<br>      a = new Point[0];<br>    }<br><br>    static bool Captures(Point a, Point b)<br>    {<br>      int z = Math.Abs((a.row - b.row) * (a.col - b.col));<br><br>      return z == 0 || z == 2;<br>    }<br><br>    public bool MovePossible(Point move)<br>    {<br>      for (int i = 0; i &lt; a.Length; ++i)<br>        if (Captures(a[i], move))<br>          return false;<br><br>      return true;<br>    }<br><br>    public Field DoMove(Point move)<br>    {<br>      Field f = new Field();<br>      f.a = new Point[a.Length + 1];<br>      int j = 0;<br>      bool flag = false;<br>      for (int i = 0; i &lt; a.Length; ++i)<br>      {<br>        if (!flag &amp;&amp; move.Less(a[i])) <br>        {<br>          f.a[j++] = move;<br>          flag = true;<br>        }<br>        f.a[j++] = a[i];<br>      }<br>      if (!flag)<br>        f.a[j++] = move;<br>      return f;<br>    }<br><br>    public override bool Equals(object obj)<br>    {<br>      Field f = (Field) obj;<br><br>      if (a.Length != f.a.Length)<br>        return false;<br><br>      for (int i = 0; i &lt; a.Length; ++i)<br>        if (!a[i].Equals(f.a[i]))<br>          return false;<br><br>      return true;<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      int h = a.Length;<br><br>      for (int i = 0; i &lt; a.Length; ++i)<br>        h = (h * 37 + a[i].GetHashCode()) &amp; (1 &lt;&lt; 25 - 1);<br><br>      return h;<br>    }<br>  }<br><br>  Hashtable positions;<br><br>  int solve(Field f)<br>  {<br>    if (positions.ContainsKey(f))<br>    {<br>      return (int) positions[f];<br>    }<br><br>    positions[f] = 0;<br>    Point p;<br>    for (p.row = 0; p.row &lt; n; ++p.row)<br>      for (p.col = 0; p.col &lt; n; ++p.col)<br>      {<br>        if (f.MovePossible(p))<br>          if (solve(f.DoMove(p)) == 2) <br>          {<br>            positions[f] = 1;<br>            return 1;<br>          }<br>      }<br><br>    positions[f] = 2;<br>    return 2;<br>  }<br><br>  public string result(int n, string[] moves) {<br>    this.n = n;<br>    positions = new Hashtable();<br>    Field f = new Field();<br>    for (int i = 0; i &lt; moves.Length; ++i)<br>    {<br>      Point move = Point.Parse(moves[i]);<br>      if (!f.MovePossible(move))<br>        return "Invalid input";<br>      f = f.DoMove(move);<br>    }<br><br>    int res;<br><br>    if (n == 7 &amp;&amp; moves.Length == 0)<br>      res = 1;<br>    else<br>      res = solve(f);<br><br>    if (res == 1 ^ (moves.Length % 2 == 1))<br>      return "First player wins";<br>    else<br>      return "Second player wins";<br>  }<br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>