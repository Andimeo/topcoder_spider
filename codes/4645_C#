<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class TokenGrid {<br>  struct Point<br>  {<br>    public int row;<br>    public int col;<br><br>    public Point(int row, int col)<br>    {<br>      this.row = row;<br>      this.col = col;<br>    }<br>  }<br><br>  const int CONSUMER = -1000000000;<br>  const int QLEN = 32;<br>  const int MAX_RESULT = 300000;<br>  bool[,] mark;<br>  Point[] queue;<br>  int qhead;<br>  int qtail;<br>  int n;<br>  int[,] need;<br>  int[,] board;<br>  int[,] goal;<br>  int unknownRow;<br>  int unknownCol;<br><br>  void parseBoard(string[] data, out int[,] board, out int unknownRow, out int unknownCol)<br>  {<br>    int n = data.Length;<br>    board = new int[n, n];<br>    unknownRow = -1;<br>    unknownCol = -1;<br>    <br>    for (int i = 0; i &lt; n; ++i) <br>    {<br>      string[] line = data[i].Split(' ');<br>      for (int j = 0; j &lt; n; ++j)<br>      {<br>        if (line[j][0] == 'X')<br>          board[i, j] = CONSUMER;<br>        else if (line[j][0] == '_')<br>        {<br>          board[i, j] = 0;<br>          unknownRow = i;<br>          unknownCol = j;<br>        } else<br>          board[i, j] = int.Parse(line[j]);<br>      }<br>    }<br>  }<br><br>  void workOutQueue()<br>  {<br>    while (qtail != qhead)<br>    {<br>      Point cur = queue[qtail];<br>      ++qtail;<br>      if (qtail &gt;= QLEN)<br>        qtail = 0;<br><br>      int am = board[cur.row, cur.col] / need[cur.row, cur.col];<br>      board[cur.row, cur.col] -= am * need[cur.row, cur.col];<br>      mark[cur.row, cur.col] = false;<br><br>      if (cur.row - 1 &gt;= 0 &amp;&amp; board[cur.row - 1, cur.col] != CONSUMER)<br>      {<br>        board[cur.row - 1, cur.col] += am;<br>        if (board[cur.row - 1, cur.col] &gt;= need[cur.row - 1, cur.col] &amp;&amp; !mark[cur.row - 1, cur.col])<br>        {<br>          mark[cur.row - 1, cur.col] = true;<br>          queue[qhead] = new Point(cur.row - 1, cur.col);<br>          ++qhead;<br>          if (qhead &gt;= QLEN)<br>            qhead = 0;<br>        }<br>      }<br><br>      if (cur.row + 1 &lt; n &amp;&amp; board[cur.row + 1, cur.col] != CONSUMER)<br>      {<br>        board[cur.row + 1, cur.col] += am;<br>        if (board[cur.row + 1, cur.col] &gt;= need[cur.row + 1, cur.col] &amp;&amp; !mark[cur.row + 1, cur.col])<br>        {<br>          mark[cur.row + 1, cur.col] = true;<br>          queue[qhead] = new Point(cur.row + 1, cur.col);<br>          ++qhead;<br>          if (qhead &gt;= QLEN)<br>            qhead = 0;<br>        }<br>      }<br><br>      if (cur.col - 1 &gt;= 0 &amp;&amp; board[cur.row, cur.col - 1] != CONSUMER)<br>      {<br>        board[cur.row, cur.col - 1] += am;<br>        if (board[cur.row, cur.col - 1] &gt;= need[cur.row, cur.col - 1] &amp;&amp; !mark[cur.row, cur.col - 1])<br>        {<br>          mark[cur.row, cur.col - 1] = true;<br>          queue[qhead] = new Point(cur.row, cur.col - 1);<br>          ++qhead;<br>          if (qhead &gt;= QLEN)<br>            qhead = 0;<br>        }<br>      }<br><br>      if (cur.col + 1 &lt; n &amp;&amp; board[cur.row, cur.col + 1] != CONSUMER)<br>      {<br>        board[cur.row, cur.col + 1] += am;<br>        if (board[cur.row, cur.col + 1] &gt;= need[cur.row, cur.col + 1] &amp;&amp; !mark[cur.row, cur.col + 1])<br>        {<br>          mark[cur.row, cur.col + 1] = true;<br>          queue[qhead] = new Point(cur.row, cur.col + 1);<br>          ++qhead;<br>          if (qhead &gt;= QLEN)<br>            qhead = 0;<br>        }<br>      }<br>    }<br>  }<br><br>  bool allOver()<br>  {<br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = 0; j &lt; n; ++j)<br>        if (board[i, j] != goal[i, j])<br>          return false;<br><br>    return true;<br>  }<br><br>  public int getUnknown(string[] setup, string[] finish) {<br>    parseBoard(finish, out goal, out unknownRow, out unknownCol);<br>    parseBoard(setup, out board, out unknownRow, out unknownCol);<br><br>    n = setup.Length;<br>    mark = new bool[n, n];<br><br>    need = new int[n, n];<br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = 0; j &lt; n; ++j)<br>      {<br>        if (i - 1 &gt;= 0)<br>          ++need[i, j];<br>        if (i + 1 &lt; n)<br>          ++need[i, j];<br>        if (j - 1 &gt;= 0)<br>          ++need[i, j];<br>        if (j + 1 &lt; n)<br>          ++need[i, j];<br>      }<br><br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = 0; j &lt; n; ++j)<br>        if (goal[i, j] &gt;= need[i, j])<br>          return -1;<br><br>    queue = new Point[QLEN];<br>    qtail = 0;<br>    qhead = 0;<br><br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = 0; j &lt; n; ++j)<br>        if (board[i, j] &gt;= need[i, j]) <br>        {<br>          queue[qhead++] = new Point(i, j);<br>          mark[i, j] = true;<br>        }<br><br>    workOutQueue();<br><br>    int res = 0;<br><br>    while (!allOver())<br>    {<br>      if (res &gt; MAX_RESULT)<br>        return -1;<br><br>      int by = 1;<br>      res += by;<br>      board[unknownRow, unknownCol] += by;<br>      if (board[unknownRow, unknownCol] &gt;= need[unknownRow, unknownCol]) <br>      {<br>        queue[qhead] = new Point(unknownRow, unknownCol);<br>        mark[unknownRow, unknownCol] = true;<br>        ++qhead;<br>        if (qhead &gt;= QLEN)<br>          qhead = 0;<br>        workOutQueue();<br>      }<br>    }<br><br>    return res;<br>  }<br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>