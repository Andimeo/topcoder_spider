<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Text;<br><br>public class VariableSolve {<br>  const double EPS = 1e-10;<br><br>  struct Element<br>  {<br>    public int[] pow;<br><br>    public Element(string s)<br>    {<br>      pow = new int[26];<br>      for (int i = 0; i &lt; s.Length; ++i)<br>      {<br>        ++pow[s[i] - 'A'];<br>      }<br>    }<br><br>    public Element Duplicate()<br>    {<br>      Element x = new Element("");<br>      for (int i = 0; i &lt; 26; ++i)<br>        x.pow[i] = pow[i];<br><br>      return x;<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      int hk = 0;<br>      for (int i = 0; i &lt; 26; ++i)<br>        hk = (hk * 31 + pow[i]) % 1000009;<br>      return hk;<br>    }<br><br>    public override bool Equals(object obj)<br>    {<br>      if (!(obj is Element))<br>        return false;<br><br>      Element e = (Element) obj;<br><br>      for (int i = 0; i &lt; 26; ++i)<br>        if (pow[i] != e.pow[i])<br>          return false;<br><br>      return true;<br>    }<br>  }<br><br>  class Quad<br>  {<br>    public double k0, k1, k2;<br><br>    public Quad(double v)<br>    {<br>      k0 = v;<br>      k1 = v;<br>      k2 = v;<br>    }<br><br>    public Quad(int pow, double koef)<br>    {<br>      k0 = 0;<br>      k1 = 0;<br>      k2 = 0;<br><br>      switch (pow)<br>      {<br>        case 0:<br>          k0 += koef;<br>          break;<br>        case 1:<br>          k1 += koef;<br>          break;<br>        case 2:<br>          k2 += koef;<br>          break;<br>      }<br><br>    }<br><br>    public void Increase(Quad by)<br>    {<br>      k0 += by.k0;<br>      k1 += by.k1;<br>      k2 += by.k2;<br>    }<br><br>    public void GcdWith(Quad q)<br>    {<br>      if (Math.Abs(q.k2) &lt; EPS &amp;&amp; Math.Abs(q.k1) &lt; EPS &amp;&amp; Math.Abs(q.k0) &lt; EPS)<br>        return;<br><br>      if (Math.Abs(k2) &lt; EPS)<br>        if (Math.Abs(k1) &lt; EPS) {<br>          if (Math.Abs(k0) &lt; EPS)<br>          {<br>            k0 = q.k0;<br>            k1 = q.k1;<br>            k2 = q.k2;<br>          }<br>        }<br>        else<br>        {<br>          double by = q.k2 / k1;<br>          q.k2 = 0;<br>          q.k1 -= by * k0;<br>          by = q.k1 / k1;<br>          q.k1 = 0;<br>          q.k0 -= by * k0;<br>          if (Math.Abs(q.k0) &gt; EPS) <br>          {<br>            k0 = q.k0;<br>            k1 = q.k1;<br>            k2 = q.k2;<br>          }<br>        }<br>      else<br>      {<br>        double by = q.k2 / k2;<br>        q.k2 = 0;<br>        q.k1 -= by*k1;<br>        q.k0 -= by*k0;<br>        q.GcdWith(this);<br>        k0 = q.k0;<br>        k1 = q.k1;<br>        k2 = q.k2;<br>      }<br>    }<br>  }<br><br>  class Polynom<br>  {<br>    Hashtable h;<br>    Hashtable tmp;<br><br>    public Polynom(string s)<br>    {<br>      h = new Hashtable();<br>      tmp = new Hashtable();<br>      s = s + '+';<br>      int j = 0;<br>      int k = 0;<br>      for (int i = 0; i &lt; s.Length; ++i)<br>      {<br>        char ch = s[i];<br><br>        switch (ch)<br>        {<br>          case '+':<br>          case '-':<br>            if (i &gt; j)<br>            {<br>              Element e = new Element(s.Substring(j, i - j));<br>              if (h.ContainsKey(e))<br>              {<br>                h[e] = (int) h[e] + k;<br>              } else h[e] = k;<br>            }<br>            if (ch == '+') k = 1; else k = -1;<br>            j = i + 1;<br>            break;<br>        }<br>      }<br>    }<br><br>    public int Nullifying(int what)<br>    {<br>      tmp.Clear();<br><br>      foreach (DictionaryEntry d in h)<br>      {<br>        Element e = ((Element) d.Key).Duplicate();<br>        int k = (int) d.Value;<br>        Quad q = new Quad(e.pow[what], k);<br>        e.pow[what] = 0;<br>        if (tmp.ContainsKey(e))<br>          ((Quad) tmp[e]).Increase(q);<br>        else<br>          tmp[e] = q;<br>      }<br><br>      Quad all = new Quad(0);<br><br>      foreach (Quad q in tmp.Values)<br>      {<br>        all.GcdWith(q);<br>      }<br><br>      if (Math.Abs(all.k2) &lt; EPS)<br>        if (Math.Abs(all.k1) &lt; EPS)<br>          return 0;<br>        else<br>          return 1;<br>      else<br>      {<br>        double d = all.k1*all.k1 - 4*all.k0*all.k2;<br>        if (d &gt; EPS)<br>          return 2;<br>        else if (d &lt; -EPS)<br>          return 0;<br>        else<br>          return 1;<br>      }<br>    }<br>  }<br><br>  public string[] getSolutions(string equation) {<br>    bool wasEq = false;<br><br>    StringBuilder b = new StringBuilder();<br>    b.Append("+");<br><br>    for (int i = 0; i &lt; equation.Length; ++i)<br>    {<br>      char ch = equation[i];<br><br>      switch (ch)<br>      {<br>        case '=':<br>          wasEq = true;<br>          b.Append('-');<br>          break;<br><br>        case '-':<br>          if (wasEq) b.Append('+'); else b.Append('-');<br>          break;<br><br>        case '+':<br>          if (wasEq) b.Append('-'); else b.Append('+');<br>          break;<br><br>        default:<br>          b.Append(ch);<br>          break;<br>      }<br>    }<br><br>    Polynom p = new Polynom(b.ToString());<br><br>    ArrayList res = new ArrayList();<br><br>    for (int i = 0; i &lt; 26; ++i)<br>    {<br>      int am = p.Nullifying(i);<br><br>      for (int j = 0; j &lt; am; ++j)<br>        res.Add(((char) ('A' + i)).ToString());<br>    }<br><br>    string[] r = new string[res.Count];<br>    res.CopyTo(r);<br><br>    return r;<br>  }<br><br>  <br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>