<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class FrogAndFly {<br>  const double EPS = 1e-12;<br>  int[] xwindow;<br>  int[] ywindow;<br>  int n;<br><br>  struct Line<br>  {<br>    public double alpha;<br>    public double beta;<br><br>    public Line(double a, double b)<br>    {<br>      alpha = a;<br>      beta = b;<br>    }<br>  }<br><br>  Line[] getCrossingParts(double y)<br>  {<br>    Line[] tmp = new Line[2];<br>    int num = 0;<br><br>    for (int i = 0; i &lt; n; ++i)<br>    {<br>      int j = (i + 1) % n;<br>      double x1 = xwindow[i];<br>      double y1 = ywindow[i];<br>      double x2 = xwindow[j];<br>      double y2 = ywindow[j];<br>      if ((y1 &lt; y - EPS &amp;&amp; y2 &gt; y + EPS) || (y1 &gt; y + EPS &amp;&amp; y2 &lt; y - EPS))<br>      {<br>        double alpha = (x1 - x2) / (y1 - y2);<br>        double beta = x1 - alpha * y1;<br><br>        tmp[num++] = new Line(alpha, beta);<br>      }<br>    }<br><br>    Line[] res = new Line[num];<br>    for (int i = 0; i &lt; num; ++i)<br>      res[i] = tmp[i];<br><br>    return res;<br>  }<br><br>  public double visibility(int hwall, int dfrog, int dfly, int ylow, int yhigh, int[] xwindow, int[] ywindow) {<br>    n = xwindow.Length;<br>    this.xwindow = xwindow;<br>    this.ywindow = ywindow;<br><br>    double koef = ((double) dfrog) / dfly;<br><br>    double ymin = hwall + (hwall - yhigh) / koef;<br>    double ymax = hwall + (hwall - ylow) / koef;<br><br>    double[] hs = new double[n + 2];<br>    for (int i = 0; i &lt; n; ++i)<br>      hs[i] = ywindow[i];<br>    hs[n] = ymin;<br>    hs[n + 1] = ymax;<br><br>    Array.Sort(hs);<br><br>    double res = 0;<br>    double area = 0;<br><br>    for (int i = 0; i &lt; hs.Length - 1; ++i)<br>    {<br>      if (hs[i] &lt; hs[i + 1] - EPS)<br>      {<br>        if (hs[i] &gt; ymin - EPS &amp;&amp; hs[i + 1] &lt; ymax + EPS)<br>        {<br>          double mid = (hs[i] + hs[i + 1]) / 2;<br><br>          Line[] cp = getCrossingParts(mid);<br>          if (cp.Length &lt; 2)<br>            continue;<br><br>          double alpha = cp[0].alpha - cp[1].alpha;<br>          double beta = cp[0].beta - cp[1].beta;<br>          if (alpha * mid + beta &lt; 0)<br>          {<br>            alpha = -alpha;<br>            beta = -beta;<br>          }<br><br>          double gamma = koef / (yhigh - ylow);<br>          double delta = (yhigh - hwall * (koef + 1)) / (yhigh - ylow);<br><br>          double a = alpha * gamma;<br>          double b = beta * gamma + alpha * delta;<br>          double c = beta * delta;<br><br>          double l = hs[i];<br>          double r = hs[i + 1];<br><br>          res += (a / 3) * (r * r * r - l * l * l) + (b / 2) * (r * r - l * l) + c * (r - l);<br>        } <br>        else if (hs[i] &gt; ymax - EPS)<br>        {<br>          double mid = (hs[i] + hs[i + 1]) / 2;<br><br>          Line[] cp = getCrossingParts(mid);<br>          if (cp.Length &lt; 2)<br>            continue;<br><br>          double alpha = cp[0].alpha - cp[1].alpha;<br>          double beta = cp[0].beta - cp[1].beta;<br>          if (alpha * mid + beta &lt; 0)<br>          {<br>            alpha = -alpha;<br>            beta = -beta;<br>          }<br><br>          double gamma = 0;<br>          double delta = 1;<br><br>          double a = alpha * gamma;<br>          double b = beta * gamma + alpha * delta;<br>          double c = beta * delta;<br><br>          double l = hs[i];<br>          double r = hs[i + 1];<br><br>          res += (a / 3) * (r * r * r - l * l * l) + (b / 2) * (r * r - l * l) + c * (r - l);<br>        }<br>      }<br>    }<br><br>    for (int i = 0; i &lt; n; ++i)<br>    {<br>      int j = (i + 1) % n;<br>      double x1 = xwindow[i];<br>      double y1 = ywindow[i];<br>      double x2 = xwindow[j];<br>      double y2 = ywindow[j];<br><br>      area += (x1 + x2) * (y1 - y2) / 2;<br>    }<br><br>    return Math.Abs(res / area);<br>  }<br><br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>