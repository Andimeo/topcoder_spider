<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class SalesmansDilemma <br>{<br>  const long infinity = long.MaxValue / 10;<br><br>  struct Edge<br>  {<br>    public int src;<br>    public int dst;<br>    public long cost;<br><br>    public Edge(int src, int dst, long cost)<br>    {<br>      this.src = src;<br>      this.dst = dst;<br>      this.cost = cost;<br>    }<br>  }<br><br>  Edge[] edges;<br>  bool[] mark;<br><br>  void dfs(int a)<br>  {<br>    if (mark[a])<br>      return;<br>    mark[a] = true;<br><br>    for (int i = 0; i &lt; edges.Length; ++i)<br>      if (edges[i].src == a)<br>        dfs(edges[i].dst);<br>  }<br><br>  public string bestRoute(int towns, int origin, int destination, string[] travelCosts, int[] profits) <br>  {<br>    edges = new Edge[travelCosts.Length];<br>    int id = 0;<br><br>    foreach (string s in travelCosts)<br>    {<br>      string[] ss = s.Split(' ');<br>      edges[id++] = new Edge(int.Parse(ss[0]), int.Parse(ss[1]), long.Parse(ss[2]) - profits[int.Parse(ss[1])]);<br>    }<br><br>    long[] d = new long[towns];<br>    for (int i = 0; i &lt; towns; ++i)<br>      d[i] = infinity;<br>    d[origin] = 0;<br><br>    bool[] upd = new bool[towns];<br><br>    for (int step = 0; step &lt;= 2 * towns; ++step)<br>    {<br>      for (int i = 0; i &lt; edges.Length; ++i)<br>      {<br>        if (d[edges[i].src] &lt; infinity &amp;&amp; d[edges[i].dst] &gt; d[edges[i].src] + edges[i].cost)<br>        {<br>          d[edges[i].dst] = d[edges[i].src] + edges[i].cost;<br>          if (step &gt;= towns)<br>            upd[edges[i].dst] = true;<br><br>          if (d[edges[i].dst] &lt; -infinity)<br>          {<br>            upd[edges[i].dst] = true;<br>            d[edges[i].dst] = -infinity;<br>          }<br>        }<br>      }<br>    }<br><br>    if (d[destination] == infinity)<br>      return "IMPOSSIBLE";<br><br>    mark = new bool[towns];<br><br>    for (int i = 0; i &lt; towns; ++i)<br>      if (upd[i] &amp;&amp; !mark[i])<br>        dfs(i);<br><br>    if (mark[destination])<br>      return "ENDLESS PROFIT";<br>    else<br>      return "BEST PROFIT: " + (profits[origin] - d[destination]);<br>  }<br><br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>