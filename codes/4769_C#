<td class="problemText" colspan="8" valign="middle" align="left">
            using System; using System.Collections; using System.Text; using System.Text.RegularExpressions;<br>public class Springs<br>   {<br>   double A,B,len;<br>   int N;<br>   int[] X, K, M;<br>   public double[] compression(int[] X_, int[] K_, int[] M_)<br>      {<br>      X=X_; K=K_; M=M_;<br>      N = X.Length;<br>      A = X[0]; B = X[N-1]; len = B-A;<br>      double minAH=-M[0], maxAH=5000;<br>      double[] F;<br>      double ah = 0, bh = 0;<br>      bool overC;<br>      for (int outStep=0; outStep &lt; 100; outStep++)<br>         {<br>         ah = (minAH+maxAH)/2;<br>         double minBH=-M[N-1], maxBH=5000;<br>         for (int step=0; step &lt; 100; step++)<br>            {<br>            bh=(minBH+maxBH)/2;<br>            F = CalcF(ah, bh, out overC);<br>            double t = T(F, X[0]);<br>            if (t&gt;0 || overC)<br>               minBH = bh;<br>            else<br>               maxBH = bh;<br>            }<br>         F = CalcF(ah, minBH, out overC);<br>         if (T(F, X[N-1]) &lt; 0 || overC)<br>            minAH = ah;<br>         else<br>            maxAH = ah;<br>         }<br>      F = CalcF(ah, bh, out overC);<br>      for (int i=0; i &lt; N; i++)<br>         {}<br>      double[] comp = new double[N];<br>      for (int i=0; i &lt; N; i++)<br>         comp[i] = -(ah + (bh-ah)*(X[i]-A)/len);<br>      return comp;<br>      }<br>   double T(double[] F, double x)<br>      {<br>      double t=-(B-x)*(B-x)/2 + (x-A)*(x-A)/2;<br>      for (int i=0; i &lt; N; i++)<br>         t += F[i] * (X[i]-x);<br>      return t;<br>      }<br>   double[] CalcF(double ah, double bh, out bool overC)<br>      {<br>      double[] F = new double[N];<br>      overC = false;<br>      for (int i=0; i &lt; N; i++)<br>         {<br>         double x = X[i];<br>         double h = ah + (bh-ah)*(x-A)/len;<br>         double comp = -h;<br>         if (comp &gt;= M[i])<br>            overC = true;<br>         F[i] = K[i]*comp + 1/(M[i]-comp)/(M[i]-comp);<br>         }<br>      return F;<br>      }<br><br><br>} // TopC#der<br><br><br>// Powered by FileEdit<br></td>