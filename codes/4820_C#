<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Text;<br><br>public class BinaryBoard {<br>    struct Point {<br>  public int row;<br>  public int col;<br><br>  public Point(int row, int col) {<br>      this.row = row;<br>      this.col = col;<br>  }<br>    }<br><br>    const int size = 6;<br>    int[,] neq = new int[2 * size, 2 * size];<br>    bool[,] need = new bool[2 * size, 2 * size];<br>    int[] numGot = new int[2 * size];<br>    int[,] got = new int[2 * size, size];<br>    int[,] field = new int[size, size];<br>    string[] res;<br><br>    Point next(Point x) {<br>  if (x.row &gt;= x.col) {<br>      ++x.row;<br>      if (x.row &gt;= size) {<br>    x.row = x.col;<br>    ++x.col;<br>    if (x.col &gt;= size) {<br>        ++x.row;<br>        x.col = x.row;<br>    }<br>      }<br>  } else {<br>      ++x.col;<br>      if (x.col &gt;= size) {<br>    ++x.row;<br>    x.col = x.row;<br>      }<br>  }<br><br>  return x;<br>    }<br><br>    int decode(string what) {<br>  if (what[0] == 'H')<br>      return what[1] - '1';<br>  else<br>      return what[1] - '1' + size;<br>    }<br><br>    void fillNeed(string[] order) {<br>  for (int i = 0; i &lt; order.Length; ++i)<br>      for (int j = i + 1; j &lt; order.Length; ++j) {<br>    need[decode(order[i]), decode(order[j])] = true;<br>      }<br>    }<br><br>    bool rec(Point at, int depth) {<br>  if (at.row &gt;= size || at.col &gt;= size) {<br>      for (int i = 0; i &lt; 2 * size; ++i)<br>    for (int j = i + 1; j &lt; 2 * size; ++j)<br>        if (neq[i, j] == 0)<br>      return false;<br><br>      res = new string[size];<br>      for (int i = 0; i &lt; size; ++i) {<br>    string s = "";<br><br>    for (int j = 0; j &lt; size; ++j) {<br>        s += (char) ('0' + field[i, j]);<br>    }<br><br>    res[i] = s;<br>      }<br>      return true;<br>  }<br>  Point nxt = next(at);<br><br>  for (int k = 0; k &lt;= 1; ++k) {<br>      got[at.row, numGot[at.row]++] = k;<br>      got[at.col + size, numGot[at.col + size]++] = k;<br>      field[at.row, at.col] = k;<br>      bool ok = true;<br>      int ng = numGot[at.row];<br>      for (int i = 0; i &lt; 2 * size; ++i)<br>    if (neq[i, at.row] == 0) {<br>        if (numGot[i] &gt;= ng) {<br>      if (got[i, ng - 1] != k) {<br>          if (got[i, ng - 1] &lt; k ^ need[i, at.row]) {<br>        ok = false;<br>        break;<br>          } else {<br>        neq[i, at.row] = depth;<br>        neq[at.row, i] = depth;<br>          }<br>      }<br>        }<br>    }<br>      if (ok) {<br>    ng = numGot[at.col + size];<br>    for (int i = 0; i &lt; 2 * size; ++i)<br>        if (neq[i, at.col + size] == 0) {<br>      if (numGot[i] &gt;= ng) {<br>          if (got[i, ng - 1] != k) {<br>        if (got[i, ng - 1] &lt; k ^ need[i, at.col + size]) {<br>            ok = false;<br>            break;<br>        } else {<br>            neq[i, at.col + size] = depth;<br>            neq[at.col + size, i] = depth;<br>        }<br>          }<br>      }<br>        }<br>    if (ok) {<br>        if (rec(nxt, depth + 1))<br>      return true;<br>    }<br>    for (int i = 0; i &lt; 2 * size; ++i)<br>        if (neq[i, at.col + size] == depth) {<br>      neq[i, at.col + size] = 0;<br>      neq[at.col + size, i] = 0;<br>        }<br>      }<br>      for (int i = 0; i &lt; 2 * size; ++i)<br>    if (neq[i, at.row] == depth) {<br>        neq[i, at.row] = 0;<br>        neq[at.row, i] = 0;<br>    }<br>      --numGot[at.row];<br>      --numGot[at.col + size];<br>  }<br><br>  return false;<br>    }<br><br>    public string[] board(string[] order) {<br>  fillNeed(order);<br><br>  for (int i = 0; i &lt; size; ++i)<br>      neq[i, i] = -1;<br><br>  rec(new Point(0, 0), 1);<br><br>  return res;<br>    }<br>}<br><br><br>// Powered by FileEdit<br></td>