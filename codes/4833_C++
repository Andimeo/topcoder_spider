<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br> <br>using namespace std;<br> <br>#define REP(i, n) for (int i = 0; i &lt; (n); ++i)<br>#define ALL(cont) cont.begin(), cont.end()<br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;VI&gt; VVI;<br>typedef pair&lt;int, int&gt; PII;<br>typedef vector&lt;string&gt; VS;<br> <br>template&lt;class T&gt; <br>vector&lt;T&gt; split(string s, string delim) {<br>  s = s + delim[0];<br>  int lp = -1;<br>  bool li = false;<br>  vector&lt;T&gt; res;<br>  REP(i, s.size()) {<br>    bool ins = delim.find(s[i]) == -1;<br>    if (li &amp;&amp; !ins) {<br>      istringstream is(s.substr(lp, i-lp));<br>      T x;<br>      is &gt;&gt; x;<br>      res.push_back(x);<br>    } else if (!li &amp;&amp; ins) {<br>      lp = i;<br>    }<br>    li = ins;<br>  }<br>  return res;<br>}<br> <br>int dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};<br>int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};<br> <br>void match(VS&amp; g, int y, int x, int k, string s, int res[50][50][50]) {<br>  char ls[3] = {' ', ' ', ' '};<br>  REP(i, s.size()) {<br>    int xp = x + dx[k]*i;<br>    int yp = y + dy[k]*i;<br>    if (xp &lt; 0 || yp &lt; 0 || yp &gt;= g.size() || xp &gt;= g[0].size()) return;<br>    if (g[yp][xp] &lt;= '3') {<br>      ls[g[yp][xp]-'0'] = s[i];      <br>    } else if (g[yp][xp] != s[i]) return;<br>  }<br>  <br>  for (int a = (ls[0]==' ' ? 0 : ls[0]-'A'); a &lt; (ls[0]==' ' ? 26 : ls[0]-'A'+1); ++a)<br>  for (int b = (ls[1]==' ' ? 0 : ls[1]-'A'); b &lt; (ls[1]==' ' ? 26 : ls[1]-'A'+1); ++b)<br>  for (int c = (ls[2]==' ' ? 0 : ls[2]-'A'); c &lt; (ls[2]==' ' ? 26 : ls[2]-'A'+1); ++c) {<br>    res[a][b][c] = 1;<br>  }<br>}<br> <br>void go(VS&amp; g, string w, int q[50][50][50]) {<br>  int res[50][50][50];<br>  REP(i, 50) REP(j, 50) REP(k, 50) res[i][j][k] = 0;<br>  REP(i, g.size()) REP(j, g[0].size()) REP(k, 8) {<br>    match(g, i, j, k, w, res);<br>  }<br>  REP(i, 50) REP(j, 50) REP(k, 50) q[i][j][k] &lt;?= res[i][j][k];<br>}<br> <br>class WordGrid {<br>  public:<br>  vector &lt;string&gt; fillSpaces(vector &lt;string&gt; grid, vector &lt;string&gt; words) {<br>    char cnt = '0';<br>    REP(i, grid.size()) REP(j, grid[0].size()) {<br>      if (grid[i][j] == '.') grid[i][j]=cnt++;<br>    }<br>    int res[50][50][50];<br>    REP(i, 50) REP(j, 50) REP(k, 50) res[i][j][k] = 1;<br>    REP(i, words.size()) {<br>      go(grid, words[i], res);<br>    }<br>    <br>    REP(i, 50) REP(j, 50) REP(k, 50) if (res[i][j][k]) {<br>//      cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; ' ' &lt;&lt; k;<br>      REP(y, grid.size()) REP(x, grid[0].size()) if (grid[y][x] &lt;= '3') {<br>        int a = (grid[y][x]=='0' ? i : grid[y][x]=='1' ? j : k);<br>        grid[y][x] = a+'A';<br>      }<br>    }<br>    <br>    return grid;<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>