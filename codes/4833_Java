<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.io.*;<br>import java.math.*;<br>import java.util.regex.*;<br>import static java.util.Arrays.*;<br>import static java.lang.Math.*;<br>public class WordGrid {<br>  TreeSet&lt;String&gt;[] pats;<br>  char[][] map;<br>  public String[] fillSpaces(String[] grid, String[] words) {<br>    pats = new TreeSet[words.length];<br>    for(int i = 0; i &lt; pats.length; i++){<br>      pats[i] = new TreeSet&lt;String&gt;();<br>    }<br>    <br>    map = new char[grid.length][];<br>    for(int i = 0; i &lt; map.length; i++){<br>      map[i] = grid[i].toCharArray();<br>    }<br>    look = new int[map.length][map[0].length];<br>    for(int i = 0; i &lt; look.length; i++){<br>      fill(look[i],-1);<br>    }<br>    int foo = 0;<br>    for(int i = 0; i &lt; map.length; i++){<br>      for(int j = 0; j &lt; map[i].length; j++){<br>        if(map[i][j] == '.') look[i][j] = foo++;<br>      }<br>    }<br>    for(int i = 0; i &lt; words.length; i++){<br>      look(words[i], i);<br>    }<br>    for(int i = 0; i &lt; pats.length; i++){<br>    //  System.out.println(i+": "+pats[i]);<br>    }<br>    for(char c = 'A'; c &lt;= 'Z'; c++){<br>      for(char a = 'A'; a &lt;= 'Z'; a++){<br>        outer:<br>        for(char b = 'A'; b &lt;= 'Z'; b++){<br>          inner:<br>          for(int i = 0; i &lt; words.length; i++){<br>            for(int j = 0; j &lt; 8; j++){<br>              char[] tmp = new char[3];<br>              tmp[0] = c;<br>              tmp[1] = a;<br>              tmp[2] = b;<br>              for(int k = 0; k &lt; 3; k++){<br>                if(((1&lt;&lt;k)&amp;j)!=0) tmp[k] = 'x';<br>              }<br>              if(pats[i].contains(new String(tmp))) continue inner;<br>            }<br>            continue outer;<br>          }<br>          char[] hei = (""+c+a+b).toCharArray();<br>          int at = 0;<br>          for(int i = 0; i &lt; map.length; i++){<br>            for(int j = 0; j &lt; map[i].length; j++){<br>              if(map[i][j] == '.') map[i][j] = hei[at++];<br>            }<br>          }<br>          String[] ret = new String[map.length];<br>          for(int i = 0; i &lt; ret.length; i++){<br>            ret[i] = new String(map[i]);<br>          }<br>          return ret;<br>        }<br>      }<br>    }<br>    return new String[] {"stupid"};<br>  }<br>  <br>  int[] dx = {1,1,1,0,0,-1,-1,-1};<br>  int[] dy = {-1,0,1,-1,1,-1,0,1};<br>  int[][] look;<br>  void look(String s, int ind){<br>    for(int i = 0; i &lt; map.length; i++){<br>      for(int j = 0; j &lt; map[i].length; j++){<br>        inner:  <br>        for(int k = 0; k &lt; dx.length; k++){<br>          char[] tmp = new char[3];<br>          fill(tmp, 'x');<br>          for(int n = 0; n &lt; s.length(); n++){<br>            int x = i+n*dx[k];<br>            int y = j+n*dy[k];<br>            if(x &lt; 0 || y &lt; 0 || x &gt;= map.length || y &gt;= map[x].length) continue inner;<br>            if(map[x][y] == '.'){<br>              tmp[look[x][y]] = s.charAt(n);<br>            }<br>            else if(map[x][y] != s.charAt(n)) continue inner;<br>          }<br>          pats[ind].add(new String(tmp));<br>          if(tmp[0] == 'x' &amp;&amp; tmp[1] == 'x' &amp;&amp; tmp[2] == 'x') return ;<br>        }<br>      }<br>    }<br>    return ;<br>  }<br> <br>  int gcd(int a, int b){<br>    return b == 0 ? a : gcd(b, a%b);<br>  }<br>}<br> <br>class Pair implements Comparable&lt;Pair&gt;{<br>  int x, y;<br>  Pair(int xx, int yy){x = xx; y = yy;}<br>  public int compareTo(Pair p){<br>    if(x != p.x) return x-p.x;<br>    return y-p.y;<br>  }<br>  public String toString(){<br>    return x+","+y;<br>  }<br>  public int hashCode(){<br>    return 17*x+y;<br>  }<br>  public boolean equals(Object o){<br>    Pair p = (Pair)o;<br>    return p.x == x &amp;&amp; p.y == y;<br>  }<br>}<br> <br>class Frac implements Comparable&lt;Frac&gt;{<br>  BigInteger u, d;<br>  Frac(long uu, long dd){<br>    this(new BigInteger(uu+""), new BigInteger(dd+""));<br>  }<br>  Frac(BigInteger uu, BigInteger dd){<br>    u = uu;<br>    d = dd;<br>    reduce();<br>  }<br>  void reduce(){<br>    if(d.signum() &lt; 0){<br>      u = u.negate();<br>      d = d.negate();<br>    }<br>    BigInteger g = u.gcd(d);<br>    if(g.equals(BigInteger.ONE)) return;<br>    u = u.divide(g);<br>    d = d.divide(g);<br>  }<br>  public boolean equals(Object o){<br>    Frac f = (Frac) o;<br>    return u.equals(f.u) &amp;&amp; d.equals(f.d);<br>  }<br>  public int compareTo(Frac f){<br>    BigInteger me = u.multiply(f.d);<br>    BigInteger him = f.u.multiply(d);<br>    return me.compareTo(him);<br>  }<br>  public String toString(){<br>    return u+"/"+d;<br>  }<br>  public int hashCode(){<br>    return 17*u.hashCode()+d.hashCode();<br>  }<br>  Frac add(Frac f){<br>    return new Frac(u.multiply(f.d).add(f.u.multiply(d)), d.multiply(f.d));<br>  }<br>  Frac sub(Frac f){<br>    return add(f.negate());<br>  }<br>  Frac negate(){<br>    return new Frac(u.negate(), d);<br>  }<br>  Frac mul(Frac f){<br>    return new Frac(u.multiply(f.u), d.multiply(f.d));<br>  }<br>  Frac div(Frac f){<br>    return new Frac(u.multiply(f.d), d.multiply(f.u));<br>  }<br>}<br> <br>// Powered by PopsEdit<br></td>