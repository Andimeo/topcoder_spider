<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br><br>public class DrawPlanar {<br>  const int maxAnswer = 10;<br><br>  struct Rectangle : IComparable<br>  {<br>    readonly public int width;<br>    readonly public int height;<br>    readonly public int area;<br><br>    public Rectangle(int width, int height)<br>    {<br>      this.width = width;<br>      this.height = height;<br>      this.area = width * height;<br>    }<br><br>    public int CompareTo (object obj)<br>    {<br>      Rectangle r = (Rectangle) obj;<br>      return area.CompareTo(r.area);<br>    }<br>  }<br><br>  int n;<br>  bool[,] g;<br><br>  public class FixedComparer : IComparer<br>  {<br>    int[] values;<br><br>    public FixedComparer(int[] values)<br>    {<br>      this.values = values;<br>    }<br><br>    public int Compare (object x, object y)<br>    {<br>      int a = (int) x;<br>      int b = (int) y;<br><br>      return -values[a].CompareTo(values[b]);<br>    }<br>  }<br><br>  public int minArea(string[] graph) {<br>    ArrayList rects = new ArrayList();<br>    for (int i = 0; i &lt;= maxAnswer; ++i)<br>      for (int j = i; j &lt;= maxAnswer; ++j) <br>      {<br>        rects.Add(new Rectangle(i, j));<br>        if (i == 0 &amp;&amp; j == graph.Length - 1)<br>          break;<br>      }<br><br>    rects.Sort();<br><br>    n = graph.Length;<br>    g = new bool[n, n];<br>    int[] deg = new int[n];<br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = 0; j &lt; n; ++j)<br>        if (graph[i][j] == 'T') {<br>          ++deg[i];<br>        }<br><br>    int[] order = new int[n];<br>    for (int i = 0; i &lt; n; ++i)<br>      order[i] = i;<br>    Array.Sort(order, new FixedComparer(deg));<br><br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = 0; j &lt; n; ++j)<br>        if (graph[order[i]][order[j]] == 'T') <br>        {<br>          g[i, j] = true;<br>        }<br><br>    foreach (Rectangle r in rects)<br>    {<br>      if (pack(r))<br>        return r.area;<br>    }<br><br>    return -1;<br>  }<br><br>  int width;<br>  int height;<br>  struct Point<br>  {<br>    public int x;<br>    public int y;<br><br>    public Point(int x, int y)<br>    {<br>      this.x = x;<br>      this.y = y;<br>    }<br>  }<br>  Point[] at;<br>  bool[] used;<br><br>  bool rec(int id)<br>  {<br>    if (id &gt;= n)<br>      return true;<br><br>    if (used[id])<br>      return rec(id + 1);<br><br>    for (int x = 0; x &lt;= width; ++x) <br>    {<br>      if (id == 0 &amp;&amp; 2 * x &gt; width)<br>        break;<br>      for (int y = 0; y &lt;= height; ++y)<br>      {<br>        if (id == 0 &amp;&amp; 2 * y &gt; height)<br>          break;<br>        Point cur = new Point();<br>        cur.x = x;<br>        cur.y = y;<br>        if (tryPlace(id, cur)) <br>        {<br>          at[id] = cur;<br>          used[id] = true;<br>          if (rec(id + 1))<br>            return true;<br>          used[id] = false;<br>        }<br>      }<br>    }<br><br>    return false;<br>  }<br><br>  private bool tryPlace(int id, Point cur)<br>  {<br>    int y = cur.y;<br>    int x = cur.x;<br>  <br>    for (int i = 0; i &lt; n; ++i)<br>      if (used[i])<br>        if (at[i].x == x &amp;&amp; at[i].y == y) <br>          return false;<br>  <br>    for (int i = 0; i &lt; n; ++i) <br>      if (used[i])<br>      {<br>        for (int j = i + 1; j &lt; n; ++j)<br>          if (used[j])<br>            if (g[i, j])<br>            {<br>              if (pointOnSegment(cur, at[i], at[j]))<br>                return false;<br>            }<br>      }<br>  <br>    for (int i = 0; i &lt; n; ++i)<br>      if (used[i])<br>        if (g[i, id])<br>        {<br>          for (int j = 0; j &lt; n; ++j) <br>            if (used[j])<br>              if (j != i) <br>              {<br>                if (pointOnSegment(at[j], cur, at[i]))<br>                  return false;<br>                for (int k = j + 1; k &lt; n; ++k) <br>                  if (used[k])<br>                    if (k != i)<br>                      if (g[j, k])<br>                        if (segmentsCross(cur, at[i], at[j], at[k]))<br>                          return false;<br>              }<br>        }<br><br>    return true;<br>  }<br><br>  private bool segmentsCross (Point a1, Point b1, Point a2, Point b2)<br>  {<br>    int c2 = (a2.x - a1.x) * (b1.y - a1.y) - (a2.y - a1.y) * (b1.x - a1.x);<br>    int d2 = (b2.x - a1.x) * (b1.y - a1.y) - (b2.y - a1.y) * (b1.x - a1.x);<br>    if (c2 * d2 &gt;= 0)<br>      return false;<br>    int c1 = (a1.x - a2.x) * (b2.y - a2.y) - (a1.y - a2.y) * (b2.x - a2.x);<br>    int d1 = (b1.x - a2.x) * (b2.y - a2.y) - (b1.y - a2.y) * (b2.x - a2.x);<br>    if (c1 * d1 &gt;= 0)<br>      return false;<br>    return true;<br>  }<br><br>  private bool pointOnSegment (Point p, Point a, Point b)<br>  {<br>    int z = (p.x - a.x) * (b.y - a.y) - (p.y - a.y) * (b.x - a.x);<br>    if (z != 0)<br>      return false;<br>    if (p.x &lt; Math.Min(a.x, b.x))<br>      return false;<br>    if (p.x &gt; Math.Max(a.x, b.x))<br>      return false;<br>    if (p.y &lt; Math.Min(a.y, b.y))<br>      return false;<br>    if (p.y &gt; Math.Max(a.y, b.y))<br>      return false;<br>    return true;<br>  }<br><br>  private bool pack (Rectangle rect)<br>  {<br>    width = rect.width;<br>    height = rect.height;<br>    at = new Point[n];<br>    used = new bool[n];<br>    return rec(0);<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>