<td class="problemText" colspan="8" valign="middle" align="left">
            #line 5 "DrawPlanar.cpp"<br><br>#include &lt;string&gt;<br>#include &lt;sstream&gt;<br>#include &lt;vector&gt;<br>#include &lt;fstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;fstream&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>#define Max(a,b) ((a)&gt;(b)?(a):(b))<br>#define Min(a,b) ((a)&lt;(b)?(a):(b))<br><br>inline bool between(int a, int b, int c)<br>{<br>  return a&lt;=c&amp;&amp;c&lt;=b || a&gt;=c&amp;&amp;c&gt;=b;<br>}<br><br>class DrawPlanar<br>{ <br>public: <br>  int n, m, X,Y;<br>  int order[20];<br>  char pos[7][2];<br>  int map[20][20];<br>  vector&lt;string&gt; net;<br>  int div[20][20], mod[20][20], GCD[20][20];<br><br>  inline int DIV(int a, int b)<br>  {<br>    return a&lt;0 ? -div[-a][b] : div[a][b];<br>  }<br>  inline int MOD(int a, int b)<br>  {<br>    return a&lt;0 ? -div[-a][b] : div[a][b];<br>  }<br>  inline int multi(int a, int b, int c)<br>  {<br>    int tmp = (pos[b][1]-pos[a][1])*(pos[c][0]-pos[a][0]) - (pos[b][0]-pos[a][0])*(pos[c][1]-pos[a][1]);<br>    if (tmp&lt;0) tmp = -1;<br>    if (tmp&gt;0) tmp = 1;<br>    return tmp;<br>  }<br>  int gcd(int a, int b)<br>  { return b==0 ? a : gcd(b,mod[a][b]); }<br>  bool search(int s, int u, int cur)<br>  {<br>    if (cur==n) return true;<br>    int i = order[u],j,k,l, x,y, k1,k2;<br>    for (x=0; x&lt;=X; x++)<br>      for (y=0; y&lt;=Y; y++)<br>        if (map[x][y]==0)<br>        {<br>          pos[u][0] = x, pos[u][1] = y;<br>          bool okay = true;<br>          for (l=s; l&lt;u&amp;&amp;okay; l++) if (net[l][u]=='T')<br>          {<br>            int g = GCD[abs(pos[u][0]-pos[l][0]) ][ abs(pos[u][1]-pos[l][1])];<br>            int step1 = DIV(pos[u][0]-pos[l][0],g), step2 = DIV(pos[u][1]-pos[l][1],g);<br>            for (k1=pos[l][0]+step1, k2=pos[l][1]+step2; k1!=x||k2!=y; k1+=step1,k2+=step2)<br>              if (map[k1][k2])<br>              {<br>                okay = false;<br>                break;<br>              }<br>            if (!okay) break;<br>/*            for (j=s; j&lt;u; j++) if (j!=l)<br>              if ( multi(u,l,j)==0 )<br>                if ( between(pos[u][0],pos[l][0],pos[j][0]) &amp;&amp;<br>                   between(pos[u][1],pos[l][1],pos[j][1]) )<br>                   break;<br>            if (j!=u)<br>            {<br>              okay = false;<br>              break;<br>            }*/<br>            for (j=s; j&lt;u&amp;&amp;okay; j++)<br>              for (k=j+1; k&lt;u; k++) if (net[j][k]=='T')<br>                if ( multi(u,l,j)*multi(u,l,k)&lt;0 &amp;&amp; multi(j,k,u)*multi(j,k,l)&lt;0 )<br>                {<br>                  okay = false;<br>                  break;<br>                }<br>          }<br>          if (okay)<br>          {<br>            for (l=s; l&lt;u&amp;&amp;okay; l++) if (net[l][u]=='T')<br>            {<br>              int g = GCD[abs(pos[u][0]-pos[l][0]) ][ abs(pos[u][1]-pos[l][1])];<br>              if (g&lt;0) g = -g;<br>              int step1 = DIV(pos[u][0]-pos[l][0],g), step2 = DIV(pos[u][1]-pos[l][1],g);<br>              for (k1=pos[l][0]+step1, k2=pos[l][1]+step2; k1!=x||k2!=y; k1+=step1,k2+=step2)<br>                map[k1][k2]++;<br>            }<br>            map[x][y]++;<br>            if (search(s,u+1,cur+1)) return true;<br>            map[x][y]--;<br>            for (l=s; l&lt;u&amp;&amp;okay; l++) if (net[l][u]=='T')<br>            {<br>              int g = GCD[ abs(pos[u][0]-pos[l][0]) ][ abs(pos[u][1]-pos[l][1])];<br>              if (g&lt;0) g = -g;<br>              int step1 = DIV(pos[u][0]-pos[l][0],g), step2 = DIV(pos[u][1]-pos[l][1],g); <br>              for (k1=pos[l][0]+step1, k2=pos[l][1]+step2; k1!=x||k2!=y; k1+=step1,k2+=step2)<br>                map[k1][k2]--;<br>            }<br>          }<br>          pos[u][0] = -1;<br>        }<br>    return false;<br>  }<br>  bool put(int _X, int _Y)<br>  {<br>    X = _X, Y = _Y;<br>    int i;<br>    for (i=0; i&lt;n; i++)<br>    {<br>      pos[i][0] = 0, pos[i][1] = 0;<br>      map[0][0] = 1;<br>      if (search(i,i+1,1)) return true;<br>      pos[i][0] = -1;<br>      map[0][0] = 0;<br>    }<br>    return false;<br>  }<br>  int minArea(vector &lt;string&gt; g) <br>  {<br>    int i,j,k;<br>    n = g.size();<br>    if (n&lt;=1) return 0;<br>    net.clear();<br>    for (i=0; i&lt;n+n; i++)<br>    {<br>      string tmp = g[i%n] + g[i%n];<br>      net.push_back(tmp);<br>    }<br>    for (i=0; i&lt;n+n; i++) order[i] = i%n;<br>    for (i=0; i&lt;20; i++) for (j=1; j&lt;20; j++) div[i][j] = i/j;<br>    for (i=0; i&lt;20; i++) for (j=1; j&lt;20; j++) mod[i][j] = i%j;<br>    for (i=0; i&lt;20; i++) for (j=0; j&lt;20; j++) GCD[i][j] = gcd(i,j);<br>    memset(pos,0xFF,sizeof(pos));<br>    memset(map,0,sizeof(map));<br><br>    if (put(0,n-1)) return 0;<br>    for (k=1; ; k++)<br>      for (j=1; j*j&lt;=k; j++) if (k%j==0)<br>      {<br>        if (put(j,k/j)) return k;<br>      }<br>  }<br>  <br><br>}; <br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>