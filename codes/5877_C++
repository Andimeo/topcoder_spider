<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br><br>using namespace std;<br><br><br>#define EPS 1e-10<br>#define eq(a,b) ( ((a)-EPS &lt;= (b)) &amp;&amp; ((b) &lt;= (a)+EPS) )<br>#define lt(a,b) ( (a)+EPS &lt; (b) )<br>#define gt(a,b) ( (a)-EPS &gt; (b) )<br>#define lte(a,b) ( (a)-EPS &lt;= (b) )<br>#define gte(a,b) ( (a)+EPS &gt;= (b) )<br>#define sq(a) ((a)*(a))<br><br>struct point {<br>   double x, y; <br>   point() { x = y = 0; }<br>   point( const point &amp;drugi ) { *this = drugi; }<br>   point( double X, double Y ) { x = X; y = Y; }<br>};<br><br>struct segment {<br>   point a, b;<br>   segment() {}<br>   segment( const segment &amp;drugi ) { *this = drugi; }<br>   segment( const point &amp;A, const point &amp;B ) { a = A; b = B; }<br>   segment( double X1, double Y1, double X2, double Y2 ) <br>      { a = point( X1, Y1 ); b = point( X2, Y2 ); }<br>};<br><br>struct line {<br>   double A, B, C;<br>   line() { A = B = C = 0; }  <br>   line( const line &amp;drugi ) { *this = drugi; }<br>   line( double a, double b, double c ) { A = a; B = b; C = c; }<br>   line( const segment &amp;S ) { <br>      A = S.b.y - S.a.y; <br>      B = S.a.x - S.b.x;<br>      C = A*S.a.x + B*S.a.y;<br>   }<br>   line( const point &amp;A, const point &amp;B ) { *this = line( segment( A, B ) ); }<br>};<br><br>int mysgn( double val ) {<br>   if( lt( val, 0 ) ) return -1; <br>   if( gt( val, 0 ) ) return 1;<br>   return 0;<br>}       <br>double myhypot( double A, double B ) <br>{  return sqrt( A*A + B*B );  }<br><br>int strana( const line &amp;L, const point &amp;T )<br>{  return mysgn( L.A*T.x + L.B*T.y - L.C );  }<br><br>int ccw( const point &amp;A, const point &amp;B, const point &amp;C )<br>{  return mysgn( (B.x-A.x)*(C.y-A.y) - (C.x-A.x)*(B.y-A.y) );  }<br><br>line okomica( const line &amp;L, const point &amp;T ) {<br>   line ret; <br>   ret.A = L.B; ret.B = -L.A;<br>   ret.C = ret.A*T.x + ret.B*T.y;<br>   return ret;<br>}<br>point midpoint( const point &amp;A, const point &amp;B ) <br>{  return point( (A.x+B.x)/2, (A.y+B.y)/2 );  }<br><br>bool intersects( const line &amp;L, const point &amp;P ) <br>{  return eq( L.A*P.x + L.B*P.y - L.C, 0 ); }<br><br>bool intersects( const segment &amp;S, const point &amp;P ) {<br>   return intersects( line(S), P ) &amp;&amp; <br>      eq( fabs(S.b.x-P.x)+fabs(S.a.x-P.x), fabs(S.b.x-S.a.x) ) &amp;&amp;<br>      eq( fabs(S.b.y-P.y)+fabs(S.a.y-P.y), fabs(S.b.y-S.a.y) );<br>}<br>bool intersects( const line &amp;L1, const line &amp;L2 ) <br>{  return !eq( L1.A*L2.B, L2.A*L1.B );  }<br><br>bool intersects( const line &amp;L, const segment &amp;S ) <br>{  return strana( L, S.a ) * strana( L, S.b ) &lt; 0;  }<br><br>point intersect( const line &amp;L1, const line &amp;L2 ) {<br>   return point( (L1.C*L2.B-L2.C*L1.B) / (L1.A*L2.B-L2.A*L1.B),<br>                 (L1.A*L2.C-L2.A*L1.C) / (L1.A*L2.B-L2.A*L1.B) );<br>}<br>point intersect( const line &amp;L, const segment &amp;S ) <br>{  return intersect( L, line(S) ); }<br><br>double dist( const point &amp;A, const point &amp;B ) <br>{  return myhypot( A.x-B.x, A.y-B.y );  }<br><br>double dist( const line &amp;L, const point &amp;T ) <br>{  return fabs(L.A*T.x + L.B*T.y - L.C) / myhypot( L.A, L.B ); }<br><br>double dist( const segment &amp;S, const point &amp;T ) {<br>   double a = dist( S.b, T ), b = dist( S.a, T ), c = dist( S.a, S.b );<br>   if( gte( sq(b), sq(a)+sq(c) ) ) return a;<br>   if( gte( sq(a), sq(b)+sq(c) ) ) return b;<br>   return dist( line( S ), T );<br>}<br><br>class CirclesOfDestruction { <br>   public: <br><br>   int on_boundary( point p, double xSize, double ySize ) {<br>      if( eq( p.x, 0.0 ) ) return 1;<br>      if( eq( p.x, xSize ) ) return 1;<br>      if( eq( p.y, 0.0 ) ) return 1;<br>      if( eq( p.y, ySize ) ) return 1;<br>      return 0;<br>   }<br><br>   double exitTime(int xSize, int ySize, int px, int py, vector &lt;int&gt; x, vector &lt;int&gt; y) { <br>      vector&lt;point&gt; p;<br>      p.push_back( point( 0, 0 ) );<br>      p.push_back( point( xSize, 0 ) );<br>      p.push_back( point( xSize, ySize ) );<br>      p.push_back( point( 0, ySize ) );<br><br>      int n = x.size();<br>      point A( px, py );<br>      for( int i = 0; i &lt; n; ++i ) {<br>         point B( x[i], y[i] );<br>         line L = okomica( line( A, B ), midpoint( A, B ) );<br>         <br>         for( int i = 0; i &lt; p.size(); ++i ) {<br>            int j = (i+1)%p.size();<br>            segment S( p[i], p[j] );<br>            if( intersects( L, S ) ) {<br>               p.insert( p.begin() + i + 1, intersect( L, S ) );<br>               ++i;<br>            }<br>         }<br>         for( int i = 0; i &lt; p.size(); ++i ) {<br>            if( strana( L, p[i] ) == strana( L, B ) ) {<br>               p.erase( p.begin() + i );<br>               --i;<br>            }<br>         }<br>      }<br><br>      double ret = 1e10;<br>      for( int i = 0; i &lt; p.size(); ++i ) {<br>         int j = (i+1)%p.size();<br>         if( on_boundary( p[i], xSize, ySize ) ) {<br>            ret &lt;?= dist( p[i], A );<br>            if( !on_boundary( p[j], xSize, ySize ) ) continue;<br>            if( !on_boundary( midpoint( p[j], p[i] ), xSize, ySize ) ) continue;<br>            ret &lt;?= dist( segment( p[i], p[j] ), A );<br>         }<br>      }<br>      if( ret &gt;= 1e9 ) return -1.0;<br>      return ret;<br>   } <br><br><br><br><br><br>   <br><br>}; <br><br><br><br>// Powered by FileEdit<br>// Powered by moj 3.0 beta 7 [modified TZTester]<br>// Powered by CodeProcessor<br></td>