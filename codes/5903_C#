<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br><br>public class CMajor {<br>  bool[] good = new bool[]{true, false, true, false, true, true, false, true, false, true, false, true};<br>  int numNotes = 12;<br><br>  public int getLongest(string[] fragments) {<br>    ArrayList idList = new ArrayList();<br>    for (int i = 0; i &lt; numNotes; ++i)<br>      if (good[i])<br>        idList.Add(i);<br>    int[] ids = new int[idList.Count];<br>    idList.CopyTo(ids);<br>    int[] unId = new int[numNotes];<br>    for (int i = 0; i &lt; ids.Length; ++i)<br>      unId[ids[i]] = i;<br>    for (int i = 0; i &lt; numNotes; ++i)<br>      if (!good[i])<br>        unId[i] = -1;<br><br>    int n = fragments.Length;<br><br>    int[,] canPlay = new int[ids.Length, n];<br>    for (int i = 0; i &lt; n; ++i)<br>    {<br>      string[] p = fragments[i].Split(' ');<br>      int[] jumps = new int[p.Length];<br>      for (int j = 0; j &lt; p.Length; ++j)<br>        jumps[j] = int.Parse(p[j]);<br>      for (int j = 0; j &lt; ids.Length; ++j)<br>      {<br>        int dest;<br>        if (trace(ids[j], jumps, out dest))<br>          canPlay[j, i] = unId[dest];<br>        else<br>          canPlay[j, i] = -1;<br>      }<br>    }<br><br>    bool[,] reach = new bool[1 &lt;&lt; n, ids.Length];<br>    for (int i = 0; i &lt; ids.Length; ++i)<br>      reach[0, i] = true;<br>    int res = 0;<br>    for (int state = 0; state &lt; (1 &lt;&lt; n); ++state)<br>    {<br>      bool any = false;<br>      for (int i = 0; i &lt; ids.Length; ++i)<br>        if (reach[state, i])<br>        {<br>          any = true;<br>          for (int j = 0; j &lt; n; ++j)<br>            if ((state &amp; (1 &lt;&lt; j)) == 0 &amp;&amp; canPlay[i, j] &gt;= 0)<br>              reach[state | (1 &lt;&lt; j), canPlay[i, j]] = true;<br>        }<br>      if (any)<br>      {<br>        int sum = 0;<br>        for (int j = 0; j &lt; n; ++j)<br>          if ((state &amp; (1 &lt;&lt; j)) &gt; 0)<br>            ++sum;<br>        if (sum &gt; res)<br>          res = sum;<br>      }<br>    }<br>    return res;<br>  }<br><br>  private bool trace(int start, int[] jumps, out int dest)<br>  {<br>    dest = 0;<br>    foreach (int jump in jumps)<br>    {<br>      start = ((start + jump) % numNotes + numNotes) % numNotes;<br>      if (!good[start])<br>        return false;<br>    }<br>    dest = start;<br>    return true;<br>  }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>