<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br><br>public class SafeJourney {<br>  struct Point<br>  {<br>    public int x;<br>    public int y;<br><br>    public Point(int x, int y)<br>    {<br>      this.x = x;<br>      this.y = y;<br>    }<br>  }<br><br>  struct Road<br>  {<br>    public Point a;<br>    public Point b;<br><br>    public Road(Point a, Point b)<br>    {<br>      this.a = a;<br>      this.b = b;<br>    }<br>  }<br><br>  ArrayList Xs;<br>  ArrayList Ys;<br>  ArrayList roads;<br><br>  void addRoad(Road r)<br>  {<br>    roads.Add(r);<br>    Xs.Add(r.a.x);<br>    Xs.Add(r.b.x);<br>    Ys.Add(r.a.y);<br>    Ys.Add(r.b.y);<br>  }<br><br>  void convertPoint(ref Point p)<br>  {<br>    p.x = Xs.BinarySearch(p.x);<br>    p.y = Ys.BinarySearch(p.y);<br>  }<br><br>  public int fewestRoadCrossings(int width, int length, string[] horizontal, string[] vertical, string home, string work) {<br>    Xs = new ArrayList();<br>    Ys = new ArrayList();<br><br>    Xs.Add(0);<br>    Xs.Add(width);<br><br>    Ys.Add(0);<br>    Ys.Add(length);<br><br>    roads = new ArrayList();<br><br>    foreach (string s1 in horizontal)<br>    {<br>      string[] s1Parts = s1.Split(',');<br><br>      foreach (string s2 in s1Parts)<br>      {<br>        string[] s2Parts = s2.Trim(' ').Split(' ');<br>        int y = int.Parse(s2Parts[0]);<br>        int x1 = int.Parse(s2Parts[1]);<br>        int x2 = int.Parse(s2Parts[2]);<br>        addRoad(new Road(new Point(x1, y), new Point(x2, y)));<br>      }<br>    }<br><br>    foreach (string s1 in vertical)<br>    {<br>      string[] s1Parts = s1.Split(',');<br><br>      foreach (string s2 in s1Parts)<br>      {<br>        string[] s2Parts = s2.Trim(' ').Split(' ');<br>        int x = int.Parse(s2Parts[0]);<br>        int y1 = int.Parse(s2Parts[1]);<br>        int y2 = int.Parse(s2Parts[2]);<br>        addRoad(new Road(new Point(x, y1), new Point(x, y2)));<br>      }<br>    }<br><br>    string[] parts = home.Trim(' ').Split(' ');<br>    Point start = new Point(int.Parse(parts[0]), int.Parse(parts[1]));<br>    parts = work.Trim(' ').Split(' ');<br>    Point dest = new Point(int.Parse(parts[0]), int.Parse(parts[1]));<br>    Xs.Add(start.x);<br>    Xs.Add(dest.x);<br>    Ys.Add(start.y);<br>    Ys.Add(dest.y);<br><br>    Xs.Sort();<br>    Ys.Sort();<br><br>    ArrayList tmp = Xs;<br>    Xs = new ArrayList();<br>    for (int i = 0; i &lt; tmp.Count; ++i)<br>      if (i == 0 || (int) tmp[i] != (int) tmp[i - 1])<br>        Xs.Add(tmp[i]);<br>    tmp = Ys;<br>    Ys = new ArrayList();<br>    for (int i = 0; i &lt; tmp.Count; ++i)<br>      if (i == 0 || (int) tmp[i] != (int) tmp[i - 1])<br>        Ys.Add(tmp[i]);<br><br>    int numXs = Xs.Count;<br>    int numYs = Ys.Count;<br><br>    for (int i = 0; i &lt; roads.Count; ++i)<br>    {<br>      Road r = (Road) roads[i];<br>      convertPoint(ref r.a);<br>      convertPoint(ref r.b);<br>      roads[i] = r;<br>    }<br><br>    convertPoint(ref start);<br>    convertPoint(ref dest);<br><br>    bool[,] reach = new bool[numXs, numYs];<br>    int[,] len = new int[numXs, numYs];<br>    bool[,] wallX = new bool[numXs, numYs];<br>    bool[,] wallY = new bool[numXs, numYs];<br>    foreach (Road road in roads)<br>    {<br>      if (road.a.x == road.b.x)<br>      {<br>        for (int i = road.a.y; i &lt; road.b.y; ++i)<br>          wallX[road.a.x, i] = true;<br>      }<br>      else<br>      {<br>        for (int i = road.a.x; i &lt; road.b.x; ++i)<br>          wallY[i, road.a.y] = true;<br>      }<br>    }<br>    reach[start.x, start.y] = true;<br>    len[start.x, start.y] = 0;<br><br>    Point[] q = new Point[2 * numXs * numYs + 100];<br>    int qtail = 0;<br>    int qhead = 1;<br>    q[qtail] = start;<br><br>    while (qtail != qhead)<br>    {<br>      Point cur = q[qtail];<br>      ++qtail;<br>      if (qtail &gt;= q.Length)<br>        qtail = 0;<br>      int clen = len[cur.x, cur.y];<br><br>      for (int dx = -1; dx &lt;= 1; ++dx)<br>        for (int dy = -1; dy &lt;= 1; ++dy)<br>          if ((dx == 0) ^ (dy == 0))<br>          {<br>            int nx = cur.x + dx;<br>            int ny = cur.y + dy;<br>            if (nx &gt;= 0 &amp;&amp; nx &lt; numXs - 1 &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; numYs - 1)<br>            {<br>              int pen = 0;<br>              if (dx == 0)<br>              {<br>                if (wallY[cur.x, cur.y + (dy + 1) / 2])<br>                  ++pen;<br>              }<br>              else<br>              {<br>                if (wallX[cur.x + (dx + 1) / 2, cur.y])<br>                  ++pen;<br>              }<br>              if (!reach[nx, ny] || len[nx, ny] &gt; clen + pen) <br>              {<br>                reach[nx, ny] = true;<br>                len[nx, ny] = clen + pen;<br>                if (pen &gt; 0)<br>                {<br>                  q[qhead] = new Point(nx, ny);<br>                  ++qhead;<br>                  if (qhead &gt;= q.Length)<br>                    qhead = 0;<br>                } else<br>                {<br>                  --qtail;<br>                  if (qtail &lt; 0)<br>                    qtail = q.Length - 1;<br>                  q[qtail] = new Point(nx, ny);<br>                }<br>              }<br>            }<br>          }<br>    }<br><br>    return len[dest.x, dest.y];<br>  }<br><br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>