<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;list&gt;<br>#include &lt;regex.h&gt; <br>using namespace std;<br><br>// LIB CODE<br>typedef vector&lt;int&gt; VI;<br>#define PB push_back<br>#define FOR(i,a,b) for(int i=(a);i&lt;int(b);++i)<br>#define SZ(v) ((int)(v).size())<br>#define FORSZ(i,a,v) FOR(i,a,SZ(v))<br>#define REPSZ(i,v) FORSZ(i,0,v)<br>#define REP(i,n) FOR(i,0,n)<br>template&lt;class T, class U&gt; T cast (U x) { T y; ostringstream a; a&lt;&lt;x; istringstream b(a.str()); b&gt;&gt;y; return y; }<br>template&lt;class T&gt; vector&lt;T&gt; split(string s, string x=" ") { vector&lt;T&gt; r; REP(i,s.size()) { string c; while(i&lt;(int)s.size()&amp;&amp;x.find(s[i])==string::npos) c+=s[i++]; if(c.size()) r.push_back(cast&lt;T&gt;(c)); } return r; }<br>#define ALL(v) (v).begin(),(v).end()<br>#define SORT(v) sort(ALL(v))<br>#define UNIQUE(v) (v).erase(unique(ALL(v)),(v).end())<br>typedef vector&lt;VI&gt; VVI;<br>#define FORE(i,a,b) for(int i=(a);i&lt;=int(b);++i)<br>typedef pair&lt;int,int&gt; PII;<br>typedef vector&lt;PII&gt; VPII;<br>#define MP make_pair<br>int DX[]={-1,0,1,0};<br>int DY[]={0,1,0,-1};<br>// REAL CODE<br><br><br><br>class SafeJourney {<br>public:<br>  int fewestRoadCrossings(int width, int length, vector &lt;string&gt; horizontal, vector &lt;string&gt; vertical, string home, string work) {<br>    VI x,y;<br>    x.PB(0); x.PB(width); y.PB(0); y.PB(length);<br>    REPSZ(i,horizontal) { VI z=split&lt;int&gt;(horizontal[i]," ,"); for(int j=0;j&lt;SZ(z);j+=3) { y.PB(z[j+0]); x.PB(z[j+1]); x.PB(z[j+2]); } }<br>    REPSZ(i,vertical) { VI z=split&lt;int&gt;(vertical[i]," ,"); for(int j=0;j&lt;SZ(z);j+=3) { x.PB(z[j+0]); y.PB(z[j+1]); y.PB(z[j+2]); } }<br>    { VI z=split&lt;int&gt;(home); x.PB(z[0]); y.PB(z[1]); }<br>    { VI z=split&lt;int&gt;(work); x.PB(z[0]); y.PB(z[1]); }<br>    SORT(x); UNIQUE(x); SORT(y); UNIQUE(y);<br>    <br>//    REPSZ(i,x) printf("%d%c",x[i],i==SZ(x)-1?'\n':' ');<br>//    REPSZ(i,y) printf("%d%c",y[i],i==SZ(y)-1?'\n':' ');<br>    <br>    map&lt;int,int&gt; fx,fy;<br>    REPSZ(i,x) fx[x[i]]=i;<br>    REPSZ(i,y) fy[y[i]]=i;<br>    <br>    <br>    VVI b(2*SZ(x)-1,VI(2*SZ(y)-1,-1));<br>    REPSZ(i,horizontal) { VI z=split&lt;int&gt;(horizontal[i]," ,"); for(int j=0;j&lt;SZ(z);j+=3) {<br>      int yy=2*fy[z[j+0]],sx=2*fx[z[j+1]],ex=2*fx[z[j+2]];<br>      FORE(xx,sx,ex) b[xx][yy]=-2;<br>    } }<br>    REPSZ(i,vertical) { VI z=split&lt;int&gt;(vertical[i]," ,"); for(int j=0;j&lt;SZ(z);j+=3) {<br>      int xx=2*fx[z[j+0]],sy=2*fy[z[j+1]],ey=2*fy[z[j+2]];<br>      FORE(yy,sy,ey) b[xx][yy]=-2;<br>    } }<br>    <br>//    REPSZ(i,b) { REPSZ(j,b[i]) printf("%c",b[i][j]==-2?'X':'.'); puts(""); }<br>    <br>    VPII q1,q2;<br>    { VI z=split&lt;int&gt;(home); printf("%d %d\n",z[1],fy[z[1]]); q2.PB(MP(2*fx[z[0]],2*fy[z[1]])); b[2*fx[z[0]]][2*fy[z[1]]]=0; }<br>    while(!q2.empty()) {<br>      swap(q1,q2);<br>      while(!q1.empty()) {<br>        int cx=q1.back().first,cy=q1.back().second; q1.pop_back();<br>//        printf("%d %d = %d\n",cx,cy,b[cx][cy]);<br>        REP(k,4) {<br>          int nx=cx+DX[k],ny=cy+DY[k];<br>          if(nx&lt;0||nx&gt;=SZ(b)||ny&lt;0||ny&gt;=SZ(b[nx])) continue;<br>          if(b[nx][ny]==-2) {<br>            nx+=DX[k],ny+=DY[k];<br>            if(nx&lt;0||nx&gt;=SZ(b)||ny&lt;0||ny&gt;=SZ(b[nx])||b[nx][ny]!=-1) continue;<br>            b[nx][ny]=b[cx][cy]+1;<br>            q2.PB(MP(nx,ny));<br>          } else if(b[nx][ny]==-1||b[cx][cy]&lt;b[nx][ny]) {<br>            b[nx][ny]=b[cx][cy];<br>            q1.PB(MP(nx,ny));<br>          }<br>        }<br>      }<br>    }<br><br>//    REPSZ(i,b) { REPSZ(j,b[i]) printf("%c",b[i][j]==-2?'X':'0'+b[i][j]); puts(""); }<br><br>    { VI z=split&lt;int&gt;(work); return b[2*fx[z[0]]][2*fy[z[1]]]; }<br>  }<br>  <br>};<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>