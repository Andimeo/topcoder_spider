<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class BallBouncing {<br>  const int MAX_STEPS = 10000000;<br>  const int MAX_COORD = 1000000;<br><br>  bool[] badPlus;<br>  bool[] badMinus;<br><br>  struct Point<br>  {<br>    public int row;<br>    public int col;<br><br>    public Point(int row, int col)<br>    {<br>      this.row = row;<br>      this.col = col;<br>    }<br>  }<br><br>  Point[] holes;<br>  int rows;<br>  int columns;<br><br>  bool falls(Point start, Point end, Point dir, int step)<br>  {<br>    if (step == 0)<br>      return falls(start, end);<br>    else<br>      return quickFalls(start, end, dir);<br>  }<br><br>  bool falls(Point start, Point end)<br>  {<br>    foreach (Point hole in holes)<br>    {<br>      int z = (hole.row - start.row) * (end.col - start.col) - (hole.col - start.col) * (end.row - start.row);<br>      if (z == 0)<br>      {<br>        if (hole.row &gt;= Math.Min(start.row, end.row) &amp;&amp; hole.row &lt;= Math.Max(start.row, end.row)<br>          &amp;&amp; hole.col &gt;= Math.Min(start.col, end.col) &amp;&amp; hole.col &lt;= Math.Max(start.col, end.col))<br>          return true;<br>      }<br>    }<br><br>    return false;<br>  }<br><br>  bool quickFalls(Point start, Point end, Point dir)<br>  {<br>    if (dir.row != dir.col)<br>      return badPlus[start.row + start.col];<br>    else<br>      return badMinus[start.row - start.col + MAX_COORD];<br>  }<br><br>  void traverse(Point start, Point direction, out Point end, out Point newStart, out Point newDirection)<br>  {<br>    int rowTime;<br>    if (direction.row &gt; 0)<br>      rowTime = (rows - 1 - start.row);<br>    else<br>      rowTime = start.row;<br>    int colTime;<br>    if (direction.col &gt; 0)<br>      colTime = (columns - 1 - start.col);<br>    else<br>      colTime = start.col;<br>    int time = Math.Min(rowTime, colTime);<br>    end = new Point(start.row + time * direction.row, start.col + time * direction.col);<br>    newDirection = direction;<br>    if (time == rowTime)<br>      newDirection = new Point(-newDirection.row, newDirection.col);<br>    if (time == colTime)<br>      newDirection = new Point(newDirection.row, -newDirection.col);<br>    newStart = new Point(end.row + (direction.row + newDirection.row) / 2, end.col + (direction.col + newDirection.col) / 2);<br>  }<br><br>  public int bounces(int rows, int columns, int startrow, int startcol, string[] sHoles) {<br>    holes = new Point[sHoles.Length];<br>    badPlus = new bool[2 * MAX_COORD];<br>    badMinus = new bool[2 * MAX_COORD];<br><br>    for (int i = 0; i &lt; sHoles.Length; ++i)<br>    {<br>      string[] ss = sHoles[i].Split(' ');<br>      holes[i] = new Point(int.Parse(ss[0]), int.Parse(ss[1]));<br>      badPlus[holes[i].row + holes[i].col] = true;<br>      badMinus[holes[i].row - holes[i].col + MAX_COORD] = true;<br>    }<br><br>    this.rows = rows;<br>    this.columns = columns;<br><br>    int step = 0;<br><br>    Point at = new Point(startrow, startcol);<br>    Point dir = new Point(1, 1);<br><br>    while (step &lt; MAX_STEPS)<br>    {<br>      Point newAt;<br>      Point newDir;<br>      Point till;<br><br>      traverse(at, dir, out till, out newAt, out newDir);<br>      if (falls(at, till, dir, step))<br>        return step;<br><br>      at = newAt;<br>      dir = newDir;<br><br>      ++step;<br>    }<br><br>    return -1;<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>