<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>public class UnitsMoving<br>{<br>  public static Array[] FormatArrays(string[] ss, string format)<br>  {<br>    int i=format.Length;<br>    Array[] ret = new Array[i];<br>    while(--i&gt;=0)<br>      ret[i] = newArray(format[i], ss.Length);<br>    for(i=ss.Length-1; i&gt;=0; i--)<br>    {<br>      object[] os = FormatArray(ss[i], format);<br>      for(int j=format.Length-1; j&gt;=0; j--)<br>        ret[j].SetValue(os[j], i);<br>    }<br>    return ret;<br>  }<br>  public static ArrayList MappingList(Hashtable ht, IList list)<br>  {<br>    ArrayList ret = new ArrayList();<br>    foreach(object o in list)<br>      ret.Add(ht[o]);<br>    return ret;<br>  }<br>  public static int[][] ListsDisperse(params IList[] datas)<br>  {<br>    ArrayList vlist;<br>    return ListsDisperse(out vlist, datas);<br>  }<br>  public static int[][] ListsDisperse(out ArrayList vlist, params IList[] datas)<br>  {<br>    int[][] ret = new int[datas.Length][];<br>    Hashtable ht = Counting(datas);<br>    vlist = new ArrayList(ht.Keys);<br>    vlist.Sort();<br>    ht = Posmap(vlist);<br>    for(int i=datas.Length-1;i&gt;=0; i--)<br>      ret[i] = (int[]) MappingList(ht, datas[i]).ToArray(typeof(int));<br>    return ret;<br>  }<br>  public static Hashtable Counting(params IEnumerable[] datas)<br>  {<br>    Hashtable ht = new Hashtable();<br>    Counting(ht, datas);<br>    return ht;<br>  }<br>  public static void Counting(Hashtable ht, params IEnumerable[] datas)<br>  {<br>    foreach(IEnumerable data in datas)<br>      foreach(object o in data)<br>        if(ht.Contains(o))<br>          ht[o] = (int)ht[o] + 1;<br>        else<br>          ht[o] = 1;<br>  }<br>  public static Array DupArray(object v, params int[] lens)<br>  {<br>    if(lens.Length==0)<br>      return Array.CreateInstance(v.GetType(), 0);<br>    for(int i=lens.Length-1; i&gt;=0; i--)<br>      v = DupArray(v, lens[i]);<br>    return (Array)v;<br>  }<br>  public static Array DupArray(object v, int len)<br>  {<br>    Array r = Array.CreateInstance(v.GetType(), len);<br>    ICloneable c = v as ICloneable;<br>    if(c==null)<br>      while(--len&gt;=0)<br>        r.SetValue(v, len);<br>    else<br>      while(--len&gt;=0)<br>        r.SetValue(c.Clone(), len);<br>    return r;<br>  }<br>  private static Array newArray(char format, int len)<br>  {<br>    switch(format)<br>    {<br>      case 'I':<br>        return Array.CreateInstance(typeof(int), len);<br>    }<br>    throw new InvalidCastException();<br>  }<br>  public static Hashtable Posmap(IList list)<br>  {<br>    Hashtable ht = new Hashtable();<br>    for(int i=0; i&lt;list.Count; i++)<br>      ht[list[i]] = i;<br>    return ht;<br>  }<br>  public static double Distance(double x1, double y1, double x2, double y2)<br>  {<br>    x1 -= x2;<br>    y1 -= y2;<br>    return Math.Sqrt(x1*x1+y1*y1);<br>  }<br>  public static object[] FormatArray(string s, string format)<br>  {<br>    int i=format.Length;<br>    object[] ret = new object[i];<br>    string[] ss = s.Split(' ');<br>    while(--i&gt;=0)<br>      ret[i] = Format(ss[i], format[i]);<br>    return ret;<br>  }<br>  public static object Format(string s, char format)<br>  {<br>    switch(format)<br>    {<br>      case 'I':<br>        return int.Parse(s.Trim());<br>    }<br>    throw new InvalidCastException();<br>  }<br>  public double bestTime(string[] start, string[] finish) <br>  {<br>    int n= start.Length, n1 = n-1, best, left = 0, right;<br>    double[][] map = (double[][])DupArray(0.0, n, n);<br>    Array[] starts = FormatArrays(start, "III"), finishs = FormatArrays(finish, "II");<br>    int[]  x = (int[])starts[0],  y = (int[])starts[1],  v = (int[])starts[2],<br>      xx = (int[])finishs[0],  yy = (int[])finishs[1];<br>    for (int i = n1; i &gt;=0; i--) <br>      for (int j = n1; j &gt;=0; j--) <br>        map[i][j] = Distance(x[i], y[i], xx[j], yy[j]) / v[i];<br>    ArrayList list;<br>    int[][] maps = ListsDisperse(out list, map);<br>    right = list.Count-1;<br>    SimpleAssignmentProblem ap = new SimpleAssignmentProblem(n);<br>    for (int t = (int)Math.Ceiling(Math.Log(right-left, 2)); t &gt;=0; t--)<br>    {<br>      best = (left + right) &gt;&gt; 1;<br>      for(int i=n1; i&gt;=0; i--)<br>        for(int j=n1; j&gt;=0; j--)<br>          ap[i,j] = maps[i][j]&lt;=best;<br>      if (ap.Solve()!=null)<br>        right = best;<br>      else <br>        left = best;<br>    }<br>    return (double)list[right];<br>  }<br>}<br>public class SimpleAssignmentProblem<br>{<br>  public SimpleAssignmentProblem(int dim)<br>  {<br>    n = dim;<br>    this.map = new bool[dim, dim];<br>  }<br>  int n;<br>  bool[,] map;<br>  int[] solution;<br>  bool[] dones;<br>  public bool this[int worker, int job]<br>  {<br>    get<br>    {<br>      return map[worker, job];<br>    }<br>    set<br>    {<br>      map[worker, job] = value;<br>    }<br>  }<br>  public int[] Solve() <br>  {<br>    solution = new int[n];<br>    for (int i=n-1; i &gt;= 0; i--)<br>      solution[i] = -1;<br>    for (int i = n-1; i &gt;=0; i--)<br>    {<br>      dones = new bool[n];<br>      if(!add(i))<br>        return null;<br>    }<br>    return solution;<br>  }<br>  private bool add(int i) <br>  {<br>    if (dones[i])<br>      return false;<br>    dones[i] = true;<br>    for (int j = n-1; j &gt;=0; j--)<br>      if (map[i,j])<br>      {<br>        int k = solution[j];<br>        solution[j] = i;<br>        if (k &lt; 0)<br>          return true;<br>        if (add(k))<br>          return true;<br>        solution[j] = k;<br>      }<br>    return false;<br>  }<br>}<br></td>