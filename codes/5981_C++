<td class="problemText" colspan="8" valign="middle" align="left">
            // another fine solution by misof<br>// #includes {{{<br>#include &lt;algorithm&gt;<br>#include &lt;numeric&gt;<br> <br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br> <br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cassert&gt;<br> <br>#include &lt;cmath&gt;<br>#include &lt;complex&gt;<br>using namespace std;<br>// }}}<br> <br>/////////////////// PRE-WRITTEN CODE FOLLOWS, LOOK DOWN FOR THE SOLUTION ////////////////////////////////<br> <br>// pre-written code {{{<br>#define CLEAR(t) memset((t),0,sizeof(t))<br>#define FOR(i,a,b) for(int i=(int)(a);i&lt;=(int)(b);++i)<br>#define FORD(i,a,b) for(int i=(int)(a);i&gt;=(int)(b);--i)<br>#define REP(i,n) for(int i=0;i&lt;(int)(n);++i)<br>#define SIZE(t) ((int)((t).size()))<br>vector&lt;string&gt; SPLIT( const string&amp; s, const string&amp; delim =" " ) { vector&lt;string&gt; res; string t; for ( unsigned int i = 0 ; i != s.size() ; i++ ) { if ( delim.find( s[i] ) != string::npos ) { if ( !t.empty() ) { res.push_back( t ); t = ""; } } else { t += s[i]; } } if ( !t.empty() ) { res.push_back(t); } return res; }<br>vector&lt;int&gt; SPLITINT( const string&amp; s, const string&amp; delim =" " ) { vector&lt;string&gt; tok = SPLIT( s, delim ); vector&lt;int&gt; res; for ( unsigned int i = 0 ; i != tok.size(); i++ ) res.push_back( atoi( tok[i].c_str() ) ); return res; }<br>typedef vector&lt;int&gt; VI;<br>// }}}<br> <br>/////////////////// CODE WRITTEN DURING THE COMPETITION FOLLOWS ////////////////////////////////<br> <br>int G1[52][52];<br>int C[52];<br>int N;<br>int G2[52][52];<br>int wt[52];<br>int moze[52][52];<br> <br>class GalaxyExpedition {<br>public:<br>  vector &lt;int&gt; possibleValues(vector &lt;string&gt; dependencies) {<br>    <br>    CLEAR(G1);<br>    N = SIZE(dependencies);<br>    <br>    REP(i,N) {<br>      VI V = SPLITINT(dependencies[i]);<br>      REP(j,SIZE(V)) G1[ i ][ V[j] ] = 1;<br>    }<br> <br>    memset(C,-1,sizeof(C));<br>    int pocC = 0;<br>    <br>    REP(v,N) if (C[v]==-1) {<br>      vector&lt;int&gt; bol1(N,0), bol2(N,0);<br>      <br>      bol1[v]=1;<br>      queue&lt;int&gt; Q1; Q1.push(v);<br>      while (!Q1.empty()) {<br>        int kde = Q1.front(); Q1.pop();<br>        REP(i,N) if (G1[kde][i]) if (!bol1[i]) { bol1[i]=1; Q1.push(i); }<br>      }<br>      <br>      bol2[v]=2;<br>      queue&lt;int&gt; Q2; Q2.push(v);<br>      while (!Q2.empty()) {<br>        int kde = Q2.front(); Q2.pop();<br>        REP(i,N) if (G1[i][kde]) if (!bol2[i]) { bol2[i]=2; Q2.push(i); }<br>      }<br> <br>      wt[pocC]=0;<br>      REP(i,N) if (bol1[i] &amp;&amp; bol2[i]) { C[i]=pocC; wt[pocC]++; }<br>      pocC++;<br>    }<br> <br>    CLEAR(G2);<br> <br>    REP(i,N) REP(j,N) if (G1[i][j]) if (C[i] != C[j]) G2[ C[i] ][ C[j] ]=1;<br> <br>    int zmena = 1;<br>    while (zmena) {<br>      zmena = 0;<br>      REP(i,pocC) REP(j,pocC) if (G2[i][j]) {<br>        REP(k,pocC) if (G2[i][k] &amp;&amp; G2[j][k]) {<br>          G2[i][k]=0; zmena=1;<br>        }<br>      }<br>    }<br> <br>    CLEAR(moze);<br> <br>    vector&lt;int&gt; done(pocC,0);<br>    vector&lt;int&gt; indegree(pocC,0);<br> <br>    REP(i,pocC) REP(j,pocC) if (G2[i][j]) indegree[j]++;<br> <br>    REP(loop,pocC) {<br>      int kde=0;<br>      while (done[kde] || indegree[kde]) kde++;<br> <br>      moze[kde][ wt[kde] ]=1;<br> <br>      REP(i,pocC) if (G2[i][kde]) {<br>        FORD(p,N,0) {<br>          // find out whether now it is possible to take p<br>          FOR(q,0,p) if (moze[i][q] &amp;&amp; moze[kde][p-q]) moze[kde][p]=1;<br>        }<br>      }<br> <br>      REP(i,pocC) if (G2[kde][i]) indegree[i]--;<br>      done[kde]=1;<br>    }<br> <br>    vector&lt;int&gt; faktmoze(N+1,0);<br> <br>    faktmoze[0]=1;<br>    REP(i,pocC) {<br>      int ok=1;<br>      REP(j,pocC) if (G2[i][j]) ok=0;<br>      if (!ok) continue;<br> <br>      FORD(p,N,0) {<br>        FOR(q,0,p) if (faktmoze[q] &amp;&amp; moze[i][p-q]) faktmoze[p]=1;<br>      }<br>    }<br>    <br>    vector &lt;int&gt; res;<br>    FOR(p,1,N) if (faktmoze[p]) res.push_back(p);<br>    return res;<br>  }<br> <br> <br>};<br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>