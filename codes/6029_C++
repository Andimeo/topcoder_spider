<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;queue&gt;<br>using namespace std;<br><br>int n;<br><br>typedef vector&lt;int&gt; VI;<br>VI adj[1000],adj2[1000],col[1000],toporder;<br>char used[1000];<br>int c[1000];<br><br>void dfs(int act) {<br>  if (used[act])<br>    return;<br>  used[act] = 1;<br>  for (VI::iterator it=adj[act].begin(); it&lt;adj[act].end(); it++)<br>    dfs(*it);<br>  toporder.push_back(act);<br>}<br><br>int dfs2(int act) {<br>  if (!used[act])<br>    return 0;<br>  used[act] = 0;<br>  int ret = 1;<br>  for (VI::iterator it=adj2[act].begin(); it&lt;adj2[act].end(); it++) {<br>    ret += dfs2(*it);<br>  }<br>  return ret;<br>}<br><br>int colour(int act) {<br>  for (VI::iterator it=col[act].begin(); it&lt;col[act].end(); it++) {<br>    if (!used[*it]) {<br>      used[*it] = 3-used[act];<br>      if (!colour(*it))<br>        return 0;<br>    }<br>    else if (used[*it] == used[act])<br>      return 0;<br>  }<br>  return 1;<br>}<br><br>class FamilyTree {<br>  public:<br>  bool checkit() {<br>    bool valid = true;<br>    for (int b=0; b&lt;n; ++b) {<br>      col[b].clear();<br>      used[b] = 0;<br>      if (adj2[b].size()&gt;2)<br>          valid = false;<br>    }<br>    if (valid) {<br>      toporder.clear();<br>      for (int i=0; i&lt;n; i++) {<br>        if (!used[i])<br>          dfs(i);<br>      }<br>      reverse(toporder.begin(),toporder.end());<br>      for (VI::iterator it=toporder.begin(); it&lt;toporder.end(); it++) {<br>        if (used[*it]) {<br>          if (dfs2(*it)&gt;1) {<br>            valid = false;<br>            break;<br>          }<br>        }<br>      }<br>    }<br>    if (valid) {<br>      for (int i=0; i&lt;n; i++) {<br>        if (adj2[i].size() == 2) {<br>          col[adj2[i][0]].push_back(adj2[i][1]);<br>          col[adj2[i][1]].push_back(adj2[i][0]);<br>        }<br>      }<br>      for (int i=0; i&lt;n; i++) {<br>        if (c[i]) {<br>          if (used[i] &amp;&amp; used[i] != c[i])<br>            return false;<br>          used[i] = c[i];<br>          if (!colour(i))<br>            return false;<br>        }<br>      }<br>      for (int i=0; i&lt;n; i++) {<br>        if (!used[i]) {<br>          used[i] = 1;<br>          if (!colour(i)) {<br>            valid = false;<br>            break;<br>          }<br>        }<br>      }<br>    }<br>    return valid;<br>  }<br>  int firstBad(vector &lt;string&gt; data) {<br>    n = 0;<br>    map&lt;string,int&gt; ind;<br>    for (int i=0; i&lt;(int)data.size(); ++i) {<br>      char a[100],b[100];<br>      sscanf(data[i].c_str(),"%s %s",a,b);<br>      if (ind.find(a) == ind.end()) {<br>        ind[a] = n;<br>        adj[n].clear();<br>        adj2[n].clear();<br>        c[n] = 0;<br>        ++n;<br>      }<br>      if (b[0] == 'm') {<br>        if (c[ind[a]] &amp;&amp; c[ind[a]] != 1)<br>          return i;<br>        c[ind[a]] = 1;<br>      }<br>      else if (b[0] == 'f') {<br>        if (c[ind[a]] &amp;&amp; c[ind[a]] != 2)<br>          return i;<br>        c[ind[a]] = 2;<br>      }<br>      else {<br>        if (ind.find(b) == ind.end()) {<br>          ind[b] = n;<br>          adj[n].clear();<br>          adj2[n].clear();<br>          c[n] = 0;<br>          ++n;<br>        }<br>        int a2 = ind[a];<br>        int b2 = ind[b];<br>        if (a2 == b2)<br>          return i;<br>        bool ins = true;<br>        for (VI::iterator it=adj2[a2].begin(); it!=adj2[a2].end(); ++it)<br>          if (*it == b2)<br>            ins = false;<br>        if (ins) {<br>          adj2[a2].push_back(b2);<br>          adj[b2].push_back(a2);<br>        }<br>      }<br>      if (!checkit())<br>        return i;<br>    }<br>    return -1;<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>