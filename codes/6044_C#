<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br><br>public class BlindMazeSolve <br>{<br>  class node<br>  {<br>    public node(string s,int a)<br>    {<br>      seq = s;<br>      at = a;<br>    }<br>    public string seq;<br>    public int at;<br>  }<br>  int height;<br>  public string getSolution(string[] maze) <br>  {<br>    height = maze[0].Length;<br>    int size = maze.Length * maze[0].Length;<br>    <br>    bool[] visited = new bool[1&lt;&lt;(size)];<br><br>    Queue q = new Queue();<br>    int start = 0;<br>    int iii,jjj;<br>    for(int j=0;j&lt;size;j++)<br>    {<br>      to(j, out iii, out jjj);<br>      if(maze[iii][jjj] == '.') start |= (1 &lt;&lt; j);<br>    }<br>    q.Enqueue(new node("",start));<br>    int[] di = new int[]{1,0,0,-1};<br>    int[] dj = new int[]{0,-1,1,0};<br>    char[] dd = new char[]{'D','L','R','U'};<br>    while(q.Count &gt; 0)<br>    {<br>      Queue nq = new Queue();<br>      while(q.Count &gt; 0)<br>      {<br>        node at = (node)q.Dequeue();<br>      <br>      //  Console.WriteLine("at + " + at.seq);<br>        int pos = at.at;<br>      <br>        for(int i=0;i&lt;4;i++)<br>        {<br>          int next = 0;<br>          string ns = at.seq + dd[i];<br>          for(int j=0;j&lt;size;j++)<br>          {<br>            if((pos &amp; (1 &lt;&lt; j)) != 0)<br>            {<br>              int ii,jj;<br>              to(j, out ii, out jj);<br>              ii += di[i];<br>              jj += dj[i];<br>              if(jj == -1)<br>              {<br>              <br>              }<br>              else<br>              {<br>                if(ii &gt;= 0 &amp;&amp; ii &lt; maze.Length &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; maze[0].Length &amp;&amp; maze[ii][jj] == '.')<br>                {<br>                  next |= (1 &lt;&lt; from(ii,jj));<br>                }<br>                else<br>                {<br>                  next |= (1 &lt;&lt; from(ii-di[i],jj-dj[i]));<br>                }<br>              }<br>            }<br>          }<br>          if(next == 0) return ns;<br>          if(!visited[next])<br>          {<br>            visited[next] = true;<br>            nq.Enqueue(new node(ns, next));<br>          }<br>        }<br>      }<br>      q = nq;<br>    }<br>    return "";<br>  }<br>  int from(int i,int j)<br>  {<br>    return height * i + j;<br>  }<br>  void to(int at,out int i,out int j)<br>  {<br>    i = at / height;<br>    j = at % height;<br>  }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>