<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.math.*;<br>public class CountryWar {<br>  double [][] prob;<br>  int target;<br>  int n;<br>  int [] units;<br>  double [][][] ww = new double[21][21][21];<br>  boolean [][] adj;<br>  public double defeatAll(String[] armies) {<br>    n = armies.length;<br>    char [] type = new char[n];<br>    units = new int[n];<br>    target = 0;<br>    int start = 0;<br>    int sunit = 0;<br>    adj = new boolean[n][n];<br>    for (int i = 0; i &lt; n; i++) {<br>      String [] ss = armies[i].split(" ");<br>      type[i] = ss[0].charAt(0);<br>      units[i] = Integer.parseInt(ss[1]);<br>      for (int j = 2; j &lt; ss.length; j++) {<br>        int jj = Integer.parseInt(ss[j]);<br>        adj[i][jj] = adj[jj][i] = true;<br>      }<br>      if (type[i] == 'Y' || type[i] == 'E') {<br>        target |= (1 &lt;&lt; i);<br>      }<br>      if (type[i] == 'Y') {<br>        start |= (1 &lt;&lt; i);<br>        sunit = units[i];<br>      }<br>    }<br>    for (int i = 0; i &lt; n; i++) adj[i][i] = false;<br>    <br>    int poss = (1 &lt;&lt; n);<br>    prob = new double[poss][21]; for (int i = 0; i &lt; poss; i++) Arrays.fill(prob[i], -1);<br>    for (int i = 0; i &lt;= 20; i++) for (int j = 0; j &lt;= 20; j++) Arrays.fill(ww[i][j], -1);<br>    return go(start, sunit);<br>  }<br>  <br>  double winExactly(int desired, int mine, int theirs) {<br>    if (ww[desired][mine][theirs] &gt; -0.5) return ww[desired][mine][theirs];<br>    if (desired &gt; mine || mine == 0) { return ww[desired][mine][theirs] = 0; }<br>    if (theirs == 0) {<br>      return (mine == desired) ? 1 : 0;<br>    }<br>    double pwin = (double)(mine*mine) / (mine*mine + mine*theirs + theirs*theirs);<br>    <br>    ww[desired][mine][theirs] = pwin * winExactly(desired, mine, theirs-1) +<br>    (1-pwin) * winExactly(desired, mine-1, theirs);<br>    return ww[desired][mine][theirs];<br>  }<br>  double go(int mask, int left) {<br>    if (left == 0) return 0;<br>    if ((mask &amp; target) == target) return 1;<br>    if (prob[mask][left] &gt; -0.5) return prob[mask][left];<br>    <br>    double maxP = 0;<br>    int m = 1;<br>    for (int next = 0; next &lt; n; next++, m &lt;&lt;= 1) {<br>      if ((m &amp; mask) != 0) continue;<br>      boolean valid = false;<br>      int m1 = 1;<br>      for (int i = 0; i &lt; n; i++, m1 &lt;&lt;= 1) {<br>        if ((m1 &amp; mask) == 0) continue;<br>        if (adj[i][next]) { valid = true; break; }<br>      }<br>      if (!valid) continue;<br>      <br>      int newMask = m | mask;<br>      double p = 0;<br>      for (int newLeft = 1; newLeft &lt;= left; newLeft++) {<br>        p += go(newMask, newLeft) * winExactly(newLeft, left, units[next]);<br>      }<br>      maxP = Math.max(maxP, p);<br>    }<br>    return prob[mask][left] = maxP;<br>  }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>