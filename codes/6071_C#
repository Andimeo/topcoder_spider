<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br><br>public class CrazySwitches {<br>  const int INFINITY = int.MaxValue;<br><br>  struct State<br>  {<br>    public int room;<br>    public uint lights;<br><br>    public State(int room, uint lights)<br>    {<br>      this.room = room;<br>      this.lights = lights;<br>    }<br>  }<br><br>  public int minimumActions(int[] switches) {<br>    int n = switches.Length;<br>    Queue queue = new Queue();<br>    int[,] d = new int[n, 1 &lt;&lt; n];<br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = 0; j &lt; (1 &lt;&lt; n); ++j)<br>        d[i, j] = INFINITY;<br><br>    State finish = new State(n - 1, (1u &lt;&lt; (n - 1)));<br>    uint[][] triggers = new uint[n][];<br>    for (int i = 0; i &lt; n; ++i)<br>    {<br>      ArrayList l = new ArrayList();<br>      for (int j = 0; j &lt; n; ++j)<br>        if (switches[j] == i &amp;&amp; j != i)<br>          l.Add(j);<br>      triggers[i] = new uint[1 &lt;&lt; l.Count];<br>      for (int j = 0; j &lt; (1 &lt;&lt; l.Count); ++j)<br>      {<br>        for (int k = 0; k &lt; l.Count; ++k)<br>          if ((j &amp; (1 &lt;&lt; k)) &gt; 0)<br>            triggers[i][j] ^= (1u &lt;&lt; (int) l[k]);<br>      }<br>    }<br>    foreach (uint trigger in triggers[0]) <br>    {<br>      State cur = new State(0, 1u ^ trigger);<br>      d[cur.room, cur.lights] = 0;<br>      queue.Enqueue(cur);<br>    }<br><br>    while (queue.Count &gt; 0 &amp;&amp; d[finish.room, finish.lights] == INFINITY)<br>    {<br>      State cur = (State) queue.Dequeue();<br>      int cd = d[cur.room, cur.lights];<br>      for (int i = 0; i &lt; n; ++i)<br>        if ((cur.lights &amp; (1 &lt;&lt; i)) &gt; 0 &amp;&amp; i != cur.room)<br>        {<br>          State next = new State(i, cur.lights);<br>          if (d[next.room, next.lights] &lt; INFINITY)<br>            continue;<br><br>          foreach (uint trigger in triggers[i])<br>          {<br>            next = new State(i, cur.lights ^ trigger);<br>            d[next.room, next.lights] = cd + 1;<br>            queue.Enqueue(next);<br>          }<br>        }<br>    }<br><br>    if (d[finish.room, finish.lights] &lt; INFINITY)<br>      return d[finish.room, finish.lights];<br>    else<br>      return -1;<br>  }<br><br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>