<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class NotchedWoodBarsPuzzle {<br>    int size;<br><br>    bool[,] rotate(bool[,] board) {<br>  bool[,] res = new bool[size, size];<br>  for (int i = 0; i &lt; size; ++i)<br>      for (int j = 0; j &lt; size; ++j)<br>    res[j, size - 1 - i] = board[i, j];<br>  return res;<br>    }<br><br>    bool[,] flip(bool[,] board) {<br>  bool[,] res = new bool[size, size];<br>  for (int i = 0; i &lt; size; ++i)<br>      for (int j = 0; j &lt; size; ++j)<br>    res[i, size - 1 - j] = !board[i, j];<br>  return res;<br>    }<br><br>    bool[,] decode(int board) {<br>  bool[,] res = new bool[size, size];<br>  for (int i = 0; i &lt; size; ++i)<br>      for (int j = 0; j &lt; size; ++j) {<br>    res[i, j] = (board &amp; 1) &gt; 0;<br>    board &gt;&gt;= 1;<br>      }<br>  return res;<br>    }<br><br>    int encode(bool[,] board) {<br>  int res = 0;<br>  for (int i = size - 1; i &gt;= 0; --i)<br>      for (int j = size - 1; j &gt;= 0; --j) {<br>    res = (res &lt;&lt; 1) + (board[i, j] ? 1 : 0);<br>      }<br>  return res;<br>    }<br>    <br>    int getCanonical(int board) {<br>  int res = board;<br>  bool[,] b = decode(board);<br>  for (int i = 0; i &lt; 2; ++i) {<br>      int cur = encode(b);<br>      if (cur &lt; res)<br>    res = cur;<br>      b = rotate(rotate(b));<br>  }<br>  b = rotate(flip(b));<br>  for (int i = 0; i &lt; 2; ++i) {<br>      int cur = encode(b);<br>      if (cur &lt; res)<br>    res = cur;<br>      b = rotate(rotate(b));<br>  }<br>  return res;<br>    }<br><br>    int[] perm;<br>    bool[] used;<br>    string[] bars;<br>    Dictionary&lt;int, object&gt;[] can;<br>    Dictionary&lt;int, object&gt; tmp;<br>    Dictionary&lt;int, object&gt; res;<br><br>    void process(int side) {<br>  bool[,] b = new bool[size, size];<br>  for (int i = 0; i &lt; size; ++i) {<br>      bool rev = (side &amp; (1 &lt;&lt; i)) &gt; 0;<br>      for (int j = 0; j &lt; size; ++j) {<br>    b[i, j] = bars[perm[i]][rev ? size - 1 - j : j] == 'S';<br>      }<br>  }<br>  tmp[encode(b)] = null;<br>    }<br><br>    void sides() {<br>  for (int side = 0; side &lt; (1 &lt;&lt; size); ++side)<br>      process(side);<br>    }<br><br>    void rec(int at) {<br>  if (at &gt;= size) {<br>      sides();<br>      return;<br>  }<br>  for (int i = 0; i &lt; 2 * size; ++i)<br>      if (!used[i]) {<br>    perm[at] = i;<br>    used[i] = true;<br>    rec(at + 1);<br>    used[i] = false;<br>      }<br>    }<br><br>    int countBits(int z) {<br>  int res = 0;<br>  while (z &gt; 0) {<br>      ++res;<br>      z = z &amp; (z - 1);<br>  }<br>  return res;<br>    }<br><br>    Dictionary&lt;int, object&gt; fillCan(int s) {<br>  tmp = new Dictionary&lt;int, object&gt;();<br>  perm = new int[size];<br>  used = new bool[2 * size];<br>  for (int i = 0; i &lt; 2 * size; ++i)<br>      if ((s &amp; (1 &lt;&lt; i)) == 0)<br>    used[i] = true;<br>  rec(0);<br>  return tmp;<br>    }<br><br>    bool[,] transposeInv(bool[,] board) {<br>  bool[,] res = new bool[size, size];<br>  for (int i = 0; i &lt; size; ++i)<br>      for (int j = 0; j &lt; size; ++j)<br>    res[j, i] = !board[i, j];<br>  return res;<br>    }<br><br>    public int countSolutions(string[] bars) {<br>  res = new Dictionary&lt;int, object&gt;();<br>  size = bars.Length / 2;<br>  this.bars = bars;<br>  can = new Dictionary&lt;int, object&gt;[1 &lt;&lt; (2 * size)];<br>  for (int s = 0; s &lt; (1 &lt;&lt; (2 * size)); ++s)<br>      if (countBits(s) == size) {<br>    can[s] = fillCan(s);<br>      }<br>  for (int s = 0; s &lt; (1 &lt;&lt; (2 * size)); ++s)<br>      if (countBits(s) == size) {<br>    int ss = (1 &lt;&lt; (2 * size)) - 1 - s;<br>    if (s &lt;= ss) {<br>        foreach (int a in can[s].Keys) {<br>      int b = encode(transposeInv(decode(a)));<br>      if (can[ss].ContainsKey(b)) {<br>          res[getCanonical(a)] = null;<br>      }<br>        }<br>    }<br>      }<br>  return res.Count;<br>    }<br>}<br><br><br><br>// Powered by FileEdit<br></td>