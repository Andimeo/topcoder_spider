<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br>#define REP(i,n) for(int i=0;i&lt;(n);++i)<br>#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)<br>#define FORD(i,a,b) for(int i=(a);i&gt;=(b);--i)<br>#define VAR(a,b) typeof(b) a=(b)<br>#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)<br>#define ALL(f,w) ({ bool _ok=true; f _ok=_ok &amp;&amp; (w); _ok; })<br>#define EXISTS(f,w) (!(ALL(f,!(w))))<br><br>typedef long long LL; typedef long double ld;<br>typedef vector&lt;int&gt; VI; typedef vector&lt;string&gt; VS;<br>const int INF = 1000000000; const LL INFLL = LL(INF)*LL(INF);<br>template&lt;class T&gt; inline int size(const T&amp;c) { return c.size(); }<br>template&lt;class T&gt; vector&lt;T&gt; makeV(T a) { vector&lt;T&gt; v(1); v[0]=a; return v; }<br>template&lt;class T&gt; vector&lt;T&gt; makeV(T a,T b) { vector&lt;T&gt; v(2);v[0]=a;v[1]=b;return v; }<br>template&lt;class T&gt; vector&lt;T&gt; makeV(T a,T b,T c) {<br>  vector&lt;T&gt; v(3);v[0]=a;v[1]=b;v[2]=c;return v;<br>}<br>int s2i(string s) { istringstream i(s); int x; i&gt;&gt;x; return x; }<br>LL s2ll(string s) { istringstream i(s); LL x; i&gt;&gt;x; return x; }<br>template&lt;class T&gt; string i2s(T x) { ostringstream o; o&lt;&lt;x; return o.str(); }<br>VS split(string s,string del=" ") {<br>  s+=del[0]; string w = ""; VS res;<br>  FOREACH(it,s) {<br>    if(find(del.begin(),del.end(),*it)==del.end()) w+=*it;<br>    else if(w!="") { res.push_back(w); w=""; }<br>  }<br>  return res;<br>}<br>VI s2vi(string s,string del=" ") {<br>  VS v = split(s,del); VI res;<br>  FOREACH(it,v) res.push_back(s2i(*it));<br>  return res;<br>}<br><br>//////////////////////////////////////////////////////////////////////<br><br>int N,N2;<br>int ile[16];<br><br>int reverse(int bar) {<br>  int result = 0;<br>  REP(i,N) if(bar&amp;(1&lt;&lt;i)) result |= 1&lt;&lt;(N-1-i);<br>  return result;<br>}<br><br>int canonical(int bar) {<br>  return min(bar,reverse(bar));<br>}<br><br>int rotate(int board) {<br>  int b = 0;<br>  REP(i,N2) if(board&amp;(1&lt;&lt;i)) b |= 1&lt;&lt;(N2-1-i);<br>  return b;<br>}<br><br>int upsideDown(int board) {<br>  int b =0;<br>  REP(x,N) REP(y,N) if(!(board&amp;(1&lt;&lt;(N*y+x)))) b|= 1&lt;&lt;(N*x+y);<br>  return b;<br>}<br><br>bool canFill(int board) {<br>  static int need[16];<br>  REP(i,16) need[i]=ile[i];<br>  REP(turn,2) {<br>    int board2 = turn==0 ? board : upsideDown(board);<br>    REP(i,N) {<br>      int b = (board2&gt;&gt;(N*i))&amp;((1&lt;&lt;N)-1);<br>      b = canonical(b);<br>      --need[b];<br>      if(need[b]&lt;0) return false;<br>    }<br>  }<br>  return true;<br>}<br><br>bool okBoard(int board) {<br>  int b = rotate(board);<br>  if(b&lt;board) return false;<br>  b = upsideDown(board);<br>  if(b&lt;board) return false;<br>  b = rotate(b);<br>  if(b&lt;board) return false;<br>  return true;<br>}<br><br>struct NotchedWoodBarsPuzzle {<br>  // MAIN<br>  int countSolutions(vector &lt;string&gt; bars) {<br>    N = size(bars)/2;<br>    N2 = N*N;<br>    REP(i,16) ile[i]=0;<br>    REP(i,2*N) {<br>      int b=0; REP(j,N) if(bars[i][j]=='D') b |= 1&lt;&lt;j;<br>      b = canonical(b);<br>      ile[b]++;<br>    }<br>    int result =0;<br>    REP(board,1&lt;&lt;(N2)) {<br>      if(!okBoard(board)) continue;<br>      if(canFill(board)) { ++result; /*cerr&lt;&lt;board &lt;&lt; " ";*/ }<br>    }<br>    return result;<br>  }<br>};<br><br><br><br>// Powered by FileEdit<br></td>