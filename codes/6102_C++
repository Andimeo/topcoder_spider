<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;list&gt;<br>using namespace std;<br><br>// LIB CODE<br>#define SZ(v) ((int)(v).size())<br>#define FOR(i,a,b) for(int i=(a);i&lt;int(b);++i)<br>#define REP(i,n) FOR(i,0,n)<br>typedef pair&lt;int,int&gt; PII;<br>typedef vector&lt;PII&gt; VPII;<br>typedef vector&lt;VPII&gt; VVPII;<br>#define VAR(a,b) __typeof(b) a=b<br>#define FORIT(it,v) for(VAR(it,(v).begin());it!=(v).end();++(it))<br>#define MP make_pair<br>#define PB push_back<br>typedef vector&lt;int&gt; VI;<br>template&lt;class T, class U&gt; T cast (U x) { T y; ostringstream a; a&lt;&lt;x; istringstream b(a.str()); b&gt;&gt;y; return y; }<br>template&lt;class T&gt; vector&lt;T&gt; split(string s, string x=" ") { vector&lt;T&gt; r; REP(i,s.size()) { string c; while(i&lt;(int)s.size()&amp;&amp;x.find(s[i])==string::npos) c+=s[i++]; if(c.size()) r.push_back(cast&lt;T&gt;(c)); } return r; }<br>#define FORE(i,a,b) for(int i=(a);i&lt;=int(b);++i)<br>#define FORD(i,a,b) for(int i=(b)-1;i&gt;=int(a);--i)<br>#define REPD(i,n) FORD(i,0,n)<br>#define REPE(i,n) FORE(i,0,n)<br>// REAL CODE<br><br>int best[1001];<br><br>class JimmyLightning {<br>public:<br>  int robTheBank(vector &lt;int&gt; doors, vector &lt;string&gt; diamonds) {<br>    int n=SZ(doors);<br>    REP(i,n-1) doors[i+1]&lt;?=doors[i];<br><br>    VVPII items(n);<br>    FORIT(i,diamonds) { VI x=split&lt;int&gt;(*i); items[x[2]-1].PB(MP(x[0],x[1])); }<br>    <br>    REP(i,n) FORIT(j,items[i]) printf("%d: %d,%d\n",i,j-&gt;first,j-&gt;second);<br>    <br>    memset(best,0,sizeof(best));<br>    REPD(i,n) FORIT(j,items[i]) FORE(k,j-&gt;second,doors[i]-1) best[k]&gt;?=best[k-j-&gt;second]+j-&gt;first;<br>    int ret=0; REPE(i,doors[0]) ret&gt;?=best[i]; return ret;<br><br>  }<br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>