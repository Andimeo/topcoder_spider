<td class="problemText" colspan="8" valign="middle" align="left">
            // I think it is good to submit wrong solutions sometimes to give others challenging opportunities.<br><br>#include &lt;algorithm&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>#define LS &lt;<br>#define Size(x) (int(x.size()))<br><br>// All macros with parameters "k,a,b" run the "k" variable in range [a,b)<br>#define FOR(k,a,b) for(typeof(a) k=(a); k LS (b); ++k)<br><br>#line 3 "TreeReconstruct.cc"<br><br>int parent[20000];<br><br>int depth[20000];<br><br>bool isNode[20000];<br><br>int treesize = 0;<br><br>int where[60];<br><br>int dist[60][60];<br><br>int dyst(int x, int y) {<br>  int count = 0;<br>  while(1) {<br>    if(x == y) return count;<br>    if(depth[x] &gt; depth[y]) x = parent[x], count++;<br>    else y = parent[y], count++;<br>    }<br>  }<br><br>int nodes;<br><br>class TreeReconstruct {<br>  public:<br>  int reconstruct(vector &lt;string&gt; g1, vector &lt;string&gt; g2) {<br>    // !FDI<br>    char *hex = "0123456789ABCDEF";<br>    int N = Size(g1);<br>    FOR(a,0,N) FOR(b,0,N) dist[a][b] = <br>      (strchr(hex, g1[a][b]) - hex) * 16 + strchr(hex, g2[a][b]) - hex;<br>    treesize = 1; parent[0] = -1; where[0] = 0;<br>    depth[0] = 0;<br>    nodes = 1;<br>    isNode[0] = true;<br>    FOR(k,1,N) {<br>      FOR(d,0,treesize) {<br>        int len = dist[0][k] - depth[d];<br>        if(len &lt; 0) continue;<br>        FOR(t,1,k) if(dyst(d, where[t]) + len != dist[t][k])<br>          goto cont;<br>        <br>        isNode[d] = true;<br>        <br>        FOR(m,0,len) {<br>          parent[treesize] = d;<br>          depth[treesize] = depth[d] + 1;<br>          isNode[treesize] = false;<br>          d = treesize; treesize++;<br>          }<br>        where[k] = d; isNode[d] = true;<br>        goto found;<br>        cont: ;<br>        }<br>      return -1;<br>      found: ;<br>      }<br>    int count = 0;<br>    FOR(t,0,treesize) if(isNode[t]) count++;<br>    return count;<br>    }<br>  };<br><br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>