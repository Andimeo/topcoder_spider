<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class Manhattan {<br>  struct Point<br>  {<br>    public int x;<br>    public int y;<br>    public int index;<br>    <br>    public Point(int x, int y, int index)<br>    {<br>      this.x = x;<br>      this.y = y;<br>      this.index = index;<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      int result = x;<br>      result = 29 * result + y;<br>      result = 29 * result + index;<br>      return result;<br>    }<br><br>    public override bool Equals(object obj)<br>    {<br>      Point point = (Point) obj;<br>      if (x != point.x) return false;<br>      if (y != point.y) return false;<br>      if (index != point.index) return false;<br>      return true;<br>    }<br>  }<br>  <br>  <br>  struct Pair : IComparable&lt;Pair&gt;<br>  {<br>    int a;<br>    int b;<br>    <br>    public Pair(int a, int b)<br>    {<br>      if (a &lt; b)<br>      {<br>        this.a = a;<br>        this.b = b;<br>      }  <br>      else<br>      {<br>        this.b = a;<br>        this.a = b;<br>      }<br>    }<br>    <br>    public int[] GetRes()<br>    {<br>      return new int[]{a, b};<br>    }<br><br>    public int CompareTo(Pair other)<br>    {<br>      if (a != other.a)<br>        return a.CompareTo(other.a);<br>      else<br>        return b.CompareTo(other.b);<br>    }<br>  }<br>  <br>  <br>  class StandardComparer : IComparer&lt;Point&gt;<br>  {<br>    public int Compare(Point x, Point y)<br>    {<br>      if (x.x != y.x)<br>        return x.x.CompareTo(y.x);<br>      else if (x.y != y.y)<br>        return x.y.CompareTo(y.y);<br>      else<br>        return x.index.CompareTo(y.index);<br>    }<br>  }<br><br>  class YComparer : IComparer&lt;Point&gt;<br>  {<br>    public int Compare(Point x, Point y)<br>    {<br>      if (x.y != y.y)<br>        return x.y.CompareTo(y.y);<br>      else<br>        return x.index.CompareTo(y.index);<br>    }<br>  }<br><br>  Point[] pts;<br>  Point[] ypts;<br>  int[] plusTree;<br>  int[] minusTree;<br>  int[] plusTreeIndex;<br>  int[] minusTreeIndex;<br><br>  public int[] furthestPair(int n, int a, int b, int m)<br>  {<br>    {<br>      int x = 0;<br>      int y = 0;<br>      pts = new Point[n];<br>      for (int i = 0; i &lt; n; ++i)<br>      {<br>        if (i &gt; 0)<br>          x = (int)(((long)a * (long) y + b) % m);<br><br>        y = (int)(((long)a * (long) x + b) % m);<br>        pts[i] = new Point(x, y, i);<br>      }<br>    }<br>    <br>    Array.Sort(pts, new StandardComparer());<br>    ypts = (Point[]) pts.Clone();<br>    IComparer&lt;Point&gt; yComparer = new YComparer();<br>    Array.Sort(ypts, yComparer);<br>    plusTree = new int[4 * n];<br>    for (int i = 0; i &lt; plusTree.Length; ++i)<br>      plusTree[i] = int.MaxValue;<br>    minusTree = new int[4 * n];<br>    for (int i = 0; i &lt; minusTree.Length; ++i)<br>      minusTree[i] = int.MaxValue;<br>    plusTreeIndex = new int[4 * n];<br>    for (int i = 0; i &lt; plusTreeIndex.Length; ++i)<br>      plusTreeIndex[i] = int.MaxValue;<br>    minusTreeIndex = new int[4 * n];<br>    for (int i = 0; i &lt; minusTreeIndex.Length; ++i)<br>      minusTreeIndex[i] = int.MaxValue;<br>    <br>    int resDist = -1;<br>    Pair resPair = new Pair(0, 0);<br>    <br>    for (int i = 0; i &lt; n; ++i)<br>    {<br>      Point p = pts[i];<br>      int atY = Array.BinarySearch(ypts, p, yComparer);<br><br>      int val1;<br>      int at1;<br>      findMin(plusTree, plusTreeIndex, 0, 0, n - 1, 0, atY - 1, out val1, out at1);<br>      if (val1 &lt; int.MaxValue)<br>      {<br>        int p1Dist = p.x + p.y - val1;<br>        if (p1Dist &gt; resDist || p1Dist == resDist &amp;&amp; resPair.CompareTo(new Pair(p.index, at1)) &gt; 0)<br>        {<br>          resDist = p1Dist;<br>          resPair = new Pair(p.index, at1);<br>        }<br>      }<br>      findMin(minusTree, minusTreeIndex, 0, 0, n - 1, atY + 1, n - 1, out val1, out at1);<br>      if (val1 &lt; int.MaxValue)<br>      {<br>        int p1Dist = p.x - p.y - val1;<br>        if (p1Dist &gt; resDist || p1Dist == resDist &amp;&amp; resPair.CompareTo(new Pair(p.index, at1)) &gt; 0)<br>        {<br>          resDist = p1Dist;<br>          resPair = new Pair(p.index, at1);<br>        }<br>      }<br>      <br>      update(plusTree, plusTreeIndex, 0, 0, n - 1, atY, p.x + p.y, p.index);<br>      update(minusTree, minusTreeIndex, 0, 0, n - 1, atY, p.x - p.y, p.index);<br>    }<br><br>    return resPair.GetRes();<br>  }<br><br>  private void update(int[] tree, int[] treeIndex, int root, int rl, int rr, int at, int val, int index)<br>  {<br>    if (rl == rr)<br>    {<br>      tree[root] = val;<br>      treeIndex[root] = index;<br>    }<br>    else<br>    {<br>      int rm = (rl + rr) / 2;<br>      if (at &lt;= rm)<br>        update(tree, treeIndex, 2 * root + 1, rl, rm, at, val, index);<br>      else<br>        update(tree, treeIndex, 2 * root + 2, rm + 1, rr, at, val, index);<br>      int leftVal = tree[2 * root + 1];<br>      int leftAt = treeIndex[2 * root + 1];<br>      int rightVal = tree[2 * root + 2];<br>      int rightAt = treeIndex[2 * root + 2];<br>      if (leftVal &lt; rightVal || leftVal == rightVal &amp;&amp; leftAt &lt; rightAt)<br>      {<br>        tree[root] = leftVal;<br>        treeIndex[root] = leftAt;<br>      }<br>      else<br>      {<br>        tree[root] = rightVal;<br>        treeIndex[root] = rightAt;<br>      }<br>    }<br>  }<br><br>  private void findMin(int[] tree, int[] treeIndex, int root, int rl, int rr, int l, int r, out int val, out int at)<br>  {<br>    if (l &gt; r)<br>    {<br>      val = int.MaxValue;<br>      at = int.MaxValue;<br>    } <br>    else<br>    {<br>      if (rl == l &amp;&amp; rr == r)<br>      {<br>        val = tree[root];<br>        at = treeIndex[root];<br>      }<br>      else<br>      {<br>        int rm = (rl + rr) / 2;<br>        int leftVal;<br>        int leftAt;<br>        int rightVal;<br>        int rightAt;<br>        findMin(tree, treeIndex, 2 * root + 1, rl, rm, l, Math.Min(r, rm), out leftVal, out leftAt);<br>        findMin(tree, treeIndex, 2 * root + 2, rm + 1, rr, Math.Max(rm + 1, l), r, out rightVal, out rightAt);<br>        if (leftVal &lt; rightVal || leftVal == rightVal &amp;&amp; leftAt &lt; rightAt)<br>        {<br>          val = leftVal;<br>          at = leftAt;<br>        }<br>        else<br>        {<br>          val = rightVal;<br>          at = rightAt;<br>        }<br>      }<br>    }<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>