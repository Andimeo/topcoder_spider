<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class PhoneNetwork {<br>    class Edge : IComparable&lt;Edge&gt; {<br>  public int a;<br>  public int b;<br>  public double c;<br>  public double q;<br>  public double nq;<br><br>  public int CompareTo(Edge e) {<br>      return -nq.CompareTo(e.nq);<br>  }<br>    }<br><br>    bool enough(double aCost, int np, Edge[] edges) {<br>  int[] comp = new int[np];<br>  for (int i = 0; i &lt; np; ++i)<br>      comp[i] = i;<br>  for (int i = 0; i &lt; edges.Length; ++i) {<br>      edges[i].nq = edges[i].q - edges[i].c * aCost;<br>  }<br>  Array.Sort(edges);<br>  double total = 0;<br>  foreach (Edge e in edges) {<br>      if (comp[e.a] == comp[e.b]) {<br>    if (e.nq &gt; 0)<br>        total += e.nq;<br>    continue;<br>      }<br>      total += e.nq;<br>      int z = comp[e.b];<br>      int zz = comp[e.a];<br>      for (int i = 0; i &lt; np; ++i)<br>    if (comp[i] == z)<br>        comp[i] = zz;<br>  }<br>  return total &gt; 0;<br>    }<br><br>    public double bestQuality(int numPoints, string[] cables) {<br>  Edge[] edges = new Edge[cables.Length];<br>  int np = numPoints;<br>  int[] comp = new int[np];<br>  for (int i = 0; i &lt; np; ++i)<br>      comp[i] = i;<br>  for (int i = 0; i &lt; cables.Length; ++i) {<br>      edges[i] = new Edge();<br>      string[] p = cables[i].Split(' ');<br>      edges[i].a = int.Parse(p[0]) - 1;<br>      edges[i].b = int.Parse(p[1]) - 1;<br>      edges[i].q = int.Parse(p[2]);<br>      edges[i].c = int.Parse(p[3]);<br>      Edge e = edges[i];<br>      int z = comp[e.b];<br>      int zz = comp[e.a];<br>      if (z == zz)<br>    continue;<br>      for (int j = 0; j &lt; np; ++j)<br>    if (comp[j] == z)<br>        comp[j] = zz;<br>  }<br>  for (int i = 1; i &lt; np; ++i)<br>      if (comp[0] != comp[i])<br>    return -1;<br><br>  double left = 0;<br>  double right = 1000000;<br>  while (right - left &gt; 1e-10) {<br>      double middle = (left + right) / 2;<br>      if (enough(middle, numPoints, edges))<br>    left = middle;<br>      else<br>    right = middle;<br>  }<br>  return (left + right) / 2;<br>    }<br>}<br><br><br>// Powered by FileEdit<br></td>