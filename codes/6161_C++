<td class="problemText" colspan="8" valign="middle" align="left">
            // {{{<br>#include &lt;algorithm&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;queue&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;complex&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>using namespace std;<br><br>#define REP(i,n) for (int i=0; i&lt;(n); i++)<br>#define FOR(i,a,b) for (int i=(a); i&lt;=(b); i++)<br>#define FORD(i,b,a) for (int i=(b); i&gt;=(a); i--)<br>#define FOREACH(it,s) for (typeof(s.begin()) it = s.begin() ; it != s.end() ; ++it )<br>#define CLEAR(s) memset(s,0,sizeof(s))<br>#define SIZE(s) ((int)(s.size()))<br><br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;VI&gt; VVI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt;VS&gt; VVS;<br>typedef pair&lt;int,int&gt; PII;<br><br>VS SPLIT(string S, const string delim = " ") {<br>  VS res;<br>  string tmp;<br>  REP(i,SIZE(S)) {<br>    if (delim.find(S[i])==string::npos) {<br>      tmp += S[i];<br>    } else {<br>      if (!tmp.empty()) res.push_back(tmp);<br>      tmp = "";<br>    }<br>  }<br>  if (!tmp.empty()) res.push_back(tmp);<br>  return res;<br>}<br><br>VI SPLITINT(string S, const string delim = " ") {<br>  VS tmp = SPLIT(S,delim);<br>  VI res(tmp.size());<br>  REP(i,SIZE(tmp)) {<br>    stringstream(tmp[i]) &gt;&gt; res[i];<br>  }<br>  return res;<br>}<br><br>template&lt;class T&gt;<br>ostream&amp; operator&lt;&lt; (ostream&amp; oout, const vector&lt;T&gt; &amp;V) {<br>  oout &lt;&lt; "( "; REP(i,SIZE(V)) oout &lt;&lt; V[i] &lt;&lt; ", "; oout &lt;&lt; ")"; return oout;<br>}<br>template&lt;class T&gt;<br>ostream&amp; operator&lt;&lt; (ostream&amp; oout, const set&lt;T&gt; &amp;V) {<br>  oout &lt;&lt; "{ "; FOREACH(it,V) oout &lt;&lt; (*it) &lt;&lt; ", "; oout &lt;&lt; "}"; return oout;<br>}<br>template&lt;class S, class T&gt;<br>ostream&amp; operator&lt;&lt; (ostream&amp; oout, const pair&lt;S,T&gt; &amp;V) {<br>  oout &lt;&lt; "[ " &lt;&lt; V-&gt;first &lt;&lt; ", " &lt;&lt; V-&gt;second &lt;&lt; "]"; return oout;<br>}<br>template&lt;class S, class T&gt;<br>ostream&amp; operator&lt;&lt; (ostream&amp; oout, const map&lt;S,T&gt; &amp;V) {<br>  oout &lt;&lt; "{ "; FOREACH(it,V) oout &lt;&lt; (it-&gt;first) &lt;&lt; "-&gt;" &lt;&lt; (it-&gt;second) &lt;&lt; ", "; oout &lt;&lt; "}"; return oout;<br>}<br>// }}}<br><br>int counts[8];<br>int R=8, C=7;<br><br>int A[12][12];<br><br>int treba[8][8];<br>int dr[] = {-1,1,0,0}; int dc[] = {0,0,-1,1};<br><br>int check() {<br>  FOR(m,0,6) FOR(v,m,6) if (treba[m][v]) {<br>    int ok = 0;<br>    FOR(r,1,R) FOR(c,1,C) if (A[r][c]==m) {<br>      REP(d,4) { int nr=r+dr[d], nc=c+dc[d]; if (A[nr][nc]==v) { ok=1; goto out; }}<br>    }<br>    out:<br>    if (!ok) return 0;<br>  }<br>  return 1;<br>}<br><br>int RESULT;<br><br>void skus(int m, int v) {<br>  if (m==7) RESULT++;<br>  if (m==v) if (!check()) return;<br>  FOR(r,1,R) FOR(c,1,C) if (A[r][c]==m) {<br>    REP(d,4) { <br>      int nr=r+dr[d], nc=c+dc[d]; <br>      if (m==v) if (nr &lt; r) continue;<br>      if (m==v) if (nc &lt; c) continue;<br>      if (A[nr][nc]==v) { <br>        A[r][c] = A[nr][nc] = -1; <br>        treba[m][v] = 0;<br>        int nm=m, nv=v+1; if (nv==7) { nm=m+1; nv=nm; }<br>        skus(nm,nv);<br>        A[r][c] = m; A[nr][nc] = v;<br>        treba[m][v] = 1;<br>      }<br>    }<br>  }<br>}<br><br>class DominoesFinding {<br>public:<br>int getPossibilities(vector &lt;string&gt; board) {<br>  CLEAR(counts);<br>  REP(r,R) REP(c,C) counts[ board[r][c] - '0' ]++;<br>  FOR(i,0,6) if (counts[i]!=8) return 0;<br>  memset(A,-1,sizeof(A));<br>  REP(r,R) REP(c,C) A[r+1][c+1] = board[r][c]-'0';<br><br>  CLEAR(treba);<br>  FOR(i,0,6) FOR(j,i,6) treba[i][j]=1;<br><br>  if (!check()) return 0;<br><br>  RESULT = 0;<br>  skus(0,0);<br>  return RESULT;<br>}<br>};<br><br>// vim: fdm=marker<br><br><br>// Powered by FileEdit<br></td>