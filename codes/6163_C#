<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Text;<br>using System.Text.RegularExpressions;<br>using System.Collections;<br>using System.Collections.Generic;<br><br>public class MixedUpPrimes<br>{<br>    Dictionary&lt;int, bool&gt; pdic = new Dictionary&lt;int, bool&gt;();<br>    List&lt;int&gt;[] dp = new List&lt;int&gt;[128];<br>    int nn;<br>    int n;<br>    int[] values;<br>    bool IsPrime(int x)<br>    {<br>        if (x &lt;= 1) return false;<br>        if (pdic.ContainsKey(x)) return pdic[x];<br>        for (int i = 2; i &lt; (int)(Math.Sqrt(x) + 1); i++)<br>        {<br>            if (x % i == 0)<br>            {<br>                pdic[x] = false;<br>                return false;<br>            }<br>        }<br>        pdic[x] = true;<br>        //if (x &gt; max) max = x;<br>        //if (x &lt; min) min = x;<br>        return true;<br>    }<br>    int max = -1;<br>    int min = int.MaxValue;<br>    List&lt;int&gt; Find(int mask)<br>    {<br><br>        if (dp[mask] != null) return dp[mask];<br>        List&lt;int&gt; rst = new List&lt;int&gt;();<br>        if ((mask &amp; (mask - 1)) == 0)<br>        {<br>            for (int i = 0; i &lt; n; i++)<br>            {<br>                if (mask == 1 &lt;&lt; i)<br>                {<br>                    rst.Add(values[i]);<br>                }<br><br>            }<br>            dp[mask] = rst;<br>            return rst;<br>        }<br>        Dictionary&lt;int, bool&gt; ff = new Dictionary&lt;int, bool&gt;();<br>        for (int i = 1; i &lt; nn - 1; i++)<br>        {<br>            if ((mask | i) == mask &amp;&amp; i != mask)<br>            {<br>                //if ((i ^ mask)!=0 &amp;&amp; (i ^ mask)<br>                List&lt;int&gt; left = Find(i);<br>                List&lt;int&gt; right = Find(i ^ mask);<br>                for (int a = 0; a &lt; left.Count; a++)<br>                {<br>                    for (int b = 0; b &lt; right.Count; b++)<br>                    {<br>                        int x1 = left[a] + right[b];<br>                        int x2 = left[a] - right[b];<br>                        int x3 = left[a] * right[b];<br>                        int x4 = int.MinValue;<br>                        //IsPrime(x1); IsPrime(x2); IsPrime(x3);<br>                        if (!ff.ContainsKey(x1))<br>                        {<br>                            rst.Add(x1);<br>                            ff[x1] = true;<br>                        }<br>                        if (!ff.ContainsKey(x2))<br>                        {<br>                            rst.Add(x2);<br>                            ff[x2] = true;<br>                        }<br>                        if (!ff.ContainsKey(x3))<br>                        {<br>                            rst.Add(x3);<br>                            ff[x3] = true;<br>                        }<br><br>                        //rst.Add(x1); rst.Add(x2); rst.Add(x3);<br>                        if (right[b] != 0)<br>                        {<br>                            x4 = left[a] / right[b];<br>                            if (!ff.ContainsKey(x4))<br>                            {<br>                                rst.Add(x4);<br>                                ff[x4] = true;<br>                            }<br>                            IsPrime(x4);<br>                        }<br>                    }<br>                }<br>            }<br>        }<br>        dp[mask] = rst;<br>        return rst;<br>    }<br>    public int[] findPrimes(int[] values)<br>    {<br>        this.values = values;<br>        n = values.Length;<br>        nn = 1 &lt;&lt; values.Length;<br>        int[] res = new int[2];<br><br>        List&lt;int&gt; dd = Find(nn - 1);<br>        for (int i = 0; i &lt; dd.Count; i++)<br>        {<br>            if (IsPrime(dd[i]))<br>            {<br>                min = Math.Min(min, dd[i]);<br>                max = Math.Max(max, dd[i]);<br>            }<br>        }<br>        res[0] = min;<br>        res[1] = max;<br>        if (max == -1 &amp;&amp; min == int.MaxValue)<br>            res = new int[0];<br>        return res;<br>    }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>