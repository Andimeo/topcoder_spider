<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>typedef vector &lt;int&gt; VI;<br>typedef vector &lt;string&gt; VS;<br><br>#define Sqr(a) ((a)*(a))<br><br>#ifdef _MSC_VER<br>  typedef __int64 LL;<br>#else<br>  typedef long long LL;<br>#endif<br><br><br>#define MAX 200<br>#define INF 1000000000<br>#define Min(a,b) ((a)&lt;(b)?(a):(b))<br><br>class Graph<br>{<br>  int cost[MAX][MAX], f[MAX][MAX], cap[MAX][MAX];<br>  int N;<br><br>  int par[MAX], dist[MAX];<br><br>private:<br>  //returns distance between vertex(prev) and vertex(now) in oriented graph<br>  int getDist(int prev, int now)<br>  {<br>    if ( f[prev][now]==cap[prev][now] ) return INF;<br>    if ( f[now][prev]&gt;0 ) return -cost[now][prev];<br>    return cost[prev][now];<br>  }<br><br>  //update current flow<br>  void Update(int posFlow)<br>  {<br>    int now = N-1;<br>    while ( now!=0 )<br>    {<br>      int prev = par[now];<br><br>      f[prev][now] += posFlow;<br>      f[now][prev] -= posFlow;<br><br>      now = prev;<br>    }<br>  }<br><br>  //check for existence of path with minimum cost and non-zero flow<br>  //posFlow - maximum possible flow of this path<br>  bool ExistsPath(int &amp;posFlow)<br>  {<br>    bool used[MAX];<br>    int i, j, k;<br>    for (i=0;i&lt;N;i++)<br>    {<br>      used[i] = false;<br>      dist[i] = INF;<br>    }<br><br>    dist[0] = 0;<br>    for (k=0;k&lt;N;k++)<br>    {<br>      bool found = false;<br>      for (i=0;i&lt;N;i++)<br>        if ( dist[i]!=INF )<br>        for (j=0;j&lt;N;j++)<br>        {<br>          int tmp = getDist(i, j);<br>          if ( dist[j] &gt; tmp+dist[i] )<br>          {<br>            dist[j] = tmp+dist[i];<br>            par[j] = i;<br>            found = true;<br>          }<br>        }<br><br>      if ( !found ) break;<br>    }<br><br>    if ( dist[N-1]==INF ) return false;<br><br>    posFlow = INF;<br>    int now = N-1;<br>    while ( now!=0 )<br>    {<br>      int prev = par[now];<br>      if ( f[now][prev]&gt;0 ) posFlow = Min(posFlow, f[now][prev]);<br>      else posFlow = Min(posFlow, cap[prev][now]-f[prev][now]);<br><br>      now = prev;<br>    }<br><br>    return true;<br>  }<br><br>  int n, m;<br><br>public:<br>  void Init(VS can, VI cst)<br>  {<br>    m = can.size();<br>    n = can[0].length();<br><br>    N = 2*n+m+2;<br>    //read graph, capacities, costs<br>    int i, j;<br><br>    for (i=0;i&lt;N;i++)<br>      for (j=0;j&lt;N;j++)<br>      {<br>        cap[i][j] = 0;<br>        cost[i][j] = 0;<br>      }<br><br><br>    for (i=1;i&lt;=n;i++)<br>      cap[0][i] = MAX;<br><br>    for (i=1;i&lt;=n;i++)<br>      for (j=n+1;j&lt;=m+n;j++)<br>      {<br>        cap[i][j] = 1;<br>        cost[i][j] = cst[j-n-1]*Sqr(i) - cst[j-n-1]*Sqr(i-1);<br>      }<br><br>    for (i=n+1;i&lt;=m+n;i++)<br>      for (j=n+m+1;j&lt;=2*n+m;j++)<br>        if ( can[i-n-1][j-n-m-1]=='Y' )<br>        {<br>          cap[i][j] = 1;<br>        }<br><br>    for (i=n+m+1;i&lt;=2*n+m;i++)<br>      cap[i][N-1] = 1;<br>  }<br><br>  int MinCostMaxFlow()<br>  {<br>    int i, j;<br>    for (i=0;i&lt;N;i++)<br>      for (j=0;j&lt;N;j++)<br>        f[i][j] = 0;<br><br>    int posFlow;<br>    while ( ExistsPath(posFlow) )<br>      Update(posFlow);<br><br>    int ans = 0, fl = 0;<br>    for (i=0;i&lt;N;i++)<br>    {<br>      fl += f[0][i];<br>      for (j=0;j&lt;N;j++)<br>        if ( f[i][j]&gt;0 )<br>          ans += cost[i][j]*f[i][j];<br>    }<br><br>    if ( fl!=n ) return -1;<br>    return ans;<br>  }<br>};<br><br>class JobPlanner <br>{<br>public:<br>  int minimalCost(vector &lt;string&gt; can, vector &lt;int&gt; cost) <br>  {<br>    Graph g;<br>    g.Init(can, cost);<br>    <br>    return g.MinCostMaxFlow();<br>  }<br><br>  <br> <br>};<br></td>