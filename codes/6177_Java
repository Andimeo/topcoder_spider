<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.math.*;<br>import java.io.*;<br>import java.text.*;<br>import java.util.regex.*;<br>import static java.util.Arrays.*;<br>import static java.lang.Math.*;<br>import static java.lang.Integer.parseInt;<br> <br>class MaxFlow{<br> <br>  /* Constructor for normal flow */<br>  MaxFlow(int[][] cost, int[][] cap){<br>    this.cost = cost;<br>    this.cap = cap;<br>    n = cost.length;<br>    f = new int[n][n];<br>    c = new int[n];<br>    d = new int[n];<br>  }<br>  int n, inf = Integer.MAX_VALUE/2;<br>  int[][] cost, cap, f;<br>  int totcost, totflow;<br>  void go(){<br>    while(findPath()) makePath();<br>  }<br>  void makePath(){<br> <br>    int flow = inf;<br>    int pos = n-1;<br>    while(d[pos] != -1){<br>      flow = min(flow, cap[d[pos]][pos]-f[d[pos]][pos]);<br>      pos = d[pos];<br>    }<br>    pos = n-1;<br>    totflow += flow;<br>    while(d[pos] != -1){<br>      f[d[pos]][pos] += flow;<br>      f[pos][d[pos]] -= flow;<br>      totcost += flow*cost[d[pos]][pos];<br>      pos = d[pos];<br>    }<br>  }<br>  /* Improved Bellman-Ford, homemade, will go into infinite loop<br>   * (instead of giving a useful error message) if a negative cycle is present */<br>  int[] c, d;<br>  boolean findPath(){<br>    fill(c, inf);<br>    fill(d, -1);<br>    c[0] = 0;<br>    boolean[] inq = new boolean[n]; // true for the nodes already enqueued<br>    LinkedList&lt;Integer&gt; que = new LinkedList&lt;Integer&gt;();<br>    que.add(0);<br>    while(que.size() &gt; 0){<br>      int at = que.removeFirst();<br>      inq[at] = false;<br>      for(int i = 0; i &lt; n; i++){<br>        if(cap[at][i]-f[at][i] &lt;= 0)continue;<br>        if(c[at]+cost[at][i] &lt; c[i]){<br>          c[i] = c[at]+cost[at][i];<br>          d[i] = at;<br>          if(!inq[i]){<br>            que.add(i);<br>            inq[i] = true;<br>          }<br>        }<br>      }<br>    }<br>    return c[n-1] != inf;<br>  }<br>}<br>public class JobPlanner {<br>  int N;<br>  int n, m;<br>  public int minimalCost(String[] can, int[] c) {<br>    N = can.length+can[0].length()+2;<br>    n = can[0].length();<br>    m = can.length;<br>    int[][] cost = new int[N][N];<br>    int[][] cap = new int[N][N];<br>    for(int i = 0; i &lt; can.length; i++){<br>      for(int j = 0; j &lt; can[i].length(); j++){<br>        if(can[i].charAt(j) == 'N') continue;<br>        cap[from(i)][to(j)] = 1;<br>      }<br>    }<br>    for(int i = 0; i &lt; n; i++){<br>      cap[to(i)][N-1] = 1;<br>    }<br>    ArrayList&lt;Pair&gt; al = new ArrayList&lt;Pair&gt;();<br>    for(int i = 0; i &lt; c.length; i++){<br>      for(int j = 1; j &lt;= n; j++){<br>        al.add(new Pair(c[i]*(j*j-(j-1)*(j-1)), i));<br>      }<br>    }<br>    MaxFlow mf = new MaxFlow(cost, cap);<br>    Collections.sort(al);<br>    int ret = 0;<br>    int flow = 0;<br>    for(int i = 0; i &lt; al.size(); i++){<br>      int node = al.get(i).y;<br>      cap[0][from(node)]++;<br>      mf.go();<br>      if(mf.totflow &gt; flow){<br>        ret += al.get(i).x;<br>        flow = mf.totflow;<br>        if(flow == n) return ret;<br>      }<br>//      System.out.printf("Tried adding to node %d, flow is now %d%n",al.get(i).y, flow);<br>    }<br>    return -1;<br>  }<br>  int from(int a){<br>    return 1+a;<br>  }<br>  int to(int a){<br>    return 1+m+a;<br>  }<br>  class Pair implements Comparable&lt;Pair&gt;{<br>    int x, y;<br>    public int compareTo(Pair p){<br>      if(x != p.x) return x-p.x;<br>      return y-p.y;<br>    }<br>    Pair(int xx, int yy){x = xx; y = yy;}<br>  }<br> <br>}<br> <br>// Powered by PopsEdit<br>// Powered by CodeProcessor<br></td>