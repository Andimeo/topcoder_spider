<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class IntegerPalindrome {<br>  long[] p10;<br>  public long findByIndex(int K) {<br>    p10 = new long[22];<br>    p10[0] = 1;<br>    for (int i = 1; i &lt; p10.Length; ++i)<br>      p10[i] = p10[i - 1] * 10;<br>    ++K;<br>    long left = 0;<br>    long right = long.MaxValue / 2;<br>    while (right - left &gt; 1)<br>    {<br>      long middle = (left + right) / 2;<br>      if (count(middle) &lt; K)<br>        left = middle;<br>      else<br>        right = middle;<br>    }<br>    return right;<br>  }<br><br>  long count(long bound)<br>  {<br>    long digits = 1;<br>    long res = 0;<br>    while (p10[digits - 1] &lt;= bound)<br>    {<br>      res += count(digits, bound, false);<br>      ++digits;<br>    }<br>    return res;<br>  }<br>  <br>  long count(long digits, long bound, bool canZero)<br>  {<br>    if (bound &lt; 0)<br>      return 0;<br>    if (digits &lt;= 0)<br>      return 1;<br>    if (p10[digits] - 1 &lt;= bound)<br>      if (!canZero)<br>        return 9 * p10[(digits + 1) / 2 - 1];<br>      else<br>        return p10[(digits + 1) / 2];<br>    long sum = 0;<br>    for (int first = 0; first &lt; 10; ++first)<br>    {<br>      if (first == 0 &amp;&amp; !canZero)<br>        continue;<br>      long a = first * p10[digits - 1];<br>      long b = 0;<br>      if (digits &gt; 1)<br>        b = first;<br>      long bb = bound - a - b;<br>      if (bb &lt; 0)<br>        continue;<br>      sum += count(digits - 2, (bound - a - b) / 10, true);<br>    }<br>    return sum;<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>