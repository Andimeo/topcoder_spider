<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;sstream&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;math.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;ctype.h&gt;<br>#define foreach(i,c)for(__typeof((c).end())i=(c).begin();i!=(c).end();++i)<br>using namespace std;<br> <br>int x[64], y[64], n;<br> <br>double _( int i, int j )<br>{<br>  if( !y[i] ) return x[i];<br>  if( !y[j] ) return x[j];<br>  return x[i] + y[i] * ( double )( x[j] - x[i] ) / ( y[i] - y[j] );<br>}<br> <br>struct P<br>{<br>  double x, y;<br>  P() {}<br>  P( double a, double b ) { x = a; y = b; }<br>};<br> <br>#define EPS 1e-9<br>double polarAngle( P p )<br>{<br>    if( fabs( p.x ) &lt;= EPS &amp;&amp; fabs( p.y ) &lt;= EPS ) return -1.0;<br>    if( fabs( p.x ) &lt;= EPS ) return ( p.y &gt; EPS ? 1.0 : 3.0 ) * acos( 0 );<br>    double theta = atan( 1.0 * p.y / p.x );<br>    if( p.x &gt; EPS ) return( p.y &gt;= -EPS ? theta : ( 4 * acos( 0 ) + theta ) );<br>    return( 2 * acos( 0 ) + theta );<br>}<br> <br>int wind( double px, double py )<br>{<br>    double ang = 0.0;<br>    for( int i = n - 1, j = 0; j &lt; n; i = j++ )<br>    {<br>        P v( x[i] - px, y[i] - py );<br>        P w( x[j] - px, y[j] - py );<br>        double va = polarAngle( v );<br>        double wa = polarAngle( w );<br>        double xx = wa - va;<br>        if( va &lt; -0.5 || wa &lt; -0.5 || fabs( fabs( xx ) - 2 * acos( 0 ) ) &lt; EPS )<br>        {<br>      // POINT IS ON THE EDGE<br>      return 0;<br>        }<br>        if( xx &lt; -2 * acos( 0 ) ) ang += xx + 4 * acos( 0 );<br>        else if( xx &gt; 2 * acos( 0 ) ) ang += xx - 4 * acos( 0 );<br>        else ang += xx;<br>    }<br>    return ( int )( ang / acos( -1.0 ) / 2 + 0.5 );<br>}<br> <br>class AllWoundUp {<br>  public:<br>  int maxWind(vector &lt;int&gt; xx, vector &lt;int&gt; yy) {<br>    n = xx.size();<br>    for( int i = 0; i &lt; n; i++ ) { x[i] = xx[i] * 2; y[i] = yy[i] * 2; }<br>    <br>    vector&lt; double &gt; xits;<br>    for( int i = n - 1, j = 0; j &lt; n; i = j++ ) if( y[i] * y[j] &lt;= 0 ) xits.push_back( _( i, j ) );<br>    sort( xits.begin(), xits.end() );<br>    <br>    int best = 0;<br>    for( int i = 1; i &lt; ( int )xits.size(); i++ ) if( xits[i] - xits[i - 1] &gt; 1e-9 )<br>    {<br>      double mid = ( xits[i - 1] + xits[i] ) * 0.5;<br>      best &gt;?= wind( mid, 0 );<br>    }<br>    return best;<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>