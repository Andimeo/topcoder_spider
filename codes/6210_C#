<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class ContextFreeGrammars {<br>  struct StrangeNumber<br>  {<br>    const int LAST = 1000000000;<br>    long value;<br>    <br>    public StrangeNumber(long value)<br>    {<br>      this.value = value;<br>      fixup();<br>    }<br>    <br>    void fixup()<br>    {<br>      if (value &gt; LAST)<br>        value = LAST + 1;<br>    }<br>    <br>    static public StrangeNumber operator+(StrangeNumber a, StrangeNumber b)<br>    {<br>      return new StrangeNumber(a.value + b.value);<br>    }<br>    <br>    static public StrangeNumber operator *(StrangeNumber a, StrangeNumber b)<br>    {<br>      return new StrangeNumber(a.value * b.value);<br>    }<br>    <br>    public int ToInt()<br>    {<br>      if (value &gt; LAST)<br>        return -1;<br>      else<br>        return (int) value;<br>    }<br>  }<br>  <br>  class Rule : IComparable&lt;Rule&gt;<br>  {<br>    public char from;<br>    public string to;<br>    public StrangeNumber[,,] am;<br><br>    public Rule(char from, string to, int len)<br>    {<br>      this.from = from;<br>      this.to = to;<br>      am = new StrangeNumber[to.Length + 1, len, len + 1];<br>      for (int i = 0; i &lt; len; ++i)<br>        am[0, i, 0] = new StrangeNumber(1);<br>    }<br><br>    public int CompareTo(Rule other)<br>    {<br>      return to.Length.CompareTo(other.to.Length);<br>    }<br>  }<br>  <br>  public int countParsingTrees(string[] sRules, char seed, string word) {<br>    List&lt;Rule&gt; rules = new List&lt;Rule&gt;();<br>    foreach (string s in sRules)<br>    {<br>      char from = s[0];<br>      string pp = s.Substring(6) + " | ";<br>      while (pp.IndexOf(" | ") &gt;= 0)<br>      {<br>        rules.Add(new Rule(from, pp.Substring(0, pp.IndexOf(" | ")), word.Length));<br>        pp = pp.Substring(pp.IndexOf(" | ") + 3);<br>      }<br>    }<br>    rules.Sort();<br>    int maxLength = 0;<br>    foreach (Rule rule in rules)<br>      if (rule.to.Length &gt; maxLength)<br>        maxLength = rule.to.Length;<br>    StrangeNumber[,,] nums = new StrangeNumber[26, word.Length, word.Length + 1];<br>    for (int len = 1; len &lt;= word.Length; ++len)<br>      for (int left = 0; left &lt; word.Length - len + 1; ++left)<br>      {<br>        int right = left + len - 1;<br>        for (int at = maxLength - 1; at &gt;= 0; --at)<br>          foreach (Rule rule in rules)<br>          {<br>            if (at &lt; rule.to.Length)<br>            {<br>              char ch = rule.to[at];<br>              if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')<br>              {<br>                if (word[right] == ch)<br>                  rule.am[at + 1, left, len] += rule.am[at, left, len - 1];<br>              }<br>              else<br>              {<br>                for (int cnt = 1; cnt &lt;= len; ++cnt)<br>                  rule.am[at + 1, left, len] += rule.am[at, left, len - cnt] * nums[ch - 'A', left + len - cnt, cnt];<br>              }<br>              if (at == rule.to.Length - 1)<br>                nums[rule.from - 'A', left, len] += rule.am[at + 1, left, len];<br>            }<br>          }<br>      }<br>    return nums[seed - 'A', 0, word.Length].ToInt();<br>  }<br><br><br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>