<td class="problemText" colspan="8" valign="middle" align="left">
            // another fine solution by misof<br>// #includes {{{<br>#include &lt;algorithm&gt;<br>#include &lt;numeric&gt;<br> <br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br> <br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cassert&gt;<br> <br>#include &lt;cmath&gt;<br>#include &lt;complex&gt;<br>using namespace std;<br>// }}}<br> <br>/////////////////// PRE-WRITTEN CODE FOLLOWS, LOOK DOWN FOR THE SOLUTION ////////////////////////////////<br> <br>// pre-written code {{{<br>#define CLEAR(t) memset((t),0,sizeof(t))<br>#define FOR(i,a,b) for(int i=(int)(a);i&lt;=(int)(b);++i)<br>#define REP(i,n) for(int i=0;i&lt;(int)(n);++i)<br>#define SIZE(t) ((int)((t).size()))<br>vector&lt;string&gt; SPLIT( const string&amp; s, const string&amp; delim =" " ) { vector&lt;string&gt; res; string t; for ( unsigned int i = 0 ; i != s.size() ; i++ ) { if ( delim.find( s[i] ) != string::npos ) { if ( !t.empty() ) { res.push_back( t ); t = ""; } } else { t += s[i]; } } if ( !t.empty() ) { res.push_back(t); } return res; }<br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;string&gt; VS;<br>// }}}<br> <br>/////////////////// CODE WRITTEN DURING THE COMPETITION FOLLOWS ////////////////////////////////<br> <br>int rules[100000][4];<br>int RC;<br>int N;<br> <br>long long dasa[52][52][2200];<br> <br>class ContextFreeGrammars {<br>public:<br>  int countParsingTrees(vector &lt;string&gt; _rules, char seed, string word) {<br>    RC=0; N = 52;<br> <br>    vector&lt;int&gt; prePismeno[26];<br>    REP(i,26) prePismeno[i].push_back(i);<br>    <br>    REP(i,SIZE(_rules)) {<br>      VS V = SPLIT(_rules[i]," :=|");<br>      int P = SIZE(V) - 1;<br>      FOR(i,1,P) {<br>        int left = V[0][0] - 'A' + 26;<br>        VI right;<br>        if (V[i].size() == 1) {<br>          prePismeno[ V[i][0]-'a' ].push_back(left);<br>        } else {<br>          REP(j,V[i].size()) {<br>            if (islower(V[i][j])) <br>              right.push_back(V[i][j]-'a');<br>            else <br>              right.push_back(V[i][j]-'A'+26);<br>          }<br>          while (right.size() &gt; 2) {<br>            rules[RC][0] = left;<br>            rules[RC][1] = right[0];<br>            rules[RC][2] = N;<br>            RC++;<br>            left = N;<br>            N++;<br>            right.erase(right.begin());<br>          }<br>          rules[RC][0] = left;<br>          rules[RC][1] = right[0];<br>          rules[RC][2] = right[1];<br>          RC++;<br>        }<br>      }<br>    }<br> <br>    CLEAR(dasa);<br> <br>    int L = SIZE(word);<br> <br>    REP(i,L) {<br>      int x = word[i]-'a';<br>      REP(j,SIZE(prePismeno[x])) dasa[i][i+1][ prePismeno[x][j] ]++;<br>    }<br> <br>    FOR(l,2,L) REP(z,L) {<br>      int k = z+l;<br>      if (k &gt; L) continue;<br>      FOR(l1,1,l-1) {<br>        REP(r,RC) {<br>          dasa[z][k][ rules[r][0] ] += dasa[z][z+l1][ rules[r][1] ] * dasa[z+l1][k][ rules[r][2] ];<br>          dasa[z][k][ rules[r][0] ] &lt;?= 1234567890;<br>        }<br>      }<br>    }<br>    <br>    int res = dasa[0][L][ seed-'A'+26 ];<br>    if (res &gt; 1000000000) res = -1;<br>    return res;<br>  }<br> <br> <br>};<br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>