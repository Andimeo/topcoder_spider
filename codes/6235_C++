<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br>#define REP(i,n) for(int i=0;i&lt;(n);++i)<br>#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)<br>#define FORD(i,a,b) for(int i=(a);i&gt;=(b);--i)<br>#define VAR(a,b) typeof(b) a=(b)<br>#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)<br>#define ALL(f,w) ({ bool _ok=true; f _ok = _ok &amp;&amp; (w); _ok; })<br>#define EXISTS(f,w) (!(ALL(f,!(w))))<br>typedef long long LL; typedef long double ld;<br>typedef vector&lt;int&gt; VI; const int INF = 1000000000;<br>const LL INFLL = LL(INF)*LL(INF); typedef vector&lt;string&gt; VS;<br>template&lt;class T&gt; inline int size(const T&amp;c) { return c.size(); }<br>template&lt;class T&gt; string i2s(T x) { ostringstream o; o&lt;&lt;x; return o.str(); }<br>int s2i(string s) { int x; istringstream i(s); i&gt;&gt;x; return x; }<br>LL s2ll(string s) { LL x; istringstream i(s); i&gt;&gt;x; return x; }<br>template&lt;class T&gt; VI makeV(T x) { VI v(1); v[0]=x; return v; }<br>template&lt;class T&gt; VI makeV(T x, T y) { VI v(2); v[0]=x;v[1]=y; return v; }<br>template&lt;class T&gt; VI makeV(T x,T y,T z) { VI v(2); v[0]=x;v[1]=y;v[2]=z;return v; }<br><br>VS split(string s, string del=" ") {<br>  s += del[0];<br>  VS res; string w;<br>  FOREACH(it,s) {<br>    if(find(del.begin(),del.end(),*it)==del.end()) w += *it;<br>    else if(w!="") { res.push_back(w); w=""; }<br>  }<br>  return res;<br>}<br>VI s2vi(string s, string del=" ") {<br>  VS v = split(s,del);<br>  VI res; FOREACH(it,v) res.push_back(s2i(*it));<br>  return res;<br>}<br><br>//////////////////////////////////////////////////////////////////////<br><br>inline int inbounds(int x) { return x&gt;=1 &amp;&amp; x&lt;=100; }<br><br>typedef vector&lt;pair&lt;char,int&gt; &gt; FF;<br>string text;<br>int poz;<br><br>int parseInt() {<br>  int res =0;<br>  while(isdigit(text[poz])) {<br>    res = 10*res + text[poz]-'0';<br>    ++poz;<br>  }<br>  return res;<br>}<br><br>pair&lt;char,int&gt; term(int dd) {<br>  return make_pair((dd==1?'I':'D'), 0);<br>}<br><br>FF increment(FF v,int dd) {<br>  if(v.empty()) {<br>    v.push_back(term(dd));<br>    return v;<br>  }<br>  pair&lt;char,int&gt; p = v.back(); v.pop_back();<br>  if(p.first=='T' &amp;&amp; inbounds(p.second+dd)) {<br>    v = increment(v,dd);<br>    v.push_back(make_pair('T',p.second+dd));<br>    return v;<br>  } else if(p.first=='D' &amp;&amp; dd==1 || p.first=='I' &amp;&amp; dd==-1) {<br>    return v;<br>  } else {<br>    v.push_back(p);<br>    v.push_back(term(dd));<br>    return v;<br>  }<br>}<br><br>FF parse() {<br>  char c = text[poz++];<br>  if(c=='f') return FF();<br>  else if(c=='T') {<br>    ++poz;<br>    int x = parseInt();<br>    ++poz;<br>    FF v = parse();<br>    ++poz;<br>    v.push_back(make_pair('T',x));<br>    return v;<br>  } else {<br>    ++poz;<br>    FF v = parse();<br>    ++poz;<br>    if(c=='D') return increment(v,-1);<br>    else return increment(v,+1);<br>    return v;<br>  }<br>}<br><br>string print(FF v) {<br>  if(v.empty()) return "f";<br>  pair&lt;char,int&gt; p = v.back(); v.pop_back();<br>  string s = print(v);<br>  if(p.first=='T') {<br>    return string("T(") + i2s(p.second) + "," + s + ")";<br>  } else {<br>    return string() + p.first + "("+s+")";<br>  }<br>}<br><br>struct TaylorAlgebra {<br>  // MAIN<br>  string getCanonical(string formula) {<br>    text = formula; poz=0;<br>    FF a = parse();<br>    return print(a);<br>  }<br>};<br><br><br><br>// Powered by FileEdit<br></td>