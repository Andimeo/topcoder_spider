<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br>public class RestoringPolygon<br>{<br>    bool per(int x11, int x12, int y1, int x2, int y21, int y22)<br>    {<br>        if (x11 &gt; x12)<br>            return per(x12, x11, y1, x2, y21, y22);<br>        else if (y21 &gt; y22)<br>            return per(x11, x12, y1, x2, y22, y21);<br>        else<br>            return (x11 &lt; x2 &amp;&amp; x2 &lt; x12 &amp;&amp; y21 &lt; y1 &amp;&amp; y1 &lt; y22);<br>    }<br> <br>  public int restore(int[] x1, int[] x2, int[] y)<br>  {<br>        int max = 0;<br>        int n = x1.Length;<br>        int[] xp = new int[2 * n];<br>        int[] yp = new int[2 * n];<br>        int[] s = new int[2 * n];<br>        int[] ss = new int[2 * n];<br>        int num;<br>        int nn = 1 &lt;&lt; n;<br>        for (int i = 0; i &lt; nn; i++)<br>        {<br>            num = 0;<br>            int ii = i;<br>            int j;<br>            for (j = 0; j &lt; n; j++)<br>            {<br>                if ((ii &amp; 1) == 1)<br>                {<br>                    s[num] = num + 1;<br>                    s[num + 1] = num;<br> <br>                    xp[num] = x1[j];<br>                    yp[num] = y[j];<br>                    num++;<br> <br>                    xp[num] = x2[j];<br>                    yp[num] = y[j];<br>                    num++;<br>                }<br>                ii &gt;&gt;= 1;<br>            }<br> <br>            int k;<br>            for(k = 0; k &lt; num; k++)<br>                for(j = k + 1; j &lt; num; j++)<br>                    if (xp[k] &gt; xp[j] || xp[k] == xp[j] &amp;&amp; yp[k] &gt; yp[j])<br>                    {<br>                        int t = xp[k];<br>                        xp[k] = xp[j];<br>                        xp[j] = t;<br> <br>                        t = yp[k];<br>                        yp[k] = yp[j];<br>                        yp[j] = t;<br> <br>                        if (s[k] != j)<br>                        {<br>                            t = s[k];<br>                            s[k] = s[j];<br>                            s[j] = t;<br>                            s[s[k]] = k;<br>                            s[s[j]] = j;<br>                        }<br>                    }<br>            bool ok = true;<br>            for (k = 0; k &lt; num; k += 2)<br>            {<br>                if (xp[k] != xp[k + 1])<br>                {<br>                    ok = false;<br>                    break;<br>                }<br>                ss[k] = k + 1;<br>                ss[k + 1] = k;<br>            }<br>            if (ok)<br>            {<br>                j = 0;<br>                for (k = 0; k &lt; num; )<br>                {<br>                    j = ss[s[j]];<br>                    k += 2;<br>                    if (j == 0)<br>                        break;<br>                }<br>                if (k != num)<br>                    ok = false;<br>                else<br>                {<br>                    ii = i;<br>                    for(int q = 0; ok &amp;&amp; q &lt; n; q++)<br>                    {<br>                        if ((ii &amp; 1) == 1)<br>                        {<br>                            for (int w = 0; ok &amp;&amp; w &lt; num; w += 2)<br>                                ok = ok &amp;&amp; !per(x1[q], x2[q], y[q], xp[w], yp[w], yp[w + 1]);<br>                        }<br>                        ii &gt;&gt;= 1;<br>                    }<br>                }<br>            }<br>            if (ok)<br>                max = Math.Max(max, num);<br>        }<br> <br>        return max;<br>  }<br> <br> <br>}<br>//Powered by [KawigiEdit] 2.0!<br></td>