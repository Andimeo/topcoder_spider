<td class="problemText" colspan="8" valign="middle" align="left">
            # include &lt;algorithm&gt;<br># include &lt;bitset&gt;<br># include &lt;cassert&gt;<br># include &lt;cctype&gt;<br># include &lt;cmath&gt;<br># include &lt;complex&gt;<br># include &lt;cstdio&gt;<br># include &lt;cstdlib&gt;<br># include &lt;cstring&gt;<br># include &lt;ctime&gt;<br># include &lt;deque&gt;<br># include &lt;functional&gt;<br># include &lt;iostream&gt;<br># include &lt;iterator&gt;<br># include &lt;list&gt;<br># include &lt;map&gt;<br># include &lt;numeric&gt;<br># include &lt;queue&gt;<br># include &lt;set&gt;<br># include &lt;sstream&gt;<br># include &lt;stack&gt;<br># include &lt;string&gt;<br># include &lt;valarray&gt;<br># include &lt;vector&gt;<br># include &lt;utility&gt;<br><br>using namespace std ;<br><br>// Types<br>typedef long double ld ;<br>typedef long long ll ;<br>typedef pair &lt; int , int &gt; pii ;<br>typedef vector &lt; int &gt; vi ;<br>typedef vector &lt; pii &gt; vp ;<br>typedef vector &lt; ld &gt; vd ;<br>typedef vector &lt; string &gt; vs ;<br>typedef vector &lt; bool &gt; vb ;<br>typedef queue &lt; pii &gt; qp ;<br>typedef map &lt; string , int &gt; msi ;<br><br>// Constants<br>const int INF = 1000000000 ;<br>const ld EPS = 1e-10L ;<br>const ld PI = 3.14159265358979L ;<br><br>class LightSwitches<br>{<br>// Global<br><br>// Functions<br>public :<br>  long long countPossibleConfigurations ( vector &lt;string&gt; s)<br>  {<br>    long long res ;<br>    int n = s.size();<br>    int m = s[0].length();<br>    vector &lt;vi&gt; mat = vector &lt;vi&gt; (n, vi(m));<br>    for (int i = 0; i &lt; n; ++ i)<br>    {<br>      for (int j = 0; j &lt; m; ++ j)<br>      {<br>        if (s[i][j] == 'Y')<br>          mat[i][j] = 1;<br>        else<br>          mat[i][j] = 0;<br>      }<br>    }<br>    int rk = 0;<br>    for (int i = 0; i &lt; m; ++ i)<br>    {<br>      bool bad = true;<br>      for (int j = 0; j &lt; mat.size(); ++ j)<br>      {<br>        if (mat[j][i] == 1)<br>        {<br>          swap(mat[j], mat.back());<br>          bad = false;<br>          break;<br>        }<br>      }<br>      if (bad)<br>        continue;<br>      ++ rk;<br>      for (int j = 0; j &lt; mat.size() - 1; ++ j)<br>      {<br>        if (mat[j][i] == 1)<br>        {<br>          for (int k = i; k &lt; m; ++ k)<br>            mat[j][k] = (mat[j][k] + mat.back()[k]) &amp; 1;<br>        }<br>      }<br>      mat.pop_back();<br>    }<br>    res = 1;<br>    for (int i = 0; i &lt; rk; ++ i)<br>      res *= 2;<br>    return res ;<br>  }<br>  <br><br>} ;<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>