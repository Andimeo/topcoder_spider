<td class="problemText" colspan="8" valign="middle" align="left">
            using System.Collections;<br> <br>public class Cannibals<br>{<br>  struct state<br>  {<br>    public state(int m, int c, bool here)<br>    {<br>      M = m;<br>      C = c;<br>      Here = here;<br>    }<br>    public int M;<br>    public int C;<br>    public bool Here;<br>    public override int GetHashCode()<br>    {<br>      return M+C*100;<br>    }<br>    public override bool Equals(object o)<br>    {<br>      state s = (state)o;<br>      return s.M == M &amp;&amp; s.C == C &amp;&amp; s.Here == Here;<br>    }<br>  }<br>  <br>  public int minCrossings(int M, int C, int R)<br>  {<br>    Hashtable visited = new Hashtable();<br>    Queue q = new Queue();<br>    state s = new state(M,C,true);<br>    visited[s] = null;<br>    q.Enqueue(s);<br>    int count = 1;<br>    while(!BFS(ref q, M, C, R, visited))<br>    {<br>      if(q.Count == 0)<br>      {<br>        return -1;<br>      }<br>      count++;<br>    }<br>    return count;<br>  }<br>  <br>  private bool BFS(ref Queue q, int M, int C, int R, Hashtable visited)<br>  {<br>    Queue q2 = new Queue();<br>    state next;<br>    while(q.Count &gt; 0)<br>    {<br>      state s = (state)q.Dequeue();<br>      int i, j;<br>      if(s.Here)<br>      {<br>        for(i=1;i&lt;=R;i++)<br>        {<br>          for(j=0;j&lt;=i/2;j++)<br>          {<br>            if(s.C-j &gt;= 0 &amp;&amp; C-s.C+j &gt;= 0 &amp;&amp; (s.M-i+j &gt;= s.C-j  || s.M-i+j==0) &amp;&amp; (M-s.M+i-j &gt;= C-s.C+j || M-s.M+i-j==0))<br>            {<br>              if(s.M-i+j == 0 &amp;&amp; s.C-j == 0)<br>              {<br>                return true;<br>              }<br>              next = new state(s.M-i+j,s.C-j,false);<br>              if(!visited.Contains(next)) <br>              {<br>                q2.Enqueue(next);<br>                visited[next] = null;<br>              }<br>            }<br>          }<br>          j = i;<br>            if(s.C-j &gt;= 0 &amp;&amp; C-s.C+j &gt;= 0 &amp;&amp; (s.M-i+j &gt;= s.C-j  || s.M-i+j==0) &amp;&amp; (M-s.M+i-j &gt;= C-s.C+j || M-s.M+i-j==0))<br>            {<br>              if(s.M-i+j == 0 &amp;&amp; s.C-j == 0)<br>              {<br>                return true;<br>              }<br>              next = new state(s.M-i+j,s.C-j,false);<br>              if(!visited.Contains(next)) <br>              {<br>                q2.Enqueue(next);<br>                visited[next] = null;<br>              }<br>            }<br>        }<br>      }<br>      else<br>      {<br>        for(i=1;i&lt;=R;i++)<br>        {<br>          for(j=0;j&lt;=i/2;j++)<br>          {<br>            if(s.C+j &gt;= 0 &amp;&amp; C-s.C-j &gt;= 0 &amp;&amp; (s.M+i-j &gt;= s.C+j  || s.M+i-j==0) &amp;&amp; (M-s.M-i+j &gt;= C-s.C-j || M-s.M-i+j==0))<br>            {<br>              if(s.M+i-j == 0 &amp;&amp; s.C+j == 0)<br>              {<br>                return true;<br>              }<br>              next = new state(s.M+i-j,s.C+j,true);<br>              if(!visited.Contains(next))<br>              {<br>                q2.Enqueue(next);<br>                visited[next] = null;<br>              }<br>            }<br>          }<br>          j=i;<br>            if(s.C+j &gt;= 0 &amp;&amp; C-s.C-j &gt;= 0 &amp;&amp; (s.M+i-j &gt;= s.C+j  || s.M+i-j==0) &amp;&amp; (M-s.M-i+j &gt;= C-s.C-j || M-s.M-i+j==0))<br>            {<br>              if(s.M+i-j == 0 &amp;&amp; s.C+j == 0)<br>              {<br>                return true;<br>              }<br>              next = new state(s.M+i-j,s.C+j,true);<br>              if(!visited.Contains(next))<br>              {<br>                q2.Enqueue(next);<br>                visited[next] = null;<br>              }<br>            }<br>        }<br>      }<br>    }<br>    q = q2;<br>    return false;<br>  }<br>}<br></td>