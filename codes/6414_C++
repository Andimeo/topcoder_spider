<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;complex&gt;<br> <br>using namespace std;<br> <br>typedef pair&lt;int, int&gt; pii;<br>typedef long long ll;<br> <br>template&lt;class T&gt;<br>void splitstr(const string &amp;s, vector&lt;T&gt; &amp;out)<br>{<br>    istringstream in(s);<br>    T tmp;<br> <br>    out.clear();<br>    while (in &gt;&gt; tmp) out.push_back(tmp);<br>}<br> <br>class Monopolies<br>{<br>public:<br>    double probability(int square);<br>};<br> <br>struct state<br>{<br>    int pos;<br>    int dbl;<br>    int moves;<br>};<br> <br>static void to_jail(state &amp;s)<br>{<br>    s.dbl = 0;<br>    s.pos = 40;<br>}<br> <br>static bool advance(state &amp;s, int square, int phase)<br>{<br>    int d1 = phase % 6 + 1;<br>    int d2 = (phase / 6) % 6 + 1;<br>    int c = phase / 36;<br>    int roll = d1 + d2;<br>    int trg;<br>    bool hit = false;<br> <br>    if (s.dbl == 0) s.moves++;<br> <br>    if (d1 == d2) s.dbl++;<br>    else s.dbl = 0;<br>    if (s.dbl == 3)<br>    {<br>        to_jail(s);<br>        return false;<br>    }<br> <br>    s.pos += roll;<br>    if (s.pos &gt; 39)<br>    {<br>        to_jail(s);<br>        return false;<br>    }<br> <br>    if (s.pos == square) hit = true;<br>    switch (s.pos)<br>    {<br>    case 7:<br>    case 22:<br>    case 36:<br>        switch (c)<br>        {<br>        case 0:<br>        case 1:<br>            to_jail(s);<br>            return hit;<br>        case 2: trg = 11; break;<br>        case 3: trg = 24; break;<br>        case 4: trg = 29; break;<br>        case 5: trg = 39; break;<br>        default: trg = s.pos;<br>        }<br>        if (trg &lt; s.pos)<br>        {<br>            to_jail(s);<br>            return hit;<br>        }<br>        s.pos = trg;<br>        break;<br>    case 30:<br>        to_jail(s);<br>        return hit;<br>    }<br>    if (s.pos == square) hit = true;<br>    if (hit) return true;<br>    return false;<br>}<br> <br>double Monopolies::probability(int square)<br>{<br>    double prob[41][3][50] = {{{0.0}}};<br>    double ps[50] = {0.0};<br> <br>    prob[0][0][0] = 1.0;<br>    for (int i = 0; i &lt; 40; i++)<br>        for (int j = 0; j &lt; 3; j++)<br>            for (int k = 0; k &lt; 45; k++)<br>                if (prob[i][j][k])<br>                {<br>                    state cur = { i, j, k };<br>                    double px = prob[i][j][k] / (36 * 20);<br>                    for (int p = 0; p &lt; 36 * 20; p++)<br>                    {<br>                        state nxt = cur;<br>                        if (advance(nxt, square, p))<br>                            ps[nxt.moves] += px;<br>                        else<br>                            prob[nxt.pos][nxt.dbl][nxt.moves] += px;<br>                    }<br>                }<br> <br>    double ans = 0.0;<br>    double notyet = 1.0;<br>    for (int i = 0; i &lt; 45; i++)<br>    {<br>        notyet -= ps[i];<br>        ans += ps[i] * notyet;<br>    }<br>    return ans;<br>}<br> <br> <br>// Powered by FileEdit<br></td>