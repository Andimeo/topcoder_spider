<td class="problemText" colspan="8" valign="middle" align="left">
            // another fine solution by misof<br>// #includes {{{<br>#include &lt;algorithm&gt;<br>#include &lt;numeric&gt;<br> <br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br> <br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cassert&gt;<br> <br>#include &lt;cmath&gt;<br>#include &lt;complex&gt;<br>using namespace std;<br>// }}}<br> <br>/////////////////// PRE-WRITTEN CODE FOLLOWS, LOOK DOWN FOR THE SOLUTION ////////////////////////////////<br> <br>// pre-written code {{{<br>#define REP(i,n) for(int i=0;i&lt;(int)(n);++i)<br>#define SIZE(t) ((int)((t).size()))<br>vector&lt;string&gt; SPLIT( const string&amp; s, const string&amp; delim =" " ) { vector&lt;string&gt; res; string t; for ( unsigned int i = 0 ; i != s.size() ; i++ ) { if ( delim.find( s[i] ) != string::npos ) { if ( !t.empty() ) { res.push_back( t ); t = ""; } } else { t += s[i]; } } if ( !t.empty() ) { res.push_back(t); } return res; }<br>vector&lt;int&gt; SPLITINT( const string&amp; s, const string&amp; delim =" " ) { vector&lt;string&gt; tok = SPLIT( s, delim ); vector&lt;int&gt; res; for ( unsigned int i = 0 ; i != tok.size(); i++ ) res.push_back( atoi( tok[i].c_str() ) ); return res; }<br>typedef vector&lt;int&gt; VI;<br>// }}}<br> <br>/////////////////// CODE WRITTEN DURING THE COMPETITION FOLLOWS ////////////////////////////////<br> <br>vector&lt;long long&gt; offset;<br>vector&lt;long long&gt; period;<br> <br>class TrainRobber {<br>public:<br>  double finalPosition(int length, int nCarriages, vector &lt;string&gt; _offset, vector &lt;string&gt; _period, int trainSpeed, int robberSpeed, int nBridges) {<br>    <br>    offset.clear();<br>    REP(i,SIZE(_offset)) { VI V = SPLITINT(_offset[i]); REP(j,SIZE(V)) offset.push_back(V[j]); }<br> <br>    period.clear();<br>    REP(i,SIZE(_period)) { VI V = SPLITINT(_period[i]); REP(j,SIZE(V)) period.push_back(V[j]); }<br> <br>    int B = SIZE(offset);<br> <br>    long long speed = trainSpeed + robberSpeed;<br> <br>    int passedCarriages = 0;<br> <br>    int passedBridges = 0;<br> <br>    long long x = 0;<br> <br>    while (passedBridges &lt; nBridges) {<br>      long long nextBridge = 987654321987654321LL;<br>      REP(i,B) nextBridge &lt;?= offset[i];<br>      REP(i,B) if (offset[i]==nextBridge) { passedBridges++; offset[i] += period[i]; }<br> <br>      long long distance = nextBridge - x;<br>      <br>      int now = (distance * robberSpeed) / (length * speed);<br>      if (now + passedCarriages &lt; nCarriages) { passedCarriages += now; x = nextBridge; continue; }<br>      return x + (nCarriages-passedCarriages) * speed * double(length) / robberSpeed;<br>    }<br>    return double(x);<br>  }<br> <br> <br>};<br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>