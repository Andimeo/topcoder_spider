<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class CornersGame {<br>  static Queue&lt;State&gt; queue;<br>  static Dictionary&lt;State, int&gt; visited;<br>  static int[] dr = new int[]{-1, 0, 1, 0};<br>  static int[] dc = new int[]{0, -1, 0, 1};<br>  static string[] board;<br>  <br>  struct Position : IComparable&lt;Position&gt;<br>  {<br>    public readonly int row;<br>    public readonly int col;<br><br>    public Position(int row, int col)<br>    {<br>      this.row = row;<br>      this.col = col;<br>    }<br><br>    public int CompareTo(Position other)<br>    {<br>      if (row != other.row)<br>        return row.CompareTo(other.row);<br>      else<br>        return col.CompareTo(other.col);<br>    }<br>    <br>    public bool IsOk()<br>    {<br>      return (row &gt;= 0 &amp;&amp; row &lt; 6 &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; 6);<br>    }<br>  }<br>  <br>  class State<br>  {<br>    Position[] d;<br>    <br>    public State(Position[] p)<br>    {<br>      d = p;<br>      Array.Sort(d);<br>    }<br><br>    public override bool Equals(object obj)<br>    {<br>      State s = (State) obj;<br>      for (int i = 0; i &lt; d.Length; ++i)<br>        if (d[i].CompareTo(s.d[i]) != 0)<br>          return false;<br>      return true;<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      int hash = 0;<br>      for (int i = 0; i &lt; d.Length; ++i)<br>        hash = ((hash * 3137) + d[i].row) * 3137 + d[i].col;<br>      return hash;<br>    }<br><br><br>    public void DoMoves()<br>    {<br>      int clen = visited[this];<br>      for (int who = 0; who &lt; d.Length; ++who)<br>        for (int dir = 0; dir &lt; dr.Length; ++dir)<br>        {<br>          Position newPos = new Position(d[who].row + dr[dir], d[who].col + dc[dir]);<br>          if (!newPos.IsOk())<br>            continue;<br>          bool canJump = false;<br>          switch (board[newPos.row][newPos.col])<br>          {<br>            case 's':<br>              canJump = true;<br>              break;<br>              <br>            case '.':<br>              for (int other = 0; other &lt; d.Length; ++other)<br>                if (newPos.CompareTo(d[other]) == 0)<br>                  canJump = true;<br>              break;<br>              <br>            default:<br>              continue;<br>          }<br>          State next;<br>          if (canJump)<br>          {<br>            newPos = new Position(d[who].row + 2 * dr[dir], d[who].col + 2 * dc[dir]);<br>            if (!newPos.IsOk())<br>              continue;<br>            if (board[newPos.row][newPos.col] != '.')<br>              continue;<br>            for (int other = 0; other &lt; d.Length; ++other)<br>              if (newPos.CompareTo(d[other]) == 0)<br>                canJump = false;<br>            if (!canJump)<br>              continue;<br>          } <br>          Position[] n = (Position[]) d.Clone();<br>          n[who] = newPos;<br>          next = new State(n);<br>          if (visited.ContainsKey(next))<br>            continue;<br>          visited[next] = clen + 1;<br>          queue.Enqueue(next);<br>        }<br>    }<br>  }<br>  <br>  public int countMoves(string[] board) {<br>    CornersGame.board = board;<br>    <br>    Position[] start = new Position[4];<br>    start[0] = new Position(4, 4);<br>    start[1] = new Position(4, 5);<br>    start[2] = new Position(5, 4);<br>    start[3] = new Position(5, 5);<br>    State s = new State(start);<br><br>    Position[] finish = new Position[4];<br>    finish[0] = new Position(0, 0);<br>    finish[1] = new Position(0, 1);<br>    finish[2] = new Position(1, 0);<br>    finish[3] = new Position(1, 1);<br>    State f = new State(finish);<br>    <br>    queue = new Queue&lt;State&gt;();<br>    visited = new Dictionary&lt;State, int&gt;();<br>    queue.Enqueue(s);<br>    visited[s] = 0;<br>    while (queue.Count &gt; 0)<br>    {<br>      queue.Dequeue().DoMoves();<br>    }<br>    if (visited.ContainsKey(f))<br>      return visited[f];<br>    else<br>      return -1;<br>  }<br><br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>