<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;ctime&gt;<br> <br>using namespace std;<br> <br>typedef vector&lt;string&gt; vs;<br> <br>template&lt;class T&gt; int size(const T&amp; c) { return (int)c.size(); }<br> <br>#define For(i, a, b) for (int i = int(a); i &lt;= int(b); ++i)<br>#define Ford(i, a, b) for (int i = int(a); i &gt;= int(b); --i)<br>#define Rep(i, n) for (int i = 0; i &lt; int(n); ++i)<br>#define Repd(i, n) for (int i = int(n)-1; i &gt;= 0; --i)<br>#define Fill(a, c) memset(&amp;a, c, sizeof(a))<br> <br>const int n = 36*36*36*36;<br>vs board;<br>int dist[n];<br>queue&lt;int&gt; que;<br> <br>void relax(int state, int newd) {<br>    if (dist[state] == -1) {<br>        dist[state] = newd;<br>        que.push(state);<br>    }<br>}<br> <br>int getState(const vs&amp; board) {<br>    int k = 0;<br>    int res = 0;<br>    Rep(i, 6) Rep(j, 6) {<br>        if (board[i][j] == 'x')<br>            res = res*36+k;<br>        ++k;<br>    }<br>    return res;<br>}<br> <br>const int di[] = {-1, 1, 0, 0}, dj[] = {0, 0, -1, 1};<br> <br>void work(int state) {<br>    vs field;<br>    field = board;<br>    int t = state;<br>    Rep(k, 4) {<br>        int i = t%36/6;<br>        int j = t%36%6;<br>        field[i][j] = 'x';<br>        t /= 36;<br>    }<br>    Rep(i, 6) Rep(j, 6) <br>        if (field[i][j] == 'x') <br>            Rep(d, 4) {<br>                int i2 = i+di[d], j2 = j+dj[d];<br>                if (i2 &lt; 0 || i2 &gt;= 6 || j2 &lt; 0 || j2 &gt;= 6)<br>                    continue;<br>                if (field[i2][j2] == '.') {<br>                    swap(field[i][j], field[i2][j2]);<br>                    relax(getState(field), dist[state]+1);<br>                    swap(field[i][j], field[i2][j2]);<br>                } else if (field[i2][j2] == 'x' || field[i2][j2] == 's') {<br>                    int i3 = i2+di[d], j3 = j2+dj[d];<br>                    if (0 &lt;= i3 &amp;&amp; i3 &lt; 6 &amp;&amp; 0 &lt;= j3 &amp;&amp; j3 &lt; 6 &amp;&amp; field[i3][j3] == '.') {<br>                        swap(field[i][j], field[i3][j3]);<br>                        relax(getState(field), dist[state]+1);<br>                        swap(field[i][j], field[i3][j3]);<br>                    }<br>                }<br>            }<br>}<br> <br>struct CornersGame {<br> <br>    int countMoves(vs board) {<br>        ::board = board;<br>        Fill(dist, -1);<br>        relax(35+36*(34+36*(29+36*28)), 0);<br>        while (!que.empty()) {<br>            int state = que.front();<br>            que.pop();<br>            work(state);<br>        }<br>        return dist[7+36*(6+36*(1+36*0))];<br>    }<br>};<br></td>