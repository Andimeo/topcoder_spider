<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;ctime&gt;<br>using namespace std;<br><br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br><br>#define For(i, a, b) for (int i = int(a); i &lt;= int(b); ++i)<br>#define Rep(i, n) for (int i = 0; i &lt; int(n); ++i)<br>#define Repd(i, n) for (int i = int(n)-1; i &gt;= 0; --i)<br>#define Fill(a, c) memset(&amp;a, c, sizeof(a))<br>#define All(v) (v).begin(), (v).end()<br>#define Size(v) (int(v.size()))<br><br>int n, m;<br>int a[9][9];<br>int k;<br>vector&lt;vi&gt; states;<br>map&lt;vi,int&gt; state2id;<br>vector&lt;vi&gt; next;<br>int dp1[100000], dp2[100000];<br><br>void rec(vi&amp; cur, int pos, int gr) {<br>    if (pos == m) {<br>        states.push_back(cur);<br>        state2id[cur] = k;<br>        ++k;<br>        return;<br>    }<br>    For(i, -1, gr) {<br>        if (pos &gt; 0 &amp;&amp; cur[pos-1] != -1 &amp;&amp; i != -1 &amp;&amp; i != cur[pos-1])<br>            continue;<br>        cur[pos] = i;<br>        rec(cur, pos+1, max(gr, i+1));<br>    }<br>}<br><br>void findStates() {<br>    vi cur(m);<br>    k = 0;<br>    rec(cur, 0, 0);<br>    states.push_back(states[0]);<br>    ++k;<br>}<br><br>void dfs(int mask, vi&amp; prev, vi&amp; next, int p, int value) {<br>    if (next[p] != -1)<br>        return;<br>    next[p] = value;<br>    if (p &gt; 0 &amp;&amp; (mask&amp;(1&lt;&lt;(p-1))))<br>        dfs(mask, prev, next, p-1, value);<br>    if (mask&amp;(1&lt;&lt;(p+1)))<br>        dfs(mask, prev, next, p+1, value);<br>    if (prev[p] != -1)<br>        Rep(i, m)<br>            if (prev[i] == prev[p] &amp;&amp; (mask&amp;(1&lt;&lt;i)))<br>                dfs(mask, prev, next, i, value);<br>}<br><br>int findNextState(int st, int mask) {<br>    vi color = states[st];<br>    int gr = (*max_element(All(color)))+1;<br>    if (gr == 0) {<br>        assert(st == 0);<br>        vi v(m, -1);<br>        int q = 0;<br>        Rep(i, m)<br>            if (mask&amp;(1&lt;&lt;i))<br>                if (i &gt; 0 &amp;&amp; (mask&amp;(1&lt;&lt;(i-1))))<br>                    v[i] = q-1;<br>                else<br>                    v[i] = q++;<br>        assert(state2id.count(v));<br>        return state2id[v];<br>    } <br>    if (mask == 0) {<br>        if (gr == 1)<br>            return k-1;<br>        else<br>            return -1;<br>    }<br>    Rep(i, gr) {<br>        bool ex = false;<br>        Rep(j, m)<br>            if (color[j] == i &amp;&amp; (mask&amp;(1&lt;&lt;j))) {<br>                ex = true;<br>                break;<br>            }<br>        if (!ex)<br>            return -1;<br>    }<br>    vi v(m, -1);<br>    int q = 0;<br>    Rep(i, m)<br>        if ((mask&amp;(1&lt;&lt;i)) &amp;&amp; v[i] == -1) <br>            dfs(mask, color, v, i, q++);<br>    assert(state2id.count(v));<br>    return state2id[v];<br>}<br><br>struct CheapestIsland {<br><br>    int minCost(vs cells) {<br>        n = Size(cells);<br>        Rep(i, n) {<br>            int k = 0;<br>            Rep(j, Size(cells[i]))<br>                if (cells[i][j] != ' ' &amp;&amp; (j == 0 || cells[i][j-1] == ' ')) {<br>                    sscanf(&amp;cells[i][j], "%d", &amp;a[i][k++]);<br>                }<br>            m = k;<br>        }<br>        findStates();<br>        Rep(i, k) {<br>            vi v(1&lt;&lt;m);<br>            if (i &lt; k-1) {<br>                v.assign(1&lt;&lt;m, -1);<br>                Repd(j, 1&lt;&lt;m)<br>                    v[j] = findNextState(i, j);<br>            } else {<br>                v.assign(1&lt;&lt;m, -1);<br>                v[0] = k-1;<br>            }<br>            next.push_back(v);<br>        }<br>        printf("n = %d m = %d k = %d\n", n, m, k);<br>        const int inf = 100000000;<br>        fill(dp1, dp1+k, inf);<br>        dp1[0] = 0;<br>        For(i, 0, n) {<br>            fill(dp2, dp2+k, inf);<br>            int add[1&lt;&lt;9];<br>            Repd(mask, 1&lt;&lt;m) {<br>                add[mask] = 0;<br>                if (i &lt; n)<br>                    Repd(q, m)<br>                        if (mask&amp;(1&lt;&lt;q))<br>                            add[mask] += a[i][q];<br>            }<br>            Repd(j, k)<br>                if (dp1[j] &lt; inf) <br>                    Repd(mask, 1&lt;&lt;m) {<br>                        int t = next[j][mask];<br>                        if (t == -1)<br>                            continue;<br>                        dp2[t] = min(dp2[t], dp1[j]+add[mask]);<br>                    }<br>            Repd(j, k)<br>                dp1[j] = dp2[j];<br>        }<br>        return min(dp1[k-1], 0);<br>    }<br>};<br></td>