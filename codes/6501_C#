<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br><br>public class AntarcticaPolice {<br>    public double minAverageCost(int[] costs, string[] roads) {<br><br><br>        bool[,] bCanReach = new bool[50, 50];<br>        for (int i = 0; i &lt; roads.Length; i++) {<br>            for (int j = 0; j &lt; roads.Length; j++) {<br>                bCanReach[i, j] = roads[i][j] == 'Y';<br>            }<br>        }<br><br>        for (int k = 0; k &lt; roads.Length; k++) {<br>            for (int i = 0; i &lt; roads.Length; i++) {<br>                for (int j = 0; j &lt; roads.Length; j++) {<br>                    bCanReach[i, j] |= bCanReach[i, k] &amp;&amp; bCanReach[k, j];<br>                }<br>            }<br>        }<br><br>        bool[] bNeed = new bool[50];<br>        bool[] bGot = new bool[50];<br>        for (int i = 0; i &lt; roads.Length; i++) {<br>            if (bCanReach[i, i]) {<br>                int iMin = 99999;<br>                int iIdx = i;<br>                bool[] bPart = new bool[50];<br>                for (int j = 0; j &lt; roads.Length; j++) {<br>                    if (bCanReach[i, j] &amp;&amp; bCanReach[j, i]) {<br>                        bNeed[j] = true;<br>                        bPart[j] = true;<br>                        if (costs[j] &lt; iMin) {<br>                            iMin = costs[j];<br>                            iIdx = j;<br>                        }<br>                    }<br>                }<br><br>                bNeed[iIdx] = false;<br>                for (int j = 0; j &lt; roads.Length; j++) {<br>                    if (j != iIdx &amp;&amp; bPart[j]) {<br>                        for (int k = 0; k &lt; roads.Length; k++) {<br>                            bCanReach[j, k] = false;<br>                            bCanReach[k, j] = false;<br>                        }<br>                    }<br>                }<br>                bCanReach[iIdx, iIdx] = false;<br>            }<br>        }<br><br>        bool[] bNoParent = new bool[50];<br><br>        for (int i = 0; i &lt; roads.Length; i++) {<br>            bNoParent[i] = true;<br>            for (int j = 0; j &lt; roads.Length; j++) {<br>                if (bCanReach[j, i]) bNoParent[i] = false;<br>            }<br>        }<br><br>        int iTot = 0;<br>        int iCount = 0;<br>        for (int i = 0; i &lt; roads.Length; i++) {<br>            if (bNoParent[i] &amp;&amp; !bNeed[i]) {<br>                bGot[i] = true;<br>                iTot += costs[i];<br>                iCount++;<br>            }<br>        }<br><br>        int iLowest = 9999;<br>        int iLowIdx = 0;<br>        for (int i = 0; i &lt; roads.Length; i++) {<br>            iLowest = 9999;<br>            iLowIdx = 0;<br>            for (int j = 0; j &lt; roads.Length; j++) {<br>                if (!bGot[j] &amp;&amp; costs[j] &lt; iLowest) {<br>                    iLowest = costs[j];<br>                    iLowIdx = j;<br>                }<br>            }<br>            if (iLowest * iCount &lt; iTot) {<br>                iTot += costs[iLowIdx];<br>                iCount++;<br>                bGot[iLowIdx] = true;<br>            }<br>        }<br>        return (double)iTot / iCount;<br>    }<br>}<br></td>