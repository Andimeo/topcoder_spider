<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class BoxTower {<br>  const int INF = 1000000000;<br>  <br>  struct State<br>  {<br>    public readonly int tx;<br>    public readonly int ty;<br>    public readonly int mask;<br><br>    public State(int tx, int ty, int mask)<br>    {<br>      this.tx = tx;<br>      this.ty = ty;<br>      this.mask = mask;<br>    }<br><br>    public override bool Equals(object obj)<br>    {<br>      State s = (State) obj;<br>      return tx == s.tx &amp;&amp; ty == s.ty &amp;&amp; mask == s.mask;<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      return (tx * 3137 + ty) * 3137 + mask;<br>    }<br>  }<br>  <br>  readonly static int[][] perm = new int[][]<br>    {<br>      new int[]{0, 1, 2},<br>      new int[]{0, 2, 1},<br>      new int[]{1, 0, 2},<br>      new int[]{1, 2, 0},<br>      new int[]{2, 0, 1},<br>      new int[]{2, 1, 0}};<br>  <br>  public int tallestTower(int[] x, int[] y, int[] z) {<br>    int[][] size = new int[x.Length][];<br>    for (int i = 0; i &lt; x.Length; ++i)<br>    {<br>      size[i] = new int[]{x[i], y[i], z[i]};<br>    }<br>    Queue&lt;State&gt; q = new Queue&lt;State&gt;();<br>    Dictionary&lt;State, int&gt; best = new Dictionary&lt;State, int&gt;();<br>    State start = new State(INF, INF, 0);<br>    q.Enqueue(start);<br>    best[start] = 0;<br>    int res = 0;<br>    while (q.Count &gt; 0)<br>    {<br>      State s = q.Dequeue();<br>      int cmax = best[s];<br>      <br>      for (int i = 0; i &lt; size.Length; ++i)<br>        if ((s.mask &amp; (1 &lt;&lt; i)) == 0)<br>        {<br>          for (int id = 0; id &lt; perm.Length; ++id)<br>          {<br>            int w = size[i][perm[id][0]];<br>            int h = size[i][perm[id][1]];<br>            int t = size[i][perm[id][2]];<br>            if (w &lt;= s.tx &amp;&amp; h &lt;= s.ty)<br>            {<br>              State next = new State(w, h, s.mask | (1 &lt;&lt; i));<br>              int r = cmax + t;<br>              if (r &gt; res)<br>                res = r;<br>              if (best.ContainsKey(next))<br>                best[next] = Math.Max(best[next], r);<br>              else<br>              {<br>                best[next] = r;<br>                q.Enqueue(next);<br>              }<br>            }<br>          }<br>        }<br>    }<br>    return res;<br>  }<br>  <br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>