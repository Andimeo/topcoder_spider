<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br><br>using namespace std;<br><br><br>string A, B, C;<br><br>struct return_type {<br>   string a, b, c;<br>   return_type() { a = b = c = ""; }<br>};<br>bool operator == ( const return_type &amp;X, const return_type &amp;Y ) {<br>   return X.a == Y.a &amp;&amp; X.b == Y.b &amp;&amp; X.c == Y.c;<br>}<br><br>return_type none;<br><br>typedef pair&lt;int,int&gt; par;<br><br>map&lt;par, return_type&gt; memo;<br><br>struct RestoreExpression {<br><br>   return_type rec( int i, int carry ) {<br>      if( i == 0 ) {<br>         if( carry ) return none;<br>         return return_type();<br>      }<br><br>      par p( i, carry );<br>      if( memo.count( p ) ) return memo[p];<br>      return_type &amp;ret = memo[p];<br>      <br>      ret = none;<br><br>      for( int aa = 0; aa &lt; 10; ++aa ) <br>         for( int bb = 0; bb &lt; 10; ++bb ) <br>            for( int cc = 0; cc &lt; 10; ++cc ) {<br><br>               if( i &gt; A.size() ) {<br>                  if( aa &gt; 0 ) continue;<br>               } else {<br>                  int pa = (int)A.size() - i;<br>                  if( pa == 0 &amp;&amp; aa == 0 &amp;&amp; A.size() &gt; 1 ) continue;<br>                  if( A[pa] != '?' &amp;&amp; A[pa] != aa+'0' ) continue;<br>               }<br>               if( i &gt; B.size() ) {<br>                  if( bb &gt; 0 ) continue;<br>               } else {<br>                  int pb = (int)B.size() - i;<br>                  if( pb == 0 &amp;&amp; bb == 0 &amp;&amp; B.size() &gt; 1 ) continue;<br>                  if( B[pb] != '?' &amp;&amp; B[pb] != bb+'0' ) continue;<br>               }<br>               if( i &gt; C.size() ) {<br>                  if( cc &gt; 0 ) continue;<br>               } else {<br>                  int pc = (int)C.size() - i;<br>                  if( pc == 0 &amp;&amp; cc == 0 &amp;&amp; C.size() &gt; 1 ) continue;<br>                  if( C[pc] != '?' &amp;&amp; C[pc] != cc+'0' ) continue;<br>               }<br><br>               for( int borrow = 0; borrow &lt; 2; ++borrow ) {<br>                  if( (aa+bb + borrow)/10 != carry ) continue;<br>                  if( (aa+bb + borrow)%10 != cc ) continue;<br>                  <br>                  return_type t = rec( i-1, borrow );<br>                  if( t == none ) continue;<br>                  t.a = (char)(aa+'0') + t.a;<br>                  t.b = (char)(bb+'0') + t.b;<br>                  t.c = (char)(cc+'0') + t.c;<br><br>                  if( ret == none ) ret = t;<br>                  else if( t.c &gt; ret.c ) ret = t;<br>                  else if( t.c == ret.c &amp;&amp; t.a &gt; ret.a ) ret = t;<br>               }<br>            }<br>      return ret;<br>   }<br><br>   string trim( string s ) {<br>      while( s.size() &gt; 1 &amp;&amp; s[0] == '0' )<br>         s.erase( 0, 1 );<br>      return s;<br>   }<br><br>   string restore( string expression ) {<br>      int f1 = expression.find( "+" );<br>      int f2 = expression.find( "=" );<br>      A = expression.substr( 0, f1 );<br>      B = expression.substr( f1+1, f2-f1-1 );<br>      C = expression.substr( f2+1);<br><br>      none.a = none.b = none.c = "NONE";<br><br>      if( A.size() &gt; C.size() ) return "no solution";<br>      if( B.size() &gt; C.size() ) return "no solution";<br><br>      memo.clear();<br><br>      return_type ret = rec( C.size(), 0 );<br>      if( ret == none ) return "no solution";<br><br>      return trim(ret.a) + "+" + trim(ret.b) + "=" + trim(ret.c);<br>   }<br><br><br><br><br><br><br>   <br> <br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 3.0 beta 7 [modified TZTester]<br>// Powered by CodeProcessor<br></td>