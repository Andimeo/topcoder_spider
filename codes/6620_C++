<td class="problemText" colspan="8" valign="middle" align="left">
            using namespace std;<br><br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;map&gt;<br>#include &lt;queue&gt;<br>#include &lt;functional&gt;<br>#include &lt;set&gt;<br>#include &lt;stack&gt;<br>#include &lt;stdarg.h&gt;<br><br>// LIBRARY START<br>#define fo(ii,ss,ff) for( int ii = ss; ii &lt;= ff; ii++ )<br>#define re(ii,ff) fo(ii,0,ff-1)<br>#define LL long long<br>#define CLR(xx) memset( (xx), 0, sizeof( (xx) ) )<br>template&lt;class T&gt; T gcd( T a, T b ) { return a ? gcd(b % a, a) : b; }  <br>// LIBRARY END<br><br>// HERE IT GOES!<br><br>#define magic 1000000000LL<br><br>LL mine[512][512], T[2][512][512], L[55][512];<br><br>class BackyardTrees<br>{<br>public:<br><br>int countWays(int TC, int W, int H, int D)<br>{<br>  LL how(0);<br>  <br>  if( TC == 1 )<br>      return ( W + 1 ) * ( H + 1 );<br>  <br>  fo( i, 1, 501 ) <br>  fo( j, 1, 501 )<br>  mine[i][j] = gcd(i,j);<br>  <br>  CLR( T ); CLR( L );<br>  <br>  T[1][0][0] = 1;<br>  <br>  L[1][0] = 1;<br>  <br>  fo( k, 2, TC )<br>      fo( i, 1, W + 1 )<br>          fo( j, 0, i )    <br>              if( i - j &gt;= D )<br>              {<br>                    L[k][i] += L[k-1][j]; <br>                  if( L[k][i] &gt;= magic )<br>                      L[k][i] -= magic;<br>                }<br>                <br>    re( i, W + 1 )<br>        re( j, H + 1 )<br>        {<br>            how += ( ( long long)(L[TC][i]) * ( W - i + 1 ) ) % magic; <br>            if( how &gt;= magic )<br>                how -= magic;<br>        }    <br>    <br>    CLR( L );<br>    <br>    L[1][0] = 1;<br>    <br>    fo( k, 2, TC )<br>      fo( i, 1, H + 1 )<br>          fo( j, 0, i )    <br>              if( i - j &gt;= D )<br>              {<br>                    L[k][i] += L[k-1][j]; <br>                  if( L[k][i] &gt;= magic )<br>                        L[k][i] -= magic;<br>                }<br>    re( i, H + 1 )<br>        re( j, W + 1 )<br>        {<br>            how += ( ( long long)(L[TC][i]) * ( H - i + 1 ) ) % magic;  <br>            if( how &gt;= magic )<br>                how -= magic;<br>        }<br>    <br>//    cout &lt;&lt; " how = " &lt;&lt; how &lt;&lt; endl;<br>    <br>    int a, b;    <br>  <br>           <br>  fo( k, 2, TC )<br>  {<br>        CLR( T[k%2] );<br>        <br>      fo( i, 1, W + 1 ) <br>        fo( j, 1, H + 1 ) <br>        {   <br>            a = i / mine[i][j],<br>            b = j / mine[i][j];<br>            <br>            re(h, mine[i][j] )<br>            if( ( i - h * a ) * ( i - h * a ) + ( j - h * b ) * ( j - h * b ) &gt;= D * D )<br>            {<br>                T[ k % 2 ][ i ][ j ] += T[ (k-1) % 2 ][ h * a ][ h * b ];<br>                <br>                if( T[ k % 2 ][ i ][ j ] &gt;= magic )<br>                    T[ k % 2 ][ i ][ j ] -= magic;      <br>            }<br>            <br>        }<br>     <br>    }<br>    <br>    LL ciot;<br>    <br>    fo( i , 1, W + 1 )<br>    fo( j , 1, H + 1 )<br>    {<br>        ciot = (LL)(W+1-i);<br>        ciot *= (H+1-j);<br>        <br>        how += ( T[ TC % 2 ][ i ][ j ] * ciot ) % magic,<br>        how += ( T[ TC % 2 ][ i ][ j ] * ciot ) % magic;<br>    <br>        how %= magic;<br>    }<br>    <br>    how %= magic;<br>    <br>  return how;<br>}<br><br>// HERE IT ENDS!<br><br><br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>