<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class TopologicalEquivalence {<br>  struct Point<br>  {<br>    public int x;<br>    public int y;<br><br>    public Point(int x, int y)<br>    {<br>      this.x = x;<br>      this.y = y;<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      return x + 3137 * y;<br>    }<br><br>    public override bool Equals(object obj)<br>    {<br>      Point point = (Point) obj;<br>      if (x != point.x) return false;<br>      if (y != point.y) return false;<br>      return true;<br>    }<br>  }<br><br>  public int countDistinct(string[] lineSegs) {<br>    Dictionary&lt;Point, Dictionary&lt;Point, int&gt;&gt; graph = new Dictionary&lt;Point, Dictionary&lt;Point, int&gt;&gt;();<br>    <br>    BuildGraph(lineSegs, graph);<br><br>    ReduceGraph(graph);<br><br>    List&lt;int[,]&gt; components = MakeComponents(graph);<br>    List&lt;int[]&gt; perms = new List&lt;int[]&gt;();<br>    <br>    for (int i = 0; i &lt; components.Count; ++i)<br>    {<br>      perms.Add(Normalize(components[i].GetUpperBound(0) + 1, components[i]));<br>    }<br>    <br>    bool[] mark = new bool[components.Count];<br>    int res = 0;<br>    for (int i = 0; i &lt; components.Count; ++i)<br>      if (!mark[i])<br>      {<br>        ++res;<br>        for (int j = i; j &lt; components.Count; ++j)<br>          if (components[i].GetUpperBound(0) + 1 == components[j].GetUpperBound(0) + 1 &amp;&amp; Compare(components[i].GetUpperBound(0) + 1, components[i], components[j], perms[i], perms[j]) == 0)<br>            mark[j] = true;<br>      }<br><br>    return res;<br>  }<br>  <br>  int Compare(int n, int[,] a, int[,] b, int[] pa, int[] pb)<br>  {<br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = 0; j &lt; n; ++j)<br>        if (a[pa[i], pa[j]] != b[pb[i], pb[j]])<br>          return a[pa[i], pa[j]].CompareTo(b[pb[i], pb[j]]);<br>    return 0;<br>  }<br><br>  int[] best;<br>  int[] perm;<br>  bool[] used;<br>  int[,] matr;<br><br>  private int[] Normalize(int n, int[,] matr)<br>  {<br>    this.matr = matr;<br>    best = new int[n];<br>    for (int i = 0; i &lt; n; ++i)<br>      best[i] = i;<br>    perm = new int[n];<br>    used = new bool[n];<br>    rec(0, n);<br>    return best;<br>  }<br><br>  private void rec(int at, int n)<br>  {<br>    if (at == n)<br>    {<br>      if (Compare(n, matr, matr, perm, best) &lt; 0)<br>      {<br>        for (int i = 0; i &lt; n; ++i)<br>          best[i] = perm[i];<br>      }<br>      return;<br>    }<br>    for (int i = 0; i &lt; n; ++i)<br>      if (!used[i])<br>      {<br>        used[i] = true;<br>        perm[at] = i;<br>        rec(at + 1, n);<br>        used[i] = false;<br>      }<br>  }<br><br>  private List&lt;int[,]&gt; MakeComponents(Dictionary&lt;Point, Dictionary&lt;Point, int&gt;&gt; graph)<br>  {<br>    Dictionary&lt;Point, object&gt; visited = new Dictionary&lt;Point, object&gt;();<br>    List&lt;Point&gt; v = new List&lt;Point&gt;();<br>    List&lt;int[,]&gt; res = new List&lt;int[,]&gt;();<br>    <br>    foreach (Point p in graph.Keys)<br>      if (!visited.ContainsKey(p))<br>      {<br>        v.Clear();<br>        Dfs(p, graph, v, visited);<br>        int[,] cur = new int[v.Count, v.Count];<br>        for (int i = 0; i &lt; v.Count; ++i)<br>          for (int j = 0; j &lt; v.Count; ++j)<br>            if (graph[v[i]].ContainsKey(v[j]))<br>              cur[i, j] = graph[v[i]][v[j]];<br>        res.Add(cur);<br>      }<br>    <br>    return res;<br>  }<br><br>  private void Dfs(Point at, Dictionary&lt;Point, Dictionary&lt;Point, int&gt;&gt; graph, List&lt;Point&gt; v, Dictionary&lt;Point, object&gt; visited)<br>  {<br>    if (visited.ContainsKey(at))<br>      return;<br>    <br>    visited[at] = null;<br>    v.Add(at);<br>    foreach (Point p in graph[at].Keys)<br>      Dfs(p, graph, v, visited);<br>  }<br><br>  private void BuildGraph(string[] lineSegs, Dictionary&lt;Point, Dictionary&lt;Point, int&gt;&gt; graph)<br>  {<br>    foreach (string ss in lineSegs)<br>      foreach (string s in ss.Split(' '))<br>      {<br>        int[] coords = Array.ConvertAll&lt;string, int&gt;(s.Split('-', ','), int.Parse);<br>        Point a = new Point(coords[0], coords[1]);<br>        Point b = new Point(coords[2], coords[3]);<br>        if (!graph.ContainsKey(a))<br>        {<br>          graph[a] = new Dictionary&lt;Point, int&gt;();<br>        }<br>        if (!graph[a].ContainsKey(b))<br>          graph[a][b] = 0;<br>        ++graph[a][b];<br>        if (!graph.ContainsKey(b))<br>        {<br>          graph[b] = new Dictionary&lt;Point, int&gt;();<br>        }<br>        if (!graph[b].ContainsKey(a))<br>          graph[b][a] = 0;<br>        ++graph[b][a];<br>      }<br>  }<br><br>  private void ReduceGraph(Dictionary&lt;Point, Dictionary&lt;Point, int&gt;&gt; graph)<br>  {<br>    List&lt;Point&gt; toRemove = new List&lt;Point&gt;();<br>    Point[] adj = new Point[2];<br>    foreach (Point p in graph.Keys)<br>    {<br>      Dictionary&lt;Point, int&gt; edges = graph[p];<br>      if (edges.Count == 2)<br>      {<br>        int cnt = 0;<br>        bool ok = true;<br>        foreach (KeyValuePair&lt;Point, int&gt; pair in edges)<br>        {<br>          adj[cnt++] = pair.Key;<br>          if (pair.Value != 1)<br>            ok = false;<br>        }<br>        if (ok)<br>        {<br>          Point a = adj[0];<br>          Point b = adj[1];<br>          graph[a].Remove(p);<br>          graph[b].Remove(p);<br>          graph[p].Clear();<br>          if (!graph[a].ContainsKey(b))<br>            graph[a][b] = 0;<br>          ++graph[a][b];<br>          if (!graph[b].ContainsKey(a))<br>            graph[b][a] = 0;<br>          ++graph[b][a];<br>          toRemove.Add(p);<br>        }<br>      }<br>    }<br>    foreach (Point p in toRemove)<br>      graph.Remove(p);<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>