<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;complex&gt;<br>#include &lt;stack&gt;<br> <br>using namespace std;<br> <br>typedef pair&lt;int, int&gt; pii;<br>typedef long long ll;<br> <br>template&lt;class T&gt;<br>void splitstr(const string &amp;s, vector&lt;T&gt; &amp;out)<br>{<br>    istringstream in(s);<br>    T tmp;<br> <br>    out.clear();<br>    while (in &gt;&gt; tmp) out.push_back(tmp);<br>}<br> <br>class TopologicalEquivalence<br>{<br>public:<br>    int countDistinct(vector &lt;string&gt; lineSegs);<br>};<br> <br>struct graph<br>{<br>    int V;<br>    bool seen[1000];<br>    vector&lt;int&gt; E[1000];<br> <br>    graph() : V(0) { memset(seen, 0, sizeof(seen)); }<br>};<br> <br>static map&lt;pair&lt;int, int&gt;, int&gt; names;<br>static int namepool;<br>static graph whole;<br> <br>static int getname(int x, int y)<br>{<br>    pii key(x, y);<br>    if (names.count(key)) return names[key];<br>    return names[key] = whole.V++;<br>}<br> <br>static void renumber(graph &amp;g)<br>{<br>    int numbermap[1000];<br>    int rmap[1000];<br>    int n = 0;<br> <br>    for (int i = 0; i &lt; g.V; i++)<br>        if (g.seen[i])<br>        {<br>            numbermap[n] = i;<br>            rmap[i] = n;<br>            n++;<br>        }<br> <br>    g.V = n;<br>    for (int i = 0; i &lt; g.V; i++)<br>    {<br>        g.seen[i] = true;<br>        g.E[i] = g.E[numbermap[i]];<br>        for (size_t j = 0; j &lt; g.E[i].size(); j++)<br>            g.E[i][j] = rmap[g.E[i][j]];<br>    }<br>}<br> <br>static void compress(graph &amp;g)<br>{<br>    bool more = true;<br> <br>    fill(g.seen, g.seen + g.V, true);<br>    while (more)<br>    {<br>        more = false;<br> <br>        for (int i = 0; i &lt; g.V; i++)<br>            if (g.E[i].size() == 2 &amp;&amp; g.E[i][0] != i)<br>            {<br>                int x = g.E[i][0];<br>                int y = g.E[i][1];<br>                replace(g.E[x].begin(), g.E[x].end(), i, y);<br>                replace(g.E[y].begin(), g.E[y].end(), i, x);<br>                more = true;<br>                g.seen[i] = false;<br>                g.E[i].clear();<br>            }<br>    }<br>    renumber(g);<br>}<br> <br>static int cedges(const graph &amp;g)<br>{<br>    int ans = 0;<br>    for (int i = 0; i &lt; g.V; i++)<br>        ans += g.E[i].size();<br>    return ans;<br>}<br> <br>static void tabulate(const graph &amp;g, int (*tbl)[100])<br>{<br>    memset(tbl, 0, 100 * 100 * 4);<br>    for (int i = 0; i &lt; g.V; i++)<br>        for (size_t j = 0; j &lt; g.E[i].size(); j++)<br>            tbl[i][g.E[i][j]]++;<br>}<br> <br>static bool equivalent(const graph &amp;a, const graph &amp;b)<br>{<br>    if (a.V != b.V) return false;<br>    if (cedges(a) != cedges(b)) return false;<br> <br>    int tbla[100][100], tblb[100][100];<br> <br>    int reorder[1000];<br>    for (int i = 0; i &lt; a.V; i++)<br>        reorder[i] = i;<br> <br>    tabulate(a, tbla);<br>    tabulate(b, tblb);<br>    do<br>    {<br>        for (int i = 0; i &lt; a.V; i++)<br>            for (int j = 0; j &lt; a.V; j++)<br>                if (tbla[i][j] != tblb[reorder[i]][reorder[j]]) goto bad;<br>        return true;<br>    bad:;<br>    } while (next_permutation(reorder, reorder + a.V));<br>    return false;<br>}<br> <br>int TopologicalEquivalence::countDistinct(vector &lt;string&gt; lineSegs)<br>{<br>    int S = lineSegs.size();<br>    vector&lt;graph&gt; comps;<br> <br>    names.clear();<br>    namepool = 0;<br>    whole = graph();<br>    for (int i = 0; i &lt; S; i++)<br>    {<br>        int x1, y1, x2, y2, n1, n2;<br>        vector&lt;string&gt; subsegs;<br>        splitstr(lineSegs[i], subsegs);<br> <br>        for (size_t j = 0; j &lt; subsegs.size(); j++)<br>        {<br>            sscanf(subsegs[j].c_str(), " %d,%d-%d,%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br>            n1 = getname(x1, y1);<br>            n2 = getname(x2, y2);<br>            whole.E[n1].push_back(n2);<br>            whole.E[n2].push_back(n1);<br>        }<br>    }<br> <br>    fill(whole.seen, whole.seen + whole.V, false);<br>    for (int i = 0; i &lt; whole.V; i++)<br>        if (!whole.seen[i])<br>        {<br>            graph c = whole;<br>            fill(c.seen, c.seen + whole.V, false);<br>            stack&lt;int&gt; st;<br>            st.push(i);<br>            whole.seen[i] = true;<br>            c.seen[i] = true;<br>            while (!st.empty())<br>            {<br>                int cur = st.top();<br>                st.pop();<br>                for (size_t j = 0; j &lt; whole.E[cur].size(); j++)<br>                {<br>                    int nxt = whole.E[cur][j];<br>                    if (!whole.seen[nxt])<br>                    {<br>                        whole.seen[nxt] = true;<br>                        c.seen[nxt] = true;<br>                        st.push(nxt);<br>                    }<br>                }<br>            }<br>            renumber(c);<br>            compress(c);<br>            renumber(c);<br>            assert(c.V &lt;= 8);<br>            comps.push_back(c);<br>        }<br> <br>    int ans = 0;<br>    for (size_t i = 0; i &lt; comps.size(); i++)<br>    {<br>        for (size_t j = 0; j &lt; i; j++)<br>            if (equivalent(comps[i], comps[j])) goto bad;<br>        ans++;<br>    bad:;<br>    }<br>    return ans;<br>}<br> <br> <br>// Powered by FileEdit<br></td>