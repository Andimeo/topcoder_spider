<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br><br>public class SpiralConstruction <br>{<br>  public struct segment<br>  {<br>    public segment(point p1, point p2)<br>    {<br>      this.p1 = p1;<br>      this.p2 = p2;<br>    }<br>    public point p1;<br>    public point p2;<br>    public bool intersect(segment rhs)<br>    {<br>      double A1 = p2.y - p1.y;<br>      double B1 = p1.x - p2.x;<br>      double C1 = A1 * p1.x + B1 * p1.y;<br><br>      double A2 = rhs.p2.y - rhs.p1.y;<br>      double B2 = rhs.p1.x - rhs.p2.x;<br>      double C2 = A2 * rhs.p1.x + B2 * rhs.p1.y;<br><br>      double det = A1 * B2 - A2 * B1;<br>      if (det == 0) return false;<br>      else<br>      {<br>        double x = (B2 * C1 - B1 * C2) / det;<br>        double y = (A1 * C2 - A2 * C1) / det;<br>        if (Math.Min(p1.x, p2.x) &lt;= x &amp;&amp; x &lt;= Math.Max(p1.x, p2.x) &amp;&amp;<br>          Math.Min(p1.y, p2.y) &lt;= y &amp;&amp; y &lt;= Math.Max(p1.y, p2.y) &amp;&amp;<br>          Math.Min(rhs.p1.x, rhs.p2.x) &lt;= x &amp;&amp; x &lt;= Math.Max(rhs.p1.x, rhs.p2.x) &amp;&amp;<br>          Math.Min(rhs.p1.y, rhs.p2.y) &lt;= y &amp;&amp; y &lt;= Math.Max(rhs.p1.y, rhs.p2.y))<br>        {<br>          return true;<br>        }<br>        return false;<br>      }<br>    }<br><br>    public bool notopp(segment rhs)<br>    {<br>      double A1 = p2.y - p1.y;<br>      double B1 = p1.x - p2.x;<br>      double C1 = A1 * p1.x + B1 * p1.y;<br><br>      double A2 = rhs.p2.y - rhs.p1.y;<br>      double B2 = rhs.p1.x - rhs.p2.x;<br>      double C2 = A2 * rhs.p1.x + B2 * rhs.p1.y;<br><br>      double det = A1 * B2 - A2 * B1;<br>      if (det == 0)<br>      {<br>        //parallel<br>        double vx1 = p1.x - p2.x;<br>        double vx2 = rhs.p2.x - rhs.p1.x;<br>        double vy1 = p1.y - p2.y;<br>        double vy2 = rhs.p2.y - rhs.p1.y;<br>        if (vx1 &gt; 0 &amp;&amp; vx2 &lt; 0 || vx1 &lt; 0 &amp;&amp; vx2 &gt; 0 || vy1 &lt; 0 &amp;&amp; vy2 &gt; 0 || vy1 &gt; 0 &amp;&amp; vy2 &lt; 0)<br>        {<br>          return true;<br>        }<br>        return false;<br><br>      }<br>      return true;<br>    }<br>    <br>    public double cross(segment them)<br>    {<br>      double vx1 = p1.x - p2.x;<br>      double vx2 = them.p2.x - them.p1.x;<br>      double vy1 = p1.y - p2.y;<br>      double vy2 = them.p2.y - them.p1.y;<br>      return vx1 * vy2 - vy1 * vx2;<br>    }<br>    public segment extend()<br>    {<br>      double vx = p2.x - p1.x;<br>      double vy = p2.y - p1.y;<br>      segment ret = new segment();<br>      ret.p1 = this.p1;<br>      ret.p2 = this.p2;<br>      ret.p2.x += vx * 5000;<br>      ret.p2.y += vy * 5000;<br>      return ret;<br>    }<br>  }<br><br>  public struct point<br>  {<br>    public double x, y;<br>  }<br>  point[] points;<br>  public int longestSpiral(string[] p) <br>  {<br>    n = p.Length;<br>    points = new point[p.Length + 1];<br>    for (int i = 0; i &lt; p.Length; i++)<br>    {<br>      string[] pp = p[i].Split(' ');<br>      point point = new point();<br>      point.x = int.Parse(pp[0]);<br>      point.y = int.Parse(pp[1]);<br>      points[i] = point;<br>    }<br>    point zero = new point();<br>    zero.x = 0;<br>    zero.y = 0;<br>    points[p.Length] = zero;<br>    choice[0] = p.Length;<br>    used[p.Length] = true;<br>    max = 1;<br>    go(1);<br>    return max;<br>  }<br>  int n;<br>  int max;<br>  int[] choice = new int[16];<br>  bool[] used= new bool[16];<br>  <br>  void go(int at)<br>  {<br>    bool canBeLast = true;<br>    for (int j = 1; j + 2 &lt; at; j++)<br>    {<br>      segment me = new segment(points[choice[j - 1]], points[choice[j]]);<br>      segment them = new segment(points[choice[at - 2]], points[choice[at - 1]]);<br>      segment ray = them.extend();<br>      if (ray.intersect(me))<br>      {<br>        canBeLast = false;<br>        break;<br>      }<br>    }<br><br>    if(canBeLast)<br>    {<br>      max = Math.Max(max, at - 1);<br>    }<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>      if (!used[i])<br>      {<br>        bool ok = true;<br><br>        // can we use i?<br>        for (int j = 1; j + 1 &lt; at; j++)<br>        {<br>          segment me = new segment(points[choice[j-1]], points[choice[j]]);<br>          segment them = new segment(points[choice[at-1]], points[i]);<br>          if(me.intersect(them))<br>          {<br>            ok = false;<br>            break;<br>          }<br>        }<br><br>        // check the last one.<br><br>        if(at &gt; 1)<br>        {<br>          segment me = new segment(points[choice[at-2]], points[choice[at-1]]);<br>          segment them = new segment(points[choice[at-1]], points[i]);<br>          if(them.cross(me) &gt;= 0 &amp;&amp; them.notopp(me))<br>          {<br><br>          }<br>          else<br>          {<br>            ok = false;<br>          }<br>        }<br><br>        if(ok)<br>        {<br>          used[i] = true;<br>          choice[at] = i;<br><br>          go(at + 1);<br><br>          used[i] = false;<br>        }<br>      }<br>    }<br>  }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>