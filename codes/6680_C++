<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br><br>using namespace std ;<br><br>vector&lt;string&gt; Split(string s , string delimit)<br>{<br>  vector&lt;string&gt; ret ;<br>  int index = s.find( delimit , 0 ) ;<br>  if( index == 0 )<br>    index += delimit.length() ;<br>  else<br>    index = 0 ;<br><br>  while( true )<br>  {<br>    int prevIndex = index ;<br>    index = s.find( delimit , prevIndex ) ;<br>    if( index == string::npos )<br>    {<br>      if( s.length()-prevIndex  &gt; 0 )// count empty string out<br>        ret.push_back( s.substr( prevIndex,s.length()-prevIndex  ) );<br>      break ;<br>    }<br>    if( index-prevIndex &gt; 0 )// count empty string out<br>      ret.push_back( s.substr( prevIndex , index-prevIndex ) );<br>    index += delimit.length() ;<br>  }<br>  return ret ;<br>}<br><br><br>class RGBStreet<br>{ <br>  public: <br>  int estimateCost(vector &lt;string&gt; houses) <br>  { <br>    int rgb[20][3] ;<br>    for( int i=0 ; i&lt;houses.size() ; i++ )<br>    {<br>      vector&lt;string&gt; t = Split(houses[i] ," ") ;<br>      rgb[i][0] = atoi(t[0].c_str()) ;<br>      rgb[i][1] = atoi(t[1].c_str()) ;<br>      rgb[i][2] = atoi(t[2].c_str()) ;<br>    }<br>    int dp[20][3]  = {0} ;<br>    for( int i=0 ; i&lt;3 ; i++ )<br>      dp[0][i] = rgb[0][i] ;<br><br>    for( int i=1 ; i&lt;houses.size() ; i++ )<br>    {<br>      dp[i][0] = min( dp[i-1][1] , dp[i-1][2] ) + rgb[i][0] ;<br>      dp[i][1] = min( dp[i-1][0] , dp[i-1][2] ) + rgb[i][1] ;<br>      dp[i][2] = min( dp[i-1][0] , dp[i-1][1] ) + rgb[i][2] ;      <br>    }<br>    return min(min( dp[houses.size()-1][0], dp[houses.size()-1][1]) , dp[houses.size()-1][2]) ;<br>  } <br>  <br> <br>}; <br><br>//i love you, hs!<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>