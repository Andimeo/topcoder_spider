<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdarg&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;limits&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;numeric&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br><br>using namespace std;<br><br>#define FORI(p, x) for(int i = p; i &lt; (int)(x); ++i)<br>#define FORJ(p, x) for(int j = p; j &lt; (int)(x); ++j)<br>#define FORK(p, x) for(int k = p; k &lt; (int)(x); ++k)<br>#define S size()<br><br>#define VS vector&lt;string&gt;<br><br>struct QueenCovering{<br>  string getPlacement(vector &lt;string&gt; board);<br><br>};<br><br>VS putq(VS vs, int x, int y) {<br>    int dx[] = {1, 1, 1, 0, 0, -1, -1, -1};<br>    int dy[] = {1, 0, -1, 1, -1, 1, 0, -1};<br><br>    vs[x][y] = 'q';<br>    FORK (0, 8) FORI (1, 8) {<br>        int nx = x + dx[k] * i;<br>        int ny = y + dy[k] * i;<br>        if (nx &lt; 0 || nx &gt;= 8 || ny &lt; 0 || ny &gt;= 8) break;<br>        if (vs[nx][ny] == '.') vs[nx][ny] = 'd';<br>    }<br>    return vs;<br>}<br><br>string go(VS vs, int row) {<br>    if (row == 8) {<br>        string res;<br>        FORI (0, 8) FORJ (0, 8) {<br>            if (vs[i][j] == 'q') {<br>                res += '1' + i;<br>                res += 'A' + j;<br>            } else if (vs[i][j] == '.') return "";<br>        }<br>        return res;<br>    }<br>    string best = go(vs, row + 1);<br><br>    FORI (0, 8) if (vs[row][i] == '.') {<br>        VS nvs = putq(vs, row, i);<br>        string cand = go(nvs, row + 1);<br>        if (cand.empty()) continue;<br>        else if (best.empty()) best = cand;<br>        else if (cand.S &lt; best.S) best = cand;<br>        else if (cand.S == best.S &amp;&amp; cand &lt; best) best = cand;<br>    }<br>    return best;<br>}<br><br>string QueenCovering :: getPlacement ( vector &lt;string&gt; board ){<br>    return go(board, 0);<br>}<br>// Powered by Krzysan's Cleaner 1.4-6<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>