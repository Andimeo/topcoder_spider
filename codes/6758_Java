<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class MergingGraph {<br>    public int distanceToCycle(String[] adj) {<br>        int n = adj.length;<br>        boolean[][] a = new boolean[n][n];<br> <br>        for (int i = 0; i &lt; n; i++) {<br>            Scanner in = new Scanner(adj[i]);<br>            while (in.hasNextInt()) {<br>                int j = in.nextInt();<br>                a[i][j] = true;<br>            }<br>        }<br>        return count(a);<br>    }<br> <br>    int gcd(int x, int y) {<br>        while (y != 0) {<br>            int t = y; y = x % y; x = t;<br>        }<br>        return x;<br>    }<br> <br>    int count(boolean[][] a) {<br>        int n = a.length;<br> <br>        boolean hasEdges = false;<br>        for (int i = 0; i &lt; n; i++) {<br>            for (int j = 0; j &lt; n; j++) {<br>                if (a[i][j]) {<br>                    hasEdges = true;<br>                }<br>            }<br>        }<br> <br>        if (!hasEdges) {<br>            return n;<br>        }<br> <br>        boolean[][] e = new boolean[n][n];<br>        for (int i = 0; i &lt; n; i++) {<br>            for (int j = 0; j &lt; n; j++) {<br>                for (int k = 0; k &lt; n; k++) {<br>                    if (a[i][j] &amp;&amp; a[i][k]) {<br>                        e[j][k] = true;<br>                    }<br>                    if (a[j][i] &amp;&amp; a[k][i]) {<br>                        e[j][k] = true;<br>                    }<br>                }<br>            }<br>        }<br> <br>        for (int i = 0; i &lt; n; i++) {<br>            for (int j = 0; j &lt; n; j++) {<br>                for (int k = 0; k &lt; n; k++) {<br>                    if (e[j][i] &amp;&amp; e[i][k]) {<br>                        e[j][k] = true;<br>                    }<br>                }<br>            }<br>        }<br> <br>        int[] col = new int[n];<br>        int cn = 1;<br>        for (int i = 1; i &lt; n; i++) {<br>            int c = -1;<br>            for (int j = 0; j &lt; i; j++) {<br>                if (e[j][i]) {<br>                    c = col[j];<br>                    break;<br>                }<br>            }<br>            if (c == -1) {<br>                col[i] = cn;<br>                cn++;<br>            } else {<br>                col[i] = c;<br>            }<br>        }<br> <br>        boolean[][] b = new boolean[cn][cn];<br>        for (int i = 0; i &lt; n; i++) {<br>            for (int j = 0; j &lt; n; j++) {<br>                if (a[i][j]) {<br>                    b[col[i]][col[j]] = true;<br>                }<br>            }<br>        }<br> <br>        int[] od = new int[cn];<br>        int[] id = new int[cn];<br>        int[] next = new int[cn];<br>        int[] prev = new int[cn];<br>        Arrays.fill(next, -1);<br>        Arrays.fill(prev, -1);<br>        for (int i = 0; i &lt; cn; i++) {<br>            for (int j = 0; j &lt; cn; j++) {<br>                if (b[i][j]) {<br>                    od[i]++;<br>                    id[j]++;<br>                    next[i] = j;<br>                    prev[j] = i;<br>                }<br>            }<br>        }<br> <br>        boolean ok = true;<br>        for (int i = 0; i &lt; cn; i++) {<br>            if (id[i] &gt; 1 || od[i] &gt; 1) {<br>                ok = false;<br>                break;<br>            }<br>        }<br> <br>        if (!ok) {<br>            return n - cn + count(b);<br>        }<br> <br>        boolean[] u = new boolean[n];<br> <br>        int ans = 0;<br>        int mp = 0;<br>        for (int i = 0; i &lt; cn; i++) {<br>            if (!u[i]) {<br>                int p = i;<br>                int k = 0;<br>                while (p != -1 &amp;&amp; !u[p]) {<br>                    u[p] = true;<br>                    k++;<br>                    p = next[p];<br>                }<br>                if (p != -1) {<br>                    ans = gcd(ans, k);<br>                } else {<br>                    p = i;<br>                    while (p != -1) {<br>                        u[p] = true;<br>                        k++;<br>                        p = prev[p];<br>                    }<br>                    mp += k - 2;<br>                }<br>            }<br>        }<br> <br>        if (ans == 0) {<br>            return n - mp;<br>        } else {<br>            return n - ans;<br>        }<br>    }<br> <br>}<br> <br> <br>// Powered by PopsEdit<br> <br>// Powered by CodeProcessor<br></td>