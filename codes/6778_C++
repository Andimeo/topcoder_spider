<td class="problemText" colspan="8" valign="middle" align="left">
            // Hello, Spectators! :D <br>#include&lt;cstdio&gt;<br>#include&lt;cstring&gt;<br>#include&lt;string&gt;<br>#include&lt;vector&gt;<br>#include&lt;queue&gt;<br>#include&lt;map&gt;<br>#include&lt;set&gt;<br>#include&lt;iostream&gt;<br>#include&lt;sstream&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;numeric&gt;<br>#include&lt;cassert&gt;<br>#include&lt;cstdlib&gt;<br>using namespace std;<br><br>#define FOR(i,a,b) for(int i = (a); i &lt; (b); ++i)<br>#define REP(i,n) FOR(i,0,n)<br>#define FORE(it,a) for( typeof( (a).begin() ) it = (a).begin(); it != (a).end() ; ++it )<br>#define all(x) (x).begin(),(x).end()<br>#define CLEAR(x,with) memset(x,with,sizeof(x))<br>#define pb push_back<br>#define sz size()<br><br>typedef long long ll;<br><br>struct Frac<br>{<br>  ll up, down;<br>  Frac(ll _up, ll _down = 1) : up(_up), down(_down) <br>  {<br>    ll g = __gcd(abs(up), abs(down));<br>    up /= g; down /= g;<br>    if(down &lt; 0) { up = -up; down = -down; }<br>    if(up == 0) down = 1;<br>  }<br>  int sigNum() const { if(up == 0) return 0; if(up &gt; 0) return 1; return -1; }<br>  double toDouble() const { return double(up) / double(down) ; }<br>  string toString() const { char buf[64]; sprintf(buf, "%Ld/%Ld", up, down); return buf; }<br>};<br>Frac operator + (const Frac&amp; a, const Frac&amp; b) { return Frac(a.up * b.down + b.up * a.down, a.down * b.down); }<br>Frac operator - (const Frac&amp; a, const Frac&amp; b) { return Frac(a.up * b.down - b.up * a.down, a.down * b.down); }<br>Frac operator * (const Frac&amp; a, const Frac&amp; b) { return Frac(a.up * b.up, a.down * b.down); }<br>Frac operator / (const Frac&amp; a, const Frac&amp; b) { return Frac(a.up * b.down, a.down * b.up); }<br><br>struct CauchyProduct <br>{<br>  vector &lt;string&gt; findInverse(vector &lt;int&gt; start, vector &lt;int&gt; repeat, int n) <br>  {<br>    vector&lt;Frac&gt; A, B;<br>    REP(i,start.sz) A.pb(Frac(start[i]));<br>    {<br>      int i = 0;<br>      while(A.sz &lt; n) { A.pb(Frac(repeat[i])); i = (i+1) % repeat.sz; }  <br>    }<br>    B.pb(Frac(1, start[0]));<br>    FOR(i,1,n)<br>    {<br>      Frac a(0);<br>      REP(j,i) a = a - (B[j]*A[i-j]);<br>      B.pb( a / A[0] );<br>    }<br>    vector&lt;string&gt; ret;<br>    REP(i,n) ret.pb(B[i].toString());<br>    return ret;    <br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>