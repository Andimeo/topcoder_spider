<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br> <br>using namespace std;<br><br>struct rec<br>{<br>  int x,t;<br>};<br><br>char d[510000][4];<br><br>class RubeGoldberg<br>{<br>public:<br>int howClose(vector &lt;string&gt; parts, string last, int target)<br>{<br>  string s;<br>  vector&lt;rec&gt; a[4];<br>  rec q;<br>  int i,j,k,n,p,ll,best,max,x,y;<br>  switch (last[0])<br>  {<br>  case 'C':<br>    ll=0;<br>    break;<br>  case 'E':<br>    ll=1;<br>    break;<br>  case 'M':<br>    ll=2;<br>    break;<br>  case 'T':<br>    ll=3;<br>    break;<br>  }<br>  n=parts.size();<br>  a[0].clear();<br>  a[1].clear();<br>  a[2].clear();<br>  a[3].clear();<br>  for (i=0;i&lt;n;i++)<br>  {<br>    s=parts[i];<br>    switch (s[0])<br>    {<br>    case 'C':<br>      x=0;<br>      break;<br>    case 'E':<br>      x=1;<br>      break;<br>    case 'M':<br>      x=2;<br>      break;<br>    case 'T':<br>      x=3;<br>      break;<br>    }<br>    p=s.find_first_of(' ');<br>    s.erase(0,p+1);<br>    switch (s[0])<br>    {<br>    case 'C':<br>      y=0;<br>      break;<br>    case 'E':<br>      y=1;<br>      break;<br>    case 'M':<br>      y=2;<br>      break;<br>    case 'T':<br>      y=3;<br>      break;<br>    }<br>    p=s.find_first_of(' ');<br>    s.erase(0,p+1);<br>    q.x=y;<br>    q.t=atoi(s.c_str());<br>    a[x].push_back(q);<br>  }<br>  memset(d,0,sizeof(d));<br>  for (i=0;i&lt;4;i++)<br>    d[0][i]=1;<br>  max=target*2;<br>  for (i=0;i&lt;max;i++)<br>    for (j=0;j&lt;4;j++)<br>      if (d[i][j]==1)<br>      {<br>        for (k=0;k&lt;a[j].size();k++)<br>          if (i+a[j][k].t&lt;=max)<br>            d[i+a[j][k].t][a[j][k].x]=1;<br>      }<br>  best=target;<br>  for (i=0;i&lt;=max;i++)<br>    if ((d[i][ll]==1)&amp;&amp;(abs(target-i)&lt;best)) best=abs(target-i);<br>  return best;<br>}<br>};<br></td>