<td class="problemText" colspan="8" valign="middle" align="left">
            #define LS &lt;<br>#include &lt;math.h&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;stdio.h&gt;<br>using namespace std;<br>#include &lt;algorithm&gt;<br>typedef long long ll;<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>#define LET(x,v) typeof(v) x = v<br>#define Size(s) (int((s).size()))<br>#define EXISTS(k,a,b,cond) (FIRST(k,a,b,cond) != (b))<br>#define FORALL(k,a,b,cond) (FIRST(k,a,b,!(cond)) == (b))<br>#define FOR(k,a,b) for(typeof(a) k = (a); k LS (b); k++)<br>#define CLCR(act, val) (*({act; static typeof(val) v__ = val; &amp;v__;}))<br>#define FIRST(k,a,b,cond) CLCR(LET(k,a); for(; k LS (b); k++) if(cond) break, k)<br>#define MAX(k,a,b,val) CLCR(LET(k,a); LET(max##k, val); for(k++; k LS (b); k++) max##k &gt;?= val, max##k)<br>#define SUM(k,a,b,val) CLCR(LET(k,a); LET(sum##k, (typeof(val))(0)); for(; k LS (b); k++) sum##k += val, sum##k)<br><br>vs parsevs(string s) {<br>  s += " ";<br>  vs res;<br>  string cur = "";<br>  FOR(k,0,Size(s)) {<br>    if(s[k] == ' ') {res.push_back(cur); cur = "";}<br>    else cur += s[k];<br>    }<br>  return res;<br>  }<br><br>vi parsevi(string s) {<br>  s += " ";<br>  vi res;<br>  int cur = 0;<br>  FOR(k,0,Size(s)) {<br>    if(s[k] == ' ') {res.push_back(cur); cur = 0;}<br>    else { cur *= 10; cur += s[k] - '0'; }<br>    }<br>  return res;<br>  }<br><br>#define INF 5000<br><br>typedef long double ld;<br><br>long double best;<br><br>long double angle[60];<br><br>int N;<br><br>#define CC (2*M_PI)<br><br>ld arcsin(ld val) {<br>  return atan(val / sqrt(1-val*val));<br>  }<br><br>#define eps 0.000001<br><br>void addit(int n, ld k, ld sum) {<br>  sum += k;<br>  if(sum &gt; CC) sum -= CC; <br>  if(n == N) {<br>    best &lt;?= sum;<br>    best &lt;?= (CC-sum);<br>    }<br>  if(angle[n] + k &lt; CC - eps) addit(n+1, angle[n], sum);<br>  if(CC - angle[n] + k &lt; CC - eps) addit(n+1, CC - angle[n], sum);<br>  }<br><br>class CCWTurning {<br>  public:<br>  double minDistance(int radius, vector &lt;int&gt; segLength) {<br>    N = Size(segLength);<br>    FOR(k,0,N) if(segLength[k] &gt; 2 * radius) return -1;<br>    FOR(k,0,N) {<br>      if(segLength[k] == 2* radius) angle[k] = M_PI;<br>      else angle[k] = arcsin((segLength[k] / 2.0) / radius) * 2;<br>      }<br>    <br>    best = INF * 2;<br>    addit(0, 0, 0);<br>    if(best &gt; INF) return -1;<br>    return sqrt(sin(best) * sin(best) + (1-cos(best)) * (1-cos(best))) * radius;<br>    }<br>  };<br><br>// Powered by FileEdit<br></td>