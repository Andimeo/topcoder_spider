<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string.h&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;math.h&gt;<br><br>using namespace std;<br><br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;VI&gt; VII;<br>typedef vector&lt;string&gt; VS;<br><br>VS split(string str, string sep)<br>{<br>  int last = -1;<br>  VS res;<br>  for(int i=0;i&lt;=str.length();i++)<br>    {<br>      if(i == str.length() || sep.find(str[i]) != string::npos)<br>  {<br>    if(i-last &gt; 1)<br>      {<br>        res.push_back(str.substr(last+1,i-last-1));<br>      }<br>    last = i;<br>  }<br>    }<br>  return res;<br>}<br><br>struct Mov<br>{<br>  double d[3];<br>  int rotmat[3][3];<br><br>  void add(Mov m)<br>  {<br>    for(int i=0;i&lt;3;i++)<br>      for(int j=0;j&lt;3;j++)<br>      {<br>  d[i] += rotmat[i][j] * m.d[j];<br>      }<br><br>    int rm2[3][3];<br>    memcpy(rm2, rotmat, sizeof(rotmat));<br>    for(int i=0;i&lt;3;i++)<br>      for(int j=0;j&lt;3;j++)<br>  {<br>    rotmat[i][j]  =0;<br>    for(int k=0;k&lt;3;k++)<br>      rotmat[i][j] += rm2[i][k] * m.rotmat[k][j];<br>  }<br>  }<br>};<br><br>int leftmat[3][3] = {<br>  {  0,1,0 },<br>  {-1,0,0},<br>   {0,0,1}<br>};<br>int rightmat[3][3] = {<br>  {0,-1,0},<br>  {1,0,0},<br>  {0,0,1}<br>};<br>int upmat[3][3] = {<br>  {0,0,1},<br>   {0,1,0},<br>    {-1,0,0}<br>   };<br>int downmat[3][3] = {<br>  {0,0,-1},<br>   {0,1,0},<br>    {1,0,0}<br>};<br><br>string comms;<br><br>Mov getComm()<br>{<br>  Mov curMov;<br>  curMov.d[0] = curMov.d[1] = curMov.d[2] = 0;<br>  memset(curMov.rotmat, 0, sizeof(curMov.rotmat));<br>  curMov.rotmat[0][0] =<br>    curMov.rotmat[1][1] =   curMov.rotmat[2][2] = 1;<br>  if(comms[0] ==')')<br>    {<br>      comms = comms.substr(1,1000);<br>      while(comms[0] != '(')<br>  {<br>    Mov m = getComm();<br>    curMov.add(m);<br>  }<br>      comms = comms.substr(1,1000);<br>    }<br>  else<br>    if(comms[0] == 'F')<br>      {<br>  curMov.d[0] = 1;<br>  comms = comms.substr(1,1000);  <br>      }<br>    else<br>      if(comms[0] &gt;= '1' &amp;&amp; comms[0] &lt;= '9')<br>  {<br>    int n = comms[0] - '0';<br>    comms = comms.substr(1,1000);<br>    Mov m = getComm();<br>    for(int i=0;i&lt;n;i++)<br>      curMov.add(m);<br>  }<br>      else<br>  {<br>    char c = comms[0];<br>    comms = comms.substr(1,1000);    <br>    switch(c)<br>      {<br>      case 'L':memcpy(curMov.rotmat, leftmat, sizeof(leftmat));<br>        break;<br>      case 'R':memcpy(curMov.rotmat, rightmat, sizeof(leftmat));<br>        break;<br>        <br>      case 'U':memcpy(curMov.rotmat, upmat, sizeof(leftmat));<br>        break;<br>      case 'D':memcpy(curMov.rotmat, downmat, sizeof(leftmat));<br>        break;<br>        <br>      }<br>  }<br>  return curMov;<br>}<br><br><br>class TurtleGraphics {<br>  public:<br>  double distance(string command) {<br>    double x = 0, y = 0;<br>    int N = command.size();<br><br>    VI repeat;<br><br>    for(int i=N-1;i&gt;=0;i--)<br>      {<br>        comms += command[i];<br>      }<br><br>  Mov curMov;<br>  curMov.d[0] = curMov.d[1] = curMov.d[2] = 0;<br>  memset(curMov.rotmat, 0, sizeof(curMov.rotmat));<br>  curMov.rotmat[0][0] =<br>    curMov.rotmat[1][1] =   curMov.rotmat[2][2] = 1;    <br>    while(comms.size() != 0)<br>      {<br>        curMov.add(getComm());<br>      }<br><br>    return sqrt(curMov.d[0] * curMov.d[0] +<br>          curMov.d[1] * curMov.d[1] +<br>          curMov.d[2] * curMov.d[2] );<br>  }<br>};<br><br><br><br><br>// Powered by FileEdit<br></td>