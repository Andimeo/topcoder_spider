<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class PaperRacing {<br>  struct Point<br>  {<br>    public int row;<br>    public int col;<br><br>    public Point(int row, int col)<br>    {<br>      this.row = row;<br>      this.col = col;<br>    }<br>  }<br>  <br>  struct Position<br>  {<br>    public int row;<br>    public int col;<br>    public int dRow;<br>    public int dCol;<br><br>    public Position(int row, int col, int dRow, int dCol)<br>    {<br>      this.row = row;<br>      this.col = col;<br>      this.dRow = dRow;<br>      this.dCol = dCol;<br>    }<br>  }<br><br>  bool[,,,] got;<br>  List&lt;Position&gt; queue;<br>  Point finish;<br>  bool[,] f;<br>  int height;<br>  int width;<br>  <br>  public int minMoves(string[] track, int vRow, int vCol) {<br>    height = track.Length;<br>    width = track[0].Length;<br>    f = new bool[height, width];<br>    Point start = new Point(0, 0);<br>    finish = new Point(0, 0);<br>    for (int row = 0; row &lt; height; ++row)<br>      for (int col = 0; col &lt; width; ++col)<br>      {<br>        f[row, col] = track[row][col] == 'X';<br>        if (track[row][col] == 'S')<br>          start = new Point(row, col);<br>        if (track[row][col] == 'F')<br>          finish = new Point(row, col);<br>      }<br>    got = new bool[height, width, 103, 103];<br>    queue = new List&lt;Position&gt;();<br>    reach(new Position(start.row, start.col, vRow, vCol));<br>    int dist = 0;<br>    while (queue.Count &gt; 0)<br>    {<br>      List&lt;Position&gt; oldQueue = queue;<br>      queue = new List&lt;Position&gt;();<br>      ++dist;<br>      foreach (Position old in oldQueue)<br>      {<br>        for (int ndRow = old.dRow - 1; ndRow &lt;= old.dRow + 1; ++ndRow)<br>          for (int ndCol = old.dCol - 1; ndCol &lt;= old.dCol + 1; ++ndCol)<br>          {<br>            if (doMove(old.row, old.col, ndRow, ndCol))<br>              return dist;<br>          }<br>      }<br>    }<br>    return -1;<br>  }<br><br>  private bool doMove(int row, int col, int dRow, int dCol)<br>  {<br>    int dr = Math.Sign(dRow);<br>    int dc = Math.Sign(dCol);<br>    int nRow = row + dRow;<br>    int nCol = col + dCol;<br>    int a = -dCol;<br>    int b = dRow;<br>    int c = -(a * (row * 2 + 1) + b * (col * 2 + 1));<br>    int sr = Math.Sign(a * (row * 2 + 1 + dr) + b * (col * 2 + 1) + c);<br>    int sc = Math.Sign(a * (row * 2 + 1) + b * (col * 2 + 1 + dc) + c);<br>    while (true)<br>    {<br>      if (row &lt; 0 || row &gt;= height || col &lt; 0 || col &gt;= width || f[row, col])<br>        return false;<br>      if (row == nRow &amp;&amp; col == nCol)<br>        break;<br>      if (dr == 0)<br>      {<br>        col += dc;<br>        if (row == finish.row &amp;&amp; col == finish.col)<br>          return true;<br>      } <br>      else if (dc == 0)<br>      {<br>        row += dr;<br>        if (row == finish.row &amp;&amp; col == finish.col)<br>          return true;<br>      } <br>      else<br>      {<br>        int s = Math.Sign(a * (row * 2 + 1 + dr) + b * (col * 2 + 1 + dc) + c);<br>        if (s == sr)<br>        {<br>          col += dc;<br>          if (row == finish.row &amp;&amp; col == finish.col)<br>            return true;<br>        } <br>        else if (s == sc)<br>        {<br>          row += dr;<br>          if (row == finish.row &amp;&amp; col == finish.col)<br>            return true;<br>        } <br>        else<br>        {<br>          if (row + dr == finish.row &amp;&amp; col == finish.col)<br>            return true;<br>          if (row == finish.row &amp;&amp; col + dc == finish.col)<br>            return true;<br>          row += dr;<br>          col += dc;<br>          if (row == finish.row &amp;&amp; col == finish.col)<br>            return true;<br>        }<br>      }<br>    }<br>    reach(new Position(nRow, nCol, dRow, dCol));<br>    return false;<br>  }<br><br>  private void reach(Position position)<br>  {<br>    if (!got[position.row, position.col, position.dRow + 51, position.dCol + 51])<br>    {<br>      got[position.row, position.col, position.dRow + 51, position.dCol + 51] = true;<br>      queue.Add(position);<br>    }<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>