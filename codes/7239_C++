<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#include&lt;ctype.h&gt;<br>#include&lt;string.h&gt;<br>#include&lt;math.h&gt;<br><br>#include&lt;queue&gt;<br>#include&lt;iostream&gt;<br>#include&lt;sstream&gt;<br>#include&lt;vector&gt;<br>#include&lt;string&gt;<br>#include&lt;set&gt;<br>#include&lt;map&gt;<br>#include&lt;list&gt;<br>#include&lt;utility&gt;<br>#include&lt;algorithm&gt;<br>using namespace std; <br>#define INF 1000000000<br><br>bool isok( int n, vector &lt;int&gt; &amp;p, vector &lt;int&gt; &amp;d, vector &lt;int&gt; &amp;c, vector&lt; vector&lt; pair&lt;int, int&gt; &gt; &gt; &amp;child, int k, int M )<br>{<br>  vector&lt;int&gt; dres( n, 0 );<br>  vector&lt;int&gt; remain( n, M );<br>  vector&lt;int&gt; nearest( n, INF );<br>  queue&lt;int&gt; wl;<br>  for( int i = 0; i &lt; n; i ++ ){<br>    dres[i] = child[i].size();<br>    if( dres[i] == 0 )<br>      wl.push( i );<br>    if( c[i] )<br>      nearest[i] = 0;<br>  }<br><br>  int nc = 0;<br>  while( !wl.empty() ){<br>    int i = wl.front();<br>    wl.pop();<br><br>    if( remain[i] &gt;= nearest[i] )<br>      ; // OK<br>    else if( d[i] &lt;= remain[i] ){<br>      // let's go parent<br>      remain[p[i]] = min( remain[p[i]], remain[i] - d[i] );<br>    }<br>    else{<br>      nc ++;<br>      nearest[i] = 0;<br>    }<br>    if( nearest[i] &lt; INF )<br>      nearest[p[i]] = min( nearest[p[i]], nearest[i] + d[i] );<br><br>    if( -- dres[p[i]] &lt;= 0 )<br>      wl.push( p[i] );<br>  }<br><br>  // circles<br>  for( int i = 0; i &lt; n; i ++ ){<br>    if( dres[i] &gt; 0 ){<br>      vector&lt; int &gt; D, N, R;<br>      D.push_back( d[i] );<br>      N.push_back( nearest[i] );<br>      R.push_back( remain[i] );<br>      dres[i] = 0;<br>      cerr &lt;&lt; i &lt;&lt; ", " &lt;&lt; d[i] &lt;&lt; "/"&lt;&lt; nearest[i]  &lt;&lt; "/"&lt;&lt;remain[i] &lt;&lt; endl;<br>      for( int j = p[i]; j != i; j = p[j] ){<br>        D.push_back( d[j] );<br>        N.push_back( nearest[j] );<br>        R.push_back( remain[j] );<br>        cerr &lt;&lt; j &lt;&lt; ", " &lt;&lt; d[j] &lt;&lt; "/"&lt;&lt; nearest[j]  &lt;&lt; "/"&lt;&lt;remain[j] &lt;&lt; endl;<br>        dres[j] = 0;<br>      }<br>      int m = D.size();<br>      vector&lt; int &gt; OK( m, 0 );<br>      for( int s = 0; s &lt; m; s ++ ){<br>        for( int t = 0, dt = 0; t &lt; m; dt += D[(s+t)%m], t ++ ){<br>          int tt = (s+t)%m;<br>          cerr &lt;&lt; s &lt;&lt; t &lt;&lt; tt &lt;&lt; N[s] &lt;&lt; R[s] &lt;&lt; endl;<br>          if( N[s] + dt &lt;= R[tt] )<br>            OK[tt] = 1;<br>          if( N[tt] + dt &lt;= R[s] )<br>            OK[s] = 1;<br>        }<br>      }<br>      int allOK = 1;<br>      for( int s = 0; s &lt; m; s ++ ){<br>        cerr &lt;&lt; OK[s] &lt;&lt; endl;<br>        if( !OK[s] ){<br>          allOK = 0;<br>        }<br>      }<br><br>      if( !allOK ){<br>        int minnt = INT_MAX;<br>        for( int s = 0; s &lt; m; s ++ ){<br>          int thisnt = 1;<br>          for( int t = 1, dt = D[s], ds = -1; t &lt; m; dt += D[(s+t)%m], t ++ ){<br>            int tt = (s+t)%m;<br>            if( OK[tt] == 0 &amp;&amp; dt &gt; R[tt] ){<br>              if( ds &lt; 0 || R[tt] &lt; ds )<br>                ds = R[tt];<br>            }<br>            if( ds &gt;= 0 ){<br>              if( ds &gt;= D[tt] )<br>                ds -= D[tt];<br>              else{<br>                ds = -1;<br>                dt = 0;<br>                thisnt ++;<br>              }<br>            }<br>          }<br>          minnt = min( minnt, thisnt );<br>        }<br>        nc += minnt;<br>        cerr &lt;&lt; minnt &lt;&lt; endl;<br>      }<br>    }<br>  }<br>  cerr &lt;&lt; M &lt;&lt; " -&gt; " &lt;&lt; nc &lt;&lt; endl;<br>  return ( nc &lt;= k );<br>}<br><br>class ByteLand {<br>  public:<br>  int buildCastles(vector &lt;int&gt; r, vector &lt;int&gt; d, vector &lt;int&gt; c, int k) {<br>    int n = r.size();<br>    vector&lt; vector&lt; pair&lt;int, int&gt; &gt; &gt; child( n );<br>    for( int i = 0; i &lt; n; i ++ )<br>      child[r[i]].push_back( pair&lt;int,int&gt;( i, d[i] ) );<br>    vector&lt; int &gt; C( n, 0 );<br>    for( int i = 0; i &lt; c.size(); i ++ )<br>      C[c[i]] = 1;<br><br>    int L = -1, R = 1000000 * 50;<br>    while( L &lt; R - 1 ){<br>      int M = (L + R) / 2;<br>      if( isok( n, r, d, C, child, k, M ) )<br>        R = M;<br>      else<br>        L = M;<br>    }<br>    return R;<br>  }<br>//BEGIN CUT HERE<br><br><br>//END CUT HERE<br>};<br><br>// Master Spark!<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>