<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;sstream&gt;<br>#include &lt;vector&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;string.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;math.h&gt;<br>#include &lt;queue&gt;<br>using namespace std;<br>#define foreach(i,c)for(__typeof((c).end())i=(c).begin();i!=(c).end();++i)<br> <br>// Maximum number of vertices in the graph<br>#define NN 64<br> <br>// Maximum edge weight (MAXW * NN * NN must fit into an int)<br>#define MAXW 16<br> <br>// Adjacency matrix and some internal arrays<br>int g[NN][NN], v[NN], w[NN], na[NN];<br>bool a[NN];<br> <br>int minCut( int n )<br>{<br>    // init the remaining vertex set<br>    for( int i = 0; i &lt; n; i++ ) v[i] = i;<br> <br>    // run Stoer-Wagner<br>    int best = MAXW * n * n;<br>    while( n &gt; 1 )<br>    {<br>        // initialize the set A and vertex weights<br>        a[v[0]] = true;<br>        for( int i = 1; i &lt; n; i++ )<br>        {<br>            a[v[i]] = false;<br>            na[i - 1] = i;<br>            w[i] = g[v[0]][v[i]];<br>        }<br> <br>        // add the other vertices<br>        int prev = v[0];<br>        for( int i = 1; i &lt; n; i++ )<br>        {<br>            // find the most tightly connected non-A vertex<br>            int zj = -1;<br>            for( int j = 1; j &lt; n; j++ )<br>                if( !a[v[j]] &amp;&amp; ( zj &lt; 0 || w[j] &gt; w[zj] ) )<br>                    zj = j;<br> <br>            // add it to A<br>            a[v[zj]] = true;<br> <br>            // last vertex?<br>            if( i == n - 1 )<br>            {<br>                // remember the cut weight<br>                best &lt;?= w[zj];<br> <br>                // merge prev and v[zj]<br>                for( int i = 0; i &lt; n; i++ )<br>                    g[v[i]][prev] = g[prev][v[i]] += g[v[zj]][v[i]];<br>                v[zj] = v[--n];<br>                break;<br>            }<br>            prev = v[zj];<br> <br>            // update the weights of its neighbours<br>            for( int j = 1; j &lt; n; j++ ) if( !a[v[j]] )<br>                w[j] += g[v[zj]][v[j]];<br>        }<br>    }<br>    return best;<br>}<br> <br>class Terrorists {<br>  public:<br>  int requiredCost(vector &lt;string&gt; roads) {<br>    int n = roads.size();<br>    for( int i = 0; i &lt; n; i++ ) for( int j = 0; j &lt; n; j++ ) g[i][j] = roads[i][j] - '0';<br>    return minCut( n );<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>