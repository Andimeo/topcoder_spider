<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class RepeatedPatterns {<br>  public long findZeroSegment(string P1, string P2, string zeroCount) {<br>    long z = long.Parse(zeroCount);<br>    string zs = null;<br>    if (z &lt; 100)<br>    {<br>      zs = "";<br>      for (int i = 0; i &lt; z; ++i)<br>        zs += '0';<br>    }<br>    long maxAnswer = 10000000000000000L - z;<br>    long answer;<br>    if (P1.IndexOf('1') &lt; 0)<br>    {<br>      if (P2.IndexOf('1') &lt; 0)<br>      {<br>        answer = 0;<br>      }<br>      else<br>      {<br>        long start2;<br>        long finish2;<br>        long max2;<br>        long num1 = P1.Length * 1000000L;<br>        splitString(P2, out start2, out finish2, out max2);<br>        if (num1 + start2 &gt;= z)<br>          answer = 0;<br>        else<br>        {<br>          if (max2 &gt;= z)<br>            answer = num1 + P2.IndexOf(zs);<br>          else<br>          {<br>            if (finish2 + num1 + start2 &gt;= z)<br>              answer = num1 + P2.Length - finish2;<br>            else<br>              answer = -1;<br>          }<br>        }<br>      }<br>    }<br>    else<br>    {<br>      if (P2.IndexOf('1') &lt; 0)<br>      {<br>        long start1;<br>        long finish1;<br>        long max1;<br>        long num1 = P1.Length * 1000000L;<br>        long num2 = P2.Length;<br>        splitString(P1, out start1, out finish1, out max1);<br>        if (start1 &gt;= z)<br>          answer = 0;<br>        else if (max1 &gt;= z)<br>          answer = P1.IndexOf(zs);<br>        else if (finish1 + start1 &gt;= z)<br>          answer = P1.Length - finish1;<br>        else if (finish1 + num2 + start1 &gt;= z)<br>          answer = num1 - finish1;<br>        else<br>        {<br>          long needNum = (z - finish1 - start1 + num2 - 1) / num2;<br>          if (100000000000000000L / num1 &lt;= needNum)<br>          {<br>            answer = -1;<br>          }<br>          else<br>          {<br>            answer = num1 * needNum;<br>            if (200000000000000000L / needNum / num2 &lt;= needNum - 1)<br>              answer = -1;<br>            else<br>            {<br>              answer += needNum * (needNum - 1) / 2 * num2;<br>              answer -= finish1;<br>            }<br>          }<br>        }<br>      }<br>      else<br>      {<br>        long start1;<br>        long finish1;<br>        long max1;<br>        long start2;<br>        long finish2;<br>        long max2;<br>        long num1 = P1.Length * 1000000L;<br>        splitString(P1, out start1, out finish1, out max1);<br>        splitString(P2, out start2, out finish2, out max2);<br>        if (start1 &gt;= z)<br>          answer = 0;<br>        else if (max1 &gt;= z)<br>          answer = P1.IndexOf(zs);<br>        else if (finish1 + start1 &gt;= z)<br>          answer = P1.Length - finish1;<br>        else if (finish1 + start2 &gt;= z)<br>          answer = num1 - finish1;<br>        else if (max2 &gt;= z)<br>          answer = num1 + P2.IndexOf(zs);<br>        else if (finish2 + start1 &gt;= z)<br>          answer = num1 + P2.Length - finish2;<br>        else if (finish2 + start2 &gt;= z)<br>          answer = 2 * num1 + 2 * P2.Length - finish2;<br>        else<br>          answer = -1;<br>      }<br>    }<br>      <br>    <br>    return answer &gt; maxAnswer ? -1 : answer;<br>  }<br><br>  void splitString(string s, out long start, out long finish, out long max)<br>  {<br>    start = 0;<br>    while (start &lt; s.Length &amp;&amp; s[(int) start] == '0')<br>      ++start;<br>    finish = 0;<br>    while (finish &lt; s.Length &amp;&amp; s[s.Length - 1 - (int)finish] == '0')<br>      ++finish;<br>    max = Math.Max(start, finish);<br>    int j = 0;<br>    for (int i = 0; i &lt; s.Length; ++i)<br>    {<br>      if (s[i] != '0')<br>      {<br>        if (i - j - 1 &gt; max)<br>        {<br>          max = i - j - 1;<br>        }<br>        j = i;<br>      }<br>    }<br>  }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>