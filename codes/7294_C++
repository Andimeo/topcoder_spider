<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;cassert&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;complex&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;ctime&gt;<br>#include &lt;deque&gt;<br>#include &lt;fstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;numeric&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;valarray&gt;<br>#include &lt;vector&gt;<br><br>using namespace std;<br><br>//Macroses<br>#define all(v) (v).begin(), (v).end()<br><br>//Types<br>typedef long long ll;<br>typedef pair &lt;int, int&gt; pii;<br>typedef vector &lt;int&gt; vi;<br>typedef vector &lt;bool&gt; vb;<br>typedef vector &lt;pii&gt; vp;<br>typedef vector &lt;double&gt; vd;<br>typedef queue &lt;pii&gt; qp;<br><br>//Constants<br>const int INF = 1000000000;<br>const double EPS = 1e-10;<br>const double PI = 3.1415926535897932384626433832795;<br><br>//Global<br>int n;<br><br>//Functions<br><br>//Main class<br>class RepeatedPatterns<br>{<br>public:<br>  long long findZeroSegment(string P1, string P2, string z)<br>    {<br>    long long res;<br>    ll q;<br>    istringstream in(z);<br>    in &gt;&gt; q;<br>    if (q &gt; 1000)<br>    {<br>      if (count(all(P1), '0') == P1.size())<br>      {<br>        if (count(all(P2), '0') == P2.size())<br>          return 0;<br>        else<br>        {<br>          int st = find(all(P2), '1') - P2.begin();<br>          int q2 = P1.size() * 1000000;<br>          if (st + q2 &gt;= q)<br>            return 0;<br>          int end = find(P2.rbegin(), P2.rend(), '1') - P2.rbegin();<br>          if (end + st + q2 &gt;= q)<br>            return q2 + P2.size() - end;<br>          return -1;<br>        }<br>      }<br>      else<br>      {<br>        if (count(all(P2), '0') == P2.size())<br>        {<br>          int st = find(all(P1), '1') - P1.begin();<br>          int end = find(P1.rbegin(), P1.rend(), '1') - P1.rbegin();<br>          ll oq = q;<br>          q -= st;<br>          q -= end;<br>          ll a = (q + P2.size() - 1) / P2.size();<br>          long double overall = a * 1000000. * P1.size() + (a - 1) * double (a) / 2 * P2.size() - end;<br>          if (overall + oq &gt; ll(100000000) * 100000000 + 100)<br>            return -1;<br>          res = a * 1000000 * P1.size() + (a - 1) * a / 2 * P2.size() - end;<br>          if (res + oq &gt;= ll(100000000) * 100000000)<br>            return -1;<br>          return res;<br>        }<br>        else<br>          return -1;<br>      }<br>    }<br>    string zr;<br>    for (int i = 0; i &lt; q; ++i)<br>    zr += '0';<br>    if (count(all(P1), '0') == P1.size())<br>      return 0;<br>    else<br>    {<br>      string test = P1 + P1;<br>      if (test.find(zr) != string::npos)<br>        return test.find(zr);<br>      if (count(all(P2), '0') == P2.size())<br>      {<br>        int st = find(all(P1), '1') - P1.begin();<br>        int end = find(P1.rbegin(), P1.rend(), '1') - P1.rbegin();<br>        ll oq = q;<br>        q -= st;<br>        q -= end;<br>        ll a = (q + P2.size() - 1) / P2.size();<br>        long double overall = a * 1000000. * P1.size() + (a - 1) * double (a) / 2 * P2.size() - end;<br>        if (overall + oq &gt; ll(100000000) * 100000000 + 100)<br>          return -1;<br>        res = a * 1000000 * P1.size() + (a - 1) * a / 2 * P2.size() - end;<br>        if (res + oq &gt;= ll(100000000) * 100000000)<br>          return -1;<br>        return res;<br>      }<br>      else<br>      {<br>        test = P1 + P2 + P1;<br>        if (test.find(zr) != string::npos)<br>          return test.find(zr) + 999999 * P1.size();<br>        test = P2 + P2;<br>        if (test.find(zr) != string::npos)<br>          return test.find(zr) + 2000000 * P1.size() + P2.size();<br>      }<br>      return -1;<br>    }<br>    return res;<br>    }<br>    <br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>