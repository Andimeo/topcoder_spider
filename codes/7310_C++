<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br>#include &lt;fstream&gt;<br>#include &lt;queue&gt;<br> <br>using namespace std;<br> <br>const double PI = acos(-1.0);<br>#define FOR(a,b) for(int i = a; i&lt; b; ++i)<br>#define SORT(a) sort(a.begin(),a.end())<br>#define SORTC(a,b) sort(a.begin(),a.end(),b)<br> <br>int dx[] = {0,0,-1,1,1,1,-1,-1};<br>int dy[] = {1,-1,0,0,1,-1,1,-1};<br> <br>int GetID(string s)<br>{<br>  if(s == "R") return 0;<br>  else if( s== "L") return 1;<br>  else if( s== "B") return 2;<br>  else if( s== "T") return 3;<br>  else if( s== "RT") return 4;<br>  else if( s== "LT") return 5;<br>  else if( s== "RB") return 6;<br>  else if( s== "LB") return 7;<br>  return 0;<br>}<br> <br>bool chk(int x,int y)<br>{<br>  if( x &gt;= 1 &amp;&amp; x&lt;= 8 &amp;&amp; y &gt;= 1 &amp;&amp; y&lt;= 8) return true;<br>  else return false;<br>}<br> <br>class KingMovement {<br>public:<br>  string finalPosition(string, string, vector &lt;string&gt;);<br>};<br> <br>string KingMovement::finalPosition(string start, string stone, vector &lt;string&gt; <br>moves) {<br>  int sy = start[0]-'A'+1;<br>  int sx = start[1]-'0';<br>  int stx = stone[1]-'0';<br>  int sty = stone[0]-'A'+1;<br>  FOR(0,moves.size())<br>  {<br>    int ID = GetID(moves[i]);<br>    if(chk(sx+dx[ID],sy+dy[ID]))<br>    {<br>      if((sx+dx[ID] == stx) &amp;&amp; (sy + dy[ID] == sty))<br>      {<br>        if(chk(stx+dx[ID],sty+dy[ID]))<br>        {<br>          sx += dx[ID];<br>          sy += dy[ID];<br>          stx += dx[ID];<br>          sty += dy[ID];<br>        }<br>      }<br>      else <br>      {<br>        sx += dx[ID];<br>        sy += dy[ID];<br>      }<br>    }<br>  }<br>  string ret = "AA,AA";<br>  ret[0] = char('A'+sy-1);<br>  ret[1] = char(sx+'0');<br>  ret[3] = char('A'+sty-1);<br>  ret[4] = char(stx+'0');<br>  return ret;<br>}<br> <br> <br>//Powered by [BrainDeveloper] 1.0!<br></td>