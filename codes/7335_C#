<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class VotingBloc {<br>  public int[] abstainers(string[] voter) {<br>      List&lt;int&gt; v1 = new List&lt;int&gt;();<br>        List&lt;int&gt; v2 = new List&lt;int&gt;();<br>      int a = 0;<br>        foreach (string s in voter)<br>        {<br>            if (s[0] == 'Y')<br>            {<br>                v1.Add(a);<br>            } <br>            else<br>            {<br>                v2.Add(a);<br>            }<br>            ++a;<br>        }<br><br>      int n1 = v1.Count;<br>      int n2 = v2.Count;<br>        if (n1 == 0 || n2 == 0)<br>            return new int[0];<br><br>        bool[,] g = new bool[n1, n2];<br>      a = 0;<br>        foreach (string s in voter)<br>        {<br>            foreach (string p in s.Substring(1).Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries))<br>            {<br>                int b = int.Parse(p) - 1;<br>                if (v1.IndexOf(a) &gt;= 0 &amp;&amp; v2.IndexOf(b) &gt;= 0)<br>                    g[v1.IndexOf(a), v2.IndexOf(b)] = true;<br>                if (v1.IndexOf(b) &gt;= 0 &amp;&amp; v2.IndexOf(a) &gt;= 0)<br>                    g[v1.IndexOf(b), v2.IndexOf(a)] = true;<br>            }<br>            ++a;<br>        }<br><br>        bool[] resA = new bool[n1];<br>        bool[] resB = new bool[n2];<br><br>      int amount = evaluate(n1, n2, g, resA, resB);<br><br>        List&lt;int&gt; res = new List&lt;int&gt;();<br>        for (int i = 0; i &lt; voter.Length; ++i)<br>        {<br>            if (v1.IndexOf(i) &gt;= 0)<br>            {<br>                int c = v1.IndexOf(i);<br>                resA[c] = true;<br>                if (evaluate(n1, n2, g, resA, resB) == amount - 1)<br>                {<br>                    --amount;<br>                    res.Add(i + 1);<br>                }<br>                else<br>                    resA[c] = false;<br>            } else<br>            {<br>                int c = v2.IndexOf(i);<br>                resB[c] = true;<br>                if (evaluate(n1, n2, g, resA, resB) == amount - 1)<br>                {<br>                    --amount;<br>                    res.Add(i + 1);<br>                }<br>                else<br>                    resB[c] = false;<br>            }<br>        }<br><br>      return res.ToArray();<br>  }<br><br>    private int n1;<br>    private int n2;<br>    private bool[,] g;<br>    private bool[] u1;<br>    private bool[] u2;<br>    private int[] pair;<br>    private bool[] mark;<br><br>    private int evaluate(int n1, int n2, bool[,] g, bool[] u1, bool[] u2)<br>    {<br>        this.n1 = n1;<br>        this.n2 = n2;<br>        this.g = g;<br>        this.u1 = u1;<br>        this.u2 = u2;<br>        pair = new int[n2];<br>        for (int i = 0; i &lt; n2; ++i)<br>            pair[i] = -1;<br>        mark = new bool[n1];<br>        int res = 0;<br>        for (int i = 0; i &lt; n1; ++i)<br>        {<br>            if (!u1[i] &amp;&amp; dfs(i))<br>            {<br>                ++res;<br>                for (int j = 0; j &lt; n1; ++j)<br>                    mark[j] = false;<br>            }<br>        }<br>        return res;<br>    }<br><br>    private bool dfs(int at)<br>    {<br>        if (u1[at] || mark[at])<br>            return false;<br>        mark[at] = true;<br>        for (int i = 0; i &lt; n2; ++i)<br>            if (!u2[i] &amp;&amp; g[at, i])<br>            {<br>                int p = pair[i];<br>                if (p &lt; 0 || dfs(p))<br>                {<br>                    pair[i] = at;<br>                    return true;<br>                }<br>            }<br>        return false;<br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>