<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class Shadow {<br>  const double EPS = 1e-8;<br>  <br>  struct Point<br>  {<br>    public double x;<br>    public double y;<br><br>    public Point(double x, double y)<br>    {<br>      this.x = x;<br>      this.y = y;<br>    }<br>  }<br>  <br>  public double area(int[] tree, int[] light) {<br>    int[] which = new int[3];<br>    List&lt;Point&gt; p = new List&lt;Point&gt;();<br><br>    for (int i = 0; i &lt; 3; ++i)<br>    {<br>      if (tree[i] &gt; tree[i + 3])<br>      {<br>        int y = tree[i];<br>        tree[i] = tree[i + 3];<br>        tree[i + 3] = y;<br>      }<br>    }<br>    <br>    if (tree[1] &gt;= light[1])<br>      return 0;<br><br>    int infDx = 0;<br>    int infDy = 0;<br>    double cx = 0;<br>    double cy = 0;<br><br>    for (which[0] = 0; which[0] &lt; 2; ++which[0])<br>      for (which[1] = 0; which[1] &lt; 2; ++which[1])<br>        for (which[2] = 0; which[2] &lt; 2; ++which[2])<br>        {<br>          int[] at = new int[3];<br>          for (int i = 0; i &lt; 3; ++i)<br>            at[i] = tree[i] + which[i] * (tree[i + 3] - tree[i]);<br>          int dx = at[0] - light[0];<br>          int dy = at[2] - light[2];<br>          int dz = at[1] - light[1];<br>          if (dz &gt;= 0)<br>          {<br>            if (infDx * dy - infDy * dx != 0)<br>              return -1;<br>            if (dx != 0 || dy != 0)<br>            {<br>              infDx = dx;<br>              infDy = dy;<br>            }<br>          } <br>          else<br>          {<br>            double nx = light[0] - dx * light[1] / (double) dz;<br>            double ny = light[2] - dy * light[1] / (double) dz;<br>            cx += nx;<br>            cy += ny;<br>            p.Add(new Point(nx, ny));<br>          }<br>        }<br><br>    if (p.Count == 0)<br>      return 0;<br><br>    cx /= p.Count;<br>    cy /= p.Count;<br>    Point center = new Point(cx, cy);<br><br>    p.Sort(delegate(Point a, Point b)<br>             {<br>               double a1 = Math.Atan2(a.y - cy, a.x - cx);<br>               double b1 = Math.Atan2(b.y - cy, b.x - cx);<br>               if (Math.Abs(a1 - b1) &gt; EPS)<br>                 return a1.CompareTo(b1);<br>               else<br>                 return dist(a, center).CompareTo(dist(b, center));<br>             });<br><br>    Point start = p[0];<br>    foreach (Point pp in p)<br>      if (pp.x &lt; start.x - EPS || pp.x &lt; start.x + EPS &amp;&amp; pp.y &lt; start.y - EPS)<br>        start = pp;<br><br>    int sAt = p.IndexOf(start);<br>    List&lt;Point&gt; conv = new List&lt;Point&gt;();<br>    <br>    for (int by = 0; by &lt;= p.Count; ++by)<br>    {<br>      Point pp = p[(sAt + by) % p.Count];<br>      conv.Add(pp);<br>      while (conv.Count &gt;= 2)<br>      {<br>        Point b = conv[conv.Count - 2];<br>        Point c = conv[conv.Count - 1];<br>        double dx2 = c.x - b.x;<br>        double dy2 = c.y - b.y;<br>        if (Math.Abs(dx2) &lt; EPS &amp;&amp; Math.Abs(dy2) &lt; EPS)<br>        {<br>          conv.RemoveAt(conv.Count - 1);<br>          continue;<br>        }<br>        if (conv.Count &lt; 3)<br>          break;<br>        Point a = conv[conv.Count - 3];<br>        double dx1 = b.x - a.x;<br>        double dy1 = b.y - a.y;<br>        if (dx1 * dy2 - dy1 * dx2 &lt; EPS)<br>        {<br>          conv.RemoveAt(conv.Count - 2);<br>        }<br>        else<br>          break;<br>      }<br>    }<br><br>    double res = 0;<br>    for (int i = 0; i &lt; conv.Count - 1; ++i)<br>    {<br>      Point a = conv[i];<br>      Point b = conv[i + 1];<br>      res += (a.x - b.x) * (a.y + b.y);<br>    }<br>    return Math.Abs(res) / 2;<br>  }<br><br>  private double dist(Point a, Point b)<br>  {<br>    double dx = a.x - b.x;<br>    double dy = a.y - b.y;<br>    return Math.Sqrt(dx * dx + dy * dy);<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>