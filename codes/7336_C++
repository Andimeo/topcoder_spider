<td class="problemText" colspan="8" valign="middle" align="left">
            // another fine solution by misof<br>// #includes {{{<br>#include &lt;algorithm&gt;<br>#include &lt;numeric&gt;<br> <br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br> <br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cassert&gt;<br> <br>#include &lt;cmath&gt;<br>#include &lt;complex&gt;<br>using namespace std;<br>// }}}<br> <br>/////////////////// PRE-WRITTEN CODE FOLLOWS, LOOK DOWN FOR THE SOLUTION ////////////////////////////////<br> <br>// pre-written code {{{<br>#define REP(i,n) for(int i=0;i&lt;(int)(n);++i)<br>// }}}<br> <br>/////////////////// CODE WRITTEN DURING THE COMPETITION FOLLOWS ////////////////////////////////<br> <br>#define COORD_TYPE double // data type used to store the coordinates: %d || %lld || %lf || %Lf<br>typedef complex&lt;COORD_TYPE&gt; point;<br>typedef vector&lt;point&gt; poly; // if used to store a polygon, don't repeat the first vertex<br> <br>#define EPSILON (1e-7) // epsilon used for computations involving doubles ; dec to 1e-9 for %Lf<br> <br>// safe comparison function according to [argument,size]: compare_arg {{{<br>template&lt;class T&gt; bool compare_arg(const complex&lt;T&gt; &amp;A, const complex&lt;T&gt; &amp;B) { <br>  // [0,0] ide uplne na zaciatok<br>  if (are_equal(B,point(0,0))) return 0;<br>  if (are_equal(A,point(0,0))) return 1;<br>  // chceme poradie: pod osou x zlava doprava, kladna poloos, nad osou sprava dolava, zaporna poloos<br>  int sgnA = signum(imag(A));<br>  int sgnB = signum(imag(B));<br>  if (sgnA == 0) if (signum(real(A))&lt;0) sgnA = 2;<br>  if (sgnB == 0) if (signum(real(B))&lt;0) sgnB = 2;<br>  if (sgnA != sgnB) return (sgnA &lt; sgnB);<br>  // v ramci polroviny sortime podla clockwise<br>  if (counterclockwise(A,B)) return 1;<br>  if (clockwise(A,B)) return 0;<br>  // a ak sa este nerozhodlo, podla vzdialenosti, blizsie skor<br>  return (square_size(A) &lt; square_size(B));<br>}<br>// }}}<br>// safe comparison functions acc. to [x,y] and [y,x]: compare_XY, compare_YX {{{<br>template&lt;class T&gt; bool compare_YX(const complex&lt;T&gt; &amp;A, const complex&lt;T&gt; &amp;B) { if (!is_zero(imag(A)-imag(B))) return (is_negative(imag(A)-imag(B))); return (is_negative(real(A)-real(B))); }<br>// }}}<br> <br>// safe comparison with 0: is_zero, is_negative, is_positive, signum {{{<br>bool is_negative(double x) { return x &lt; -EPSILON; } bool is_zero(double x) { return fabs(x) &lt;= EPSILON; } bool is_positive(double x) { return x &gt; EPSILON; }<br>template&lt;class T&gt; int signum(const T &amp;A) { if (is_zero(A)) return 0; if (is_negative(A)) return -1; return 1; }<br>// }}}<br>// safe equality test for points {{{ <br>template&lt;class T&gt; bool are_equal(const complex&lt;T&gt; &amp;A, const complex&lt;T&gt; &amp;B) { return is_zero(real(B)-real(A)) &amp;&amp; is_zero(imag(B)-imag(A)); }<br>// }}}<br>// cross-product, dot_product, square_size (=dot_product(A,A)) for 2D vectors {{{<br>template&lt;class T&gt; T square_size(const complex&lt;T&gt; &amp;A) { return real(A) * real(A) + imag(A) * imag(A); }<br>template&lt;class T&gt; T cross_product(const complex&lt;T&gt; &amp;A, const complex&lt;T&gt; &amp;B) { return real(A) * imag(B) - real(B) * imag(A); }<br>// }}}<br>// safe colinearity and orientation tests: colinear, clockwise, counterclockwise {{{<br>template&lt;class T&gt; bool clockwise(const complex&lt;T&gt; &amp;B, const complex&lt;T&gt; &amp;C) { return is_negative( cross_product( B, C )); }<br>template&lt;class T&gt; bool counterclockwise(const complex&lt;T&gt; &amp;A, const complex&lt;T&gt; &amp;B, const complex&lt;T&gt; &amp;C) { return is_positive( cross_product( B-A, C-A )); }<br>template&lt;class T&gt; bool counterclockwise(const complex&lt;T&gt; &amp;B, const complex&lt;T&gt; &amp;C) { return is_positive( cross_product( B, C )); }<br>// }}}<br> <br>// polygon area: twice_signed_poly_area, poly_area {{{<br>template&lt;class T&gt; T twice_signed_poly_area(const vector&lt; complex&lt;T&gt; &gt; &amp;V) { T res = 0; for (unsigned int i=0; i&lt;V.size(); i++) res += cross_product( V[i], V[(i+1)%V.size()] ); return res; }<br>template&lt;class T&gt; T poly_area(const vector&lt; complex&lt;T&gt; &gt; &amp;V) { return fabs(0.5 * twice_signed_poly_area(V)); }<br>// }}}<br>// compute a CCW convex hull with no unnecessary points: convex_hull {{{<br>template&lt;class T&gt; vector&lt; complex&lt;T&gt; &gt; convex_hull( vector&lt; complex&lt;T&gt; &gt; V ) { <br>  // handle boundary cases<br>  if (V.size() == 2) if (are_equal(V[0],V[1])) V.pop_back();<br>  if (V.size() &lt;= 2) return V;<br>  // find the bottommost point -- this can be optimized!<br>  sort(V.begin(), V.end(), compare_YX&lt;COORD_TYPE&gt; );<br> <br>  complex&lt;T&gt; offset = V[0];<br>  for (unsigned int i=0; i&lt;V.size(); i++) V[i] -= offset;<br>  sort(V.begin()+1, V.end(), compare_arg&lt;COORD_TYPE&gt; );<br> <br>  int count = 2;<br>  vector&lt;int&gt; hull(V.size()+2);<br>  for (unsigned int i=0; i&lt;2; i++) hull[i]=i;<br> <br>  for (unsigned int i=2; i&lt;V.size(); i++) {<br>    while (count&gt;=2 &amp;&amp; !counterclockwise( V[hull[count-2]], V[hull[count-1]], V[i] ) ) count--;<br>    hull[count++]=i;<br>  }<br>  <br>  vector&lt; complex&lt;T&gt; &gt; res;<br>  for (int i=0; i&lt;count; i++) res.push_back( V[hull[i]] + offset );<br> <br>  if (res.size()==2) if (are_equal(res[0],res[1])) res.pop_back();<br>  return res;<br>}<br> <br>// }}}<br> <br>int tx[2], ty[2], tz[2];<br>int lx, ly, lz;<br> <br>class Shadow {<br>public:<br>  double area(vector &lt;int&gt; ttt, vector &lt;int&gt; lll) {<br>    tx[0] = ttt[0]; ty[0] = ttt[1]; tz[0] = ttt[2];<br>    tx[1] = ttt[3]; ty[1] = ttt[4]; tz[1] = ttt[5];<br>    if (tx[0]&gt;tx[1]) swap(tx[0],tx[1]);<br>    if (ty[0]&gt;ty[1]) swap(ty[0],ty[1]);<br>    if (tz[0]&gt;tz[1]) swap(tz[0],tz[1]);<br>    lx = lll[0]; ly = lll[1]; lz = lll[2];<br> <br>    if (tx[0]&lt;lx &amp;&amp; lx&lt;tx[1])<br>      if (ty[0]&lt;ly &amp;&amp; ly&lt;ty[1])<br>        if (tz[0]&lt;lz &amp;&amp; lz&lt;tz[1])<br>          return -1.0; // everywhere<br> <br>    int dim = 0;<br>    dim += (tx[0] &lt; tx[1]);<br>    dim += (ty[0] &lt; ty[1]);<br>    dim += (tz[0] &lt; tz[1]);<br> <br>    if (dim &lt;= 1) return 0.0; // point/line casts no shadows<br> <br>    if (ly &lt;= ty[0]) return 0.0; // light below object<br> <br>    if (dim == 2) {<br>      // we can still see a line<br>      if (tx[0]==tx[1]) if (lx==tx[0]) return 0.0;<br>      if (ty[0]==ty[1]) if (ly==ty[0]) return 0.0;<br>      if (tz[0]==tz[1]) if (lz==tz[0]) return 0.0;<br>    }<br> <br>    // now we surely see something<br>    if (ty[1] &gt;= ly) return -1.0; // infinite<br> <br>    // a ideme premietat<br>    poly P;<br> <br>    REP(i,2) REP(j,2) REP(k,2) {<br>      double sx=lx, sy=ly, sz=lz;<br>      double bx=tx[i], by=ty[j], bz=tz[k];<br> <br>      double dx=sx-bx, dy=sy-by, dz=sz-bz;<br> <br>      double mult = sy / dy;<br>      P.push_back( point( sx - mult*dx, sz - mult * dz ));<br>    }<br> <br>    poly Q = convex_hull(P);<br>    return poly_area(Q);<br>  }<br> <br> <br>};<br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>