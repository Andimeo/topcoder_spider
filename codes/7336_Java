<td class="problemText" colspan="8" valign="middle" align="left">
            public class Shadow {<br>    final static double EPS = 1e-9;<br> <br>    boolean between(int x, int y, int z) {<br>        return (x &lt;= y &amp;&amp; y &lt;= z) || (z &lt;= y &amp;&amp; y &lt;= x);<br>    }<br> <br>    double projectx(double x1, double y1, double z1, double x2, double y2, double z2) {<br>        return x1 + (x2 - x1) * y1 / (y1 - y2);<br>    }<br> <br>    double projectz(double x1, double y1, double z1, double x2, double y2, double z2) {<br>        return z1 + (z2 - z1) * y1 / (y1 - y2);<br>    }<br> <br>    class Poly {<br>        int n;<br>        double[] x;<br>        double[] y;<br> <br>        public Poly(int n, double[] x, double[] y) {<br>            this.n = n;<br>            this.x = x;<br>            this.y = y;<br>        }<br> <br>        double xarea() {<br>            double r = 0;<br>            for (int i = 0; i &lt; n; i++) {<br>                r += (x[(i + 1) % n] * x[(i + 1) % n] + x[i] * x[(i + 1) % n] + x[i] * x[i]) * (y[(i + 1) % n] - y[i]);<br>            }<br>            return Math.abs(r) / 3;<br>        }<br> <br>        Poly transpose() {<br>            return new Poly(n, y, x);<br>        }<br> <br>        double area() {<br>            double r = 0;<br>            for (int i = 0; i &lt; n; i++) {<br>                r += (x[(i + 1) % n] - x[i]) * (y[(i + 1) % n] + y[i]);<br>            }<br>            return Math.abs(r) / 2;<br>        }<br>    }<br> <br>    Poly convexHull(double[] x, double[] y, int n) {<br>        int j = 0;<br>        for (int i = 1; i &lt; n; i++) {<br>            if (y[i] &lt; y[j] || (y[i] == y[j] &amp;&amp; x[i] &lt; x[j])) {<br>                j = i;<br>            }<br>        }<br> <br>        int m = 0;<br>        int k = j;<br>        int[] v = new int[n];<br>        boolean[] u = new boolean[n];<br>        boolean found = false;<br>        do {<br>            v[m++] = k;<br>            u[k] = true;<br> <br>            k = 0;<br>            double bd = 0;<br>            found = false;<br>            for (int i = 0; i &lt; n; i++) {<br>                if (i != v[m - 1]) {<br>                    double vp =<br>                            (x[k] - x[v[m - 1]]) * (y[i] - y[v[m - 1]]) -<br>                            (y[k] - y[v[m - 1]]) * (x[i] - x[v[m - 1]]);<br>                    double td = Math.hypot(x[i] - x[v[m - 1]], y[i] - y[v[m - 1]]);<br>                    if (!found || vp &lt; -EPS || (vp &lt; EPS &amp;&amp; td &gt; bd)) {<br>                        found = true;<br>                        k = i;<br>                        bd = td;<br>                    }<br>                }<br>            }<br>        } while (k != j &amp;&amp; found);<br> <br>        double[] xh = new double[m];<br>        double[] yh = new double[m];<br>        for (int i = 0; i &lt; m; i++) {<br>            xh[i] = x[v[i]];<br>            yh[i] = y[v[i]];<br>        }<br>        return new Poly(m, xh, yh);<br>    }<br> <br>    public double area(int[] tree, int[] light) {<br>        int x1 = tree[0];<br>        int y1 = tree[1];<br>        int z1 = tree[2];<br>        int x2 = tree[3];<br>        int y2 = tree[4];<br>        int z2 = tree[5];<br>        int xp = light[0];<br>        int yp = light[1];<br>        int zp = light[2];<br> <br> <br>        if (x1 &gt; x2) {<br>            int t = x1; x1 = x2; x2 = t;<br>        }<br>        if (y1 &gt; y2) {<br>            int t = y1; y1 = y2; y2 = t;<br>        }<br>        if (z1 &gt; z2) {<br>            int t = z1; z1 = z2; z2 = t;<br>        }<br> <br>        if (x1 == x2 &amp;&amp; z1 == z2) {<br>            return 0;<br>        }<br> <br>        if (between(x1, xp, x2) &amp;&amp; between(y1, yp, y2) &amp;&amp; between(z1, zp, z2)) {<br>            return -1;<br>        }<br> <br>        if (x1 == x2 &amp;&amp; x1 == xp) {<br>            return 0;<br>        }<br> <br>        if (z1 == z2 &amp;&amp; z1 == zp) {<br>            return 0;<br>        }<br>        <br>        if (yp &lt;= y1) {<br>            return 0;<br>        }<br> <br>        if (yp &lt;= y2) {<br>            return -1;<br>        }<br> <br>        double[] x = new double[8];<br>        double[] y = new double[8];<br> <br>        x[0] = projectx(xp, yp, zp, x1, y1, z1);<br>        y[0] = projectz(xp, yp, zp, x1, y1, z1);<br>        x[1] = projectx(xp, yp, zp, x1, y1, z2);<br>        y[1] = projectz(xp, yp, zp, x1, y1, z2);<br>        x[2] = projectx(xp, yp, zp, x1, y2, z1);<br>        y[2] = projectz(xp, yp, zp, x1, y2, z1);<br>        x[3] = projectx(xp, yp, zp, x1, y2, z2);<br>        y[3] = projectz(xp, yp, zp, x1, y2, z2);<br>        x[4] = projectx(xp, yp, zp, x2, y1, z1);<br>        y[4] = projectz(xp, yp, zp, x2, y1, z1);<br>        x[5] = projectx(xp, yp, zp, x2, y1, z2);<br>        y[5] = projectz(xp, yp, zp, x2, y1, z2);<br>        x[6] = projectx(xp, yp, zp, x2, y2, z1);<br>        y[6] = projectz(xp, yp, zp, x2, y2, z1);<br>        x[7] = projectx(xp, yp, zp, x2, y2, z2);<br>        y[7] = projectz(xp, yp, zp, x2, y2, z2);<br> <br>        return convexHull(x, y, 8).area();<br>    }<br> <br>}<br> <br> <br>// Powered by PopsEdit<br> <br>// Powered by CodeProcessor<br></td>