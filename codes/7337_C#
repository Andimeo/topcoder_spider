<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class ExpensiveTravel {<br>  int n;<br>  int[] map;<br>  int height;<br>  int width;<br>  const double EPS = 1e-10;<br>  <br>  public int minTime(string[] m, int startRow, int startCol, int endRow, int endCol) {<br>    height = m.Length;<br>    width = m[0].Length;<br>    n = height * width;<br>    map = new int[height * width];<br>    for (int r = 0; r &lt; height; ++r)<br>      for (int c = 0; c &lt; width; ++c)<br>        map[r * width + c] = m[r][c] - '0';<br>    int start = (startRow - 1) * width + (startCol - 1);<br>    int finish = (endRow - 1) * width + (endCol - 1);<br>    int[] dist = new int[n];<br>    for (int i = 0; i &lt; n; ++i)<br>      dist[i] = -1;<br>    int[] q = new int[n * 2];<br>    int qt = 0;<br>    int qh = 1;<br>    q[qt] = start;<br>    dist[start] = 0;<br>    while (qt &lt; qh)<br>    {<br>      int cur = q[qt++];<br>      List&lt;int&gt; adj = fillAdj(cur);<br>      foreach (int x in adj)<br>        if (dist[x] &lt; 0)<br>        {<br>          dist[x] = dist[cur] + 1;<br>          q[qh++] = x;<br>        }<br>    }<br>    return dist[finish];<br>  }<br><br>  List&lt;int&gt; fillAdj(int start)<br>  {<br>    double[] dist = new double[n];<br>    for (int i = 0; i &lt; n; ++i)<br>      dist[i] = 1 + EPS;<br>    int[] heap = new int[n];<br>    int[] heapAt = new int[n];<br>    for (int i = 0; i &lt; n; ++i)<br>      heapAt[i] = -1;<br>    int nheap = 1;<br>    heap[0] = start;<br>    dist[start] = 1.0 / map[start];<br>    bool[] mark = new bool[n];<br>    while (nheap &gt; 0)<br>    {<br>      int bi = heap[0];<br>      heap[0] = heap[nheap - 1];<br>      --nheap;<br>      if (nheap &gt; 0)<br>      {<br>        int i = 0;<br>        while (true)<br>        {<br>          int at = i;<br>          if (2 * i + 1 &lt; nheap &amp;&amp; dist[heap[2 * i + 1]] &lt; dist[heap[at]])<br>            at = 2 * i + 1;<br>          if (2 * i + 2 &lt; nheap &amp;&amp; dist[heap[2 * i + 2]] &lt; dist[heap[at]])<br>            at = 2 * i + 2;<br>          if (at == i)<br>            break;<br>          int t = heap[at];<br>          heap[at] = heap[i];<br>          heap[i] = t;<br>          heapAt[heap[at]] = at;<br>          heapAt[heap[i]] = i;<br>          i = at;<br>        }<br>      }<br>      mark[bi] = true;<br>      int r = bi / width;<br>      int c = bi % width;<br>      if (r &gt; 0)<br>      {<br>        int newPos = bi - width;<br>        double newDist = dist[bi] + 1.0 / map[newPos];<br>        update(dist, heap, heapAt, newDist, newPos, ref nheap);<br>      }<br>      if (r &lt; height - 1)<br>      {<br>        int newPos = bi + width;<br>        double newDist = dist[bi] + 1.0 / map[newPos];<br>        update(dist, heap, heapAt, newDist, newPos, ref nheap);<br>      }<br>      if (c &gt; 0)<br>      {<br>        int newPos = bi - 1;<br>        double newDist = dist[bi] + 1.0 / map[newPos];<br>        update(dist, heap, heapAt, newDist, newPos, ref nheap);<br>      }<br>      if (c &lt; width - 1)<br>      {<br>        int newPos = bi + 1;<br>        double newDist = dist[bi] + 1.0 / map[newPos];<br>        update(dist, heap, heapAt, newDist, newPos, ref nheap);<br>      }<br>    }<br>    List&lt;int&gt; adj = new List&lt;int&gt;();<br>    for (int i = 0; i &lt; n; ++i)<br>      if (mark[i])<br>        adj.Add(i);<br>    return adj;<br>  }<br><br>  static void update(double[] dist, int[] heap, int[] heapAt, double newDist, int newPos, ref int nheap)<br>  {<br>    if (newDist &lt; dist[newPos])<br>    {<br>      dist[newPos] = newDist;<br>      if (heapAt[newPos] &lt; 0)<br>      {<br>        heap[nheap++] = newPos;<br>        heapAt[newPos] = nheap - 1;<br>      }<br>      int i = heapAt[newPos];<br>      while (i &gt; 0)<br>      {<br>        int at = (i - 1) / 2;<br>        if (dist[heap[at]] &lt; dist[heap[i]])<br>          break;<br>        int t = heap[at];<br>        heap[at] = heap[i];<br>        heap[i] = t;<br>        heapAt[heap[at]] = at;<br>        heapAt[heap[i]] = i;<br>        i = at;<br>      }<br>    }<br>  }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>