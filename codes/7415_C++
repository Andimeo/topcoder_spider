<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;algorithm&gt; <br>#include&lt;sstream&gt;<br>#include&lt;numeric&gt; <br>#include&lt;string&gt; <br>#include&lt;vector&gt; <br>using namespace std; <br>  <br>#define FOR(i,a,b) for(int i = (a); i &lt; (b); ++i) <br>#define REP(i,n) FOR(i,0,n) <br>#define FORE(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();++it) <br>#define all(x) (x).begin(),(x).end() <br>#define CLEAR(x,with) memset(x,with,sizeof(x)) <br>#define sz size() <br>typedef long long ll; <br>const ll M = 1000000007;<br>ll cache[31][31][51][51];<br>ll c2[31][31];<br>struct ReverseResources<br>{<br>  vector&lt;string&gt; R;<br>  string S;<br>  ll go2(int left, int right);<br>  ll go(int left, int right, int idx, int pos)<br>  {<br>    if(pos == R[idx].sz) return left == right ? 1 : 0;<br>    if(left == right) return 0;<br>    ll&amp; ret = cache[left][right][idx][pos]; if(ret != -1) return ret;<br>    ret = 0;<br>    if(R[idx][pos] != '%')<br>    {<br>      if(S[left] == R[idx][pos]) ret = go(left+1, right, idx, pos+1) % M;<br>    }<br>    else<br>    {<br>      for(int p = left+1; p &lt;= right; ++p)<br>      {<br>        ll add = (go2(left, p) * go(p, right, idx, pos+2)) % M;<br>        ret = (ret + add) % M;<br>      }<br>    }<br>    return ret;<br>  }<br>  int findDecompositions(string str, vector &lt;string&gt; resources)<br>  {<br>    S = str;<br>    R = resources;<br>    CLEAR(cache,-1);<br>    CLEAR(c2,-1);<br>    return go2(0, S.sz);<br>  }  <br>};<br>ll ReverseResources::go2(int left, int right)<br>{<br>  ll&amp; ret = c2[left][right]; if(ret != -1) return ret;<br>  ret = 0;<br>  REP(i,R.sz) ret = (ret + go(left, right, i, 0)) % M;<br>  return ret;<br>}<br></td>