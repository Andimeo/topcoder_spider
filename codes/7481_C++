<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;queue&gt;<br>#include &lt;complex&gt;<br> <br>using namespace std;<br> <br>#define RA(x) (x).begin(), (x).end()<br>#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)<br> <br>typedef long long ll;<br>typedef pair&lt;ll, ll&gt; pii;<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef complex&lt;double&gt; pnt;<br> <br> <br>class FibonacciKnapsack<br>{<br>public:<br>    long long maximalCost(vector &lt;string&gt; items, string C);<br>};<br> <br>template&lt;class FI&gt;<br>ll recurse(FI first, FI last, ll C, bool usedl)<br>{<br>    if (first == last)<br>        return 0LL;<br>    ll totw = 0, totc = 0;<br>    for (FI i = first; i &lt; last; i++)<br>    {<br>        totw += i-&gt;first;<br>        totc += i-&gt;second;<br>    }<br>    if (totw &lt;= C)<br>        return totc;<br>    else if (first-&gt;first &lt;= C &amp;&amp; (usedl || (first - 1)-&gt;first != first-&gt;first))<br>        return max(recurse(first + 1, last, C - first-&gt;first, true) + first-&gt;second,<br>                   recurse(first + 1, last, C, false));<br>    else<br>        return recurse(first + 1, last, C, false);<br>}<br> <br>long long FibonacciKnapsack::maximalCost(vector &lt;string&gt; items, string _C)<br>{<br>    ll C = atoll(_C.c_str());<br>    int N = items.size();<br>    vector&lt;pii&gt; it(N);<br>    for (int i = 0; i &lt; N; i++)<br>    {<br>        istringstream s(items[i]);<br>        s &gt;&gt; it[i].first &gt;&gt; it[i].second;<br>    }<br> <br>    sort(it.begin(), it.end());<br>    reverse(it.begin(), it.end());<br>    return recurse(it.begin(), it.end(), C, true);<br>}<br> <br> <br>// Powered by FileEdit<br></td>