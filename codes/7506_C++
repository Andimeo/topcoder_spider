<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;map&gt;<br>#include &lt;cmath&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br> <br>#define REP(i, n) for(int i=0; i&lt;(n); ++i)<br>typedef pair&lt;int, int&gt; PII;<br>#define MP make_pair<br>#define ST first<br>#define ND second<br>#define PB push_back<br>typedef long long LL;<br>#define VAR(v,i) __typeof(i) v=(i)<br>#define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)<br> <br>set&lt;PII&gt; zly;<br>set&lt;PII&gt; akt, akt2;<br>vector&lt;pair&lt;int, char&gt; &gt; bou;<br>string bous;<br> <br>int dx[] = {-1, 1, 0, 0};<br>int dy[] = {0, 0, -1, 1};<br>bool cyfra(char x){ return  x&gt;='0' &amp;&amp; x&lt;='9'; }<br>class MedievalCity {<br>  public:<br>  int getDangerousBlocks(vector &lt;string&gt; boundary, int dangerBound) {<br>    int x = 0, y = 0;<br>    LL pole = 0LL;<br>    REP(i, (int)boundary.size()) bous += boundary[i];<br>    int mm = bous.size();<br>    REP(i, mm){<br>      int ile = 1;<br>      char znak = bous[i];<br>      if (cyfra(bous[i+1])){<br>        ile = bous[++i] - '0';<br>        if (cyfra(bous[i+1])) ile = 10*ile + bous[++i] - '0';<br>      }<br>      bou.PB(MP(ile, znak));<br>      switch(znak){<br>        case 'R': pole += (LL)ile * (LL)y; x += ile; break;<br>        case 'L': pole -= (LL)ile * (LL)y; x -= ile; break;<br>        case 'U': y += ile; break;<br>        case 'D': y -= ile; break;<br>      }<br>    }<br>  //  printf("%lld\n", pole);<br>    bool odwr = pole&lt;0LL;<br>    FOREACH(it, bou){<br>  //    printf("%d %c\n", it-&gt;ST, it-&gt;ND);<br>      PII zew, wew, zm;<br>      switch(it-&gt;ND){<br>        case 'R': zew.ST = 0; zew.ND = 0; wew.ST = 0; wew.ND = -1; zm.ST = 1; zm.ND = 0; break;<br>        case 'L': zew.ST = -1; zew.ND = -1; wew.ST = -1; wew.ND = 0; zm.ST = -1; zm.ND = 0; break;<br>        case 'U': zew.ST = -1; zew.ND = 0; wew.ST = 0; wew.ND = 0; zm.ST = 0; zm.ND = 1; break;<br>        case 'D': zew.ST = 0; zew.ND = -1; wew.ST = -1; wew.ND = -1; zm.ST = 0; zm.ND = -1; break;<br>      }<br>      if (odwr) swap(zew, wew);<br>      REP(i, it-&gt;ST){<br>        zly.insert(MP(x+zew.ST, y+zew.ND));<br>        akt.insert(MP(x+wew.ST, y+wew.ND));<br>        x+=zm.ST; y+=zm.ND;<br>      }<br>    }<br>  //  FOREACH(it, zly) printf("ZLY: %d %d\n", it-&gt;ST, it-&gt;ND);<br>  //  FOREACH(it, akt) printf("AKT: %d %d\n", it-&gt;ST, it-&gt;ND);<br>    LL pocz = (LL)zly.size();<br>    for(int o = 0; o &lt;= dangerBound; ++o){<br>      FOREACH(it, akt){ zly.insert(*it); }<br>      if (o &lt; dangerBound) FOREACH(it, akt){<br>        REP(i, 4) if (zly.count(MP(it-&gt;ST + dx[i], it-&gt;ND + dy[i])) == 0) akt2.insert(MP(it-&gt;ST + dx[i], it-&gt;ND + dy[i]));<br>      }<br>      swap(akt, akt2);<br>      akt2.clear();<br>    }<br>    return (int)((LL)zly.size() - pocz);<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>