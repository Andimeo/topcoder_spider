<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br><br>public class MedievalCity {<br>  <br>  final static int hp = 99997;<br>  final static int maxh = 1000000;<br>  <br>  class Hash {<br>    int[] first, x, y, next;<br>    int hc;<br>    <br>    Hash() {<br>      first = new int[hp];<br>      x = new int[maxh];<br>      y = new int[maxh];<br>      next = new int[maxh];<br>      hc = 0;<br>      Arrays.fill(first, -1);<br>    }<br><br>    public void add(int nx, int ny) {<br>      if (contains(nx, ny))<br>        return;<br>      int h = ((nx ^ 12345) + (ny ^ 54321)) % hp;<br>      x[hc] = nx;<br>      y[hc] = ny;<br>      next[hc] = first[h];<br>      first[h] = hc;<br>      hc++;<br>    }<br><br>    public boolean contains(int nx, int ny) {<br>      int h = ((nx ^ 12345) + (ny ^ 54321)) % hp;<br>      int i = first[h];<br>      while (i != -1) {<br>        if (x[i] == nx &amp;&amp; y[i] == ny)<br>          return true;<br>        i = next[i];<br>      }<br>      return false;<br>    }<br>  }<br>  <br>  final static int[] dx = {0, 0, 1, -1};<br>  final static int[] dy = {1, -1, 0, 0};<br>  <br>  public int getDangerousBlocks(String[] boundary, int dangerBound) {<br>    <br>    Hash[] g = new Hash[2];<br>    g[0] = new Hash();<br>    g[1] = new Hash();<br>    <br>    int x = 1000000;<br>    int y = 1000000;<br>    StringBuilder sb = new StringBuilder();<br>    for (int i=0; i&lt;boundary.length; i++)<br>      sb.append(boundary[i]);<br>    int i = 0;<br>    long square = 0;<br>    while (i &lt; sb.length()) {<br>      char c = sb.charAt(i);<br>      i++;<br>      int d = 0;<br>      if (i &lt; sb.length() &amp;&amp; sb.charAt(i) &gt;= '0' &amp;&amp; sb.charAt(i) &lt;= '9') {<br>        while (i &lt; sb.length() &amp;&amp; sb.charAt(i) &gt;= '0' &amp;&amp; sb.charAt(i) &lt;= '9') {<br>          d = 10 * d + sb.charAt(i) - '0';<br>          i++;<br>        }<br>      } else<br>        d = 1;<br>      if (c == 'L')<br>        square += d * y;<br>      if (c == 'R')<br>        square -= d * y;<br>      for (int j=0; j&lt;d; j++) {<br>        if (c == 'L') {<br>          g[0].add(x-1, y-1);<br>          g[1].add(x-1, y);<br>          x--;<br>        }<br>        if (c == 'R') {<br>          g[0].add(x, y);<br>          g[1].add(x, y-1);<br>          x++;<br>        }<br>        if (c == 'U') {<br>          g[0].add(x-1, y);<br>          g[1].add(x, y);<br>          y++;<br>        }<br>        if (c == 'D') {<br>          g[0].add(x, y-1);<br>          g[1].add(x-1, y-1);<br>          y--;<br>        }<br>      }<br>    }<br>    <br>    int good = 0;<br>    int bad = 1;<br>    if (square &lt; 0) {<br>      good = 1;<br>      bad = 0;<br>    }<br>    <br>    int now = 0;<br>    while (dangerBound &gt; 0) {<br>      dangerBound--;<br>      int all = g[good].hc;<br>      while (now &lt; all) {<br>        int xx = g[good].x[now];<br>        int yy = g[good].y[now];<br>        now++;<br>        <br>        for (int d=0; d&lt;4; d++) {<br>          int nx = xx + dx[d];<br>          int ny = yy + dy[d];<br>          if (!g[bad].contains(nx, ny)) {<br>            g[good].add(nx, ny);<br>          }<br>        }<br>      }<br>    }<br>    <br>    return g[good].hc;<br>  }<br><br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>