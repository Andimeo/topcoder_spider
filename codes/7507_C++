<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;stack&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>using namespace std;<br> <br> <br>typedef vector &lt;int &gt; VI;<br>#define REP(i,n) for (int i=0; i&lt;n; ++i)<br>#define FOREACH(it,x) for(__typeof((x).begin()) it=(x.begin()); it!=(x).end(); ++it)<br>#define FOR(i,p,k) for (int i=p; i&lt;=k; ++i)<br>#define PB push_back<br>#define ALL(x) x.begin(),x.end()<br>#define SIZE(x) (int)x.size()<br> <br>const int K=10;<br>const int MASK=1&lt;&lt;K;<br>const int N=54;<br>const int INF=1000000000;<br>int dist[N][N][MASK];<br>int wiersz[K];<br>int kolumna[K];<br>int typ[K];<br>int pola=0;<br> <br>#define koduj(a,b,c) (((a)*N+(b))*MASK+(c))<br>VI q;<br>VI res;<br> <br>int dx[]={1,-1,0,0};<br>int dy[]={0,0,1,-1};<br> <br>void popraw(int mask,int d){<br>  int ile=0;<br>  REP(i,pola) if (mask&amp;(1&lt;&lt;i)){<br>    if (!typ[i]) return;<br>    ile++;<br>  }<br>  if (ile==0) return;<br>  ile--;<br>  res[ile]=min(res[ile],d);<br>}<br> <br>    class VegetableGarden<br>        { <br>        public: <br>        vector &lt;int&gt; getMinDistances(vector &lt;string&gt; garden){ <br>          int n=SIZE(garden);<br>          int m=SIZE(garden[0]);<br>          REP(i,n) REP(j,m) if (garden[i][j]!='.'){<br>            typ[pola]=garden[i][j]=='I';<br>            wiersz[pola]=i;<br>            kolumna[pola]=j;<br>            pola++;<br>          }<br>          int ile=1&lt;&lt;pola;<br>          int dobre_pola=count(typ,typ+pola,1);<br>          REP(i,dobre_pola) res.PB(INF);<br>          n++; m++;<br>          REP(i,n) REP(j,m) REP(mask,ile) dist[i][j][mask]=-1;<br>          dist[0][0][0]=0;<br>          q.PB(koduj(0,0,0));<br>          REP(foo,SIZE(q)){<br>            int stan=q[foo];<br>            int mask=stan%MASK;<br>            stan/=MASK;<br>            int j=stan%N;<br>            stan/=N;<br>            int i=stan;<br>            if (i==0 &amp;&amp; j==0) popraw(mask,dist[i][j][mask]);<br>            REP(ruch,4){<br>              int ni=i+dx[ruch];<br>              int nj=j+dy[ruch];<br>              if (ni&gt;=0 &amp;&amp; ni&lt;n &amp;&amp; nj&gt;=0 &amp;&amp; nj&lt;m){<br>                int nmask=mask;<br>                if (ruch&lt;2){<br>                  int gdzie=ruch?ni:i;<br>                  REP(x,pola) if (wiersz[x]==gdzie &amp;&amp; kolumna[x]&lt;j)<br>                    nmask^=(1&lt;&lt;x);<br>                }<br>                if (dist[ni][nj][nmask]==-1){<br>                  dist[ni][nj][nmask]=dist[i][j][mask]+1;<br>                  q.PB(koduj(ni,nj,nmask));<br>                }<br>              }<br>            }<br>          }<br>          return res;<br>        } <br>        <br> <br>         }; <br> <br>    <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>