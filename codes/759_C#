<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Text;<br>using System.Text.RegularExpressions;<br>using System.Collections;<br><br>public class RiverHill {<br>  struct Flood {<br>    public Flood( int RR, int CC, int L) {<br>      r= RR; c= CC; lsf= L;<br>    }<br>    public int r,c,lsf;<br>  }<br>  int R,C,MD;<br>  int[] dd= new int[] {0,1,0,-1,0};<br>  int flood( int rX, int cX) {<br>    bool[,] u= new bool[R,C];<br>    int[,] lf= new int[R,C];<br>    for( int r= 0; r != R; r++)<br>      for( int c= 0; c != C; c++)<br>        lf[r,c]= MD+1;<br>    Queue q= new Queue();<br>    q.Enqueue(new Flood(rX,cX,0));<br>    int res= 0;<br>    while( q.Count != 0) {<br>      Flood p= (Flood)q.Dequeue();<br>      if(!u[p.r,p.c]) res++;<br>      u[p.r,p.c]= true;<br>      lf[p.r,p.c]= 0;<br>      for( int i= 0; i != 4; i++) {<br>        int nr= p.r+dd[i];<br>        int nc= p.c+dd[i+1];<br>        if(nr&gt;=0&amp;&amp;nc&gt;=0&amp;&amp;nr&lt;R&amp;&amp;nc&lt;C) {<br>          if(M[p.r][p.c]&gt;M[nr][nc]) {<br>            q.Enqueue(new Flood(nr,nc,0));<br>            lf[nr,nc]= 0;<br>          } else if(M[p.r][p.c]==M[nr][nc]) {<br>            if(p.lsf != MD &amp;&amp; lf[nr,nc] &gt; p.lsf+1) {<br>              q.Enqueue(new Flood(nr,nc,p.lsf+1));<br>              lf[nr,nc]= 1+p.lsf;<br>            }<br>          }<br>        }<br>      }<br>    }<br>    return res;<br>  }<br>  string[] M;<br>  public int largest(string[] map, int maxDist) {<br>    R= map.Length;<br>    C= map[0].Length;<br>    MD= maxDist;<br>    M= map;<br>    int res= 0;<br>    for( int r= 0; r != R; r++)<br>      for( int c= 0; c != C; c++)<br>        res= Math.Max(res,flood(r,c));<br>    return res;<br>  }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>