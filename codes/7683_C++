<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br> <br>using namespace std;<br> <br>double EPS=1e-10;<br>double Pi=acos(-1.0);<br> <br>int n;<br> <br>struct Circle{<br>  double x,y,r;<br>}c[100];<br> <br>struct Raid{<br>  int num;<br>  int remove;<br>  double low,high;<br>  double x1,y1;<br>  double x2,y2;<br>}arc[10000];<br> <br>struct point{<br>  double x,y;<br>};<br> <br>int f;<br> <br>double Polar(double x,double y)<br>{<br>  if(fabs(x)&lt;EPS){<br>    if(y&gt;EPS) return Pi/2.0;<br>    else return 3*Pi/2.0;<br>  }<br>  else{<br>    if(x&gt;EPS) return atan(y/x);<br>    else return atan(y/x)+Pi;<br>  }<br>}<br> <br>int Remove(int k,double low,double high)<br>{<br>  if(low+EPS&lt;arc[k].high&amp;&amp;arc[k].low+EPS&lt;high){<br>    if(arc[k].high+EPS&lt;=high){<br>      if(low+EPS&lt;=arc[k].low) arc[k].remove=1;<br>      else arc[k].high=low;<br>    }<br>    else if(low+EPS&lt;=arc[k].low) arc[k].low=high;<br>    else {<br>      arc[f].low=arc[k].low;<br>      arc[f].high=low;<br>      arc[f].remove=0;<br>      arc[f].num=arc[k].num;<br>      f++;<br>      arc[k].low=high;<br>    }<br>  }<br>  return 0;<br>}<br> <br>int Remove_Arc(int k,double low,double high)<br>{<br>  Remove(k,low,high);<br>  if(low+EPS&lt;0) Remove(k,low+2*Pi,high+2*Pi);<br>  if(high&gt;2*Pi+EPS) Remove(k,low-2*Pi,high-2*Pi);<br>  return 0;<br>}<br> <br>int Cir_Cir(int k,int n)<br>{<br>  Circle c1=c[arc[k].num];<br>  Circle c2=c[n];<br>  double del,alpha;<br>  double d;<br>  d=sqrt((c1.x-c2.x)*(c1.x-c2.x)+(c2.y-c1.y)*(c2.y-c1.y));<br>  if(d+EPS&lt;c1.r+c2.r){<br>    if(d&gt;EPS+fabs(c1.r-c2.r)){<br>      del=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));<br>      alpha=Polar(c2.x-c1.x,c2.y-c1.y);<br>      Remove_Arc(k,alpha-del,alpha+del);<br>    }<br>    else if(c1.r+EPS&lt;c2.r) Remove_Arc(k,0,2*Pi);<br>  }<br>  return 0;<br>}<br> <br>double Area_Poly(point a[],int n)<br>{<br>  int i;<br>  double area;<br>  a[n]=a[0];<br>  area=0;<br>  for(i=0;i&lt;n;i++) area+=a[i].x*a[i+1].y-a[i].y*a[i+1].x;<br>  area/=2.0;<br>  return area;<br>}<br> <br>double Length(Raid a)<br>{<br>  double r=c[a.num].r;<br>  double alpha=a.high-a.low;<br>  return r*alpha;<br>}<br> <br>int Equal(Circle a,Circle b)<br>{<br>  if(fabs(a.x-b.x)&lt;EPS&amp;&amp;fabs(a.y-b.y)&lt;EPS&amp;&amp;fabs(a.r-b.r)&lt;EPS) return 1;<br>  return 0;<br>}<br> <br>class Meteorites {<br>  public:<br>  double perimeter(vector &lt;int&gt; x, vector &lt;int&gt; y, vector &lt;int&gt; r) {<br>    n=x.size();<br>    double ret=0;<br>    int i,j,k=0,t;<br>    for(i=0;i&lt;n;i++){<br>      c[i].x=x[i];<br>      c[i].y=y[i];<br>      c[i].r=r[i];<br>      for(j=0;j&lt;k;j++)if(Equal(c[j],c[i]))break;<br>      if(j&lt;k) continue;<br>      c[k++]=c[i];<br>    }<br>    n=k;<br>    f=0;<br>    for(i=0;i&lt;n;i++){<br>      arc[f].num=i;<br>      arc[f].low=0;<br>      arc[f].high=2*Pi;<br>      arc[f].remove=0;<br>      t=f;<br>      f++;<br>      for(j=0;j&lt;n;j++)if(i!=j){<br>        for(k=t;k&lt;f;k++)if(arc[k].remove==0)<br>          Cir_Cir(k,j);<br>      }<br>    }<br>    k=0;<br>    for(i=0;i&lt;f;i++)if(arc[i].remove==0){<br>      arc[k]=arc[i];<br>      arc[k].x1=c[arc[k].num].r*cos(arc[k].low)+c[arc[k].num].x;<br>      arc[k].y1=c[arc[k].num].r*sin(arc[k].low)+c[arc[k].num].y;<br>      arc[k].x2=c[arc[k].num].r*cos(arc[k].high)+c[arc[k].num].x;<br>      arc[k].y2=c[arc[k].num].r*sin(arc[k].high)+c[arc[k].num].y;<br>      k++;<br>    }<br>//    while(1){<br>      for(i=0;i&lt;k;i++) if(arc[i].remove==0){<br>        ret+=Length(arc[i]);        <br>      }<br>//    }<br>    return ret;<br>  }<br>};<br> <br>// Powered by PopsEdit<br></td>