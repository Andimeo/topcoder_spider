<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>int opt[100][100][2];<br>const int INF = 1000000001;<br><br>struct Node<br>{<br>  int pos, T;<br>} p[100];<br><br>bool cmp(Node a, Node b)<br>{<br>  return a.pos &lt; b.pos;<br>}<br><br>int abs(int a)<br>{<br>  return a &gt; 0 ? a : -a;<br>}<br><br>int min(int a, int b)<br>{<br>  return a &lt; b ? a : b;<br>}<br><br>class FastPostman<br>{<br>public:<br>  <br>  int minTime(vector &lt;int&gt; address, vector &lt;int&gt; maxTime, int initialPos)<br>  {<br>    int i, j, n = address.size(), res;<br>    <br>    for (i = 0; i &lt; n; i++)<br>    {<br>      p[i].pos = address[i];<br>      p[i].T = maxTime[i];<br>    }<br>    sort(p, p+n, cmp);<br>    for (i = 0; i &lt; n; i++)<br>    {<br>      opt[i][i][0] = opt[i][i][1] = abs(initialPos-p[i].pos);<br>      if (opt[i][i][0] &gt; p[i].T) opt[i][i][0] = opt[i][i][1] = INF;<br>    }<br>    for (i = n-1; i &gt;= 0; i--)<br>    {<br>      for (j = i+1; j &lt; n; j++)<br>      {<br>        opt[i][j][0] = min(opt[i+1][j][0]+p[i+1].pos-p[i].pos, opt[i+1][j][1]+p[j].pos-p[i].pos);<br>        if (opt[i][j][0] &gt; p[i].T) opt[i][j][0] = INF;<br>        opt[i][j][1] = min(opt[i][j-1][0]+p[j].pos-p[i].pos, opt[i][j-1][1]+p[j].pos-p[j-1].pos);<br>        if (opt[i][j][1] &gt; p[j].T) opt[i][j][1] = INF;<br>      }<br>    }<br>    res = min(opt[0][n-1][0], opt[0][n-1][1]);<br>    if (res == INF) return -1;<br>    return res;<br>  }<br>};<br></td>