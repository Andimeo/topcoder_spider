<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br>using System.Diagnostics;<br><br>class State : IComparable&lt;State&gt;{<br>    int n;<br>    int[] first, second;<br>    public State(int n_,int[] first_, int []second_){<br>        n = n_;<br>        first = (int[])first_.Clone();<br>        second = (int[])second_.Clone(); <br>    }<br><br>    public int CompareTo(State rhs) { <br>        if (n != rhs.n) return n.CompareTo(rhs.n);<br>        int k = first.Length;<br>        if (first.Length != rhs.first.Length) return first.Length.CompareTo(rhs.first.Length);<br>        for (int i = 0; i &lt; k; i++) if (first[i] != rhs.first[i]) return first[i].CompareTo(rhs.first[i]);<br>        for (int i = 0; i &lt; k; i++) if (second[i] != rhs.second[i]) return second[i].CompareTo(rhs.second[i]);<br>        return 0;<br>    }<br>};<br><br>public class RaceOrdering {<br><br>    const int oo = 1000003;<br>    SortedDictionary&lt;State, int&gt; Q = new SortedDictionary&lt;State, int&gt;();<br><br>    public int countOrders(int n, int[] first, int[] second) {<br>        return (int)go(n, first, second);<br>    }<br><br>    private long go(int n, int[] first, int[] second) {<br>        if (n == 1) return 1;<br>        State state = new State(n, first, second);<br>        if (Q.ContainsKey(state)) return Q[state];<br>        bool[] used = new bool[n];<br>        bool[] right = new bool[n];<br>        foreach (int item in first) used[item] = true;<br>        foreach (int item in second) { right[item] = used[item] = true; }<br>        int k = first.Length;<br>        for (int i = 0; i &lt; n; i++) {<br>            if (!used[i]) {<br>                List&lt;int&gt; A = new List&lt;int&gt;();<br>                List&lt;int&gt; B = new List&lt;int&gt;();<br>                for (int j = 0; j &lt; k; j++) if (first[j] != i) {<br>                        A.Add(first[j] &gt;= i ? first[j] - 1 : first[j]);<br>                        B.Add(second[j] &gt;= i ? second[j] - 1 : second[j]);<br>                    }<br>                return (go(n - 1, A.ToArray(), B.ToArray()) * n) % oo;<br>            }<br>        }<br><br>        long sum = 0;<br>        for (int i = 0; i &lt; n; i++) if (!right[i]) {<br>                List&lt;int&gt; A = new List&lt;int&gt;();<br>                List&lt;int&gt; B = new List&lt;int&gt;();<br>                for (int j = 0; j &lt; k; j++) if (first[j] != i) {<br>                        A.Add(first[j] &gt;= i ? first[j] - 1 : first[j]);<br>                        B.Add(second[j] &gt;= i ? second[j] - 1 : second[j]);<br>                    }<br>                sum = (sum + go(n - 1, A.ToArray(), B.ToArray())) % oo;<br>            }<br><br><br>        return Q[state]=(int)sum;<br>    }<br>    #region TESTCODE<br><br><br>    #endregion<br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>