<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;iostream&gt;<br>#include&lt;sstream&gt;<br>#include&lt;cstdlib&gt;<br>#include&lt;cmath&gt;<br>#include&lt;vector&gt;<br>#include&lt;string&gt;<br>#include&lt;algorithm&gt;<br>using namespace std;<br>typedef vector&lt;int&gt;VI;typedef vector&lt;VI&gt;VVI;<br>typedef vector&lt;string&gt;VS;<br>typedef pair&lt;int,int&gt;PII;<br>#define FOR(i,n) for((i)=0;(i)&lt;(n);(i)++)<br>#define FORN(i,n) for((i)=(n)-1;(i)&gt;=0;(i)--)<br>#define BE(a) ((a).begin()),((a).end())<br>#define SI(a) ((a).size())<br>#define PB push_back<br>#define MP make_pair<br>#define FORIT(i,a) for((i)=(a).begin();(i)!=(a).end();(i)++)<br>#define CLR(a,v) memset((a),(v),sizeof(a))<br><br>#define MAXN 110<br>int cap[MAXN][MAXN], flow[MAXN][MAXN], cost[MAXN][MAXN];<br>int n, sink, source, total_cost;<br><br>inline int cf(int i, int j) {<br>    if (flow[j][i]) return flow[j][i];<br>    else return cap[i][j] - flow[i][j];<br>}<br><br>inline int costf(int i, int j) {<br>    if (flow[j][i]) return -cost[j][i];<br>    else return cost[i][j];<br>}<br><br>inline void pushf(int i, int j, int x) {<br>    total_cost += costf(i, j) * x;<br>    if (flow[j][i]) flow[j][i] -= x;<br>    else flow[i][j] += x;<br>}<br><br>int augment(void) {<br>    int dist[MAXN], prev[MAXN];<br>    bool reach[MAXN];<br>    bool changed;<br>    int i, j;<br>    CLR(reach,0);<br>    reach[source] = changed = true;<br>    dist[source] = 0;<br>    while (changed) {<br>        changed = false;<br>        FOR (i,n) if (reach[i]) FOR (j,n) if (cf(i, j))<br>            if (!reach[j] || dist[i] + costf(i, j) &lt; dist[j]) {<br>                reach[j] = changed = true;<br>                dist[j] = dist[i] + costf(i, j);<br>                prev[j] = i;<br>            }<br>    }<br>    if (!reach[sink]) return 0;<br>    for (i = sink; i != source; i = prev[i]) pushf(prev[i], i, 1);<br>    return 1;<br>}<br><br>int mcmf(void) {<br>    int ret, x;<br>    CLR(flow,0);<br>    ret = total_cost = 0;<br>    while (x = augment()) ret += x;<br>    return ret;<br>}<br><br>struct ChessMatchup {<br>    int maximumScore(VI a, VI b) {<br>        int i, j;<br>        n = SI(a) + SI(b) + 2;<br>        source = n - 2;<br>        sink = n - 1;<br>        CLR(cap,0);<br>        CLR(cost,0);<br>        FOR (i,SI(a)) cap[source][i] = 1;<br>        FOR (i,SI(b)) cap[SI(a) + i][sink] = 1;<br>        FOR (i,SI(a)) FOR (j,SI(b)) {<br>            cap[i][SI(a) + j] = 1;<br>            cost[i][SI(a) + j] = -((a[i] &gt;= b[j]) + (a[i] &gt; b[j]));<br>        }<br>        cout &lt;&lt; mcmf() &lt;&lt; endl;<br>        return -total_cost;<br>    }<br><br><br>}; <br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]                    <br>// Powered by CodeProcessor<br></td>