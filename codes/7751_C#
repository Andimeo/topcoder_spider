<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class NormalizingTrees {<br>  struct Root<br>  {<br>    public int root;<br>    public int parent;<br><br>    public Root(int root, int parent)<br>    {<br>      this.root = root;<br>      this.parent = parent;<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      return root + 3137 * parent;<br>    }<br><br>    public override bool Equals(object obj)<br>    {<br>      Root _root = (Root) obj;<br>      if (root != _root.root) return false;<br>      if (parent != _root.parent) return false;<br>      return true;<br>    }<br>  }<br>  <br>  class Desc : IComparable&lt;Desc&gt;<br>  {<br>    public int[] arr;<br><br>    public Desc(int[] arr)<br>    {<br>      this.arr = arr;<br>    }<br><br>    public int CompareTo(Desc other)<br>    {<br>      for (int i = 0; i &lt; Math.Min(arr.Length, other.arr.Length); ++i)<br>        if (arr[i] &lt; other.arr[i])<br>          return -1;<br>        else if (arr[i] &gt; other.arr[i])<br>          return 1;<br>      if (arr.Length &gt; other.arr.Length)<br>        return -1;<br>      else if (arr.Length &lt; other.arr.Length)<br>        return 1;<br>      else<br>        return 0;<br>    }<br>  }<br>  <br>  Dictionary&lt;Root, Desc&gt; best;<br>  int n;<br>  List&lt;int&gt;[] adj;<br>  <br>  public int[] normalize(int[] tree) {<br>    n = tree.Length;<br>    adj = new List&lt;int&gt;[n];<br>    for (int i = 0; i &lt; n; ++i)<br>      adj[i] = new List&lt;int&gt;();<br>    for (int i = 0; i &lt; tree.Length; ++i)<br>    {<br>      if (tree[i] &gt;= 0)<br>      {<br>        int a = i;<br>        int b = tree[i];<br>        adj[a].Add(b);<br>        adj[b].Add(a);<br>      }<br>    }<br>    <br>    best = new Dictionary&lt;Root, Desc&gt;();<br><br>    Desc res = null;<br>    <br>    for (int i = 0; i &lt; n; ++i)<br>    {<br>      Desc cur = get(new Root(i, -1));<br>      if (res == null || res.CompareTo(cur) &gt; 0)<br>        res = cur;<br>    }<br><br>    return res.arr;<br>  }<br><br>  private Desc get(Root root)<br>  {<br>    if (best.ContainsKey(root))<br>      return best[root];<br><br>    List&lt;Desc&gt; children = new List&lt;Desc&gt;();<br>    <br>    foreach (int x in adj[root.root])<br>      if (x != root.parent)<br>      {<br>        children.Add(get(new Root(x, root.root)));<br>      }<br>    <br>    children.Sort();<br>    List&lt;int&gt; l = new List&lt;int&gt;();<br>    <br>    List&lt;int&gt;[] nums = new List&lt;int&gt;[children.Count];<br>    l.Add(-1);<br>    int[] at = new int[children.Count];<br>    for (int i = 0; i &lt; children.Count; ++i)<br>    {<br>      nums[i] = new List&lt;int&gt;();<br>      at[i] = 1;<br>      nums[i].Add(l.Count);<br>      l.Add(0);<br>    }<br>    <br>    while (true)<br>    {<br>      int bi = -1;<br>      int bb = int.MaxValue;<br>      for (int i = 0; i &lt; children.Count; ++i)<br>        if (at[i] &lt; children[i].arr.Length)<br>        {<br>          int cur = nums[i][children[i].arr[at[i]]];<br>          if (cur &lt; bb)<br>          {<br>            bb = cur;<br>            bi = i;<br>          }<br>        }<br><br>      if (bi &lt; 0)<br>        break;<br><br>      nums[bi].Add(l.Count);<br>      ++at[bi];<br>      l.Add(bb);<br>    }<br>    <br>    Desc res = new Desc(l.ToArray());<br><br>    best[root] = res;<br>    return res;<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>