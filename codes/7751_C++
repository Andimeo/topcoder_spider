<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br>#define REP(i,n) for(int _n=n, i=0;i&lt;_n;++i)<br>#define FOREACH(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)<br>const int INF = 1000000000;<br>typedef vector&lt;int&gt; VI;<br>template&lt;class T&gt; inline int size(const T&amp;c) { return c.size(); }<br> <br>vector&lt;vector&lt;int&gt; &gt; edges;<br> <br>VI calc(int x, int par) {<br>  vector&lt;VI&gt; ch;<br>  FOREACH(it,edges[x]) if(*it!=par) ch.push_back(calc(*it, x));<br>  sort(ch.begin(), ch.end());<br>  VI res;<br>  res.push_back(-1);<br>  int k = size(ch);<br>  vector&lt;VI&gt; newN(k);<br>  for(;;) {<br>    bool pr=false;<br>    REP(i,k) {<br>      int lim = size(newN[i]);<br>      int p = lim;<br>      while(ch[i][p] &lt; lim) {<br>        pr=true;<br>        int pp = ch[i][p];<br>        pp = pp==-1 ? 0 : newN[i][pp];<br>        newN[i].push_back(size(res));<br>        res.push_back(pp);<br>        ++p;<br>      }<br>    }<br>    if(!pr) break;<br>  }<br>  res.push_back(INF);<br>  return res;<br>}<br> <br>VI calc(int r) {<br>  return calc(r,-1);<br>}<br> <br>struct NormalizingTrees {<br>vector &lt;int&gt; normalize(vector &lt;int&gt; tree) {<br>  int n= size(tree);<br>  edges.resize(n);<br>  REP(i,n) edges[i].clear();<br>  REP(i,n) {<br>    int j = tree[i];<br>    if(j!=-1) { edges[i].push_back(j); edges[j].push_back(i); }<br>  }<br>  VI res(1,INF);<br>  REP(i,n) res = min(res, calc(i));<br>  res.pop_back();<br>  return res;<br>}<br> <br>};<br> <br>// Powered by FileEdit<br> <br>// Powered by TomekAI<br>// Powered by TZTester 1.01 [25-Feb-2003]<br> <br>// Powered by CodeProcessor<br></td>