<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class PlaneDivision {<br>  class Rational<br>  {<br>    public long p;<br>    public long q;<br><br>    public Rational(long p, long q)<br>    {<br>      long z = gcd(Math.Abs(p), Math.Abs(q));<br>      if (q &lt; 0)<br>        z = -z;<br>      this.p = p / z;<br>      this.q = q / z;<br>    }<br>    <br>    static long gcd(long a, long b)<br>    {<br>      while (b &gt; 0)<br>      {<br>        long t = a % b;<br>        a = b;<br>        b = t;<br>      }<br>      return a;<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      return (int) p + 3137 * (int) q;<br>    }<br><br>    public override bool Equals(object obj)<br>    {<br>      Rational rational = (Rational) obj;<br>      if (p != rational.p) return false;<br>      if (q != rational.q) return false;<br>      return true;<br>    }<br>    <br>    public static Rational operator+(Rational a, Rational b)<br>    {<br>      long z = gcd(a.q, b.q);<br>      return new Rational(a.p * (b.q / z) + b.p * (a.q / z), a.q * (b.q / z));<br>    }<br><br>    public static Rational operator*(Rational a, long q)<br>    {<br>      return new Rational(a.p * q, a.q);<br>    }<br>  }<br>  <br>  class Point<br>  {<br>    public Rational x;<br>    public Rational y;<br><br>    public Point(Rational x, Rational y)<br>    {<br>      this.x = x;<br>      this.y = y;<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      return x.GetHashCode() + 3137 * y.GetHashCode();<br>    }<br><br>    public override bool Equals(object obj)<br>    {<br>      Point point = (Point) obj;<br>      if (!Equals(x, point.x)) return false;<br>      if (!Equals(y, point.y)) return false;<br>      return true;<br>    }<br>  }<br>  <br>  public int howManyFiniteParts(int[] x1, int[] y1, int[] x2, int[] y2) {<br>    int n = x1.Length;<br>    Dictionary&lt;Point, object&gt; pnts = new Dictionary&lt;Point, object&gt;();<br>    long[] a = new long[n];<br>    long[] b = new long[n];<br>    long[] c = new long[n];<br>    for (int i = 0; i &lt; n; ++i)<br>    {<br>      a[i] = y1[i] - y2[i];<br>      b[i] = x2[i] - x1[i];<br>      c[i] = -(a[i] * x1[i] + b[i] * y1[i]);<br>    }<br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = i + 1; j &lt; n; ++j)<br>      {<br>        long z = a[i] * b[j] - a[j] * b[i];<br>        if (z == 0)<br>          continue;<br>        long zx = -(c[i] * b[j] - c[j] * b[i]);<br>        long zy = -(a[i] * c[j] - a[j] * c[i]);<br>        pnts[new Point(new Rational(zx, z), new Rational(zy, z))] = null;<br>      }<br>    if (pnts.Count == 0)<br>      return 0;<br>    int res = 1 - pnts.Count;<br>    for (int i = 0; i &lt; n; ++i)<br>    {<br>      int cnt = 0;<br>      foreach (Point p in pnts.Keys)<br>      {<br>        if ((p.x * a[i] + p.y * b[i] + new Rational(1, 1) * c[i]).p == 0)<br>          ++cnt;<br>      }<br>      res += (cnt - 1);<br>    }<br>    return res;<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>