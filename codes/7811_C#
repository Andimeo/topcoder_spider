<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class MutateTree {<br>    class Tree<br>    {<br>        public char ch;<br>        public Tree l = null;<br>        public Tree r = null;<br>        public Tree parent;<br><br>        public Tree locate(char ch)<br>        {<br>            if (ch == this.ch)<br>                return this;<br>            Tree rr = null;<br>            if (l != null)<br>                rr = l.locate(ch);<br>            if (r != null &amp;&amp; rr == null)<br>                rr = r.locate(ch);<br>            return rr;<br>        }<br><br>        public void setParents()<br>        {<br>            if (l != null)<br>            {<br>                l.parent = this;<br>                l.setParents();<br>            }<br>            if (r != null)<br>            {<br>                r.parent = this;<br>                r.setParents();<br>            }<br>        }<br><br>        public bool valid()<br>        {<br>            if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')<br>                return (l == null &amp;&amp; r == null);<br>            if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')<br>                return (l != null &amp;&amp; r != null &amp;&amp; l.valid() &amp;&amp; r.valid());<br>            return false;<br>        }<br><br>        public string encode()<br>        {<br>            return (l != null ? l.encode() : "") + (r != null ? r.encode() : "") + ch;<br>        }<br>    }<br><br>  public string newTree(string tree, int root1, int root2) {<br>      Tree t = parse(tree);<br>        if (t == null || !t.valid() || t.encode() != tree)<br>            return "BADTREE";<br>        t.setParents();<br>      Tree r1 = t.locate(tree[root1]);<br>        Tree r2 = t.locate(tree[root2]);<br>      Tree tmp = r1;<br>        while (tmp != null)<br>        {<br>            if (tmp == r2)<br>                return "OVERLAP";<br>            tmp = tmp.parent;<br>        }<br>        tmp = r2;<br>        while (tmp != null)<br>        {<br>            if (tmp == r1)<br>                return "OVERLAP";<br>            tmp = tmp.parent;<br>        }<br>        if (r1.parent.l == r1)<br>        {<br>            if (r2.parent.l == r2)<br>            {<br>                r1.parent.l = r2;<br>                r2.parent.l = r1;<br>            } else<br>            {<br>                r1.parent.l = r2;<br>                r2.parent.r = r1;<br>            }<br>        } else<br>        {<br>            if (r2.parent.l == r2)<br>            {<br>                r1.parent.r = r2;<br>                r2.parent.l = r1;<br>            }<br>            else<br>            {<br>                r1.parent.r = r2;<br>                r2.parent.r = r1;<br>            }<br>        }<br>      return t.encode();<br>    }<br><br>    private Tree parse(string tree)<br>    {<br>        if (tree.Length == 0)<br>            return null;<br>        Tree t = new Tree();<br>        t.ch = tree[tree.Length - 1];<br>        if (t.ch &gt;= 'a' &amp;&amp; t.ch &lt;= 'z')<br>        {<br>            int balance = 1;<br>            int i = tree.Length - 2;<br>            for (; i &gt;= 0; --i)<br>            {<br>                if (tree[i] &gt;= 'a' &amp;&amp; tree[i] &lt;= 'z')<br>                    ++balance;<br>                else<br>                {<br>                    --balance;<br>                    if (balance == 0)<br>                        break;<br>                }<br>            }<br>            if (i &lt; 0)<br>                return null;<br>            t.r = parse(tree.Substring(i, tree.Length - i - 1));<br>            t.l = parse(tree.Substring(0, i));<br>        }<br>        return t;<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>