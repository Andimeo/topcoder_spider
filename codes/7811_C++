<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;deque&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>#line 24<br>#define IT(c)           __typeof((c).begin())<br>#define FORIT(i, c)     for(IT(c) i = (c).begin(); i != (c).end(); ++i)<br> <br>#define SZ(c)           (int((c).size()))<br> <br>#line 33<br>#define PB              push_back<br> <br>#line 152<br>struct MutateTree {<br>    string newTree(string tree, int root1, int root2);<br>};<br> <br>#line 288<br>struct Node<br>{<br>    char label;<br>    struct Node *a, *b;<br>};<br> <br>#define BADTREE "BADTREE"<br>#define branch  islower<br>#define leaf    isupper<br> <br>char l1, l2;<br>Node* r1, *r2;<br> <br>ostringstream oss;<br> <br>bool find(Node *node, char c)<br>{<br>    if (node)<br>        return node-&gt;label == c || find(node-&gt;a, c) || find(node-&gt;b, c);<br>    return false;<br>}<br> <br>Node *mix(Node *n)<br>{<br>    if (n == r1) return r2;<br>    if (n == r2) return r1;<br>    return n;<br>}<br> <br>void print(Node *node)<br>{<br>    if (node)<br>    {<br>        print(mix(node-&gt;a));<br>        print(mix(node-&gt;b));<br>        oss &lt;&lt; node-&gt;label;<br>    }<br>}<br> <br>string MutateTree::newTree(string tree, int root1, int root2)<br>{<br>    map&lt;char, Node*&gt; index;<br>    vector&lt;Node *&gt; Q;<br>    FORIT(i, tree)<br>    {<br>        Node *n = new Node;<br>        n-&gt;label = *i;<br>        index[n-&gt;label] = n;<br>        if (branch(n-&gt;label))<br>        {<br>            if (SZ(Q) &lt; 2)<br>                return BADTREE;<br>            n-&gt;b = Q.back(); Q.pop_back();<br>            n-&gt;a = Q.back(); Q.pop_back();<br>        }<br>        else<br>        {<br>            n-&gt;a = n-&gt;b = 0;<br>        }<br>        Q.PB(n);<br>    }<br>    if (SZ(Q) != 1)<br>        return BADTREE;<br> <br>    l1 = tree[root1];<br>    l2 = tree[root2];<br>    if (find(index[l1], l2) || find(index[l2], l1))<br>        return "OVERLAP";<br> <br>    r1 = index[l1];<br>    r2 = index[l2];<br>    print(Q.back());<br>    return oss.str();<br>}<br></td>