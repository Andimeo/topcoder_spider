<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br><br>using namespace std;<br><br><br>const int maxnode=1000+5;<br>const int maxedge=100000+5;<br><br>int nodes,pedge,source,sink;<br>vector&lt;int&gt; living[maxnode*2+2],allnode[maxnode*2+2];<br>int first[maxnode],node[maxedge],next[maxedge],flow[maxedge],capa[maxedge];<br>int heig[maxnode],surp[maxnode],queue[maxnode];<br><br>void addedge(int a,int b,int c,int d)<br>{<br>  a--;b--;<br>  node[pedge]=b;next[pedge]=first[a];first[a]=pedge;capa[pedge]=c;flow[pedge]=0;pedge++;<br>  node[pedge]=a;next[pedge]=first[b];first[b]=pedge;capa[pedge]=d;flow[pedge]=0;pedge++;<br>}<br>void init(int _nodes,int _source,int _dest)<br>{<br>  nodes=_nodes;<br>  source=_source-1;<br>  sink=_dest-1;<br>  pedge=0;<br>  memset(first,255,sizeof(first));<br>  for (int i=0;i&lt;maxnode*2+2;i++)<br>  {<br>    living[i].clear();<br>    allnode[i].clear();<br>  }<br>}<br>int prepush()<br>{<br>  int i,k,t,p,p1,c,reheig,head,tail=1;<br>  memset(heig,255,sizeof(heig));<br>  heig[sink]=0;<br>  queue[0]=sink;<br>  for (head=0;head&lt;tail;head++)<br>    for (i=first[k=queue[head]];i!=-1;i=next[i])<br>      if (capa[i^1]&gt;0) <br>      {<br>        t=node[i];<br>        if (heig[t]==-1)<br>        {<br>          heig[t]=heig[k]+1;<br>          queue[tail++]=t;<br>        }<br>      }<br>  heig[source]=nodes;<br>  for (i=0;i&lt;nodes;i++) <br>  {<br>    if (heig[i]==-1) heig[i]=2*nodes+1;<br>    allnode[heig[i]].push_back(i);<br>  }<br>  memset(surp,0,sizeof(surp));<br>  vector&lt;int&gt;::iterator it;<br>  for (i=first[source];i!=-1;i=next[i])<br>    if (flow[i]&lt;capa[i])<br>    {<br>      t=node[i];<br>      if (surp[t]==0) living[heig[t]].push_back(t);<br>      surp[t]+=capa[i]-flow[i];<br>      surp[source]-=capa[i]-flow[i];<br>      flow[i]=capa[i];<br>      flow[i^1]=-flow[i];<br>    }<br>  for (p=nodes;p&amp;&amp;living[p].empty();p--);<br>  while (p)<br>  {<br>    it=living[p].begin();<br>    k=*it;<br>    living[p].erase(it);<br>    p1=p;<br>    for (it=allnode[p].begin();it!=allnode[p].end();it++) if (*it==k) break;<br>    allnode[p].erase(it);<br>    while (surp[k])<br>    {<br>      reheig=nodes*2+1;<br>      for (i=first[k];i!=-1&amp;&amp;surp[k];i=next[i])<br>        if (flow[i]&lt;capa[i])<br>        {<br>          t=node[i];<br>          if (heig[t]+1==heig[k])<br>          {<br>            t=node[i];<br>            c=(capa[i]-flow[i]&lt;surp[k])?capa[i]-flow[i]:surp[k];<br>            if (surp[t]==0&amp;&amp;t!=source&amp;&amp;t!=sink) <br>            {<br>              living[heig[t]].push_back(t);<br>              if (heig[t]&gt;p) p=heig[t];<br>            }<br>            surp[t]+=c;<br>            surp[k]-=c;<br>            flow[i]+=c;<br>            flow[i^1]-=c;<br>          }<br>          else if (heig[t]+1&lt;reheig) reheig=heig[t]+1;<br>        }<br>      if (surp[k]) heig[k]=reheig;<br>    }<br>    allnode[heig[k]].push_back(k);<br>    if (allnode[p1].empty())<br>    {<br>      for (i=p1+1;i&lt;=nodes;i++) <br>      {<br>        living[nodes+1].insert(living[nodes+1].begin(),living[i].begin(),living[i].end());<br>        living[i].clear();<br>        allnode[nodes+1].insert(allnode[nodes+1].begin(),allnode[i].begin(),allnode[i].end());<br>        for (it=allnode[i].begin();it!=allnode[i].end();it++)<br>          heig[*it]=nodes+1;<br>        allnode[i].clear();<br>      }<br>      if (nodes+1&gt;p) p=nodes+1;<br>    }<br>    for (;p&amp;&amp;living[p].empty();p--);<br>  }<br>  return surp[sink];<br>}<br><br>class WSNParentsAssignment<br>{<br>public:<br>  int n;<br>  vector&lt;string&gt; G;<br>  int result;<br>  int solve(vector&lt;int&gt; R)<br>  {<br>    for (int D=0;D&lt;=n;D++)<br>      if (check(R,D))<br>        return D;<br>    return -1;<br>  }<br>  bool check(vector&lt;int&gt; R,int MD)<br>  {<br>    int D[60];<br>    memset(D,0,sizeof(D));<br>    for (int i=0;i&lt;n;i++) if (R[i]&gt;=0 &amp;&amp; R[i]&lt;n) D[R[i]]++;<br>    for (int i=0;i&lt;n;i++) if (D[i]&gt;MD) return false;<br>    int src=n+n+1,dest=n+n+2;<br>    init(n+n+2,src,dest);<br>    int exp=0;<br>    for (int i=0;i&lt;n;i++) if (R[i]==-1) exp++,addedge(src,i+1,1,0);<br>    for (int i=0;i&lt;n;i++) addedge(i+n+1,dest,MD-D[i],0);<br>    for (int i=0;i&lt;n;i++) if (R[i]==-1 &amp;&amp; G[i][n]=='Y') addedge(i+1,dest,1,0);<br>    for (int i=0;i&lt;n;i++) if (R[i]==-1)<br>      for (int k=0;k&lt;n;k++) if (G[i][k]=='Y')<br>        addedge(i+1,k+n+1,1,0);<br>    int flow=prepush();<br>    return flow==exp;<br>  }<br>  bool check(vector&lt;int&gt; R)<br>  {<br>    return check(R,result);<br>  }<br>  bool noAnswer()<br>  {<br>    bool R[60];<br>    memset(R,false,sizeof(R));<br>    for (int i=0;i&lt;n;i++) if (G[i][n]=='Y') R[i]=true;<br>    for (int step=0;step&lt;n;step++)<br>      for (int i=0;i&lt;n;i++)<br>        for (int j=0;j&lt;n;j++)<br>          if (R[i] &amp;&amp; G[j][i]=='Y')<br>            R[j]=true;<br>    for (int i=0;i&lt;n;i++) if (!R[i]) return true;<br>    return false;<br>  }<br>  vector &lt;int&gt; minNetworkBurdenLevel(vector &lt;string&gt; _G, string nearest)<br>  {<br>    G=_G;<br>    n=G.size();<br>    for (int i=0;i&lt;n;i++) G[i]+=nearest.substr(i,1);<br>    vector&lt;int&gt; R;<br>    if (noAnswer()) return R;<br>    for (int i=0;i&lt;n;i++) R.push_back(-1);<br>    result=solve(R);<br>    for (int key=0;key&lt;n;key++)<br>      for (int i=0;i&lt;=n;i++)<br>        if (G[key][i]=='Y')<br>        {<br>          if (key==i) continue;<br>          R[key]=i;<br>          if (check(R)) break;<br>        }<br>    return R;<br>  }<br>};<br></td>