<td class="problemText" colspan="8" valign="middle" align="left">
            // {{{<br>#include &lt;algorithm&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;utility&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br>#define REP(i,n) for(int i=0;i&lt;(n);++i)<br>#define FOR(i,a,b) for(int i=(a);i&lt;=(b);++i)<br>#define FORD(i,a,b) for(int i=(a);i&gt;=(b);--i)<br>#define FOREACH(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)<br>typedef long long LL; typedef vector&lt;int&gt; VI; typedef vector&lt;string&gt; VS;<br>const int INF = 1000000000;<br>const LL INFLL = LL(INF)*LL(INF);<br>template&lt;class T&gt; inline int size(const T&amp;c) { return c.size(); }<br>template&lt;class T&gt; string i2s(T x) { stringstream s; s&lt;&lt;x; return s.str(); }<br>int s2i(string s) { stringstream ss(s); int x; ss&gt;&gt;x; return x; }<br>LL s2ll(string s) { stringstream ss(s); LL x; ss&gt;&gt;x; return x; }<br><br>VS split(string s, string delim=" ") {<br>  s += delim[0];<br>  string w; VS res;<br>  FOREACH(it,s) {<br>    if(find(delim.begin(),delim.end(),*it)==delim.end()) {<br>      w += *it;<br>    } else {<br>      if(w!="") res.push_back(w);<br>      w="";<br>    }<br>  }<br>  return res;<br>}<br><br>VI s2vi(string s, string delim=" ") {<br>  VS v = split(s,delim);<br>  VI res; FOREACH(it,v) res.push_back(s2i(*it));<br>  return res;<br>}<br><br>// }}}<br><br>typedef long double ld;<br><br>int ncontestants;<br>vector&lt;VI&gt; wheels;<br>VI limit;<br><br>ld cacheHP[52][128];<br>bool doneHP[52][128];<br><br>bool wantToRespin(int,int);<br><br>ld calcHoldProb(int nr, int val) {<br>  ld &amp;res = cacheHP[nr][val];<br>  if(doneHP[nr][val]) return res;<br>  doneHP[nr][val]=true;<br>  if(nr==ncontestants) { res=1; return res; }<br>  int n = size(wheels[nr]);<br>  res = 0;<br>  REP(i,n) {<br>    int a = wheels[nr][i];<br>    bool respin = a &gt; val ? wantToRespin(nr,a) : true;<br>    if(!respin) {}<br>    else {<br>      ld res2=0;<br>      REP(j,n) {<br>        int ab = a + wheels[nr][j];<br>        if(ab &gt; limit[nr] || ab&lt;=val) res2 += calcHoldProb(nr+1,val);<br>      }<br>      res2 /= n;<br>      res += res2;<br>    }<br>  }<br>  return res;<br>}<br><br>bool wantToRespin(int nr, int a) {<br>  ld p1 = calcHoldProb(nr+1,a);<br>  ld p2 = 0;<br>  int n = size(wheels[nr]);<br>  REP(i,n) {<br>    int ab = a + wheels[nr][i];<br>    if(ab&lt;=limit[nr]) p2 += calcHoldProb(nr+1,ab);<br>  }<br>  p2 /= n;<br>  if(p1&lt;1e-8 &amp;&amp; p2 &lt;1e-8) { p1=p2=0; }<br>  return (p2&gt;=p1);<br>}<br><br>struct BigWheels {<br><br>// MAIN<br>vector &lt;int&gt; enough(vector &lt;string&gt; wheels1) {<br>  ncontestants = size(wheels1);<br>  wheels.resize(ncontestants);<br>  REP(i,ncontestants) wheels[i] = s2vi(wheels1[i]);<br>  limit.resize(ncontestants);<br>  REP(i,ncontestants) limit[i] = *max_element(wheels[i].begin(), wheels[i].end());<br>  VI res;<br>  FOREACH(it,wheels[0]) {<br>    if(!wantToRespin(0,*it)) res.push_back(*it);<br>  }<br>  sort(res.begin(), res.end());<br>  res.resize(unique(res.begin(), res.end())-res.begin());<br>  return res;<br>}<br><br>};<br><br><br><br>// Powered by FileEdit<br></td>