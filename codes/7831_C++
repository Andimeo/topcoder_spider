<td class="problemText" colspan="8" valign="middle" align="left">
            // Cry as challenge phase is passing by<br><br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br><br>#include &lt;cmath&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br><br>#include &lt;queue&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br><br>using namespace std;<br><br>#define FORC(it,v) for( __typeof((v).begin()) it = (v).begin(); it != (v).end(); ++it )<br><br>int PP[ 2 ] = { -1, 1 };<br>int dp[ 51 ][ 51 ][ 1&lt;&lt;9 ];<br><br>int need;<br>int R, S;<br><br>int indeks[ 51 ][ 51 ];<br>vector&lt; string &gt; grid;<br><br>int bitcnt[ 1 &lt;&lt; 9 ];<br><br>struct state {<br>    int x, y;<br>    int mask;<br><br>    state() {}<br>    state( int _x, int _y, int _mask ) : x( _x ), y( _y ), mask( _mask ) {}<br><br>    int &amp;ref() { return dp[x][y][mask]; }<br>};<br><br>queue&lt; state &gt; Q;<br><br>void push( state X ) {<br>    Q.push( X );<br>    X.ref() = 0;<br>}<br><br>int dx[6] = { -1, 1, 0, 0, 0, 0 };<br>int dy[6] = { 0, 0, -1, -1, 1, 1 };<br><br>inline bool valid( int x, int y ) { if( x &lt; 0 || y &lt; 0 || x &gt;= R || y &gt;= S ) return false; return true; }<br><br>bool isboundary( int x, int y ) {<br>    if( x == 0 || x == R-1 ) return true;<br>    if( y == 0 || y == S-1 ) return true;<br><br>    dx[2] = PP[ y&amp;1 ];<br>    dx[4] = PP[ y&amp;1 ];<br><br>    for( int pc = 0; pc &lt; 6; ++pc ) {<br>        int nx = x + dx[pc];<br>        int ny = y + dy[pc];<br><br>        if( !valid( nx, ny ) ) continue;<br>        if( grid[nx][ny] == '.' ) return true;<br>    }<br><br>    return false;<br>}<br><br>class ExploringHoneycombs {<br>public:<br>    int minWay( vector &lt;string&gt; cells, int ne ) {<br>        bitcnt[0] = 0;<br><br>        for( int i = 1; i &lt; (1&lt;&lt;9); ++i )<br>            bitcnt[i] = (i&amp;1) + bitcnt[i&gt;&gt;1];<br><br>        R = ( int )cells.size();<br>        S = ( int )cells[0].size();<br><br>        grid = cells;<br>        need = ne;<br>        memset( dp, -1, sizeof dp );<br><br>        int cnt = 0;<br><br>        for( int i = 0; i &lt; R; ++i )<br>            for( int j = 0; j &lt; S; ++j ) {<br>                indeks[i][j] = -1;<br>                if( grid[i][j] == 'H' ) indeks[i][j] = cnt++;<br>            }<br><br>        for( int i = 0; i &lt; R; ++i )<br>            for( int j = 0; j &lt; S; ++j ) {<br>                if( isboundary( i, j ) == false ) continue;<br><br>                if( grid[i][j] == 'H' )<br>                    push( state( i, j, 1&lt;&lt;indeks[i][j] ) );<br>                else if( grid[i][j] == 'E' )<br>                    push( state( i, j, 0 ) );<br>            }<br><br>        for( ; !Q.empty(); Q.pop() ) {<br>            state ex = Q.front();<br><br>            if( bitcnt[ ex.mask ] &gt;= need ) {<br>                if( isboundary( ex.x, ex.y ) )<br>                    return ex.ref();<br>            }<br><br>            dx[2] = PP[ ex.y&amp;1 ];<br>            dx[4] = PP[ ex.y&amp;1 ];            <br><br>            for( int pc = 0; pc &lt; 6; ++pc ) {<br>                int x = ex.x + dx[pc];<br>                int y = ex.y + dy[pc];<br><br>                if( !valid( x, y ) ) continue;<br>                if( grid[ x ][ y ] == 'W' ) continue;<br>                if( grid[ x ][ y ] == '.' ) continue;<br><br>                int mm = ex.mask;<br><br>                if( grid[ x ][ y ] == 'H' ) mm |= 1 &lt;&lt; indeks[ x ][ y ];<br><br>                state nov( x, y, mm );<br><br>                if( nov.ref() == -1 ) { <br>                    nov.ref() = ex.ref() + 1;<br>                    Q.push( nov );<br>                }<br>            }<br>        }<br><br>        return -1;<br>    }<br>};<br><br><br><br><br><br><br><br><br><br>// Powered by FileEdit<br>// Powered by moj 3.0 beta 11 [modified TZTester]<br>// Powered by CodeProcessor<br></td>