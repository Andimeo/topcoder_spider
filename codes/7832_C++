<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;stack&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>using namespace std;<br> <br> <br>typedef vector &lt;int &gt; VI;<br>#define REP(i,n) for (int i=0; i&lt;(n); ++i)<br>#define FOREACH(it,x) for(__typeof((x).begin()) it=(x.begin()); it!=(x).end(); ++it)<br>#define FOR(i,p,k) for (int i=(p); i&lt;=(k); ++i)<br>#define PB push_back<br>#define ALL(x) x.begin(),x.end()<br>#define SIZE(x) (int)x.size()<br> <br>typedef long double LD;<br>LD EPS = 1E-9;<br>vector&lt;int&gt; holdx, holdy;<br>LD armLength;<br> <br>inline bool IsZero(LD x){ return x&gt;=-EPS &amp;&amp; x&lt;=EPS; }<br>#define POINTT LD<br>#define POINTR LD<br>struct POINT {<br>    POINTT x,y;<br>    POINT(POINTT wx, POINTT wy) : x(wx), y(wy) {}<br>    POINT() {}<br>    bool operator ==(POINT&amp; a) {return a.x==x &amp;&amp; a.y==y;}<br>};<br>#define SQ(x) ((x)*(x))<br>vector&lt;POINT&gt; CirclesCross(POINT c1, POINTR c1r, POINT c2, POINTR c2r){<br>  vector&lt;POINT&gt; r;<br>  c2.x -= c1.x; c2.y-= c1.y;<br>  if (IsZero(c2.x) &amp;&amp; IsZero(c2.y)) return r;<br>  LD A = (-SQ(c2r)+SQ(c1r)+SQ(c2.x)+SQ(c2.y))/2.0;<br>  if (IsZero(c2.y)){<br>    LD x = A/c2.x; LD y2=SQ(c1r)-SQ(x);<br>    if (y2 &lt;-EPS) return r;<br>    if(IsZero(y2)) r.PB(POINT(c1.x+x,c1.y));<br>    else{<br>      r.PB(POINT(c1.x+x,c1.y+sqrt(y2)));<br>      r.PB(POINT(c1.x+x,c1.y-sqrt(y2)));<br>    }<br>    return r;<br>  }<br>  LD a = SQ(c2.x) + SQ(c2.y);<br>  LD b = -2.0 *A * c2.x;<br>  LD d = 4.0*((SQ(c2.x)+SQ(c2.y))*SQ(c1r)-A*A);<br>  if (d&lt;-EPS) return r;<br>  LD x = -b/(2.0*a);<br>  if (IsZero(d)) r.PB(POINT(c1.x + x, c1.y+(A - c2.x*x)/c2.y));<br>  else{<br>    LD e = sqrt(d)*c2.y/(2.0*a);<br>    r.PB(POINT(c1.x+x+e, c1.y+(A-c2.x*(x+e))/c2.y));<br>    r.PB(POINT(c1.x+x-e, c1.y+(A-c2.x*(x-e))/c2.y));<br>  }<br>  return r;<br>}<br> <br>int n;<br>const int N = 20;<br>int vis[N][N][N];<br>LD res = 0.0;<br> <br>void licz_min_max(int a,int b,int c,LD &amp;miny,LD &amp;maxy) {<br>  miny = 1000000;<br>  maxy = 0;<br>  vector&lt;POINT&gt; kand;<br>  int t[]= {a, b, c};<br>  REP(i,3) kand.PB(POINT(holdx[t[i]],holdy[t[i]]+armLength));<br>  REP(i,3) kand.PB(POINT(holdx[t[i]],holdy[t[i]]-armLength));<br>  REP(i,3) REP(j,i){<br>    vector&lt;POINT&gt; r = CirclesCross(POINT(holdx[t[i]], holdy[t[i]]), armLength, POINT(holdx[t[j]], holdy[t[j]]), armLength);<br>    FOREACH(it,r) kand.PB(*it);<br>  }<br>  FOREACH(it,kand){<br>    bool ok = true;<br>    REP(i,3) if (SQ(it-&gt;x - holdx[t[i]]) + SQ(it-&gt;y - holdy[t[i]]) &gt; SQ(armLength) + EPS) ok = false;<br>    if (ok) miny = min(miny, it-&gt;y), maxy = max(maxy, it-&gt;y);<br>  }<br>}<br> <br>bool stoi(int a,int b,int c){<br>  LD miny, maxy;<br>  licz_min_max(a,b,c,miny,maxy);<br>  return miny &lt;= armLength+EPS;<br>}<br> <br>LD najwyzszy(int a,int b,int c){<br>  LD miny, maxy;<br>  licz_min_max(a,b,c,miny,maxy);<br>  return maxy + armLength;<br>}<br> <br>bool dobra_pozycja(int a,int b,int c,int d){<br>  int t[]={a,b,c,d};<br>  vector&lt;POINT&gt; kand;<br> <br>  REP(i,4) kand.PB(POINT(holdx[t[i]],holdy[t[i]]-armLength));<br>  REP(i,4) kand.PB(POINT(holdx[t[i]],holdy[t[i]]+armLength));<br>  REP(i,4) REP(j,i){<br>    vector&lt;POINT&gt; r = CirclesCross(POINT(holdx[t[i]], holdy[t[i]]), armLength, POINT(holdx[t[j]], holdy[t[j]]), armLength);<br>    FOREACH(it,r) kand.PB(*it);<br>  }<br>  FOREACH(it,kand){<br>    bool ok = true;<br>    REP(i,4) if (SQ(it-&gt;x - holdx[t[i]]) + SQ(it-&gt;y - holdy[t[i]]) &gt; SQ(armLength) + EPS) ok = false;<br>    if (ok) return true;<br>  }<br>  return false;<br>}<br> <br>void dfs(int a,int b,int c){<br>  int t[]={a,b,c};<br>  sort(t,t+3);<br>  a=t[0]; b=t[1]; c=t[2];<br>  if (vis[a][b][c]) return;<br>  vis[a][b][c]=1;<br>  res = max(res, najwyzszy(a,b,c));<br>  REP(d,n) if (a != d &amp;&amp; b != d &amp;&amp; c != d){<br>    if (dobra_pozycja(a,b,c,d)){<br>      int t2[] = {a,b,c,d};<br>      REP(pomin,4){<br>        VI v;<br>        REP(i,4) if (i!=pomin) v.PB(t2[i]);<br>        dfs(v[0],v[1],v[2]);<br>      }<br>    }<br>  }<br>}<br> <br>class WallClimbing {<br>  public:<br>  double maxHeight(vector &lt;int&gt; _holdx, vector &lt;int&gt; _holdy, int _armLength) {<br>    armLength = _armLength;<br>    holdx = _holdx; holdy = _holdy;<br>    res = 2.0 * armLength;<br>    n = SIZE(holdx);<br>    REP(i,n) REP(j,i) REP(k,j){<br>      if (stoi(i,j,k)) dfs(i,j,k);<br>    }<br>    return res;<br>  }<br>  <br> <br>};<br> <br> <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>