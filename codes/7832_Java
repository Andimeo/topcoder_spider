<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br>import java.text.*;<br>import java.math.*;<br> <br> <br>public class WallClimbing<br>{<br>  static class Vector {<br>    double x, y;<br>    <br>    Vector(double x, double y) {<br>      this.x = x;<br>      this.y = y;<br>    }<br>    <br>    Vector diff(Vector b) {<br>      return new Vector(x - b.x, y - b.y);<br>    }<br>    <br>    double len2() {<br>      return x * x + y * y;<br>    }<br>    <br>    double len() {<br>      return Math.sqrt(len2());<br>    }<br>    <br>    Vector norm() {<br>      return mul(1. / len());<br>    }<br>    <br>    Vector mul(double b) {<br>      return new Vector(x * b, y * b);<br>    }<br>    <br>    Vector add(Vector b) {<br>      return new Vector(x + b.x, y + b.y);<br>    }<br>    <br>    Vector rot() {<br>      return new Vector(y, -x);<br>    }<br>  }<br>  <br>  final double EPS = 1e-8;<br>  <br>  Vector circle(Vector a, Vector b, double sign) {<br>    Vector c = a.add(b).mul(0.5);<br>    Vector v = a.diff(b).rot();<br>    double d = v.len() * 0.5;<br>    v = v.norm();<br>    if (d &gt; r + EPS) {<br>      return null;<br>    }<br>    double x = r * r - d * d;<br>    x = Math.sqrt(Math.max(0., x));<br>    return c.add(v.mul(x * sign));<br>  }<br>  <br>  Vector[] ps;<br>  boolean[][][] col;<br>  int n;<br>  double ans;<br>  <br>  void dfs(int u, int v, int w) {<br>    if (col[u][v][w]) {<br>      return;<br>    }<br>    col[u][v][w] = true;<br>    double max = maxy(new Vector[]{ps[u], ps[v], ps[w]});<br>    ans = Math.max(ans, max);<br>    //System.out.println(u + " " + v + " " + w + " " + max);<br>    for (int t = 0; t &lt; n; ++t) {<br>      if (u != t &amp;&amp; v != t &amp;&amp; w != t &amp;&amp; can(new Vector[]{ps[u], ps[v], ps[w], ps[t]})) {<br>        dfs(t, v, w);<br>        dfs(u, t, w);<br>        dfs(u, v, t);<br>      }<br>    }<br>  }<br>  <br>  double miny(Vector[] vs) {<br>    double ret = Double.POSITIVE_INFINITY;<br>    int n = vs.length;<br>    for (int i = 0; i &lt; n; ++i) {<br>      if (check(vs, vs[i].diff(new Vector(0, r)))) {<br>        ret = Math.min(ret, vs[i].y - r);<br>      }<br>      for (int j = i + 1; j &lt; n; ++j) {<br>        Vector v = circle(vs[i], vs[j], 1);<br>        if (v != null &amp;&amp; check(vs, v)) {<br>          ret = Math.min(ret, v.y);<br>        }<br>        v = circle(vs[i], vs[j], -1);<br>        if (v != null &amp;&amp; check(vs, v)) {<br>          ret = Math.min(ret, v.y);<br>        }<br>      }<br>    }<br>    return ret;<br>  }<br>  <br>  double maxy(Vector[] vs) {<br>    double ret = Double.NEGATIVE_INFINITY;<br>    int n = vs.length;<br>    for (int i = 0; i &lt; n; ++i) {<br>      if (check(vs, vs[i].add(new Vector(0, r)))) {<br>        ret = Math.max(ret, vs[i].y + r);<br>      }<br>      for (int j = i + 1; j &lt; n; ++j) {<br>        Vector v = circle(vs[i], vs[j], 1);<br>        if (v != null &amp;&amp; check(vs, v)) {<br>          ret = Math.max(ret, v.y);<br>        }<br>        v = circle(vs[i], vs[j], -1);<br>        if (v != null &amp;&amp; check(vs, v)) {<br>          ret = Math.max(ret, v.y);<br>        }<br>      }<br>    }<br>    return ret;<br>  }<br>  <br>  boolean can(Vector[] vs) {<br>    int n = vs.length;<br>    for (int i = 0; i &lt; n; ++i) {<br>      for (int j = i + 1; j &lt; n; ++j) {<br>        Vector v = circle(vs[i], vs[j], 1);<br>        if (v != null &amp;&amp; check(vs, v)) {<br>          return true;<br>        }<br>        v = circle(vs[i], vs[j], -1);<br>        if (v != null &amp;&amp; check(vs, v)) {<br>          return true;<br>        }<br>      }<br>    }<br>    return false;<br>  }<br>  <br>  boolean check(Vector[] vs, Vector v) {<br>    for (Vector u : vs) {<br>      if (u.diff(v).len() &gt; r + EPS) {<br>        return false;<br>      }<br>    }<br>    return true;<br>  }<br>  <br>  double r;<br>  <br>  public double maxHeight(int[] holdx, int[] holdy, int r)<br>  {<br>    this.r = r;<br>    n = holdx.length;<br>    col = new boolean[n][n][n];<br>    ps = new Vector[n];<br>    for (int i = 0; i &lt; n; ++i) {<br>      ps[i] = new Vector(holdx[i], holdy[i]);<br>    }<br>    ans = r;<br>    for (int u = 0; u &lt; n; ++u) {<br>      for (int v = u + 1; v &lt; n; ++v) {<br>        for (int w = v + 1; w &lt; n; ++w) {<br>          if (miny(new Vector[]{ps[u], ps[v], ps[w]}) &lt; r + EPS) {<br>            dfs(u, v, w);<br>          }<br>        }<br>      }<br>    }<br>    return ans + r;<br>  }<br>  <br> <br>}<br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>