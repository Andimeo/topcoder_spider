<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;iostream&gt;<br>#include&lt;cstdio&gt;<br>#include&lt;cctype&gt;<br>#include&lt;cmath&gt;<br>#include&lt;cstdlib&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;vector&gt;<br>#include&lt;string&gt;<br>#include&lt;list&gt;<br>#include&lt;deque&gt;<br>#include&lt;map&gt;<br>#include&lt;set&gt;<br>#include&lt;queue&gt;<br>#include&lt;stack&gt;<br>#include&lt;utility&gt;<br>#include&lt;sstream&gt;<br>#include&lt;cstring&gt;<br>using namespace std;<br> <br>#define FOR(I,A,B) for(int I=(A);I&lt;=(B);I++)<br>#define REP(I,N) for(int I=0;I&lt;(N);I++)<br>#define ALL(X) (X).begin(),(X).end()<br>#define PB push_back<br>#define MP make_pair<br>#define FI first<br>#define SE second<br>typedef vector&lt;int&gt; VI;<br>typedef pair&lt;int,int&gt; PII;<br>typedef long long ll;<br>typedef vector&lt;string&gt; VS;<br>#define INFTY 100000000<br>#define VAR(V,init) __typeof(init) V=(init)<br>#define FOREACH(I,C) for(VAR(I,(C).begin());I!=(C).end();I++)<br> <br> <br>// A pasted maxflow<br> <br>#define MAX_N 300<br> <br>struct kraw<br>{<br>  int c,f; /* przepustowosc, przeplyw */<br>  int v; /* wierzcholek docelowy */<br>};<br> <br>vector&lt;kraw&gt; t[MAX_N];<br>vector&lt;kraw&gt;::iterator poz[MAX_N];<br>int n;<br>int c[MAX_N][MAX_N],c0[MAX_N][MAX_N]; /* c0 do odzysku przeplywu */<br> <br>/* Minimalny przekroj to krawedzie, laczace po wykonaniu algorytmu<br> * wierzcholek o tab[i]&gt;=0 i wierzcholek o tab[i]==-1. */<br>int tab[MAX_N];<br> <br> <br>/* dodawanie krawedzi skierowanej z przepustowoscia */<br>void add_edge(int v1,int v2,int c)<br>{<br>  kraw e;<br>  e.v=v2; e.c=c; e.f=0; t[v1].PB(e);<br>  e.v=v1; e.c=0; e.f=0; t[v2].PB(e);<br>}<br> <br>int v2;<br> <br>bool bfs(int v)<br>{<br>  REP(i,n) tab[i]=-1;<br>  tab[v]=0;<br>  int kol[n],p,k;<br>  kol[0]=v; p=k=0;<br>  while (p&lt;=k)<br>  {<br>    v=kol[p++];<br>    FOREACH(it,t[v])<br>      if (tab[it-&gt;v]==-1 &amp;&amp; c[v][it-&gt;v]&gt;0)<br>      {<br>        tab[it-&gt;v]=tab[v]+1; kol[++k]=it-&gt;v;<br>      }<br>  }<br>  return (tab[v2]!=-1);<br>}<br> <br>int dfs(int v,int mi)<br>{<br>  int wyn=0,y;<br>  if (v==v2 || !mi) return mi;<br>  for (vector&lt;kraw&gt;::iterator &amp;it=poz[v]; it!=t[v].end(); ++it)<br>  {<br>    if (tab[v]+1==tab[it-&gt;v] &amp;&amp; c[v][it-&gt;v]) <br>    {<br>      y=dfs(it-&gt;v,min(mi,c[v][it-&gt;v]));<br>      c[v][it-&gt;v]-=y; c[it-&gt;v][v]+=y;<br>      wyn+=y; mi-=y;<br>      if (!mi) break;<br>    }<br>  }<br>  return wyn;<br>}<br> <br>/* Maksymalny przeplyw */<br>int maxflow(int pocz,int kon)<br>{<br>  int wyn=0;<br>  v2=kon;<br>  memset(c,0,sizeof(c));<br>  REP(i,n) REP(j,(int)t[i].size())<br>    c[i][t[i][j].v]+=t[i][j].c;<br>  REP(i,n) REP(j,n) c0[i][j]=c[i][j];<br>  while (bfs(pocz))<br>  {<br>    REP(i,n) poz[i]=t[i].begin();<br>    wyn+=dfs(pocz,INFTY);<br>  }<br>  /* Odzyskujemy przeplyw */<br>  REP(i,n) FOREACH(it,t[i])<br>  {<br>    it-&gt;f=max(0, min(it-&gt;c,c0[i][it-&gt;v]-c[i][it-&gt;v]));<br>    c[i][it-&gt;v]+=it-&gt;f;<br>  }<br>  return wyn;<br>}<br> <br>int X[]={0,0,1,-1};<br>int Y[]={1,-1,0,0};<br> <br>inline bool ins(int f,int g) { return f&gt;=0 &amp;&amp; f&lt;g; }<br> <br>class PrinceOfPersia<br>{<br>  public:<br>  int minObstacles(vector &lt;string&gt; t)<br>  {<br>    int x=t.size(),y=t[0].size();<br>    PII p,k; p.FI=k.FI=-1;<br>    REP(i,x) REP(j,y) if (t[i][j]=='P')<br>    {<br>      if (p.FI&lt;0) p=MP(i,j); else k=MP(i,j);<br>    }<br>    n=x*y*2;<br>    REP(i,x) REP(j,y) if (t[i][j]!='#') add_edge(i*y+j,i*y+j+x*y,1);<br>    REP(i,x) REP(j,y) REP(k,4)<br>    {<br>      int a=i+X[k],b=j+Y[k];<br>      if (ins(a,x) &amp;&amp; ins(b,y))<br>        add_edge(i*y+j+x*y,a*y+b,200);<br>    }<br>    int w=maxflow(p.FI*y+p.SE+x*y,k.FI*y+k.SE);<br>    if (w&gt;100) return -1;<br>    return w;<br>  }<br>  <br> <br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>