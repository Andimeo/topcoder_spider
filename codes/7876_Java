<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br><br>public class PrinceOfPersia {<br>        final static int INF = 1000000;<br><br>        public int minObstacles(String[] maze) {<br>            int height = maze.length;<br>            int width = maze[0].length();<br>            int n = 2 * height * width + 2;<br>            int d = height * width;<br>            int s = n - 2;<br>            int t = n - 1;<br>            int nP = 0;<br>            int[][] c = new int[n][n];<br>            for (int r1 = 0; r1 &lt; height; ++r1)<br>                for (int c1 = 0; c1 &lt; width; ++c1)<br>                    for (int dr = -1; dr &lt;= 1; ++dr)<br>                        for (int dc = -1; dc &lt;= 1; ++dc)<br>                            if (dr == 0 ^ dc == 0) {<br>                                int r2 = r1 + dr;<br>                                int c2 = c1 + dc;<br>                                if (r2 &gt;= 0 &amp;&amp; r2 &lt; height &amp;&amp; c2 &gt;= 0 &amp;&amp; c2 &lt; width) {<br>                                    int p1 = r1 * width + c1;<br>                                    int p2 = r2 * width + c2;<br>                                    c[p1 + d][p2] = INF;<br>                                }<br>                            }<br>            for (int i = 0; i &lt; d; ++i) {<br>                int r1 = i / width;<br>                int c1 = i % width;<br>                char ch = maze[r1].charAt(c1);<br>                c[i][i + d] = 1;<br>                if (ch == 'P') {<br>                    ++nP;<br>                    if (nP == 1)<br>                        c[s][i + d] = INF;<br>                    else<br>                        c[i][t] = INF;<br>                } else if (ch == '#') {<br>                    c[i][i + d] = 0;<br>                }<br>            }<br>            int res = flow(n, s, t, c);<br>            if (res &gt; INF / 2)<br>                return -1;<br>            else<br>                return res;<br>        }<br><br>    int n;<br>    int s;<br>    int t;<br>    int[][] c;<br>    boolean[] mark;<br><br>    private int flow(int n, int s, int t, int[][] c) {<br>        this.n = n;<br>        this.s = s;<br>        this.t = t;<br>        this.c = c;<br>        int res = 0;<br>        while (true) {<br>            mark = new boolean[n];<br>            int z = dfs(s, INF);<br>            if (z == 0)<br>                break;<br>            res += z;<br>        }<br>        return res;<br>    }<br><br>    private int dfs(int at, int by) {<br>        if (at == t)<br>            return by;<br>        if (mark[at])<br>            return 0;<br>        mark[at] = true;<br>        for (int i = 0; i &lt; n; ++i)<br>            if (c[at][i] &gt; 0) {<br>                int z = dfs(i, Math.min(by, c[at][i]));<br>                if (z &gt; 0) {<br>                    c[at][i] -= z;<br>                    c[i][at] += z;<br>                    return z;<br>                }<br>            }<br>        return 0;<br>    }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>