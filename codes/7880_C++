<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;stack&gt;<br>#include &lt;queue&gt;<br>#include &lt;utility&gt;<br>#include &lt;complex&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;numeric&gt;<br>#include &lt;functional&gt;<br>#include &lt;iterator&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cassert&gt;<br>#include &lt;cstring&gt;<br><br>using namespace std;<br><br>#define RA(x) (x).begin(), (x).end()<br>#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)<br>#define SZ(x) ((int) (x).size())<br><br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef pair&lt;int, int&gt; pii;<br>typedef complex&lt;double&gt; pnt;<br>typedef long double ld;<br>typedef long long ll;<br><br>template&lt;class T&gt;<br>static void splitstr(const string &amp;s, vector&lt;T&gt; &amp;out)<br>{<br>    istringstream in(s);<br>    out.clear();<br>    copy(istream_iterator&lt;T&gt;(in), istream_iterator&lt;T&gt;(), back_inserter(out));<br>}<br><br>template&lt;class T&gt; static T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }<br><br>struct board<br>{<br>    int vals[5][5];<br>    int turns;<br><br>    int *operator[](int r) { return vals[r]; }<br>    const int *operator[](int r) const { return vals[r]; }<br>    bool operator &lt;(const board &amp;b) const<br>    {<br>        if (turns != b.turns) return turns &lt; b.turns;<br>        return lexicographical_compare(&amp;vals[0][0], &amp;vals[0][0] + 25, &amp;b.vals[0][0], &amp;b.vals[0][0] + 25); <br>    }               <br>};<br><br>static map&lt;board, board&gt; cache;<br>static int R, C;<br>static int inc;<br><br>static inline void apply1(int &amp;v)<br>{<br>    if (v == 0) return;<br>    v += inc;<br>    v = v &lt; 1 ? 3 : v &gt; 3 ? 1 : v;<br>}<br><br>static inline void apply(board &amp;b, int d, int ul, int s)<br>{<br>    int p, q;<br>    switch (d)<br>    {<br>        case 0:<br>            p = ul ? s : 0;<br>            q = ul ? R : s;<br>            for (int i = p; i &lt; q; i++)<br>                for (int j = 0; j &lt; C; j++)<br>                    apply1(b[i][j]);<br>            break;<br>        case 1:<br>            p = ul ? s : 0;<br>            q = ul ? C : s;<br>            for (int i = p; i &lt; q; i++)<br>                for (int j = 0; j &lt; R; j++)<br>                    apply1(b[j][i]);<br>            break;<br>    }<br>}<br><br>static void get_cnts(const board &amp;b, int *out)<br>{<br>    fill(out, out + 4, 0);<br>    for (int i = 0; i &lt; R; i++)<br>        for (int j = 0; j &lt; C; j++)<br>            out[b[i][j]]++;<br>}<br><br>static void dump(const board &amp;b)<br>{<br>    printf("%d\n", b.turns);<br>    for (int i = 0; i &lt; R; i++)<br>    {<br>        for (int j = 0; j &lt; C; j++)<br>            printf("%d", b[i][j]);<br>        printf("\n");<br>    }<br>    printf("\n");<br>}<br><br>static board recurse(const board &amp;state, int play)<br>{<br>    if (cache.count(state)) return cache[state];<br>    if (state.turns == 0) return cache[state] = state;<br><br>    board best, bestn;<br>    int bestp = -1;<br>    for (int d = 0; d &lt; 2; d++)<br>        for (int ul = 0; ul &lt; 2; ul++)<br>        {<br>            int mx = d ? C : R;<br>            for (int i = 1; i &lt; mx; i++)<br>            {<br>                board nxt = state;<br>                apply(nxt, d, ul, i);<br>                nxt.turns--;<br>                board final = recurse(nxt, play % 3 + 1);<br>                int cnts[4] = {0};<br>                get_cnts(final, cnts);<br>                int prio = 0;<br>                int mx = *max_element(cnts + 1, cnts + 4);<br>                if (cnts[play] == mx &amp;&amp; count(cnts + 1, cnts + 4, mx) == 1)<br>                    prio += 10000;<br>                if (cnts[play] == mx)<br>                    prio += 1000;<br>                prio += cnts[play];<br>                if (prio &gt; bestp)<br>                {<br>                    bestp = prio;<br>                    best = final;<br>                    bestn = nxt;<br>                }<br>            }<br>        }<br>    //printf("----\n");<br>    //dump(state);<br>    //dump(bestn);<br>    //dump(best);<br>    //printf("----\n");<br>    return cache[state] = best;<br>}<br><br>// I didn't expect a sort of Spanish inquisition<br>class Inc <br>{<br>public:<br>    vector &lt;string&gt; finalBoard(vector &lt;string&gt; ib, int inc, int turns) <br>    {<br>        ::inc = inc;<br>        R = ib.size();<br>        C = ib[0].size();<br>        board init;<br>        init.turns = turns;<br>        for (int i = 0; i &lt; R; i++)<br>            for (int j = 0; j &lt; C; j++)<br>                init[i][j] = (ib[i][j] == '.') ? 0 : ib[i][j] - '0';<br>        board final = recurse(init, 1);<br>        for (int i = 0; i &lt; R; i++)<br>            for (int j = 0; j &lt; C; j++)<br>                if (ib[i][j] != '.') ib[i][j] = final[i][j] + '0';<br>        return ib;<br>    }<br>};<br><br><br><br>// Powered by FileEdit<br></td>