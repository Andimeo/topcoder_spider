<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class NowhereLand {<br>    class Edge {<br>        int s;<br>        int t;<br>        int c;<br>        int f;<br>        Edge r;<br>        boolean good;<br> <br>        public Edge(int s, int t, int c) {<br>            this.s = s;<br>            this.t = t;<br>            this.c = c;<br>            this.f = 0;<br>        }<br>    }<br> <br>    class Graph {<br>        int n;<br>        ArrayList&lt;Edge&gt; edges[];<br> <br>        public Graph(int n) {<br>            this.n = n;<br>            edges = new ArrayList[n];<br>            for (int i = 0; i &lt; n; i++) {<br>                edges[i] = new ArrayList&lt;Edge&gt;();<br>            }<br>        }<br> <br>        Edge addEdge(int s, int t, int c) {<br>            Edge ef = new Edge(s, t, c);<br>            Edge er = new Edge(t, s, 0);<br>            ef.r = er;<br>            er.r = ef;<br>            edges[s].add(ef);<br>            edges[t].add(er);<br>            return ef;<br>        }<br> <br>        Edge addEdge2(int s, int t, int c) {<br>            Edge ef = new Edge(s, t, c);<br>            Edge er = new Edge(t, s, 0);<br>            ef.r = er;<br>            ef.good = true;<br>            er.r = ef;<br>            edges[s].add(ef);<br>            edges[t].add(er);<br>            return ef;<br>        }<br> <br>        boolean[] u;<br> <br>        int dfs(int i, int t, int c) {<br>            if (i == t) {<br>                return c;<br>            }<br>            u[i] = true;<br> <br>            for (Edge e : edges[i]) {<br>                if (e.f &lt; e.c &amp;&amp; !u[e.t]) {<br>                    int cap = dfs(e.t, t, Math.min(c, e.c - e.f));<br>                    if (cap &gt; 0) {<br>                        e.f += cap;<br>                        e.r.f -= cap;<br>                        return cap;<br>                    }<br>                }<br>            }<br> <br>            return 0;<br>        }<br> <br>        int maxFlow(int s, int t) {<br>            u = new boolean[n];<br> <br>            int flow = 0;<br>            while (true) {<br>                Arrays.fill(u, false);<br>                int df = dfs(s, t, Integer.MAX_VALUE);<br>                if (df == 0) {<br>                    break;<br>                }<br>                flow += df;<br>            }<br> <br>            return flow;<br>        }<br>    }<br> <br>    public int placeGuards(String[] cities, int K, String[] guards, String[] agencies) {<br>        int n = cities.length;<br> <br>        int[][] type = new int[n][K];<br> <br>        for (int i = 0; i &lt; n; i++) {<br>            Scanner s = new Scanner(guards[i]);<br>            while (s.hasNextInt()) {<br>                int j = s.nextInt();<br>                type[i][j] = 1;<br>            }<br>            s = new Scanner(agencies[i]);<br>            while (s.hasNextInt()) {<br>                int j = s.nextInt();<br>                if (type[i][j] != 1) {<br>                    type[i][j] = 2;<br>                }<br>            }<br>        }<br> <br>        int r = 0;<br>        for (int i = 0; i &lt; K; i++) {<br>            int[] v = new int[n];<br>            int m = 0;<br>            for (int j = 0; j &lt; n; j++) {<br>                if (type[j][i] == 2) {<br>                    v[j] = m++;<br>                }<br>            }<br>            Graph g = new Graph(m + 2);<br>            for (int j = 0; j &lt; n; j++) {<br>                for (int k = 0; k &lt; n; k++) {<br>                    if (type[j][i] != type[k][i] || type[j][i] == 2) {<br>                        if (cities[j].charAt(k) == '1') {<br>                            if (type[j][i] == 1 &amp;&amp; type[k][i] == 0) {<br>                                r++;<br>                            } else if (type[j][i] == 1 &amp;&amp; type[k][i] == 2) {<br>                                g.addEdge(m, v[k], 1);<br>                            } else if (type[j][i] == 2 &amp;&amp; type[k][i] == 0) {<br>                                g.addEdge(v[j], m + 1, 1);<br>                            } else if (type[j][i] == 2 &amp;&amp; type[k][i] == 2) {<br>                                g.addEdge(v[j], v[k], 1);<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br>            r += g.maxFlow(m, m + 1);<br>        }<br>        return r;<br>    }<br> <br>}<br> <br> <br>// Powered by PopsEdit<br> <br>// Powered by CodeProcessor<br></td>