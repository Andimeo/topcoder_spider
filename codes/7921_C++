<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cctype&gt;<br> <br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;string&gt;<br>#include &lt;sstream&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br> <br>using namespace std;<br> <br>#define TRACE(x...) <br>#define WATCH(x...) TRACE( cout &lt;&lt; #x " = " &lt;&lt; x &lt;&lt; "\n" )<br>#define PRINT(x...) TRACE( printf (x) )<br> <br>#define REP(i, x) for (int i = 0; i &lt; x; ++i)<br>#define FOR(i, x, y) for (int i = x; i &lt; y; ++i)<br>#define FORE(i, x) for (typeof(x.begin()) i = x.begin(); i != x.end(); i++)<br> <br>#define SZ(x) int(x.size())<br>#define ALL(x) x.begin(), x.end()<br>#define PB push_back<br>#define MP make_pair<br> <br>int tam[110];<br>int label[110];<br> <br>class RoadReconstruction {<br> <br>  public:<br>  <br>  void unionSet (int a, int b) {<br>    if (tam[a] &lt; tam[b]) {<br>      tam[b] += tam[a];<br>      tam[a] = 1;<br>      label[a] = label[b];<br>    }<br>    else {<br>      tam[a] += tam[b];<br>      tam[b] = 1;<br>      label[b] = label[a];<br>    }<br>  }<br>  <br>  int findSet (int x) {<br>    if (x != label[x])<br>      label[x] = findSet(label[x]);<br>    return (label[x]);<br>  }<br>  <br>  string selectReconstruction (vector &lt;string&gt; r) {<br>    string ret = "";<br>    vector &lt;string&gt; aux;<br>    string orig, dest, id;<br>    map &lt;string, int&gt; m;<br>    int cid = 0;<br>    int cost;<br>    int add = 0;<br>    vector &lt;pair &lt;int, int&gt; &gt; ok;<br>    vector &lt;pair &lt;int, pair &lt;string, pair &lt;int, int&gt; &gt; &gt; &gt; edges;<br>    <br>    sort(ALL(r));<br>    int n = SZ(r);<br>    <br>    REP(i, n) {<br>      istringstream iss(r[i]);<br>      cost = 0;<br>      iss &gt;&gt; id;<br>      iss &gt;&gt; orig;<br>      iss &gt;&gt; dest;<br>      iss &gt;&gt; cost;<br>      if (m.find(orig) == m.end())<br>        m[orig] = cid++;<br>      if (m.find(dest) == m.end())<br>        m[dest] = cid++;<br>        <br>      WATCH(id);<br>      WATCH(orig);<br>      WATCH(dest);<br>      WATCH(cost);<br>      <br>      if (cost == 0) {<br>        ok.PB(MP(m[orig], m[dest]));<br>      }<br>      else {<br>        edges.PB(MP(cost, MP(id, MP(m[orig], m[dest]))));<br>      }<br>    }<br>    sort(ALL(edges));<br>    REP(i, cid) {<br>      tam[i] = 1;<br>      label[i] = i;<br>    }<br>    REP(i, SZ(ok)) {<br>      int u = ok[i].first;<br>      int v = ok[i].second;<br>      findSet(u);<br>      findSet(v);<br>      if (label[u] != label[v]) {<br>        unionSet(label[u], label[v]);<br>        add++;<br>      }<br>    }<br>    for (int i = 0; i &lt; SZ(edges) &amp;&amp; add &lt; cid - 1; ++i) {<br>      int u = edges[i].second.second.first;<br>      int v = edges[i].second.second.second;<br>      findSet(u);<br>      findSet(v);<br>      if (label[u] != label[v]) {<br>        unionSet(label[u], label[v]);<br>        add++;<br>        aux.PB(edges[i].second.first);<br>      }<br>    }<br>    sort(ALL(aux));<br>    REP(i, SZ(aux)) {<br>      if (i)<br>        ret += " ";<br>      ret += aux[i];<br>    }<br>    if (add == cid - 1)<br>      return (ret);<br>    return ("IMPOSSIBLE");<br>  }<br>  <br>};<br></td>