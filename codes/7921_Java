<td class="problemText" colspan="8" valign="middle" align="left">
            import static java.lang.Math.*;<br>import static java.lang.Integer.*;<br>import static java.lang.Long.*;<br>import static java.math.BigInteger.*;<br>import static java.util.Arrays.*;<br>import static java.util.Collections.*;<br>import java.math.*;<br>import java.text.*;<br>import java.util.*;<br>import java.io.*;<br> <br>class GraphAlgo<br>{<br>  public static final int INF_EDGE = Integer.MAX_VALUE;<br>  public static final int NIL_EDGE = 0;<br>  public static final int NIL_NODE = -1;<br>  /////////////////////// print //////////////////////////////////////////<br> <br>  public void print(int[][] graph, int order)<br>  {<br>    int i, j;<br>    for (i=0; i&lt;order; ++i) {<br>      System.out.printf("%2d:", i);<br>      for (j=0; j&lt;order; ++j)<br>        System.out.printf(" %d", graph[i][j]);<br>      System.out.println();<br>    }<br>    System.out.println();<br>  }<br>    /////////////////////// dfs //////////////////////////////////////////<br> <br>  // return the number of visited vertices<br>  public int dfs(int[][] graph, int order, int cur, boolean[] visited)<br>  {<br>    int ret = 1;      // self<br>    visited[cur] = true;<br>    for (int i=0; i&lt;order; ++i)<br>      if (!visited[i] &amp;&amp; graph[cur][i]!=NIL_EDGE)<br>        ret += dfs(graph, order, i, visited);<br>    return ret;<br>  }<br>  <br>  //////////////////// minimum spanning tree (weighted undirected graph) ///////////////////////////////<br> <br>  public int[][] mstGraph;<br>  <br>  // Prim<br>  public int mst(int[][] graph, int order, int vertex)<br>  {<br>    class V implements Comparable&lt;V&gt; {<br>      int w, v, p;    // weight, vertex, parent<br>      V(int w, int v, int p) { this.w=w; this.v=v; this.p=p; }<br>      public int compareTo(V other) { return w - other.w; }<br>    }<br>    mstGraph = new int[order][order];<br>    for (int i=0; i&lt;order; ++i)<br>      for (int j=0; j&lt;order; ++j)<br>        mstGraph[i][j] = NIL_EDGE;<br> <br>    int ret = 0;<br>    Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;(); // tree node set<br>    Queue&lt;V&gt; q = new PriorityQueue&lt;V&gt;();<br>    q.offer(new V(NIL_EDGE,vertex,vertex));<br>    while (!q.isEmpty()) {<br>      V cur = q.poll();<br>      if (s.contains(cur.v)) continue; // already in tree<br>      s.add(cur.v);<br>      mstGraph[cur.v][cur.p] = mstGraph[cur.p][cur.v] = cur.w;<br>      ret += cur.w;<br>      for (int i=0; i&lt;order; ++i)<br>        if (graph[cur.v][i] != NIL_EDGE)<br>          q.offer(new V(graph[cur.v][i],i,cur.v));<br>    }<br>    return ret;<br>  }<br>}<br> <br>public class RoadReconstruction<br>{<br>  HashMap&lt;String, Integer&gt; city = new HashMap&lt;String,Integer&gt;();<br>  int[][] g;<br>  String[][] name;<br>  int n;<br> <br>  void addcity(String s)<br>  {<br>    if (city.containsKey(s)) return;<br>    city.put(s, n++);<br>  }<br>  <br>  public String selectReconstruction(String[] roads)<br>  {<br>    int i, j, k;<br> <br>    n = 0;<br>    for (String s : roads) {<br>      addcity(s.split(" ")[1]);<br>      addcity(s.split(" ")[2]);<br>    }<br> <br>    g = new int[n][n];<br>    name = new String[n][n];<br> <br>    for (String s : roads) {<br>      String[] all = s.split(" ");<br>      int a = city.get(all[1]);<br>      int b = city.get(all[2]);<br>      if (all.length == 4) {<br>        int v = parseInt(all[3])*10000 + all[0].charAt(0)*10 + all[0].charAt(1);<br>        if (g[a][b] != 1) {<br>          if (g[a][b]==0 || (g[a][b] &gt; v)) {<br>            g[a][b] = g[b][a] = v;<br>        //err.printf("%s: %d %d\n", all[0], g[a][b], parseInt(all[3])*10000);<br>            name[a][b] = name[b][a] = all[0];<br>          }<br>        }<br>      }<br>      else<br>        g[a][b] = g[b][a] = 1;<br>    }<br> <br>    GraphAlgo algo = new GraphAlgo();<br>    <br>    if (algo.dfs(g, n, 0, new boolean[n]) != n)<br>      return "IMPOSSIBLE";<br> <br>    //algo.print(g, n);<br>    algo.mst(g, n, 0);<br> <br>    List&lt;String&gt; res = new ArrayList&lt;String&gt;();<br>    for (i=0; i&lt;n; ++i)<br>      for (j=i; j&lt;n; ++j)<br>        if (algo.mstGraph[i][j] &gt; 1)<br>          res.add(name[i][j]);<br> <br>    sort(res);<br>    String ret = "";<br>    for (String s : res)<br>      ret += s + " ";<br>    if (ret.length() &gt; 0)<br>      ret = ret.substring(0,ret.length()-1);<br>    return ret;<br>  }<br> <br> <br>   PrintStream out = System.out;<br>   PrintStream err = System.err;<br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>