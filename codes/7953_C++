<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br> <br>using namespace std;<br> <br>template&lt;class T&gt; inline void checkmin(T &amp;a,T b){if(b&lt;a) a=b;}<br> <br>const int maxn=25+5;<br>const int oo=1000;<br> <br>class EscapeArtist<br>{<br>public:<br>    int n;<br>    bool G[maxn][maxn];<br>    int D[maxn][maxn];<br>    double C[maxn][maxn];<br>    vector&lt;int&gt; path;<br>    double f[maxn][maxn],r[maxn][maxn];<br>    double calcL(int s,int t)<br>    {<br>        double &amp;r=C[s][t];<br>        if (r&gt;-1.0) return r;<br>        if (s==t) return r=1;<br>        r=0;<br>        for (int i=0;i&lt;n;i++) if (D[s][i]==1 &amp;&amp; D[s][i]+D[i][t]==D[s][t]) r+=calcL(i,t);<br>        return r;<br>    }<br>    double solveC(int s,int t,int d)<br>    {<br>        double &amp;r=f[s][t];<br>        if (r&gt;-1.0) return r;<br>        if (s==t) return 1.0;<br>        r=0;<br>        for (int i=0;i&lt;n;i++) if (D[s][i]==1 &amp;&amp; D[s][i]+D[i][t]==D[s][t]) <br>        {<br>            if (d+1&lt;path.size() &amp;&amp; i==path[d+1]) <br>                continue;<br>            if (d+1&lt;path.size() &amp;&amp; i==path[d] &amp;&amp; s==path[d+1]) <br>                continue;<br>            r+=solveC(i,t,d+1);<br>        }<br>        return r;<br>    }<br>    double getC(int src,int dest)<br>    {<br>        double &amp;ret=r[src][dest];<br>        if (ret&gt;-1.0) return ret;<br>        for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) f[i][j]=-2;<br>        return ret=solveC(src,dest,0);<br>    }<br>    double solve(int src,int dest,int p1,int p2,int step)<br>    {<br>        int d=D[src][dest];<br>        if (step&gt;d) <br>            return (p2!=dest)?0:1;<br>        double result=0.0;<br>        for (int i=0;i&lt;n;i++) if (D[src][i]==step-1)<br>            for (int j=0;j&lt;n;j++) if (G[i][j] &amp;&amp; D[src][i]+1+D[j][dest]==d)<br>                if (p2==j || (i==p2 &amp;&amp; j==p1))<br>                    result+=getC(src,i)*C[j][dest]/getC(src,dest);<br>        return result;<br>    }<br>  double bestRoute(vector &lt;string&gt; corridors, vector &lt;int&gt; agentStart, vector &lt;int&gt; agentTarget, int start, int finish)<br>  {<br>    n=corridors.size();<br>        for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) G[i][j]=corridors[i][j]=='1';<br>        for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) D[i][j]=oo;<br>        for (int i=0;i&lt;n;i++) D[i][i]=0;<br>        for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) if (G[i][j]) D[i][j]=1;<br>        for (int k=0;k&lt;n;k++) for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) checkmin(D[i][j],D[i][k]+D[k][j]);<br>        for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) C[i][j]=-2.0;<br>        for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) calcL(i,j);<br>        double result=1.0;<br>        int nextk=-1,step=0;<br>        path.clear();<br>        for (int k=start;k!=finish;k=nextk)<br>        {<br>            for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) r[i][j]=-2.0;<br>            path.push_back(k);<br>            step++;<br>            double bestr=-1.0;<br>            for (int i=0;i&lt;n;i++) if (G[i][k] &amp;&amp; D[i][finish]+1==D[k][finish])<br>            {<br>                double p=1.0;<br>                for (int v=0;v&lt;agentStart.size();v++)<br>                    p*=(1.0-solve(agentStart[v],agentTarget[v],k,i,step));<br>                if (p&gt;bestr) bestr=p,nextk=i;<br>            }<br>            result*=bestr;<br>        }<br>        return 1.0-result;<br>  }<br>};<br> <br> <br> <br>// Powered by PopsEdit<br></td>