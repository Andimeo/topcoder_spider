<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class CoolRectangles {<br>  public int compress(int[] x1, int[] y1, int[] x2, int[] y2) {<br>    List&lt;int&gt; Xs = new List&lt;int&gt;();<br>    List&lt;int&gt; Ys = new List&lt;int&gt;();<br>    foreach (int a in x1)<br>      if (Xs.IndexOf(a) &lt; 0) Xs.Add(a);<br>    foreach (int a in x2)<br>      if (Xs.IndexOf(a) &lt; 0) Xs.Add(a);<br>    foreach (int a in y1)<br>      if (Ys.IndexOf(a) &lt; 0) Ys.Add(a);<br>    foreach (int a in y2)<br>      if (Ys.IndexOf(a) &lt; 0) Ys.Add(a);<br>    Xs.Sort();<br>    Ys.Sort();<br>    int nx = Xs.Count - 1;<br>    int ny = Ys.Count - 1;<br>    bool[,] hr = new bool[nx + 1, ny + 1];<br>    bool[,] hd = new bool[nx + 1, ny + 1];<br>    for (int i = 0; i &lt; x1.Length; ++i)<br>    {<br>      int cx1 = Xs.IndexOf(x1[i]);<br>      int cy1 = Ys.IndexOf(y1[i]);<br>      int cx2 = Xs.IndexOf(x2[i]);<br>      int cy2 = Ys.IndexOf(y2[i]);<br>      x1[i] = cx1;<br>      y1[i] = cy1;<br>      x2[i] = cx2;<br>      y2[i] = cy2;<br>      for (int j = cx1; j &lt; cx2; ++j)<br>      {<br>        hr[j, cy1] = hr[j, cy2] = true;<br>      }<br>      for (int j = cy1; j &lt; cy2; ++j)<br>      {<br>        hd[cx1, j] = hd[cx2, j] = true;<br>      }<br>    }<br>    int[,] nr = new int[nx + 1, ny + 1];<br>    int[,] nd = new int[nx + 1, ny + 1];<br>    for (int i = nx; i &gt;= 0; --i)<br>      for (int j = ny; j &gt;= 0; --j)<br>      {<br>        if (hr[i, j])<br>          nr[i, j] = 1 + nr[i + 1, j];<br>        if (hd[i, j])<br>          nd[i, j] = 1 + nd[i, j + 1];<br>      }<br>    bool[,,,] valid = new bool[nx + 1, ny + 1, nx + 1, ny + 1];<br>    for (int i = 0; i &lt;= nx; ++i)<br>      for (int j = 0; j &lt;= ny; ++j)<br>        for (int i1 = i + 1; i1 &lt;= nx; ++i1)<br>          for (int j1 = j + 1; j1 &lt;= ny; ++j1)<br>            valid[i, j, i1, j1] = nr[i, j] &gt;= (i1 - i) &amp;&amp; nd[i, j] &gt;= (j1 - j) &amp;&amp; nr[i, j1] &gt;= (i1 - i) &amp;&amp; nd[i1, j] &gt;= (j1 - j);<br>    bool[, , ,] outer = new bool[nx + 1, ny + 1, nx + 1, ny + 1];<br>    for (int sx = 1; sx &lt;= nx; ++sx)<br>      for (int sy = 1; sy &lt;= ny; ++sy)<br>        for (int i1 = sx; i1 &lt;= nx; ++i1)<br>          for (int j1 = sy; j1 &lt;= ny; ++j1)<br>          {<br>            int i = i1 - sx;<br>            int j = j1 - sy;<br>            if (valid[i, j, i1, j1] || outer[i, j, i1, j1])<br>            {<br>              if (i1 &lt; nx)<br>                outer[i, j, i1 + 1, j1] = true;<br>              if (j1 &lt; ny)<br>                outer[i, j, i1, j1 + 1] = true;<br>              if (i &gt; 0)<br>                outer[i - 1, j, i1, j1] = true;<br>              if (j &gt; 0)<br>                outer[i, j - 1, i1, j1] = true;<br>            }<br>          }<br>    List&lt;int&gt; rx1 = new List&lt;int&gt;();<br>    List&lt;int&gt; rx2 = new List&lt;int&gt;();<br>    List&lt;int&gt; ry1 = new List&lt;int&gt;();<br>    List&lt;int&gt; ry2 = new List&lt;int&gt;();<br>    for (int i = 0; i &lt;= nx; ++i)<br>      for (int j = 0; j &lt;= ny; ++j)<br>        for (int i1 = i + 1; i1 &lt;= nx; ++i1)<br>          for (int j1 = j + 1; j1 &lt;= ny; ++j1)<br>            if (valid[i, j, i1, j1] &amp;&amp; !outer[i, j, i1, j1])<br>            {<br>              rx1.Add(i);<br>              rx2.Add(i1);<br>              ry1.Add(j);<br>              ry2.Add(j1);<br>            }<br>    int m = rx1.Count;<br>    n = x1.Length;<br>    can = new bool[m, n];<br>    int[] cost = new int[m];<br>    for (int i = 0; i &lt; m; ++i)<br>    {<br>      cost[i] = (Xs[rx2[i]] - Xs[rx1[i]]) * (Ys[ry2[i]] - Ys[ry1[i]]);<br>      for (int j = 0; j &lt; n; ++j)<br>        can[i, j] = (rx1[i] &gt;= x1[j] &amp;&amp; rx2[i] &lt;= x2[j] &amp;&amp; ry1[i] &gt;= y1[j] &amp;&amp; ry2[i] &lt;= y2[j]);<br>    }<br>    int[] perm = new int[m];<br>    for (int i = 0; i &lt; m; ++i)<br>      perm[i] = i;<br>    Array.Sort(cost, perm);<br>    int res = 0;<br>    int size = 0;<br>    pair = new int[n];<br>    for (int i = 0; i &lt; n; ++i)<br>      pair[i] = -1;<br>    for (int i = 0; i &lt; m; ++i)<br>    {<br>      int cur = perm[i];<br>      mark = new bool[m];<br>      if (dfs(cur))<br>      {<br>        res += cost[i];<br>        ++size;<br>      }<br>    }<br>    if (size == n)<br>      return res;<br>    else<br>      return -1;<br>  }<br><br>  private bool dfs(int at)<br>  {<br>    if (mark[at])<br>      return false;<br>    mark[at] = true;<br>    for (int i = 0; i &lt; n; ++i)<br>      if (can[at, i])<br>      {<br>        if (pair[i] &lt; 0 || dfs(pair[i]))<br>        {<br>          pair[i] = at;<br>          return true;<br>        }<br>      }<br>    return false;<br>  }<br><br>  bool[,] can;<br>  int n;<br>  int[] pair;<br>  bool[] mark;<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>