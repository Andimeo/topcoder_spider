<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;iostream&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;stack&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>using namespace std;<br> <br>typedef long long LL;<br>#define MP(a,b) make_pair(a,b)<br>#define ST first<br>#define ND second<br> <br>typedef vector &lt;int &gt; VI;<br>#define REP(i,n) for (int i=0; i&lt;n; ++i)<br>#define FOREACH(it,x) for(__typeof((x).begin()) it=(x.begin()); it!=(x).end(); ++it)<br>#define FOR(i,p,k) for (int i=p; i&lt;=k; ++i)<br>#define PB push_back<br>#define ALL(x) x.begin(),x.end()<br>#define SIZE(x) (int)x.size()<br> <br>const int INF = 1000000001;<br>const int MAXN=100000;<br>struct Edge{<br>  int v,rev,c,koszt;<br>  Edge(int vv,int rrev,int cc,int kkoszt) : v(vv), rev(rrev), c(cc), koszt(kkoszt) {}<br>  Edge(){}<br>};<br>vector&lt;Edge&gt; kraw[MAXN];<br>int parent[MAXN],parent_kraw[MAXN];<br>int used[MAXN],dist[MAXN],pot[MAXN];<br>void AddEdge(int a,int b,int c,int koszt){<br>  kraw[a].PB(Edge(b,SIZE(kraw[b])+(a==b),c,koszt));<br>  kraw[b].PB(Edge(a,SIZE(kraw[a])-1,0,-koszt));<br>}<br> <br>pair&lt;int,LL&gt; MinCostMaxFlow(int beg,int end,int n){<br>  int res=0;<br>  LL koszt=0;<br>  REP(i,n) pot[i]=0; //poczatkowy potencjal, zakladam, ze poczatkowo<br>                     //wszystkie wagi sa nieujemne, jesli moba byc ujemne,<br>                     //to trzeba obliczyc poczatkowe potencjaly Bellmanem-Fordem<br>  while (1){<br>    REP(i,n) dist[i]=INF,used[i]=0; <br>    dist[beg]=0;<br>    //algorytm Dijkstry, mozna zmienic na wersje z kopcem dla grafu rzadkiego<br>    REP(k,n){<br>      int best=-1;<br>      REP(i,n) if (!used[i] &amp;&amp; (best==-1 || dist[i]&lt;dist[best])) best=i;<br>      used[best]=1;<br>      if (dist[best]==INF) break;<br>      FOREACH(it,kraw[best]) if (it-&gt;c&gt;0){<br>        int x=it-&gt;koszt-pot[it-&gt;v]+pot[best];<br>        if (dist[it-&gt;v]&gt;dist[best]+x){<br>          dist[it-&gt;v]=dist[best]+x;<br>          parent[it-&gt;v]=best;<br>          parent_kraw[it-&gt;v]=it-kraw[best].begin();<br>        }<br>      }<br>    }<br> <br>    if (dist[end]==INF) break; //brak sciezki powiekszajacej<br>    REP(i,n) dist[i]+=pot[i],pot[i]=dist[i]; //uaktualnienie potencjalu<br> <br>    int cap=INF; //minimalna przepustowosc na sciezce<br>    int x=end;<br>    do{<br>      cap=min(cap,kraw[parent[x]][parent_kraw[x]].c);<br>      x=parent[x];<br>    } while (x!=beg);<br>    res+=cap;<br> <br>    x=end;<br>    do{<br>      koszt+=kraw[parent[x]][parent_kraw[x]].koszt*(LL)cap;<br>      kraw[parent[x]][parent_kraw[x]].c-=cap;<br>      kraw[x][kraw[parent[x]][parent_kraw[x]].rev].c+=cap;<br>      x=parent[x];<br>    } while (x!=beg);<br>  }<br>  return MP(res,koszt);<br>}<br> <br>const int N=510;<br>VI v,x1,x2,y1,y2;<br>int vis[N][N];<br>int n;<br>int odwiedzone;<br>int maxx,minx,maxy,miny;<br>map&lt;int,int&gt; mapa;<br> <br>int nalezy(int i,int j,int k){<br>  if (i&lt;0 || j&lt;0) return 0;<br>  int a=mapa[x1[k]];<br>  int b=mapa[x2[k]];<br>  if (!(i&gt;=a &amp;&amp; i&lt;b)) return 0;<br>  a=mapa[y1[k]];<br>  b=mapa[y2[k]];<br>  if (!(j&gt;=a &amp;&amp; j&lt;b)) return 0;<br>  return 1;<br>}<br> <br>int gdzies_nalezy(int i,int j){<br>  REP(k,n) if (nalezy(i,j,k)) return 1;<br>  return 0;<br>}<br> <br>int dx[]={0,0,1,-1};<br>int dy[]={1,-1,0,0};<br> <br>void dfs(int i,int j){<br>  vis[i][j]=1;<br>  odwiedzone++;<br>  minx&lt;?=i; maxx&gt;?=i;<br>  miny&lt;?=j; maxy&gt;?=j;<br>  REP(ruch,4){<br>    int ni=i+dx[ruch];<br>    int nj=j+dy[ruch];<br>    if (ni&gt;=0 &amp;&amp; nj&gt;=0 &amp;&amp; ni&lt;SIZE(v) &amp;&amp; nj&lt;SIZE(v) &amp;&amp; !vis[ni][nj]){<br>      int ok=1;<br>      REP(k,n) if (nalezy(i,j,k) &amp;&amp; !nalezy(ni,nj,k) || !nalezy(i,j,k) &amp;&amp; nalezy(ni,nj,k)){<br>        ok=0;<br>        break;<br>      }<br>      if (ok) dfs(ni,nj);<br>    }<br>  }<br>}<br> <br>    class CoolRectangles<br>        { <br>        public: <br>        int compress(vector &lt;int&gt; _x1, vector &lt;int&gt; _y1, vector &lt;int&gt; _x2, vector &lt;int&gt; _y2){ <br>          x1=_x1; x2=_x2; y1=_y1; y2=_y2;<br>          n=SIZE(x1);<br>          FOREACH(it,x1) v.PB(*it);<br>          FOREACH(it,x2) v.PB(*it);<br>          FOREACH(it,y1) v.PB(*it);<br>          FOREACH(it,y2) v.PB(*it);<br>          sort(ALL(v));<br>          v.erase(unique(ALL(v)),v.end());<br>          REP(i,SIZE(v)) mapa[v[i]]=i;<br>          int k=SIZE(v);<br>          int prostokaty=0;<br>          REP(i,n) AddEdge(0,i+1,1,0);<br>          REP(i,k-1) REP(j,k-1) if (!vis[i][j] &amp;&amp; gdzies_nalezy(i,j)){<br>            minx=N,maxx=-1;<br>            miny=N,maxy=-1;<br>            odwiedzone=0;<br>            dfs(i,j);<br>            if ((maxx-minx+1)*(maxy-miny+1)==odwiedzone){<br>              prostokaty++;<br>              int pole=(v[maxx+1]-v[minx])*(v[maxy+1]-v[miny]);<br>              REP(a,n) if (nalezy(i,j,a)) AddEdge(a+1,n+prostokaty,1,pole);<br>            }<br>          }<br>          cout &lt;&lt; prostokaty &lt;&lt; endl;<br>          int wierzcholki=n+prostokaty+2;<br>          REP(i,prostokaty) AddEdge(n+1+i,wierzcholki-1,1,0);<br>          pair&lt;int,LL&gt; p=MinCostMaxFlow(0,wierzcholki-1,wierzcholki);<br>          if (p.ST!=n) return -1;<br>          return (int)p.ND;<br>        } <br>        <br> <br>         }; <br> <br>    <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>