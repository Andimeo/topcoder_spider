<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;fstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;queue&gt;<br>using namespace std;<br><br>#define Min(a,b) ((a)&gt;(b)?(b):(a))<br>#define Max(a,b) ((a)&gt;(b)?(a):(b))<br>#define prr make_pair<br><br>//typedef __int64 ll;<br><br>class WeighingScale<br>{ <br>  public:<br>  int n,m;<br>  vector&lt;string&gt; map;<br>  int l[60], r[60];<br>  bool adjust()<br>  {<br>    int i,j;<br>    for (;;)<br>    {<br>      int bakl[60], bakr[60];<br>      memcpy(bakl,l,sizeof(l));<br>      memcpy(bakr,r,sizeof(r));<br>      for (i=0; i&lt;n; i++)<br>        for (j=0; j&lt;n; j++)<br>          if (map[i][j]=='=')<br>          {<br>            l[i] = l[j] = Max(l[i],l[j]);<br>            r[i] = r[j] = Min(r[i],r[j]);<br>          }<br>          else if (map[i][j]=='+')<br>          {<br>            l[i] = Max(l[i], l[j]+10);<br>            r[j] = Min(r[j], r[i]-10);<br>          } else if (map[i][j]=='-')<br>          {<br>            swap(i,j);<br>            l[i] = Max(l[i], l[j]+10);<br>            r[j] = Min(r[j], r[i]-10);<br>            swap(i,j);<br>          }<br>      for (i=0; i&lt;n; i++)<br>        if (l[i]&gt;r[i]) return false;<br>      bool okay = true;<br>      for (i=0; i&lt;n; i++)<br>        if (l[i]!=bakl[i]||r[i]!=bakr[i])<br>        {<br>          okay = false;<br>          break;<br>        }<br>      if (okay) return true;<br>    }<br>  }<br>    int OPT[60][60], COUNT;<br>    int TYPE[60][60];<br>  void put(int a, int b, int t)<br>  {<br>    if (TYPE[a][b]!=0&amp;&amp;TYPE[a][b]!=t+1)<br>    {<br>      TYPE[a][b] = -1;<br>      return;<br>    }<br>    TYPE[a][b] = t+1;<br>    OPT[a][b]++;<br>  }<br>  vector &lt;int&gt; count(vector &lt;string&gt; _map, int A, int B) <br>  {<br>    int i,j,k,u;<br>    map = _map;<br>    n = map.size();<br>    <br>    for (i=0; i&lt;n; i++)<br>      l[i]=10, r[i] = 30;<br>    adjust();<br><br>    int bakl[60], bakr[60];<br>    memcpy(bakl,l,sizeof(l));<br>    memcpy(bakr,r,sizeof(r));<br><br>    COUNT = 0;<br>    memset(TYPE,0,sizeof(TYPE));<br>    memset(OPT,0,sizeof(OPT));<br>    for (i=bakl[A]; i&lt;=bakr[A]; i+=10)<br>    {<br>      l[A] = r[A] = i;<br>      if (adjust())<br>      {<br>        int bakl2[60], bakr2[60];<br>        memcpy(bakl2,l,sizeof(l));<br>        memcpy(bakr2,r,sizeof(r));<br>        for (j=bakl2[B]; j&lt;=bakr2[B]; j+=10)<br>        {<br>          l[B] = r[B] = j;<br>          if (adjust())<br>          {<br>            COUNT++;<br>            for (k=0; k&lt;n; k++) if (k!=A&amp;&amp;k!=B)<br>              for (u=k+1; u&lt;n; u++) if (u!=A&amp;&amp;u!=B)<br>              {<br>                if (l[k]+l[u]&gt;l[A]+l[B])<br>                  put(k,u,2);<br>                if (l[k]==r[k]&amp;&amp;l[u]==r[u]&amp;&amp;l[k]+l[u]==l[A]+l[B])<br>                  put(k,u,1);<br>                if (r[k]+r[u]&lt;l[A]+l[B])<br>                  put(k,u,0);<br>              }<br>          }<br>          memcpy(l,bakl2,sizeof(l));<br>          memcpy(r,bakr2,sizeof(r));<br>        }<br>      }<br>      memcpy(l,bakl,sizeof(l));<br>      memcpy(r,bakr,sizeof(r));<br>    }<br><br>    vector&lt;int&gt; ans;<br>    ans.push_back(0);<br>    ans.push_back(0);<br>    ans.push_back(0);<br>    for (i=0; i&lt;n; i++)<br>      for (j=i+1; j&lt;n; j++)<br>        if (TYPE[i][j]!=0&amp;&amp;TYPE[i][j]!=-1&amp;&amp;OPT[i][j]==COUNT)<br>          ans[TYPE[i][j]-1]++;<br>    return ans;<br>  }<br>  <br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>