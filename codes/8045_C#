<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class MarbleMachine {<br>    const int PERIOD = 60;<br>    string[] layout;<br>    string[] actions;<br>    int[] at;<br>    long[] am;<br>    List&lt;int&gt;[] transit;<br>    int height;<br>    int width;<br>    int n;<br><br>  public long maxMarbles(string[] layout, string[] actions, int t) {<br>        this.layout = layout;<br>        this.actions = actions;<br>        height = layout.Length;<br>        width = layout[0].Length;<br>        at = new int[actions.Length];<br>        am = new long[height * width];<br>        transit = new List&lt;int&gt;[height * width];<br>        for (int i = 0; i &lt; height * width; ++i) {<br>            transit[i] = new List&lt;int&gt;();<br>            transit[i].Add(i);<br>        }<br>        for (int i = 0; i &lt; PERIOD; ++i)<br>        {<br>            oneStep();<br>        }<br>        n = height * width + 1;<br>        long[,] m = new long[n, n];<br>        for (int i = 0; i &lt; n - 1; ++i)<br>        {<br>            m[i, n - 1] = am[i];<br>            foreach (int x in transit[i])<br>            {<br>                m[i, x] = 1;<br>            }<br>        }<br>        m[n - 1, n - 1] = 1;<br>        m = pow(m, t / PERIOD);<br>        for (int i = 0; i &lt; n - 1; ++i)<br>            am[i] = m[i, n - 1];<br>        for (int i = 0; i &lt; t % PERIOD; ++i)<br>            oneStep();<br>        long res = 0;<br>        foreach (long x in am)<br>            res = Math.Max(res, x);<br>        return res;<br>  }<br><br>    private long[,] pow(long[,] m, int a)<br>    {<br>        if (a == 0)<br>        {<br>            long[,] res = new long[n, n];<br>            for (int i = 0; i &lt; n; ++i)<br>                res[i, i] = 1;<br>            return res;<br>        }<br>        else if (a % 2 == 0)<br>        {<br>            long[,] b = pow(m, a / 2);<br>            return mul(b, b);<br>        }<br>        else<br>        {<br>            return mul(m, pow(m, a - 1));<br>        }<br>    }<br><br>    private long[,] mul(long[,] a, long[,] b)<br>    {<br>        long[,] res = new long[n, n];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>            {<br>                long z = 0;<br>                for (int k = 0; k &lt; n; ++k)<br>                    z += a[i, k] * b[k, j];<br>                res[i, j] = z;<br>            }<br>        return res;<br>    }<br><br>    private void oneStep()<br>    {<br>        long[] newAm = new long[height * width];<br>        List&lt;int&gt;[] newTransit = new List&lt;int&gt;[height * width];<br>        for (int i = 0; i &lt; height * width; ++i)<br>            newTransit[i] = new List&lt;int&gt;();<br>        for (int i = 0; i &lt; height * width; ++i)<br>        {<br>            int row = i / width;<br>            int col = i % width;<br>            int color = layout[row][col] - '0';<br>            char ch = actions[color][at[color]];<br>            switch (ch)<br>            {<br>                case 'N':<br>                    if (row &gt; 0)<br>                    {<br>                        newAm[i - width] += am[i];<br>                        newTransit[i - width].AddRange(transit[i]);<br>                    }<br>                    break;<br>                case 'S':<br>                    if (row &lt; height - 1)<br>                    {<br>                        newAm[i + width] += am[i];<br>                        newTransit[i + width].AddRange(transit[i]);<br>                    }<br>                    break;<br>                case 'W':<br>                    if (col &gt; 0)<br>                    {<br>                        newAm[i - 1] += am[i];<br>                        newTransit[i - 1].AddRange(transit[i]);<br>                    }<br>                    break;<br>                case 'E':<br>                    if (col &lt; width - 1)<br>                    {<br>                        newAm[i + 1] += am[i];<br>                        newTransit[i + 1].AddRange(transit[i]);<br>                    }<br>                    break;<br>                case 'D':<br>                    break;<br>                default:<br>                    newAm[i] += am[i];<br>                    newTransit[i].AddRange(transit[i]);<br>                    newAm[i] += (ch - '0');<br>                    break;<br>            }<br>        }<br>        am = newAm;<br>        transit = newTransit;<br>        for (int i = 0; i &lt; actions.Length; ++i)<br>        {<br>            at[i] = (at[i] + 1) % actions[i].Length;<br>        }<br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>