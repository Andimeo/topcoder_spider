<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class PartialSeries {<br>  const int MAXV = 11;<br>  const int INF = 10000;<br>  int[] series;<br>  int[] available;<br>  int n;<br>  int m;<br>  <br>  class State<br>  {<br>    public int at;<br>    public int have;<br>    public int first;<br>    public int delta;<br><br>    public State(int at, int have, int first, int delta)<br>    {<br>      this.at = at;<br>      this.have = have;<br>      this.first = first;<br>      this.delta = delta;<br>    }<br><br>    public override int GetHashCode()<br>    {<br>      int result = at;<br>      result = 29 * result + have;<br>      result = 29 * result + first;<br>      result = 29 * result + delta;<br>      return result;<br>    }<br><br>    public override bool Equals(object obj)<br>    {<br>      State state = (State) obj;<br>      if (at != state.at) return false;<br>      if (have != state.have) return false;<br>      if (first != state.first) return false;<br>      if (delta != state.delta) return false;<br>      return true;<br>    }<br>  }<br><br>  Dictionary&lt;State, int&gt; cache;<br>  <br>  public int[] getFirst(int[] series, int[] available) {<br>    this.series = series;<br>    this.available = available;<br>    n = series.Length;<br>    m = available.Length;<br>    cache = new Dictionary&lt;State, int&gt;();<br>    int need = INF;<br>    int st = -1;<br>    for (int start = 0; start &lt; MAXV; ++start)<br>    {<br>      int cur = get(0, (1 &lt;&lt; m) - 1, start, 2);<br>      if (cur &lt; need)<br>      {<br>        st = start;<br>        need = cur;<br>      }<br>    }<br>    int[] res = new int[n];<br>    res[0] = st;<br>    int last = st;<br>    int lDelta = 2;<br>    int we = (1 &lt;&lt; m) - 1;<br>    if (series[0] == -1)<br>    {<br>      for (int j = 0; j &lt; available.Length; ++j)<br>        if (available[j] == st &amp;&amp; ((we &gt;&gt; j) &amp; 1) != 0)<br>        {<br>          we ^= (1 &lt;&lt; j);<br>          break;<br>        }<br>    }<br>    for (int i = 1; i &lt; n; ++i)<br>    {<br>      for (int z = 0; z &lt; MAXV; ++z)<br>      {<br>        int nDelta = z &gt; last ? 3 : z &lt; last ? 1 : 2;<br>        int add = lDelta * nDelta == 3 ? 1 : 0;<br>        if (get(i, we, z, nDelta) + add == need)<br>        {<br>          res[i] = z;<br>          need -= add;<br>          last = z;<br>          lDelta = nDelta;<br>          if (series[i] == -1)<br>          {<br>            for (int j = 0; j &lt; available.Length; ++j)<br>              if (available[j] == z &amp;&amp; ((we &gt;&gt; j) &amp; 1) != 0)<br>              {<br>                we ^= (1 &lt;&lt; j);<br>                break;<br>              }<br>          }<br>          break;<br>        }<br>      }<br>    }<br>    return res;<br>  }<br><br>  int get(int at, int have, int first, int delta)<br>  {<br>    if (series[at] == -1)<br>    {<br>      int i;<br>      for (i = 0; i &lt; m; ++i)<br>        if (available[i] == first &amp;&amp; ((have &gt;&gt; i) &amp; 1) != 0)<br>          break;<br>      if (i &lt; m)<br>      {<br>        if (at == n - 1)<br>          return 0;<br>        else<br>        {<br>          State s = new State(at, have, first, delta);<br>          if (cache.ContainsKey(s))<br>            return cache[s];<br>          int res = INF;<br>          for (int next = 0; next &lt; MAXV; ++next)<br>          {<br>            int nDelta = next &gt; first ? 3 : next &lt; first ? 1 : 2;<br>            int add = 0;<br>            if (nDelta * delta == 3)<br>              add = 1;<br>            res = Math.Min(res, add + get(at + 1, have ^ (1 &lt;&lt; i), next, nDelta));<br>          }<br>          cache[s] = res;<br>          return res;<br>        }<br>      }<br>      else return INF;<br>    }<br>    else {<br>      if (series[at] == first)<br>      {<br>        if (at == n - 1)<br>          return 0;<br>        else<br>        {<br>          State s = new State(at, have, first, delta);<br>          if (cache.ContainsKey(s))<br>            return cache[s];<br>          int res = INF;<br>          for (int next = 0; next &lt; MAXV; ++next)<br>          {<br>            int nDelta = next &gt; first ? 3 : next &lt; first ? 1 : 2;<br>            int add = 0;<br>            if (nDelta * delta == 3)<br>              add = 1;<br>            res = Math.Min(res, add + get(at + 1, have, next, nDelta));<br>          }<br>          cache[s] = res;<br>          return res;<br>        }<br>      }<br>      else return INF;<br>    }<br>  }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>