<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;cstdio&gt;<br>#include&lt;iostream&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;set&gt;<br>#include&lt;map&gt;<br>#include&lt;stack&gt;<br>#include&lt;list&gt;<br>#include&lt;queue&gt;<br>#include&lt;deque&gt;<br>#include&lt;cctype&gt;<br>#include&lt;string&gt;<br>#include&lt;vector&gt;<br>#include&lt;sstream&gt;<br>#include&lt;iterator&gt;<br>#include&lt;numeric&gt;<br>#include&lt;ctime&gt;<br>#include&lt;cmath&gt;<br>using namespace std;<br> <br>//LIB CODE<br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>//typedef long long ll;<br>typedef pair&lt;int,int&gt; pii;<br> <br>#define INIT(a,b) __typeof(b) a=(b)<br>#define FOREACH(a,b) for(INIT(a,(b).begin());a!=(b).end();++a)<br>#define PB push_back<br>template&lt;class T&gt; inline int sz(const T&amp;t) {return t.size();}<br> <br>//REAL CODE<br> <br>struct Point {<br>  int x,y;<br>};<br> <br>struct Rect {<br>  int llx,lly,urx,ury;<br>};<br> <br>struct seg {<br>  Point a,b;<br>};<br> <br>Rect rec[50];<br>seg ss[50];<br> <br>int dblcmp(double d) {<br>  if(fabs(d)&lt;1e-6) return 0;<br>  return d&gt;0?1:-1;<br>}<br> <br>double det(double x1,double y1,double x2,double y2) {<br>  return x1*y2-x2*y1;<br>}<br> <br>double cross(Point a,Point b,Point c) {<br>  return det(b.x-a.x,b.y-a.y,c.x-a.x,c.y-a.y);<br>}<br> <br>double dotdet(double x1,double y1,double x2,double y2) {<br>  return x1*x2+y1*y2;<br>}<br> <br>double dot(Point a,Point b,Point c) {<br>  return dotdet(b.x-a.x,b.y-a.y,c.x-a.x,c.y-a.y);<br>}<br> <br>int betweencmp(Point a,Point b,Point c) {<br>  return dblcmp(dot(a,b,c));<br>}<br> <br>int segcross(Point a,Point b,Point c,Point d,Point&amp; p) {<br>  double s1,s2,s3,s4;<br>  int d1,d2,d3,d4;<br>  d1=dblcmp(s1=cross(a,b,c));<br>  d2=dblcmp(s2=cross(a,b,d));<br>  d3=dblcmp(s3=cross(c,d,a));<br>  d4=dblcmp(s4=cross(c,d,b));<br>  if((d1^d2)==-2&amp;&amp;(d3^d4)==-2) {<br>    return 1;<br>  }<br>  if(d1==0&amp;&amp;betweencmp(c,a,b)&lt;=0||<br>     d2==0&amp;&amp;betweencmp(d,a,b)&lt;=0||<br>     d3==0&amp;&amp;betweencmp(a,c,d)&lt;=0||<br>     d4==0&amp;&amp;betweencmp(b,c,d)&lt;=0)<br>     return 2;<br>  return 0;<br>}<br> <br> <br>bool inrect(Point p,Rect rect) {<br>  return (p.x&gt;rect.llx)&amp;&amp;p.x&lt;rect.urx&amp;&amp;p.y&gt;rect.lly&amp;&amp;p.y&lt;rect.ury;<br>}<br> <br>struct RectangleCrossings {<br>  vector &lt;int&gt; countAreas(vector &lt;string&gt; r, vector &lt;string&gt; s) {<br>    vector&lt;int&gt; ret;<br>    ret.clear();<br>    int i;<br>    for(i=0;i&lt;r.size();i++) {<br>      istringstream in(r[i]);<br>      in&gt;&gt;rec[i].llx&gt;&gt;rec[i].lly&gt;&gt;rec[i].urx&gt;&gt;rec[i].ury;<br>    }<br>    for(i=0;i&lt;s.size();i++) {<br>      istringstream in(s[i]);<br>      in&gt;&gt;ss[i].a.x&gt;&gt;ss[i].a.y&gt;&gt;ss[i].b.x&gt;&gt;ss[i].b.y;<br>    }<br>    int a1=0,a2=0;<br>    for(i=0;i&lt;r.size();i++)<br>    {<br>      int j;<br>      bool flag=false;<br>      for(j=0;j&lt;s.size();j++)<br>        if(inrect(ss[j].a,rec[i])||inrect(ss[j].b,rec[i]))<br>          flag=true;<br>      Point p1, p2, p3, p4;<br>      p1.x = rec[i].llx, p1.y=rec[i].lly;<br>      p2.x = rec[i].llx, p2.y=rec[i].ury;<br>      p3.x = rec[i].urx, p3.y=rec[i].ury;<br>      p4.x = rec[i].urx, p4.y=rec[i].lly;<br>      Point p;<br>      bool f1=false;<br>      for(j=0;j&lt;s.size();j++) {<br>        if(segcross(ss[j].a,ss[j].b,p1,p2,p)!=0) {cout&lt;&lt;"p1 p2"&lt;&lt;endl; f1=true;}<br>        if(segcross(ss[j].a,ss[j].b,p2,p3,p)!=0) {cout&lt;&lt;"p2 p3"&lt;&lt;endl; f1=true;}<br>        if(segcross(ss[j].a,ss[j].b,p3,p4,p)!=0) {cout&lt;&lt;"p3 p4"&lt;&lt;endl; f1=true;}<br>        if(segcross(ss[j].a,ss[j].b,p4,p1,p)!=0) {cout&lt;&lt;"p4 p1"&lt;&lt;endl; f1=true;}<br>      }<br>      if(flag) a1+=(rec[i].ury-rec[i].lly)*(rec[i].urx-rec[i].llx);<br>      if(!flag&amp;&amp;f1) a2+=(rec[i].ury-rec[i].lly)*(rec[i].urx-rec[i].llx);<br>    }<br>    ret.PB(a1); ret.PB(a2);<br>    return ret;<br>  }<br>};<br> <br>//Powered by [KawigiEdit] 2.0!<br>//Coded by Ikki<br></td>