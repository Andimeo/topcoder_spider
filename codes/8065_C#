<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text;<br>using System.Diagnostics;<br><br>public class RainyDay {<br>    public int minimumRainTime(string path, string forecast) {<br>        Queue&lt;int&gt; Q = new Queue&lt;int&gt;();<br>        int[,] dp = new int[50, 50];<br>        int k = 0;<br>        dp[(k++) % 50, 0] = (int)1e9; dp[(k++) % 50, 0] = (int)1e9; dp[(k++) % 50, 0] = (int)1e9; dp[(k++) % 50, 0] = (int)1e9; dp[(k++) % 50, 0] = (int)1e9; dp[(k++) % 50, 0] = (int)1e9; dp[(k++) % 50, 0] = (int)1e9; dp[(k++) % 50, 0] = (int)1e9; dp[(k++) % 50, 0] = (int)1e9; dp[(k++) % 50, 0] = (int)1e9; dp[(k++) % 50, 0] = (int)1e9;<br>        init(dp, (int)1e9);<br><br>        for (int i = 0; i &lt; path.Length; i++) if (path[i] == 'Y') {<br>                Q.Enqueue(i); Q.Enqueue(0);<br>                dp[i, 0] = 0;<br>            }<br><br>        while (Q.Count &gt; 0) {<br>            int i = Q.Dequeue(); int t = Q.Dequeue();<br><br>            for (int v = -1; v &lt;= 1; v++) if(inrange(i+v,0,path.Length)){<br>                int ni=v+i;<br>                int newt=(t+1)%forecast.Length;<br>                int ncost = dp[i, t];<br>                if (path[i] == '.' &amp;&amp; forecast[(i + t) % forecast.Length] == 'R') {<br>                    ncost++;<br>                }<br>                if (path[ni] == '.' &amp;&amp; forecast[(i + newt) % forecast.Length] == 'R') {<br>                    ncost++;<br>                }<br>                <br><br>                if(ncost&lt;dp[ni,newt]){<br>                    dp[ni, newt] = ncost;<br>                    Q.Enqueue(ni); Q.Enqueue(newt);<br><br>                }<br>            }<br>        }<br><br>        int ret = (int)1e9;<br><br>        for (int i = 0; i &lt; path.Length; i++)<br>            if(path[i]=='H')<br>                for (int j = 0; j &lt; 50; j++) ret = Math.Min(ret, dp[i, j]);<br>        return ret;<br>    }<br><br>    bool inrange&lt;T&gt;(T arg, T left, T right) where T : IComparable&lt;T&gt; {<br>        return arg.CompareTo(left) &gt;= 0 &amp;&amp; arg.CompareTo(right) &lt; 0;<br>    }<br><br><br>    void init&lt;T&gt;(Array test, T val) {<br>        int[] indx = new int[test.Rank];<br>        int[] dim = new int[test.Rank];<br>        for (int j = 0; j &lt; dim.Length; j++) dim[j] = test.GetLength(j);<br>        for (int i = 0; i &lt; test.Length; i++) {<br>            int tmp = i;<br>            for (int j = 0; j &lt; indx.Length; j++) {<br>                indx[j] = tmp % dim[j];<br>                tmp /= dim[j];<br>            }<br>            test.SetValue(val, indx);<br>        }<br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>