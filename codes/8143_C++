<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br> <br>using namespace std;<br> <br>template&lt;class T&gt; inline T sqr(T x){return x*x;}<br> <br>const int maxsize=100000;<br> <br>class RadarGuns<br>{<br>public:<br>  int node,src,dest,nedge;<br>  int head[maxsize];<br>  int pnode[maxsize],capa[maxsize],flow[maxsize],cost[maxsize],next[maxsize];<br>  int prev[maxsize],dist[maxsize],pedge[maxsize];<br>  bool changed[maxsize];<br>  void addedge(int u,int v,int c,int w)<br>  {<br>    pnode[nedge]=v;capa[nedge]=c;flow[nedge]=0;cost[nedge]=+w;next[nedge]=head[u];head[u]=(nedge++);<br>    pnode[nedge]=u;capa[nedge]=0;flow[nedge]=0;cost[nedge]=-w;next[nedge]=head[v];head[v]=(nedge++);<br>  }<br>  vector &lt;int&gt; getRange(vector &lt;int&gt; enterTimes, vector &lt;int&gt; exitTimes, int speedTime, int fineCap)<br>  {<br>    int n=enterTimes.size();<br>    memset(head,255,sizeof(head));<br>    node=n+n+2;<br>    src=node-1;<br>    dest=node;<br>    nedge=0;<br>    for (int i=1;i&lt;=n;i++) addedge(src,i,1,0);<br>    for (int i=1;i&lt;=n;i++) addedge(i+n,dest,1,0);<br>    for (int i=1;i&lt;=n;i++)<br>      for (int k=1;k&lt;=n;k++)<br>      {<br>        int t=exitTimes[k-1]-enterTimes[i-1];<br>        if (t&lt;=0) continue;<br>        if (t&gt;=speedTime) t=0;<br>        else t=sqr(t-speedTime);<br>        addedge(i,k+n,1,min(fineCap,t));<br>      }<br>    vector&lt;int&gt; R;<br>    for (int step=0;step&lt;2;step++)<br>    {<br>      int nflow=0,ncost=0;<br>      memset(flow,0,sizeof(flow));<br>      while (1)<br>      {<br>        for (int i=1;i&lt;=node;i++) dist[i]=(step==0)?100000000:-100000000;<br>        for (int i=1;i&lt;=node;i++) prev[i]=-1,changed[i]=false;<br>        dist[src]=0;<br>        prev[src]=src;<br>        changed[src]=true;<br>        while (1)<br>        {<br>          bool ok=true;<br>          for (int i=1;i&lt;=node;i++) if (changed[i])<br>          {<br>            changed[i]=false;<br>            for (int k=head[i];k!=-1;k=next[k])<br>              if (flow[k]&lt;capa[k] &amp;&amp; (step==0 &amp;&amp; cost[k]+dist[i]&lt;dist[pnode[k]]<br>                         || step==1 &amp;&amp; cost[k]+dist[i]&gt;dist[pnode[k]]))<br>              {<br>                dist[pnode[k]]=cost[k]+dist[i];<br>                changed[pnode[k]]=true;<br>                prev[pnode[k]]=i;<br>                pedge[pnode[k]]=k;<br>                ok=false;<br>              }<br>          }<br>          if (ok) break;<br>        }<br>        if (prev[dest]==-1) break;<br>        nflow++;<br>        ncost+=dist[dest];<br>        for (int k=dest;k!=src;k=prev[k])<br>        {<br>          flow[pedge[k]]++;<br>          flow[pedge[k]^1]--;<br>        }<br>      }<br>      if (nflow&lt;n) return R;<br>      R.push_back(ncost);<br>    }<br>    return R;<br>  }<br>};<br> <br> <br> <br>// Powered by PopsEdit<br></td>