<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;queue&gt;<br>#include&lt;map&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;sstream&gt;<br>#include&lt;string&gt;<br>#include&lt;vector&gt;<br>#include&lt;cmath&gt;<br>using namespace std;<br><br>#define FOR(i,a,b) for(int i = (a); i &lt; (b); ++i)<br>#define REP(i,n) FOR(i,0,n)<br>#define FORE(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();++it)<br>#define pb push_back<br>#define all(x) (x).begin(),(x).end()<br>#define CLEAR(x,with) memset(x,with,sizeof(x))<br>#define sz size()<br>typedef long long ll;<br><br>const int MAXV = 40;<br>struct NetworkFlow<br>{<br>  int flow[MAXV][MAXV], cap[MAXV][MAXV], totalFlow, V;<br>  NetworkFlow(int V): V(V) { CLEAR(cap,0); CLEAR(flow,0);totalFlow = 0; }<br><br>  void addEdge(int a, int b, int c) { cap[a][b] += c; }<br><br>  void push(int a, int b, int c) { flow[a][b] += c; flow[b][a] = - flow[a][b]; }<br>  int res(int a, int b) { return cap[a][b] - flow[a][b]; }<br><br>  int pushFlow(int source = 0, int sink = 1)<br>  {<br>    vector&lt;int&gt; pred(V, -1); queue&lt;int&gt; q;<br>    q.push(source); pred[source] = source;<br>    while(!q.empty() &amp;&amp; pred[sink] == -1)<br>    {<br>      int u = q.front(); q.pop();<br>      for(int v = 0; v &lt; V; ++v) if(res(u,v) &gt; 0 &amp;&amp; pred[v] == -1) { pred[v] = u; q.push(v); }<br>    }<br>    if(pred[sink] == -1) return 0;<br>    int h, amt = 987654321;<br>    h = sink; while(pred[h] != h) { amt &lt;?= res(pred[h], h); h = pred[h]; }<br>    h = sink; while(pred[h] != h) { push(pred[h], h, amt); h = pred[h]; }<br>    totalFlow += amt;<br>    return amt;<br>  }<br>};<br><br><br>struct SoftwareCompanies <br>{<br>  int graph[12][12];<br>  int n;<br>  vector&lt;string&gt; generate(const vector&lt;string&gt;&amp; names, int mask)<br>  {<br>    vector&lt;string&gt; ret;<br>    REP(i,n) if(mask&amp;(1&lt;&lt;i)) ret.pb(names[i]);<br>    sort(all(ret));<br>    return ret;<br>  }<br>  vector &lt;string&gt; produceData(vector &lt;string&gt; names, vector &lt;string&gt; process, vector &lt;int&gt; cost, vector &lt;int&gt; amount, string company1, string company2) <br>  {<br>    CLEAR(graph,0);<br>    n = names.sz;<br>    map&lt;string,int&gt; m;<br>    REP(i,n) m[names[i]] = i;<br>    CLEAR(graph,0);<br>    REP(i,n)<br>    {<br>      istringstream inp(process[i]);<br>      string b;<br>      while(inp &gt;&gt; b)<br>      {<br>        int j = m[b];<br>        graph[i][j] = 1;<br>      }<br>    }<br>    int bestMoney = 0, bestAmount = 0;<br>    vector&lt;string&gt; ret;<br>    int src = m[company1], snk = m[company2];<br>    int ourMask = (1&lt;&lt;src) | (1&lt;&lt;snk);<br>    REP(mask,(1&lt;&lt;n))<br>    {<br>      if((mask&amp;ourMask) != ourMask) continue;<br>      NetworkFlow flow(n*2);<br>      int totalCost = 0;<br>      REP(i,n) if(mask&amp;(1&lt;&lt;i)) <br>      {<br>        totalCost += cost[i];<br>        flow.addEdge(i*2, i*2+1, amount[i]);<br>        REP(j,n) if(graph[i][j] &amp;&amp; mask&amp;(1&lt;&lt;j))<br>        {<br>          flow.addEdge(i*2+1, j*2, 987654321);<br>        }<br>      }<br>      while(flow.pushFlow(src*2, snk*2+1));<br>      if(bestAmount &lt; flow.totalFlow || (bestAmount == flow.totalFlow &amp;&amp; bestMoney &gt;= totalCost))<br>      {<br>        vector&lt;string&gt; cand = generate(names, mask);<br>        if(bestAmount == flow.totalFlow &amp;&amp; bestMoney == totalCost &amp;&amp; cand &gt; ret) continue;<br>        bestAmount = flow.totalFlow;<br>        bestMoney = totalCost;<br>        ret = cand;<br>      }<br>    }<br>    return ret;<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>