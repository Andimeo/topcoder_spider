<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class SoftwareCompanies {<br>    class Graph {<br>        int n;<br>        int[][] c;<br>        int[][] f;<br>        boolean[] u;<br> <br>        Graph(int n) {<br>            this.n = n;<br>            c = new int[n][n];<br>            f = new int[n][n];<br>        }<br> <br>        int dfs(int s, int t, int cmax) {<br>            if (s == t) {<br>                return cmax;<br>            }<br>            u[s] = true;<br>            for (int i = 0; i &lt; n; i++) {<br>                if (!u[i] &amp;&amp; c[s][i] - f[s][i] &gt; 0) {<br>                    int r = dfs(i, t, Math.min(cmax, c[s][i] - f[s][i]));<br>                    if (r &gt; 0) {<br>                        f[s][i] += r;<br>                        f[i][s] -= r;<br>                        return r;<br>                    }<br>                }<br>            }<br>            return 0;<br>        }<br> <br>        int maxFlow(int s, int t) {<br>            u = new boolean[n];<br>            for (int i = 0; i &lt; n; i++) {<br>                Arrays.fill(f[i], 0);<br>            }<br>            int flow = 0;<br>            while (true) {<br>                Arrays.fill(u, false);<br>                int df = dfs(s, t, Integer.MAX_VALUE);<br>                if (df == 0) {<br>                    break;<br>                }<br>                flow += df;<br>            }<br>            return flow;<br>        }<br>    }<br> <br>    public String[] produceData(String[] names, String[] process, int[] cost, int[] amount, String company1, String company2) {<br>        int n = names.length;<br>        Graph g = new Graph(2 * n);<br> <br>        for (int i = 0; i &lt; n; i++) {<br>            StringTokenizer st = new StringTokenizer(process[i]);<br>            while (st.hasMoreTokens()) {<br>                String s = st.nextToken();<br>                for (int j = 0; j &lt; n; j++) {<br>                    if (names[j].equals(s)) {<br>                        g.c[2 * i + 1][2 * j] = 1000000;<br>                    }<br>                }<br>            }<br>        }<br> <br>        int st = 0;<br>        for (int i = 0; i &lt; n; i++) {<br>            if (company1.equals(names[i])) {<br>                st = i;<br>            }<br>        }<br>        int ds = 0;<br>        for (int i = 0; i &lt; n; i++) {<br>            if (company2.equals(names[i])) {<br>                ds = i;<br>            }<br>        }<br> <br>        String[] r = new String[]{};<br>        int bestData = 0;<br>        int bestCost = 0;<br>        for (int i = 0; i &lt; (1 &lt;&lt; n); i++) {<br>            int cst = 0;<br>            ArrayList&lt;String&gt; nms = new ArrayList&lt;String&gt;();<br>            for (int j = 0; j &lt; n; j++) {<br>                if ((i &amp; (1 &lt;&lt; j)) != 0) {<br>                    cst += cost[j];<br>                    g.c[2 * j][2 * j + 1] = amount[j];<br>                    nms.add(names[j]);<br>                } else {<br>                    g.c[2 * j][2 * j + 1] = 0;<br>                }<br>            }<br> <br>            int data = g.maxFlow(2 * st, 2 * ds + 1);<br>            if (data &gt; bestData) {<br>                bestData = data;<br>                bestCost = cst;<br>                r = nms.toArray(new String[nms.size()]);<br>                Arrays.sort(r);<br>            } else if (data == bestData) {<br>                if (cst &lt; bestCost) {<br>                    bestCost = cst;<br>                    r = nms.toArray(new String[nms.size()]);<br>                    Arrays.sort(r);<br>                } else if (cst == bestCost) {<br>                    String[] tmp = nms.toArray(new String[nms.size()]);<br>                    Arrays.sort(tmp);<br>                    boolean better = false;<br>                    for (int j = 0; j &lt; r.length; j++) {<br>                        if (tmp.length &lt;= j) {<br>                            better = true;<br>                            break;<br>                        }<br>                        if (tmp[j].compareTo(r[j]) &lt; 0) {<br>                            better = true;<br>                            break;<br>                        } else if (tmp[j].compareTo(r[j]) &gt; 0) {<br>                            break;<br>                        }<br>                    }<br>                    if (better) {<br>                        r = tmp;<br>                    }<br>                }<br>            }<br>        }<br> <br>        return r;<br>    }<br> <br> <br>}<br> <br> <br>// Powered by PopsEdit<br> <br>// Powered by CodeProcessor<br></td>