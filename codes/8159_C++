<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;iostream&gt;<br>#include &lt;map&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;utility&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br><br>#define FOREACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++) <br><br>typedef pair&lt; int, int &gt; point;<br>#define X first<br>#define Y second<br><br>int R, C;<br>int grid[ 60 ][ 60 ];<br><br>int nd, nh;<br>point d[ 10 ];<br>point h[ 10 ];<br><br>int cost[ 10 ][ 10 ];<br>int dp[ 1 &lt;&lt; 10 ], prev[ 1 &lt;&lt; 10 ];<br><br>const int dx[ 4 ] = { 1, 0, -1, 0 };<br>const int dy[ 4 ] = { 0, 1, 0, -1 };<br><br>inline bool valid( int x, int y ) { return 0 &lt;= x &amp;&amp; x &lt; R &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; C; }<br><br>int solve( int a, int b )<br>{<br>    queue&lt; point &gt; Q;<br>    int dist[ 60 ][ 60 ];<br>    bool seen[ 60 ][ 60 ];<br><br>    memset( dist, -1, sizeof dist );<br>    memset( seen, false, sizeof seen );<br><br>    Q.push( d[a] );<br>    dist[ d[a].X ][ d[a].Y ] = 0;<br>    seen[ d[a].X ][ d[a].Y ] = true;<br><br>    grid[ h[b].X ][ h[b].Y ] = 1;<br><br>    while( !Q.empty() ) {<br>        point p = Q.front(); Q.pop();<br><br>        for( int i = 0; i &lt; 4; ++i ) {<br>            point q = p; q.X += dx[i]; q.Y += dy[i];<br><br>            if( valid( q.X, q.Y ) &amp;&amp; grid[ q.X ][ q.Y ] &amp;&amp; !seen[ q.X ][ q.Y ] ) {<br>                Q.push( q );<br>                dist[ q.X ][ q.Y ] = dist[ p.X ][ p.Y ] + 1;<br>                seen[ q.X ][ q.Y ] = true;<br>            }<br>        }<br>    }<br><br>    grid[ h[b].X ][ h[b].Y ] = 0;<br><br>    return dist[ h[b].X ][ h[b].Y ];<br>}<br><br>inline void update( int &amp;x, int val ) { if( x &lt; 0 || val &lt; x ) x = val; }<br><br>class DogField {<br>public:<br>    int saveDogs(vector &lt;string&gt; a) {<br>        R = a.size();<br>        C = a[0].size();<br><br>        nd = nh = 0;<br><br>        for( int i = 0; i &lt; R; ++i ) <br>            for( int j = 0; j &lt; C; ++j ) {<br>                if( a[i][j] == 'D' ) {<br>                    grid[i][j] = 1;<br>                    d[ nd++ ] = point( i, j );<br>                } else if( a[i][j] == 'H' ) {<br>                    grid[i][j] = 0;<br>                    h[ nh++ ] = point( i, j );<br>                } else if( a[i][j] == '.' ) grid[i][j] = 1;<br>                else grid[i][j] = 0;<br>            }<br>        <br>        for( int i = 0; i &lt; nd; ++i )<br>            for( int j = 0; j &lt; nh; ++j )<br>                cost[i][j] = solve( i, j );<br><br>        memset( prev, -1, sizeof prev );<br>        prev[0] = 0;<br><br>        for( int i = 0; i &lt; nd; ++i ) {<br>            memset( dp, -1, sizeof dp );<br><br>            for( int state = 0; state &lt; ( 1 &lt;&lt; nh ); ++state ) if( prev[state] &gt;= 0 )<br>                for( int k = 0; k &lt; nh; ++k ) if( cost[i][k] &gt;= 0 &amp;&amp; !( state &amp; ( 1 &lt;&lt; k ) ) )<br>                    update( dp[ state | (1 &lt;&lt; k) ], prev[state] + cost[i][k] );<br><br>            memcpy( prev, dp, sizeof prev );<br>        }<br><br>        return prev[ ( 1 &lt;&lt; nh ) - 1 ];<br>    }<br>    <br> <br>};<br><br><br>    <br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>