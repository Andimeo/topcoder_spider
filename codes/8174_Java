<td class="problemText" colspan="8" valign="middle" align="left">
            import java.math.*;<br> <br>public class TVGame {<br> <br>  public int expectedProfit(String[] board) {<br>    int n = board.length;<br>    long[][] a = new long[n][n];<br>    for (int i = 0; i &lt; n; i++) {<br>      char[] c = board[i].toCharArray();<br>      for (int j = 0; j &lt; n; j++) {<br>        if (c[j] &gt;= 'A' &amp;&amp; c[j] &lt;= 'I') a[i][j] = -1 -(c[j] - 'A');<br>        else a[i][j] = c[j] - '0';<br>      }<br>    }<br>    int res = det(a);<br>    System.out.println(res);<br>    return res;<br>  }<br>  int det(long[][] a) {<br>    int n = a.length;<br>    Fraction[][] c = new Fraction[n][n];<br>    Fraction res = Fraction.ONE;<br>    for (int i = 0; i &lt; n; i++) {<br>      for (int j = 0; j &lt; n; j++) {<br>        c[i][j] = new Fraction(a[i][j]);<br>      }<br>    }<br>    for (int i = 0; i &lt; n; i++) {<br>      int p = i;<br>      Fraction max = c[i][i].abs();<br>      for (int j = i + 1; j &lt; n; j++) {<br>        if (c[j][i].abs().compareTo(max) &gt; 0) {<br>          p = j;<br>          max = c[j][i].abs();<br>        }<br>      }<br>      if (i != p) res = res.negate();<br>      Fraction[] t1 = c[p];<br>      c[p] = c[i];<br>      c[i] = t1;<br>      if (c[i][i].signum() == 0) return 0;<br>      res = res.mul(c[i][i]);<br>      for (int j = i + 1; j &lt; n; j++) {<br>        c[j][i] = c[j][i].div(c[i][i]);<br>        for (int k = i + 1; k &lt; n; k++) {<br>          c[j][k] = c[j][k].sub(c[i][k].mul(c[j][i]));<br>        }<br>      }<br>    }<br>    if (n % 2 == 0) res = res.negate();<br>    BigInteger b = res.child.mod(BigInteger.valueOf(121547));<br>    System.out.println(b);<br>    if (b.signum() &lt; 0) b = b.add(BigInteger.valueOf(121547));<br>    return b.intValue();<br>  }<br>  static class Fraction implements Comparable&lt;Fraction&gt; {<br>    static final Fraction ONE = new Fraction(BigInteger.ONE, BigInteger.ONE);<br>    BigInteger child, mother;<br>    Fraction(long c) {<br>      child = BigInteger.valueOf(c);<br>      mother = BigInteger.ONE;<br>      reduction();<br>    }<br>    Fraction(BigInteger c, BigInteger m) {<br>      child = c;<br>      mother = m;<br>      reduction();<br>    }<br>    void reduction() {<br>      boolean minus = false;<br>      if (child.signum() &lt; 0) {<br>        child = child.negate();<br>        minus = !minus;<br>      }<br>      if (mother.signum() &lt; 0) {<br>        mother = mother.negate();<br>        minus = !minus;<br>      }<br>      BigInteger d = child.gcd(mother);<br>      if (d.signum() != 0) {<br>        child = child.divide(d);<br>        mother = mother.divide(d);<br>      }<br>      if (minus) child = child.negate();<br>    }<br>    Fraction sub(Fraction f) {<br>      return new Fraction(child.multiply(f.mother).subtract(f.child.multiply(mother)), mother.multiply(f.mother));<br>    }<br>    Fraction mul(Fraction f) {<br>      return new Fraction(child.multiply(f.child), mother.multiply(f.mother));<br>    }<br>    Fraction div(Fraction f) {<br>      return new Fraction(child.multiply(f.mother), mother.multiply(f.child));<br>    }<br>    Fraction negate() {<br>      return new Fraction(child.negate(), mother);<br>    }<br>    Fraction abs() {<br>      return new Fraction(child.abs(), mother);<br>    }<br>    int signum() {<br>      return child.signum();<br>    }<br>    public int compareTo(Fraction o) {<br>      if (mother.signum() == 0 &amp;&amp; o.mother.signum() == 0 &amp;&amp; child.signum() == 0 &amp;&amp; o.child.signum() != 0) return child.compareTo(o.child);<br>      return (child.multiply(o.mother).compareTo(o.child.multiply(mother)));<br>    }<br>    public boolean equals(Object obj) {<br>      return (obj instanceof Fraction &amp;&amp; compareTo((Fraction)obj) == 0);<br>    }<br>  }<br>}<br></td>