<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cmath&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>#define PB push_back<br>#define SZ(v) ((int)(v).size())<br>#define MP make_pair<br>#define FOR(i,a,b) for(int i=(a);i&lt;(b);++i)<br>#define REP(i,n) FOR(i,0,n)<br>#define FORE(i,a,b) for(int i=(a);i&lt;=(b);++i)<br>#define REPE(i,n) FORE(i,0,n)<br>#define FORSZ(i,a,v) FOR(i,a,SZ(v))<br>#define REPSZ(i,v) REP(i,SZ(v))<br>#define VAR(a,b) __typeof(b) a=b<br>#define FORIT(i,v) for(VAR(i,(v).begin());i!=(v).end();++i)<br><br>typedef long long ll; typedef pair&lt;int,int&gt; PII;<br>typedef vector&lt;int&gt; VI; typedef vector&lt;VI&gt; VVI;<br>typedef vector&lt;double&gt; VD; typedef vector&lt;VD&gt; VVD;<br>typedef vector&lt;ll&gt; VLL; typedef vector&lt;VLL&gt; VVLL;<br>typedef vector&lt;PII&gt; VPII; typedef vector&lt;VPII&gt; VVPII;<br>typedef vector&lt;string&gt; VS; typedef vector&lt;VS&gt; VVS;<br><br>template&lt;class T&gt; T cast(const string &amp;s) { T ret; ostringstream a; a&lt;&lt;s; istringstream b(a.str()); b&gt;&gt;ret; return ret; }<br>template&lt;class T&gt; vector&lt;T&gt; split(const string &amp;s,const string &amp;x=" ") { vector&lt;T&gt; ret; string cur; REPSZ(i,s) if(x.find(s[i])==string::npos) cur+=s[i]; else if(cur!="") ret.PB(cast&lt;T&gt;(cur)),cur=""; if(cur!="") ret.PB(cast&lt;T&gt;(cur)); return ret; }<br><br>int code(char a,char b) { int x=a=='?'?26:tolower(a)-'a',y=b=='?'?26:tolower(b)-'a'; return x*27+y; }<br><br>VI e[729];<br>int match[729],done[729];<br>bool augment(int at) {<br>  if(done[at]) return false; else done[at]=true;<br>  REPSZ(i,e[at]) {<br>    int to=e[at][i];<br>    if(match[to]==-1||augment(match[to])) {<br>      match[to]=at;<br>      return true;<br>    }<br>  }<br>  return false;<br>}<br><br>class AncientLanguage {<br>public:<br>  int minWords(vector &lt;string&gt; S) {<br>    string s; REPSZ(i,S) s+=S[i]; s="?"+s+"?"; int n=SZ(s);<br>    for(int i=1;i+1&lt;n;i+=2) {<br>      e[code(s[i],s[i+1])].PB(code(s[i-1],s[i]));<br>      if(i+2&lt;n) e[code(s[i],s[i+1])].PB(code(s[i+1],s[i+2]));<br>    }<br>    REP(i,729) { sort(e[i].begin(),e[i].end()); e[i].erase(unique(e[i].begin(),e[i].end()),e[i].end()); }<br>    <br>    int ret=0;<br>    memset(match,-1,sizeof(match));<br>    REP(i,729) {<br>      memset(done,0,sizeof(done));<br>      if(augment(i)) ++ret;<br>    }<br>    return ret;<br>  }<br>};<br></td>