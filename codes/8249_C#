<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br> <br>public class PolylineUnion<br>{<br>  class PT<br>  {<br>    public long x, y;<br>    <br>    public PT (string s)<br>    {<br>      string[] ss = s.Split (',');<br>      <br>      this.x = long.Parse (ss[0]);<br>      this.y = long.Parse (ss[1]);<br>    }<br>  }<br>  <br>  class PL<br>  {<br>    public List&lt;PT&gt; pts;<br>    <br>    public PL (string s)<br>    {<br>      this.pts = new List&lt;PT&gt; ();<br>      <br>      foreach (string ss in s.Split ('-'))<br>        this.pts.Add (new PT (ss));<br>    }<br>  }<br>  <br>  bool inmiddle (long x1, long x2, long y)<br>  {<br>    if (x1 &gt; x2)<br>      return inmiddle (x2, x1, y);<br>    <br>    return x1 &lt; y &amp;&amp; y &lt; x2;<br>  }<br>  <br>  bool isect (PT a1, PT a2, PT b)<br>  {<br>    long dx1 = a2.x - a1.x;<br>    long dy1 = a2.y - a1.y;<br>    <br>    long dx2 = b.x - a1.x;<br>    long dy2 = b.y - a1.y;<br>    <br>    if (dx1 * dy2 - dx2 * dy1 != 0)<br>      return false;<br>    <br>    return inmiddle (a1.x, a2.x, b.x) || inmiddle (a1.y, a2.y, b.y);<br>  }<br>  <br>  bool isect (PT a1, PT a2, PT b1, PT b2)<br>  {<br>    long dx = a2.x - a1.x;<br>    long dy = a2.y - a1.y;<br>    <br>    long dx1 = b1.x - a1.x;<br>    long dy1 = b1.y - a1.y;<br>    long dx2 = b2.x - a1.x;<br>    long dy2 = b2.y - a1.y;<br>    <br>    long q1 = (dx * dy1 - dy * dx1);<br>    long q2 = (dx * dy2 - dy * dx2);<br>    <br>    return q1 * q2 &lt; 0;<br>  }<br>  <br>  bool common (PL a, PL b)<br>  {<br>    foreach (PT pa in a.pts)<br>      foreach (PT pb in b.pts)<br>        if (pa.x == pb.x &amp;&amp; pa.y == pb.y)<br>          return true;<br>    <br>    for (int i = 0; i &lt; a.pts.Count - 1; ++i)<br>      for (int j = 0; j &lt; b.pts.Count - 1; ++j)<br>        if (isect (a.pts[i], a.pts[i + 1], b.pts[j], b.pts[j + 1]) &amp;&amp; isect (b.pts[j], b.pts[j + 1], a.pts[i], a.pts[i + 1]))<br>          return true;<br>    <br>    for (int i = 0; i &lt; a.pts.Count - 1; ++i)<br>      foreach (PT j in b.pts)<br>        if (isect (a.pts[i], a.pts[i + 1], j))<br>          return true;<br>    <br>    for (int i = 0; i &lt; b.pts.Count - 1; ++i)<br>      foreach (PT j in a.pts)<br>        if (isect (b.pts[i], b.pts[i + 1], j))<br>          return true;<br>    <br>    return false;<br>  }<br>  <br>  int[] uf;<br>  <br>  int ufget (int a)<br>  {<br>    if (uf[a] != a)<br>      uf[a] = ufget (uf[a]);<br>    <br>    return uf[a];<br>  }<br>  <br>  void union (int a, int b)<br>  {<br>    int qa = ufget (a);<br>    int qb = ufget (b);<br>    <br>    uf[qa] = qb;<br>  }<br>  <br>  public int countComponents (string[] polylines)<br>  {<br>    List&lt;PL&gt; pls = new List&lt;PL&gt; ();<br>    <br>    foreach (string pl in string.Join ("", polylines).Split (' '))<br>      pls.Add (new PL (pl));<br>    <br>    int n = pls.Count;<br>    <br>    uf = new int[n];<br>    for (int i = 0; i &lt; n; ++i)<br>      uf[i] = i;<br>    <br>    int comp = n;<br>    <br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = i + 1; j &lt; n; ++j)<br>        if (ufget (i) != ufget (j) &amp;&amp; common (pls[i], pls[j]))<br>    {<br>      union (i, j);<br>      --comp;<br>    }<br>    <br>    return comp;<br>  }<br>  <br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>