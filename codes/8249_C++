<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;utility&gt;<br>#include &lt;iterator&gt;<br>#include &lt;numeric&gt;<br>#include &lt;list&gt;<br>#include &lt;complex&gt;<br> <br>using namespace std;<br> <br>typedef vector&lt;int&gt; vi;<br>typedef vector&lt;string&gt; vs;<br>typedef long long ll;<br>typedef complex&lt;int&gt; pnt;<br>typedef pair&lt;int, int&gt; pii;<br> <br>#define RA(x) (x).begin(), (x).end()<br>#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)<br>#define SZ(x) ((int) (x).size())<br> <br>template&lt;class T&gt;<br>void splitstr(const string &amp;s, vector&lt;T&gt; &amp;out)<br>{<br>    istringstream in(s);<br>    out.clear();<br>    copy(istream_iterator&lt;T&gt;(in), istream_iterator&lt;T&gt;(), back_inserter(out));<br>}<br> <br> <br>static int cross(const pnt &amp;a, const pnt &amp;b) { return imag(conj(a) * b); }<br>static int area(const pnt &amp;a, const pnt &amp;b, const pnt &amp;c) { return cross(b -a, c - a); }<br> <br>static bool isect(const pnt &amp;p1, const pnt &amp;p2, const pnt &amp;q1, const pnt &amp;q2)<br>{<br>    if (max(p1.real(), p2.real()) &lt; min(q1.real(), q2.real())) return false;<br>    if (max(q1.real(), q2.real()) &lt; min(p1.real(), p2.real())) return false;<br>    if (max(p1.imag(), p2.imag()) &lt; min(q1.imag(), q2.imag())) return false;<br>    if (max(q1.imag(), q2.imag()) &lt; min(p1.imag(), p2.imag())) return false;<br> <br>    int c1 = area(p1, p2, q1);<br>    int c2 = area(p1, p2, q2);<br>    if (c1 &lt; 0 &amp;&amp; c2 &lt; 0) return false;<br>    if (c1 &gt; 0 &amp;&amp; c2 &gt; 0) return false;<br>    c1 = area(q1, q2, p1);<br>    c2 = area(q1, q2, p2);<br>    if (c1 &lt; 0 &amp;&amp; c2 &lt; 0) return false;<br>    if (c1 &gt; 0 &amp;&amp; c2 &gt; 0) return false;<br>    return true;<br>}<br> <br>class PolylineUnion<br>{<br>public:<br>    int countComponents(vector &lt;string&gt; polylines);<br>};<br> <br>static int parent[2600];<br>typedef pair&lt;pnt, pnt&gt; line;<br> <br>static int root(int x)<br>{<br>    if (parent[x] &lt; 0) return x;<br>    else return parent[x] = root(parent[x]);<br>}<br> <br>int PolylineUnion::countComponents(vector &lt;string&gt; polylines)<br>{<br>    string pl2 = accumulate(RA(polylines), string());<br>    vs pl3;<br>    splitstr(pl2, pl3);<br>    vector&lt;line&gt; lines;<br>    for (size_t i = 0; i &lt; pl3.size(); i++)<br>    {<br>        vs p;<br>        replace(RA(pl3[i]), '-', ' ');<br>        splitstr(pl3[i], p);<br>        vector&lt;pnt&gt; pnts;<br>        for (size_t j = 0; j &lt; p.size(); j++)<br>        {<br>            int x, y;<br>            sscanf(p[j].c_str(), "%d,%d", &amp;x, &amp;y);<br>            pnts.push_back(pnt(x, y));<br>        }<br>        if (pnts.size() == 1) pnts.push_back(pnts.back());<br> <br>        for (int i = 1; i &lt; SZ(pnts); i++)<br>            lines.push_back(make_pair(pnts[i - 1], pnts[i]));<br>    }<br>    memset(parent, -1, sizeof(parent));<br>    int N = lines.size();<br>    for (int i = 0; i &lt; N; i++)<br>        for (int j = i + 1; j &lt; N; j++)<br>        {<br>            int ra = root(i);<br>            int rb = root(j);<br>            if (ra != rb &amp;&amp; isect(lines[i].first, lines[i].second, lines[j].first, lines[j].second))<br>            {<br>                if (parent[ra] &lt; parent[rb])<br>                    swap(ra, rb);<br>                parent[ra] = rb;<br>            }<br>        }<br>    int a = 0;<br>    for (int i = 0; i &lt; N; i++)<br>        if (parent[i] &lt; 0) a++;<br>    return a;<br>}<br> <br> <br>// Powered by FileEdit<br></td>