<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;queue&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cmath&gt;<br>#include &lt;algorithm&gt;<br>using namespace std;<br><br>#define PB push_back<br>#define SZ(v) ((int)(v).size())<br>#define MP make_pair<br>#define FOR(i,a,b) for(int i=(a);i&lt;(b);++i)<br>#define REP(i,n) FOR(i,0,n)<br>#define FORE(i,a,b) for(int i=(a);i&lt;=(b);++i)<br>#define REPE(i,n) FORE(i,0,n)<br>#define FORSZ(i,a,v) FOR(i,a,SZ(v))<br>#define REPSZ(i,v) REP(i,SZ(v))<br>#define VAR(a,b) __typeof(b) a=b<br>#define FORIT(i,v) for(VAR(i,(v).begin());i!=(v).end();++i)<br><br>typedef long long ll; typedef pair&lt;int,int&gt; PII;<br>typedef vector&lt;int&gt; VI; typedef vector&lt;VI&gt; VVI;<br>typedef vector&lt;double&gt; VD; typedef vector&lt;VD&gt; VVD;<br>typedef vector&lt;ll&gt; VLL; typedef vector&lt;VLL&gt; VVLL;<br>typedef vector&lt;PII&gt; VPII; typedef vector&lt;VPII&gt; VVPII;<br>typedef vector&lt;string&gt; VS; typedef vector&lt;VS&gt; VVS;<br><br>template&lt;class T&gt; T cast(const string &amp;s) { T ret; ostringstream a; a&lt;&lt;s; istringstream b(a.str()); b&gt;&gt;ret; return ret; }<br>template&lt;class T&gt; vector&lt;T&gt; split(const string &amp;s,const string &amp;x=" ") { vector&lt;T&gt; ret; string cur; REPSZ(i,s) if(x.find(s[i])==string::npos) cur+=s[i]; else if(cur!="") ret.PB(cast&lt;T&gt;(cur)),cur=""; if(cur!="") ret.PB(cast&lt;T&gt;(cur)); return ret; }<br><br>bool can(VI req,VI val) {<br>  sort(req.begin(),req.end()); sort(val.begin(),val.end());<br>  REPSZ(i,req) if(req[i]&gt;val[i]) return false;<br>  return true;<br>}<br><br>class CardsAndSlots {<br>public:<br>  string firstValid(vector &lt;int&gt; values, string letters, vector &lt;int&gt; required) {<br>    if(!can(required,values)) return "";<br>    string ret;<br>    while(SZ(values)&gt;0) {<br>      int b=-1;<br>      REPSZ(i,values) if(values[i]&gt;=required[0]&amp;&amp;(b==-1||letters[i]&lt;letters[b]||letters[i]==letters[b]&amp;&amp;values[i]&lt;values[b])) {<br>        VI nvalues=values; string nletters=letters; VI nrequired=required;<br>        nvalues.erase(nvalues.begin()+i); nletters.erase(nletters.begin()+i); nrequired.erase(nrequired.begin()+0);<br>        if(can(nrequired,nvalues)) b=i;<br>      }<br>      assert(b!=-1);<br>      ret+=letters[b];<br>      values.erase(values.begin()+b); letters.erase(letters.begin()+b); required.erase(required.begin()+0);<br>    }<br>    return ret;<br>  }<br>};<br></td>