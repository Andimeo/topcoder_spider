<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Text;<br><br>public class PyramidPuzzle {<br>    int size;<br>    int n;<br><br>    int[] identity()<br>    {<br>        int[] res = new int[size];<br>        for (int i = 0; i &lt; size; ++i)<br>            res[i] = i;<br>        return res;<br>    }<br><br>    void setRotateSide(int[] res, int a, int b, bool twice)<br>    {<br>        int[] p = new int[n * n];<br>        int row = 0;<br>        int col = 0;<br>        for (int u = 0; u &lt; n * n; ++u)<br>        {<br>            int nrow = n - 1 - (col / 2);<br>            int ncol = 2 * (row - (col / 2)) - col % 2;<br>            p[u] = nrow * nrow + ncol;<br>            if (col == 2 * row)<br>            {<br>                ++row;<br>                col = 0;<br>            }<br>            else<br>            {<br>                ++col;<br>            }<br>        }<br>        if (twice)<br>        {<br>            int[] pp = new int[n * n];<br>            for (int i = 0; i &lt; n * n; ++i)<br>                pp[i] = p[p[i]];<br>            p = pp;<br>        }<br>        for (int i = 0; i &lt; n * n; ++i)<br>        {<br>            res[i + a * n * n] = p[i] + b * n * n;<br>        }<br>    }<br><br>    int[] minusX(int x)<br>    {<br>        int[] res = identity();<br>        for (int u = 0; u &lt; x * x; ++u)<br>        {<br>            res[u] = 2 * n * n + u;<br>            res[u + n * n] = u;<br>            res[u + 2 * n * n] = u + n * n;<br>        }<br>        if (x == n)<br>        {<br>            setRotateSide(res, 3, 3, false);<br>        }<br>        return res;<br>    }<br><br>    int[] prod(int[] a, int[] b)<br>    {<br>        int[] c = new int[size];<br>        for (int i = 0; i &lt; size; ++i)<br>            c[i] = a[b[i]];<br>        return c;<br>    }<br><br>    int[] plusX(int x)<br>    {<br>        int[] p = minusX(x);<br>        return prod(p, p);<br>    }<br><br>    int[] back()<br>    {<br>        int[] res = identity();<br>        setRotateSide(res, 0, 0, false);<br>        setRotateSide(res, 1, 2, true);<br>        setRotateSide(res, 2, 3, false);<br>        for (int i = 0; i &lt; n * n; ++i)<br>        {<br>            res[3 * n * n + i] = i + n * n;<br>        }<br>        return res;<br>    }<br><br>    int[] left()<br>    {<br>        return prod(plusX(n), prod(back(), minusX(n)));<br>    }<br><br>    int[] right()<br>    {<br>        return prod(minusX(n), prod(back(), plusX(n)));<br>    }<br><br>    public int repeatCount(int edgeLength, string[] moves)<br>    {<br>        n = edgeLength;<br>        size = 4 * n * n;<br>        StringBuilder b = new StringBuilder();<br>        foreach (string x in moves)<br>            b.Append(x);<br>        int[] r = identity();<br>        foreach (string part in b.ToString().Split(' '))<br>        {<br>            switch (part[0])<br>            {<br>                case '+':<br>                    r = prod(plusX(int.Parse(part.Substring(1))), r);<br>                    break;<br><br>                case '-':<br>                    r = prod(minusX(int.Parse(part.Substring(1))), r);<br>                    break;<br><br>                case 'L':<br>                    r = prod(left(), r);<br>                    break;<br><br>                case 'R':<br>                    r = prod(right(), r);<br>                    break;<br><br>                case 'B':<br>                    r = prod(back(), r);<br>                    break;<br>            }<br>        }<br>        int[] pow = new int[size + 1];<br>        bool[] mark = new bool[size];<br>        for (int i = 0; i &lt; size; ++i)<br>        {<br>            if (!mark[i])<br>            {<br>                int cnt = 0;<br>                int j = i;<br>                do<br>                {<br>                    j = r[j];<br>                    mark[j] = true;<br>                    ++cnt;<br>                } while (i != j);<br>                for (int k = 2; k * k &lt;= cnt; ++k)<br>                {<br>                    int pw = 0;<br>                    while (cnt % k == 0)<br>                    {<br>                        cnt /= k;<br>                        ++pw;<br>                    }<br>                    pow[k] = Math.Max(pow[k], pw);<br>                }<br>                if (cnt &gt; 1)<br>                    pow[cnt] = Math.Max(pow[cnt], 1);<br>            }<br>        }<br>        int res = 1;<br>        for (int i = 0; i &lt;= size; ++i)<br>            for (int j = 0; j &lt; pow[i]; ++j)<br>            {<br>                res = (res * i) % 987654319;<br>            }<br>        return res;<br>  }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>