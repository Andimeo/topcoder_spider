<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;  <br>#include &lt;iostream&gt;  <br>#include &lt;sstream&gt;  <br>#include &lt;string&gt;  <br>#include &lt;vector&gt;  <br>#include &lt;queue&gt;  <br>#include &lt;set&gt;  <br>#include &lt;map&gt;  <br>#include &lt;cstdio&gt;  <br>#include &lt;cstdlib&gt;  <br>#include &lt;cctype&gt;  <br>#include &lt;cmath&gt;  <br>#include &lt;list&gt;  <br>using namespace std;  <br><br>#define PB push_back<br>#define MP make_pair<br>#define SZ(v) ((int)(v).size())<br>#define FOR(i,a,b) for(int i=(a);i&lt;(b);++i)<br>#define REP(i,n) FOR(i,0,n)<br>#define FORE(i,a,b) for(int i=(a);i&lt;=(b);++i)<br>#define REPE(i,n) FORE(i,0,n)<br>#define FORSZ(i,a,v) FOR(i,a,SZ(v))<br>#define REPSZ(i,v) REP(i,SZ(v))<br>typedef long long ll;<br><br>void norm(vector&lt;vector&lt;int&gt; &gt; &amp;x) {<br>  vector&lt;vector&lt;int&gt; &gt; y=x;<br>  REPSZ(i,y) {<br>    if(y&lt;x) x=y;<br>    y.PB(y[0]);<br>    y.erase(y.begin());<br>  }<br>}<br><br>vector&lt;int&gt; get(const vector&lt;int&gt; &amp;type,const vector&lt;int&gt; &amp;door,int at,int me) {<br>  REPSZ(i,door) if(door[i]==at) {<br>    vector&lt;int&gt; ret(1,type[me]);<br>    FORSZ(j,1,door) ret.PB(type[door[(i+j)%SZ(door)]]);<br>    return ret;<br>  }<br>  assert(false);<br>}<br><br>class TwistyPassages {  <br>public:  <br>  vector &lt;int&gt; similarRooms(vector &lt;string&gt; maze) {<br>    int n=SZ(maze);<br>    vector&lt;int&gt; type(n,0); int nrtypes=1;<br>    vector&lt;vector&lt;int&gt; &gt; doors(n,vector&lt;int&gt;(0));<br>    REP(i,n) { istringstream iss(maze[i]); int j; while(iss&gt;&gt;j) doors[i].PB(j); }<br>    <br>    while(true) {<br>      bool change=false;<br>      REP(i,nrtypes) {<br>        map&lt;vector&lt;vector&lt;int&gt; &gt;,vector&lt;int&gt; &gt; have;<br>        REP(j,n) if(type[j]==i) {<br>          vector&lt;vector&lt;int&gt; &gt; cur(SZ(doors[j])); REPSZ(k,doors[j]) cur[k]=get(type,doors[doors[j][k]],j,doors[j][k]); norm(cur);<br>          have[cur].PB(j);<br>        }<br>        if(SZ(have)&gt;1) {<br>          for(map&lt;vector&lt;vector&lt;int&gt; &gt;,vector&lt;int&gt; &gt;::iterator j=have.begin();j!=have.end();++j) {<br>            if(j==have.begin()) continue;<br>            REPSZ(k,j-&gt;second) type[j-&gt;second[k]]=nrtypes;<br>          }<br>          nrtypes++;<br>          change=true;<br>          break;<br>        }<br>      }<br>      if(!change) break;<br>    }<br>    REP(j,n) {<br>      printf("%d (%d): ",j,type[j]);<br>          vector&lt;vector&lt;int&gt; &gt; cur(SZ(doors[j])); REPSZ(k,doors[j]) cur[k]=get(type,doors[doors[j][k]],j,doors[j][k]); norm(cur);<br>      REPSZ(j,cur) { printf("["); REPSZ(k,cur[j]) printf("%d%c",cur[j][k],k==SZ(cur[j])-1?']':','); }<br>      puts("");<br>    }<br>    <br>    vector&lt;int&gt; ret(n,0);<br>    REP(i,n) REP(j,n) if(i!=j&amp;&amp;type[i]==type[j]) ++ret[i];<br>    return ret;<br>  }  <br>};<br></td>