<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br> <br>public class CommercialPlanner<br>{<br>  class C : IComparable&lt;C&gt;<br>  {<br>    public long st;<br>    public long dur;<br>    public long free;<br>    public C next;<br>    <br>    public C (long st, long dur)<br>    {<br>      this.st = st;<br>      this.dur = dur;<br>    }<br>    <br>    <br>    public int CompareTo (C c)<br>    {<br>      return this.st.CompareTo (c.st);<br>    }<br>  }<br>  <br>  void optimize (ref long bi, ref long bv, long ti, long tv)<br>  {<br>    if (tv &lt; bv)<br>      return;<br>    <br>    if (tv == bv &amp;&amp; ti &gt; bi)<br>      return;<br>    <br>    bi = ti;<br>    bv = tv;<br>  }<br>  <br>  public int bestMinute (int[] starts, int[] durations, int ourDuration, int secondsPerDay, int n)<br>  {<br>    long od = ourDuration;<br>    long spd = secondsPerDay;<br>    <br>    int q = starts.Length;<br>    <br>    if (q == 0)<br>    {<br>      if (od &lt;= spd)<br>        return 0;<br>      <br>      return -1;<br>    }<br>    <br>    List&lt;C&gt; l = new List&lt;C&gt; ();<br>    <br>    for (int i = 0; i &lt; q; ++i)<br>      l.Add (new C (starts[i], durations[i]));<br>    <br>    l.Sort ();<br>    <br>    for (int i = 0; i &lt; q - 1; ++i)<br>    {<br>      l[i].free = l[i + 1].st - l[i].st - l[i].dur;<br>      l[i].next = l[i + 1];<br>    }<br>    <br>    l[q - 1].free = spd + l[0].st - l[q - 1].st - l[q - 1].dur;<br>    l[q - 1].next = l[0];<br>    <br>    long besti = -1;<br>    long bestv = -1;<br>    <br>    foreach (C c in l)<br>      if (c.free &gt;= od)<br>    {<br>      long tryi = (c.st + c.dur) % spd;<br>      long tryv = c.free;<br>      <br>      C cn = c;<br>      <br>      for (int i = 0; i &lt; n - 1; ++i)<br>      {<br>        cn = cn.next;<br>        tryv += cn.dur + cn.free;<br>      }<br>      <br>      tryv = Math.Min (tryv, spd);<br>      <br>      optimize (ref besti, ref bestv, tryi, tryv);<br>    }<br>    <br>    if (l[0].st &gt;= od &amp;&amp; l[q - 1].st + l[q - 1].dur &lt;= spd)<br>    {<br>      long tryi = 0;<br>      long tryv = l[0].st;<br>      <br>      C cn = l[q - 1];<br>      <br>      for (int i = 0; i &lt; n - 1; ++i)<br>      {<br>        cn = cn.next;<br>        tryv += cn.dur + cn.free;<br>      }<br>      <br>      tryv = Math.Min (tryv, spd);<br>      <br>      optimize (ref besti, ref bestv, tryi, tryv);<br>    }<br>    <br>    return (int)besti;<br>  }<br>  <br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>