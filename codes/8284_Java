<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import static java.lang.StrictMath.min;<br>import static java.lang.StrictMath.max;<br><br><br>public class CommercialPlanner {<br>    int n, k;<br>    long maxPos, maxAns;<br><br>    boolean overlap(long p0, long d0, long p1, long d1) {<br>        if (p0 + d0 &lt;= p1) {<br>            return false;<br>        }<br>        if (p1 + d1 &lt;= p0) {<br>            return false;<br>        }<br>        return true;<br>    }<br><br>    public int bestMinute(int[] starts, int[] dur, int d, int spd, int m) {<br>        n = starts.length;<br>        long[] pos = new long[n + 1];<br>        for (int i = 0; i &lt; n; ++i) {<br>            for (int j = i + 1; j &lt; n; ++j) {<br>                if (starts[j] &lt; starts[i]) {<br>                    k = starts[i];<br>                    starts[i] = starts[j];<br>                    starts[j] = k;<br>                    k = dur[i];<br>                    dur[i] = dur[j];<br>                    dur[j] = k;<br>                }<br>            }<br>            pos[i] = starts[i];<br>            pos[i] = (pos[i] + dur[i]) % spd;<br>        }<br>        pos[n] = 0;<br><br>        maxAns = -1;<br>        maxPos = -1;<br>        long[] a = new long[n];<br>        for (int k = 0; k &lt;= n; ++k) {<br>            long p = pos[k];<br>            boolean fail = false;<br>            long t;<br>            for (int i = 0; i &lt; n; ++i) {<br>                if (overlap(p, d, starts[i], dur[i])) {<br>                    fail = true;<br>                    break;<br>                }<br>                if (overlap(p - spd, d, starts[i], dur[i])) {<br>                    fail = true;<br>                    break;<br>                }<br>                if (overlap(p + spd, d, starts[i], dur[i])) {<br>                    fail = true;<br>                    break;<br>                }<br>                t = starts[i];<br>                while (t &lt; p) {<br>                    t += spd;<br>                }<br>                a[i] = t;<br>            }<br>            if (fail) {<br>                continue;<br>            }<br>            Arrays.sort(a);<br>            long l;<br>            if (m &gt; n) {<br>                l = 0;<br>            } else {<br>                l = a[m - 1] - p;<br>            }<br>            if (l &gt; maxAns || (l == maxAns &amp;&amp; p &lt; maxPos)) {<br>                maxAns = l;<br>                maxPos = p;<br>            }<br>        }<br>        return (int) maxPos;<br>    }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by CodeProcessor<br></td>