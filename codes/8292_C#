<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class FactoryEmulation {<br>  class Order : IComparable&lt;Order&gt; {<br>    public int time;<br>    public long goods;<br>    public long income;<br><br>    public Order(int a, long b, long c) {<br>      time = a;<br>      goods = b;<br>      income = c;<br>    }<br><br>    public int CompareTo(Order x) {<br>      return time.CompareTo(x.time);<br>    }<br>  }<br><br>  class Penalty : IComparable&lt;Penalty&gt; {<br>    public long a;<br>    public long b;<br>    public long c;<br>    public long start;<br><br>    public Penalty(long p1, long p2, long p3, long p4) {<br>      a = p1;<br>      b = p2;<br>      c = p3;<br>      start = p4;<br>    }<br><br>    public int CompareTo(Penalty x) {<br>      return start.CompareTo(x.start);<br>    }<br>  }<br><br>  Order[] all;<br>  long res;<br><br>  long eval(long at, long time, List&lt;Penalty&gt; p, long spent) {<br>    long z = at * time - spent;<br>    int l = -1;<br>    int r = p.Count;<br>    while (r - l &gt; 1) {<br>      int m = (l + r) / 2;<br>      if (p[m].start &lt;= at)<br>  l = m;<br>      else<br>  r = m;<br>    }<br>    if (l &gt;= 0)<br>      z += (p[l].a * at * at + p[l].b * at + p[l].c);<br>    return z;<br>  }<br><br>  void doIt(int at, int time, long minP, long maxP, List&lt;Penalty&gt; p, long money, long spent) {<br>    if (at &gt;= all.Length) {<br>      res = Math.Max(res, money);<br>      return;<br>    }<br>    doIt(at + 1, time, minP, maxP, p, money, spent);<br>    int spareTime = all[at].time - time;<br>    maxP += spareTime;<br>    time += spareTime;<br>    long left = minP;<br>    long right = maxP;<br>    while (right - left &gt; 5) {<br>      long lm = (2 * left + right) / 3;<br>      long rm = (left + 2 * right) / 3;<br>      if (eval(lm, time, p, spent) &gt; eval(rm, time, p, spent)) {<br>  right = rm;<br>      } else left = lm;<br>    }<br>    long mx = left;<br>    for (long i = left + 1; i &lt;= right; ++i)<br>      if (eval(i, time, p, spent) &gt; eval(mx, time, p, spent))<br>  mx = i;<br>    if (eval(mx, time, p, spent) &lt; all[at].goods)<br>      return;<br>    left = minP - 1;<br>    right = mx;<br>    while (right - left &gt; 1) {<br>      long m = (left + right) / 2;<br>      if (eval(m, time, p, spent) &gt;= all[at].goods)<br>  right = m;<br>      else<br>  left = m;<br>    }<br>    long nMinP = right;<br>    left = maxP + 1;<br>    right = mx;<br>    while (left - right &gt; 1) {<br>      long m = (left + right) / 2;<br>      if (eval(m, time, p, spent) &gt;= all[at].goods)<br>  right = m;<br>      else<br>  left = m;<br>    }<br>    long nMaxP = right;<br>    List&lt;Penalty&gt; nl = new List&lt;Penalty&gt;();<br>    foreach (Penalty x in p) {<br>      if (x.start &lt; nMaxP)<br>  nl.Add(x);<br>    }<br>    nl.Add(new Penalty(-1, nMaxP - time, eval(nMaxP, time, p, 0), nMaxP));<br>    doIt(at + 1, time, nMinP, nMaxP, nl, money + all[at].income, spent + all[at].goods);<br>  }<br><br>  public long maxIncome(string[] orders) {<br>    res = 0;<br>    all = Array.ConvertAll&lt;string, Order&gt;(orders, delegate(string x) {<br>    string[] p = x.Split(' ');<br>    return new Order(int.Parse(p[0]), int.Parse(p[1]), int.Parse(p[2]));<br>  });<br>    Array.Sort(all);<br>    List&lt;Penalty&gt; l = new List&lt;Penalty&gt;();<br>    l.Add(new Penalty(-1, 1, 0, 1));<br>    doIt(0, 0, 1, 1, l, 0, 0);<br>    return res;<br>  }<br>}<br><br><br>// Powered by FileEdit<br></td>