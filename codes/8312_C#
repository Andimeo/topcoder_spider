<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br><br>public class TowersAttack <br>{<br>    public double maxDamage(int[] towersX, int[] towersY, int r, int damage, int enemyX, int enemyY)<br>    {<br>        int N = towersX.Length;<br>        bool[,] B = new bool[N, N];<br>        double r2 = r * r;<br>        for (int i = 0; i &lt; N; i++)<br>        {<br>            for (int j = 0; j &lt; i; j++)<br>            {<br>                if ((towersX[i] - towersX[j]) * (towersX[i] - towersX[j]) + (towersY[i] - towersY[j]) * (towersY[i] - towersY[j]) - 1e-9 &lt; r2)<br>                {<br>                    B[i, j] = true;<br>                    B[j, i] = true;<br>                }<br>                else<br>                {<br>                    B[i, j] = false;<br>                    B[j, i] = false;<br>                }<br>            }<br>        }<br>        int[] E = new int[N];<br>        Queue&lt;int&gt; Q = new Queue&lt;int&gt;();<br>        for (int i = 0; i &lt; N; i++)<br>        {<br>            if ((towersX[i] - enemyX) * (towersX[i] - enemyX) + (towersY[i] - enemyY) * (towersY[i] - enemyY) - 1e-9 &lt; r2)<br>            {<br>                Q.Enqueue(i);<br>                E[i] = 0;<br>            }<br>            else<br>            {<br>                E[i] = 1000;<br>            }<br>        }<br>        if (Q.Count == 0)<br>            return 0;<br>        while (Q.Count &gt; 0)<br>        {<br>            int k = Q.Dequeue();<br>            for (int i = 0; i &lt; N; i++)<br>            {<br>                if (E[i] &gt; E[k] + 1 &amp;&amp; B[i, k])<br>                {<br>                    E[i] = E[k] + 1;<br>                    Q.Enqueue(i);<br>                }<br>            }<br>        }<br>        double g = 0;<br>        for (int i = 0; i &lt; N; i++)<br>        {<br>            if (E[i] != 1000)<br>            {<br>                g += (double)(damage) / Math.Pow(2, E[i]);<br>            }<br>        }<br>        return g;<br>    }<br>    <br><br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by r1cs1]<br>// Powered by CodeProcessor<br></td>