<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import static java.lang.Math.*;<br>public class NCool {<br>  private static final int MAX = 10000;<br>  public static int nCoolPoints(int[] pxs, int[] pys, int n){<br>    ArrayList&lt;Double2D&gt; qs = new ArrayList&lt;Double2D&gt;();<br>    for(int i = 0; i &lt; pxs.length; i++){<br>      qs.add(new Double2D(pxs[i], pys[i]));<br>    }<br>    ArrayList&lt;Double2D&gt; hs = new ArrayList&lt;Double2D&gt;();<br>    hs = Double2D.convexHull(qs);<br>    <br>    int m = hs.size();<br>    int[] xs = new int[m];<br>    int[] ys = new int[m];<br>    for(int i = 0; i &lt; m; i++){<br>      xs[i] = (int)Math.round(hs.get(i).x);<br>      ys[i] = (int)Math.round(hs.get(i).y);<br>    }<br>    int[] maxys = new int[MAX + 1];<br>    Arrays.fill(maxys, Integer.MIN_VALUE);<br>    int[] minys = new int[MAX + 1];<br>    Arrays.fill(minys, Integer.MAX_VALUE);<br>    ArrayList&lt;Int2D&gt; ps = new ArrayList&lt;Int2D&gt;();<br>    for(int i1 = 0; i1 &lt; m; i1++){<br>      int i2 = (i1 + 1) % m;<br>      int x1 = xs[i1], x2 = xs[i2];<br>      int y1 = ys[i1], y2 = ys[i2];<br>      if(x1 == x2){<br>        maxys[x1] = Math.max(y1, maxys[x1]);<br>        maxys[x1] = Math.max(y2, maxys[x1]);<br>        minys[x1] = Math.min(y1, minys[x1]);<br>        minys[x1] = Math.min(y2, minys[x1]);<br>      }<br>      else{<br>        for(int x = Math.min(x1, x2); x &lt;= Math.max(x1, x2); x++){<br>          double y = y1 + ((double)(y2 - y1) / (double)(x2 - x1)) * (x - x1);<br>          // System.out.println(x + " " + y);<br>          maxys[x] = Math.max((int)(Math.floor(y + 1.0E-10)), maxys[x]);<br>          minys[x] = Math.min((int)(Math.ceil(y - 1.0E-10)), minys[x]);<br>        }<br>      }<br>    }<br>    for(int x = 0; x &lt;= MAX; x++){<br>      if(minys[x] &lt;= maxys[x]){<br>        for(int y = minys[x]; y &lt;= maxys[x]; y++){<br>          // System.out.println(x + " " + y);<br>          ps.add(new Int2D(x, y));<br>        }<br>      }<br>    }<br>    HashMap&lt;Int2D, Integer&gt; cnt = new HashMap&lt;Int2D, Integer&gt;();<br>    for(Int2D p : ps){<br>      Int2D key = new Int2D(p.x % (n - 1), p.y % (n - 1));<br>      if(cnt.containsKey(key)){<br>        cnt.put(key, cnt.get(key) + 1);<br>      }<br>      else{<br>        cnt.put(key, 1);<br>      }<br>    }<br>    int res = 0;<br>    for(Int2D key : cnt.keySet()){<br>      if(cnt.get(key) &gt;= 2) res += cnt.get(key);<br>    }<br>    return res;<br>  }<br>}<br><br>class Int2D{<br>  public int x, y;<br>  public Int2D(int x, int y) {<br>    super();<br>    this.x = x;<br>    this.y = y;<br>  }<br>  @Override<br>  public int hashCode() {<br>    final int prime = 31;<br>    int result = 1;<br>    result = prime * result + x;<br>    result = prime * result + y;<br>    return result;<br>  }<br>  @Override<br>  public boolean equals(Object obj) {<br>    if (this == obj)<br>      return true;<br>    if (obj == null)<br>      return false;<br>    if (getClass() != obj.getClass())<br>      return false;<br>    final Int2D other = (Int2D) obj;<br>    if (x != other.x)<br>      return false;<br>    if (y != other.y)<br>      return false;<br>    return true;<br>  }<br>}<br><br>class Double2D {<br>  static final double EPS = 1.0E-10; // problem specific<br><br>  static int fcmp(double x, double y) {<br>    return abs(x - y) &lt; EPS ? 0 : Double.compare(x, y);<br>  }<br><br>  static ArrayList&lt;Double2D&gt; convexHull(ArrayList&lt;Double2D&gt; ps) {<br>    ArrayList&lt;Double2D&gt; qs = new ArrayList&lt;Double2D&gt;(ps);<br>    Comparator&lt;Double2D&gt; cmp = new Comparator&lt;Double2D&gt;() {<br>      public int compare(Double2D p1, Double2D p2) {<br>        return fcmp(p1.y, p2.y) == 0 ? -fcmp(p1.x, p2.x) : fcmp(p1.y,<br>            p2.y);<br>      }<br>    };<br>    Collections.sort(qs, cmp);<br>    ArrayList&lt;Double2D&gt; hs = new ArrayList&lt;Double2D&gt;();<br>    walkRightSide(qs, hs);<br>    Collections.reverse(qs);<br>    walkRightSide(qs, hs);<br>    return hs;<br>  }<br><br>  static void walkRightSide(ArrayList&lt;Double2D&gt; qs, ArrayList&lt;Double2D&gt; hs) {<br>    hs.add(qs.get(0));<br>    int s = hs.size();<br>    hs.add(qs.get(1));<br>    int cnt = 2;<br>    while (cnt &lt; qs.size()) {<br>      Double2D p1 = hs.get(hs.size() - 2);<br>      Double2D p2 = hs.get(hs.size() - 1);<br>      Double2D p3 = qs.get(cnt);<br>      if (ccw(p1, p2, p3) &gt; 0) { /* this condition is problem specific */<br>        hs.add(p3);<br>        cnt++;<br>      } else {<br>        hs.remove(hs.size() - 1);<br>        if (hs.size() == s) {<br>          hs.add(p3);<br>          cnt++;<br>        }<br>      }<br>    }<br>    hs.remove(hs.size() - 1);<br>  }<br><br>  double x, y;<br><br>  Double2D(double x, double y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br><br>  Double2D add(Double2D p) {<br>    return new Double2D(x + p.x, y + p.y);<br>  }<br><br>  Double2D sub(Double2D p) {<br>    return new Double2D(x - p.x, y - p.y);<br>  }<br><br>  double dot(Double2D p) {<br>    return x * p.x + y * p.y;<br>  }<br><br>  double cross(Double2D p) {<br>    return x * p.y - y * p.x;<br>  }<br><br>  double norm() {<br>    return sqrt(x * x + y * y);<br>  }<br><br>  double norm2() {<br>    return x * x + y * y;<br>  }<br><br>  double dist(Double2D p) {<br>    double dx = x - p.x, dy = y - p.y;<br>    return sqrt(dx * dx + dy * dy);<br>  }<br><br>  double dist2(Double2D p) {<br>    double dx = x - p.x, dy = y - p.y;<br>    return dx * dx + dy * dy;<br>  }<br><br>  static int ccw(Double2D p1, Double2D p2, Double2D p3) {<br>    Double2D v12 = p2.sub(p1), v13 = p3.sub(p1);<br>    if (fcmp(v12.cross(v13), 0) &gt; 0)<br>      return 1;<br>    if (fcmp(v12.cross(v13), 0) &lt; 0)<br>      return -1;<br>    if (fcmp(v12.dot(v13), 0) &lt; 0)<br>      return -2;<br>    if (fcmp(v12.norm2(), v13.norm2()) &lt; 0)<br>      return 2;<br>    return 0;<br>  }<br>}<br></td>