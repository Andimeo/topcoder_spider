<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br> <br>public class HillWalker<br>{<br>    public int highestPoint(string[] landscape, int threshold, int timeToDark)<br>    {<br>        int[,] height = new int[landscape.Length, landscape[0].Length];<br>        int[,] timeback = new int[landscape.Length, landscape[0].Length];<br>        bool[,] done = new bool[landscape.Length, landscape[0].Length];<br>        for (int i = 0; i &lt; landscape.Length; i++)<br>        {<br>            for (int j = 0; j &lt; landscape[i].Length; j++)<br>            {<br>                if (char.IsLower(landscape[i][j]))<br>                    height[i, j] += landscape[i][j] - 'a' + 26;<br>                else<br>                    height[i, j] += landscape[i][j] - 'A';<br>            }<br>        }<br> <br>        PriorityQueue&lt;Node&gt; Q = new PriorityQueue&lt;Node&gt;();<br>        Q.Push(new Node(0, 0, 0));<br> <br>        int[] dx = new int[] { -1, 0, 1, 0 };<br>        int[] dy = new int[] { 0, -1, 0, 1 };<br>        while (Q.Count &gt; 0)<br>        {<br>            Node top = Q.Pop();<br>            if (top.X &lt; 0 || top.X &gt;= landscape.Length || top.Y &lt; 0 || top.Y &gt;= landscape[0].Length || done[top.X, top.Y])<br>                continue;<br>            done[top.X, top.Y] = true;<br>            timeback[top.X, top.Y] = top.steps;<br> <br>            for (int i = 0; i &lt; 4; i++)<br>            {<br>                int nx = top.X + dx[i];<br>                int ny = top.Y + dy[i];<br>                if (nx &lt; 0 || nx &gt;= landscape.Length || ny &lt; 0 || ny &gt;= landscape[0].Length) continue;<br> <br>                if (Math.Abs(height[top.X, top.Y] - height[nx, ny]) &gt; threshold) continue;<br> <br>                int time = 1;<br>                if (height[nx, ny] &lt; height[top.X, top.Y])<br>                    time = (height[top.X, top.Y] - height[nx, ny]) * (height[top.X, top.Y] - height[nx, ny]);<br> <br>                Q.Push(new Node(top.steps + time, nx, ny));<br>            }<br>        }<br> <br>        int ans = 0;<br>        Q.Push(new Node(0, 0, 0));<br>        done = new bool[landscape.Length, landscape[0].Length];<br>        while (Q.Count &gt; 0)<br>        {<br>            Node top = Q.Pop();<br>            if (top.X &lt; 0 || top.X &gt;= landscape.Length || top.Y &lt; 0 || top.Y &gt;= landscape[0].Length || done[top.X, top.Y])<br>                continue;<br>            done[top.X, top.Y] = true;<br>            if (top.steps + timeback[top.X, top.Y] &lt;= timeToDark)<br>                ans = Math.Max(ans, height[top.X, top.Y]);<br> <br>            for (int i = 0; i &lt; 4; i++)<br>            {<br>                int nx = top.X + dx[i];<br>                int ny = top.Y + dy[i];<br>                if (nx &lt; 0 || nx &gt;= landscape.Length || ny &lt; 0 || ny &gt;= landscape[0].Length) continue;<br>                if (Math.Abs(height[top.X, top.Y] - height[nx, ny]) &gt; threshold) continue;<br> <br>                int time = 1;<br>                if (height[nx, ny] &gt; height[top.X, top.Y])<br>                    time = (height[nx, ny] - height[top.X, top.Y]) * (height[nx, ny] - height[top.X, top.Y]);<br> <br>                Q.Push(new Node(top.steps + time, nx, ny));<br>            }<br>        }<br>        return ans;<br>    }<br> <br>    class Node : IComparable&lt;Node&gt;<br>    {<br>        public int steps, X, Y;<br> <br>        public Node(int s, int x, int y)<br>        {<br>            X = x;<br>            Y = y;<br>            steps = s;<br>        }<br> <br>        public int CompareTo(Node other)<br>        {<br>            return steps - other.steps;<br>        }<br>    }<br> <br> <br>}<br> <br>public class PriorityQueue&lt;T&gt;<br>{<br>    private T[] list;<br>    public int Count;<br>    public System.Collections.Generic.Comparer&lt;T&gt; Comparer;<br> <br>    public PriorityQueue()<br>    {<br>        list = new T[16];<br>        Count = 0;<br>        Comparer = System.Collections.Generic.Comparer&lt;T&gt;.Default;<br>    }<br> <br>    public void Push(T value)<br>    {<br>        if (Count == list.Length)<br>        {<br>            T[] tmp = new T[list.Length * 2];<br>            System.Array.Copy(list, tmp, list.Length);<br>            list = tmp;<br>        }<br>        list[Count++] = value;<br>        int i = Count - 1;<br>        while (i &gt; 0 &amp;&amp; Comparer.Compare(list[i], list[parent(i)]) &lt; 0)<br>        {<br>            T tmp = list[i];<br>            list[i] = list[parent(i)];<br>            list[parent(i)] = tmp;<br>            i = parent(i);<br>        }<br>    }<br> <br>    public T Pop()<br>    {<br>        T ret = list[0];<br>        list[0] = list[--Count];<br>        int i = 0;<br>        while (true)<br>        {<br>            int left = (i * 2) + 1;<br>            if (left &gt;= Count) break;<br>            int right = left + 1;<br>            int ind = left;<br>            if (right &lt; Count &amp;&amp; Comparer.Compare(list[left], list[right]) &gt; 0)<br>                ind = right;<br>            if (Comparer.Compare(list[i], list[ind]) &gt;= 0)<br>            {<br>                T tmp = list[i];<br>                list[i] = list[ind];<br>                list[ind] = tmp;<br>                i = ind;<br>            }<br>            else break;<br>        }<br>        return ret;<br>    }<br> <br>    private int parent(int i)<br>    {<br>        return (i - 1) / 2;<br>    }<br>}<br>//Powered by [KawigiEdit] 2.0!<br></td>