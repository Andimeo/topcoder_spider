<td class="problemText" colspan="8" valign="middle" align="left">
            using namespace std;<br> <br>#include &lt;stdlib.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;math.h&gt;<br>#include &lt;ctype.h&gt;<br>#include &lt;string.h&gt;<br>#include &lt;string&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br> <br>#define PB push_back<br>#define SZ size()<br>#define REP(v, hi) for (int v=0; v&lt;(hi); v++)<br>#define REPD(v, hi) for (int v=((hi)-1); v&gt;=0; v--)<br>#define FOR(v, lo, hi) for (int v=(lo); v&lt;(hi); v++)<br>#define FORD(v, lo, hi) for (int v=((hi)-1); v&gt;=(lo); v--)<br> <br>typedef vector &lt;int&gt; VI;<br>typedef vector &lt;VI&gt; VVI;<br>typedef vector &lt;string&gt; VS;<br> <br>/* ############################ THE REAL CODE ############################ */<br> <br>struct state { <br>  int x,y,t; <br>  state (int _x, int _y, int _t): x(_x), y(_y), t(_t) {};<br>};<br><br>bool operator &lt; (state a, state b) {<br>  return a.t &gt; b.t;<br>}<br><br>const int dy[4] = {-1,1,0,0};<br>const int dx[4] = {0,0,-1,1};<br><br>class HillWalker {<br>public:<br>  int highestPoint(vector &lt;string&gt; m, int thres, int dark) {<br>    int Y=m.SZ, X=m[0].SZ;<br>    VVI h(Y, VI(X));<br>    REP(y,Y) REP(x,X) {<br>      if (isupper(m[y][x])) h[y][x] = m[y][x]-'A';<br>      if (islower(m[y][x])) h[y][x] = m[y][x]-'a' + 26;<br>    }<br><br>    VVI d1(Y, VI(X, -1));<br>    VVI d2(Y, VI(X, -1));<br><br>    priority_queue&lt;state&gt; pq;<br>    pq.push(state(0,0,0));<br><br>    while (!pq.empty()) {<br>      state s = pq.top(); pq.pop();<br>      int y=s.y, x=s.x, t=s.t;<br>      if (d1[y][x]!=-1) continue;<br>      d1[y][x]=t;<br><br>      REP(d,4) {<br>  int ny=y+dy[d], nx=x+dx[d];<br>  if (ny&lt;0||ny&gt;=Y||nx&lt;0||nx&gt;=X) continue;<br>  int dh = h[y][x]-h[ny][nx];<br>  if (abs(dh) &gt; thres) continue;<br>  if (d1[ny][nx]!=-1) continue;<br>  pq.push(state(nx,ny,t + (dh&gt;0 ? dh*dh : 1)));<br>      }<br>    }<br><br>    pq.push(state(0,0,0));<br>    while (!pq.empty()) {<br>      state s = pq.top(); pq.pop();<br>      int y=s.y, x=s.x, t=s.t;<br>      if (d2[y][x]!=-1) continue;<br>      d2[y][x]=t;<br><br>      REP(d,4) {<br>  int ny=y+dy[d], nx=x+dx[d];<br>  if (ny&lt;0||ny&gt;=Y||nx&lt;0||nx&gt;=X) continue;<br>  int dh = h[y][x]-h[ny][nx];<br>  if (abs(dh) &gt; thres) continue;<br>  if (d2[ny][nx]!=-1) continue;<br>  pq.push(state(nx,ny,t + (dh&lt;0 ? dh*dh : 1)));<br>      }<br>    }<br><br>    int res=0;<br>    REP(y,Y) REP(x,X) if (d1[y][x]!=-1 &amp;&amp; d2[y][x]!=-1 &amp;&amp; d1[y][x]+d2[y][x] &lt;= dark) res &gt;?= h[y][x];<br>    return res;<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>