<td class="problemText" colspan="8" valign="middle" align="left">
            import java.math.BigInteger;<br>public class TVGameWinnings {<br> <br> <br>    //from http://www.merriampark.com/perm.htm<br>private static class PermutationGenerator {<br> <br>  private int[] a;<br>  private BigInteger numLeft;<br>  private BigInteger total;<br> <br>  //-----------------------------------------------------------<br>  // Constructor. WARNING: Don't make n too large.<br>  // Recall that the number of permutations is n!<br>  // which can be very large, even when n is as small as 20 --<br>  // 20! = 2,432,902,008,176,640,000 and<br>  // 21! is too big to fit into a Java long, which is<br>  // why we use BigInteger instead.<br>  //----------------------------------------------------------<br> <br>  public PermutationGenerator (int n) {<br>    if (n &lt; 1) {<br>      throw new IllegalArgumentException ("Min 1");<br>    }<br>    a = new int[n];<br>    total = getFactorial (n);<br>    reset ();<br>  }<br> <br>  //------<br>  // Reset<br>  //------<br> <br>  public void reset () {<br>    for (int i = 0; i &lt; a.length; i++) {<br>      a[i] = i;<br>    }<br>    numLeft = new BigInteger (total.toString ());<br>  }<br> <br>  //------------------------------------------------<br>  // Return number of permutations not yet generated<br>  //------------------------------------------------<br> <br>  public BigInteger getNumLeft () {<br>    return numLeft;<br>  }<br> <br>  //------------------------------------<br>  // Return total number of permutations<br>  //------------------------------------<br> <br>  public BigInteger getTotal () {<br>    return total;<br>  }<br> <br>  //-----------------------------<br>  // Are there more permutations?<br>  //-----------------------------<br> <br>  public boolean hasMore () {<br>    return numLeft.compareTo (BigInteger.ZERO) == 1;<br>  }<br> <br>  //------------------<br>  // Compute factorial<br>  //------------------<br> <br>  private static BigInteger getFactorial (int n) {<br>    BigInteger fact = BigInteger.ONE;<br>    for (int i = n; i &gt; 1; i--) {<br>      fact = fact.multiply (new BigInteger (Integer.toString (i)));<br>    }<br>    return fact;<br>  }<br> <br>  //--------------------------------------------------------<br>  // Generate next permutation (algorithm from Rosen p. 284)<br>  //--------------------------------------------------------<br> <br>  public int[] getNext () {<br> <br>    if (numLeft.equals (total)) {<br>      numLeft = numLeft.subtract (BigInteger.ONE);<br>      return a;<br>    }<br> <br>    int temp;<br> <br>    // Find largest index j with a[j] &lt; a[j+1]<br> <br>    int j = a.length - 2;<br>    while (a[j] &gt; a[j+1]) {<br>      j--;<br>    }<br> <br>    // Find index k such that a[k] is smallest integer<br>    // greater than a[j] to the right of a[j]<br> <br>    int k = a.length - 1;<br>    while (a[j] &gt; a[k]) {<br>      k--;<br>    }<br> <br>    // Interchange a[j] and a[k]<br> <br>    temp = a[k];<br>    a[k] = a[j];<br>    a[j] = temp;<br> <br>    // Put tail end of permutation after jth position in increasing order<br> <br>    int r = a.length - 1;<br>    int s = j + 1;<br> <br>    while (r &gt; s) {<br>      temp = a[s];<br>      a[s] = a[r];<br>      a[r] = temp;<br>      r--;<br>      s++;<br>    }<br> <br>    numLeft = numLeft.subtract (BigInteger.ONE);<br>    return a;<br> <br>  }}<br>    public static int[] getMinMax(String[] board){<br>  PermutationGenerator g = new PermutationGenerator(board.length);<br>  int max=Integer.MIN_VALUE;<br>  int min=Integer.MAX_VALUE;<br>  while(g.hasMore()){<br>      int[] cvals = g.getNext();<br>      boolean[] hit = new boolean[board.length];<br>      int groups = 0;<br>      int result = 1;<br>      outer:<br>      for(int i=0;i&lt;board.length;i++){<br>    if(!hit[i]){<br>        int k=i;<br>        do{<br>      hit[k]=true;<br>      char v = board[k].charAt(cvals[k]);<br>      if(v&lt;='9' &amp;&amp; v&gt;='0'){<br>          result *=v-'0';<br>      }else{<br>          result *=-( v-'A' +1);<br>      }<br>      if(result == 0)<br>          break outer;<br>      k= cvals[k];<br>        }while(k!=i);<br>        groups++;<br>    }<br>      }<br>      if(groups %2 ==0)<br>    result =-result;<br>      min = Math.min(min,result);<br>      max = Math.max(max,result);<br>  }<br>  return new int[]{min, max};<br>    }<br>}<br></td>