<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include "float.h"<br>#include &lt;ctime&gt;<br>using namespace std;<br><br>class WarTransportation {<br>public:<br>  int messenger(int n, vector &lt;string&gt; highways);<br>};<br><br>typedef pair&lt;int,int&gt; pii;<br><br>#define FOR(i, a, b) for (int i(a), _b(b); i &lt;= _b; ++i)<br>#define FORD(i,a,b) for (int i(a),_b(b); i &gt;= _b; --i)<br>#define REP(i,n) for (int i(0),_n(n); i &lt; _n; ++i)<br>#define REPD(i,n) for (int i((n)-1); i &gt;= 0; --i)<br>#define MP make_pair<br><br>template&lt;typename T&gt; inline int size(const T&amp; c) { return (int)c.size(); }<br><br>const int inf = 100000000;<br><br>int n;<br>vector&lt;pii&gt; forw[100], back[100];<br>int dist1[100], dist2[100], dist[100];<br>bool was[100];<br><br>int solve2() {<br>  REP(i, n) {<br>    dist[i] = inf;<br>    was[i] = false;<br>  }<br>  dist[1] = 0;<br>  for (;;) {<br>    int j = -1;<br>    REP(i, n)<br>      if (!was[i] &amp;&amp; dist[i] &lt; inf &amp;&amp; (j == -1 || dist[i] &lt; dist[j]))<br>        j = i;<br>    if (j == -1) break;<br>    was[j] = true;<br>    REP(i, size(back[j])) {<br>      int x = back[j][i].first, w = back[j][i].second;<br>      if (dist[j]+w &lt; dist[x]) {<br>        dist[x] = dist[j]+w;<br>        dist[x] = max(dist[x], dist2[x]);<br>      }<br>    }<br>  }<br>  return dist[0] &gt;= inf ? -1 : dist[0];<br>}<br><br>int getDistance(int x1, int x2) {<br>  REP(i, n) {<br>    dist[i] = inf;<br>    was[i] = false;<br>  }<br>  dist[x1] = 0;<br>  while (!was[x2]) {<br>    int j = -1;<br>    REP(i, n)<br>      if (!was[i] &amp;&amp; dist[i] &lt; inf &amp;&amp; (j == -1 || dist[i] &lt; dist[j]))<br>        j = i;<br>    if (j == -1) break;<br>    was[j] = true;<br>    REP(i, size(forw[j])) {<br>      int x = forw[j][i].first, w = forw[j][i].second;<br>      if (dist[j]+w &lt; dist[x]) <br>        dist[x] = dist[j]+w;<br>    }<br>  }<br>  return dist[x2];<br>}<br><br>int solve() {<br>  REP(i, n) {<br>    dist1[i] = inf;<br>    was[i] = false;<br>  }<br>  dist1[1] = 0;<br>  for (;;) {<br>    int j = -1;<br>    REP(i, n) <br>      if (!was[i] &amp;&amp; dist1[i] &lt; inf &amp;&amp; (j == -1 || dist1[i] &lt; dist1[j]))<br>        j = i;<br>    if (j == -1) break;<br>    was[j] = true;<br>    REP(i, size(back[j])) {<br>      int x = back[j][i].first, w = back[j][i].second;<br>      if (dist1[j]+w &lt; dist1[x]) <br>        dist1[x] = dist1[j]+w;<br>    }<br>  }<br>  if (dist1[0] &gt;= inf) return -1;<br><br>  REP(i, n) {<br>    if (dist1[i] &gt;= inf) {<br>      dist2[i] = inf;<br>      continue;<br>    }<br>    if (i == 1) {<br>      dist2[i] = 0;<br>      continue;<br>    }<br>    bool found = false;<br>    REP(j, size(forw[i])) {<br>      int x = forw[i][j].first, w = forw[i][j].second;<br>      if (dist1[i] == dist1[x]+w) {<br>        forw[i][j].second = inf;<br>        dist2[i] = max(dist1[i], getDistance(i, 1));<br>        forw[i][j].second = w;<br>        found = true;<br>        break;<br>      }<br>    }<br>    assert(found);<br>  }<br><br>  return solve2();<br>}<br><br>int WarTransportation::messenger(int n, vector &lt;string&gt; highways) {    <br>  ::n = n;<br>  REP(i, n) {<br>    forw[i].clear();<br>    back[i].clear();<br>  }<br>  string s;<br>  REP(i, size(highways)) s += highways[i];<br>  if (!s.empty()) s = ","+s;<br>  REP(i, size(s))<br>    if (s[i] == ',') {<br>      int u, v, w;<br>      sscanf(s.c_str()+(i+1), "%d%d%d", &amp;u, &amp;v, &amp;w);<br>      --u; --v;<br>      forw[u].push_back(MP(v, w));<br>      back[v].push_back(MP(u, w));<br>    }<br>  return solve();<br>}<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.12 [modified TZTester]<br>// Powered by CodeProcessor<br></td>