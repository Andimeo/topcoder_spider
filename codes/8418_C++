<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;cassert&gt;<br>#include &lt;cctype&gt;<br>#include &lt;cmath&gt;<br>#include &lt;complex&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;ctime&gt;<br>#include &lt;deque&gt;<br>#include &lt;functional&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;numeric&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;string&gt;<br>#include &lt;valarray&gt;<br>#include &lt;vector&gt;<br>#include &lt;utility&gt;<br><br>using namespace std;<br><br>#define all(v) (v).begin(), (v).end()<br><br>// Types<br>typedef long double ld;<br>typedef long long ll;<br>typedef pair &lt;int, int&gt; pii;<br>typedef vector &lt;int&gt; vi;<br>typedef vector &lt;pii&gt; vp;<br>typedef vector &lt;ld&gt; vd;<br>typedef vector &lt;string&gt; vs;<br>typedef vector &lt;bool&gt; vb;<br>typedef queue &lt;pii&gt; qp;<br>typedef map &lt;string, int&gt; msi;<br><br>// Constants<br>const int INF = 1000000000;<br>const ld EPS = 1e-10L;<br>const ld PI = 3.14159265358979L;<br><br>// Vars<br><br>// Functions<br>template &lt;typename T&gt; void read(const vs &amp;a, vector &lt;T&gt; &amp;b) {<br>  string s;<br>  for (int i = 0; i &lt; a.size(); ++i) {<br>    s += a[i];<br>  }<br>  istringstream in(s);<br>  T c;<br>  while (in &gt;&gt; c) {<br>    b.push_back(c);<br>  }<br>}<br><br>bool cmp(const pair &lt;pair &lt;int, int&gt;, pair &lt;int, string&gt; &gt; &amp;a, const pair &lt;pair &lt;int, int&gt;, pair &lt;int, string&gt; &gt; &amp;b) {<br>  if (a.second.first != b.second.first) {<br>    return a.second.first &gt; b.second.first;<br>  }<br>  return a.second.second &lt; b.second.second;<br>}<br><br>//Interface<br>class TheSquares {<br>public:<br>  vector &lt;string&gt; findSequence(vector &lt;string&gt; x, vector &lt;string&gt; y, vector &lt;string&gt; lengths, vector &lt;string&gt; names, int k) {<br>    vector &lt;string&gt; res;<br>    int n;<br>    vi xx, yy, l;<br>    vs t;<br>    read(x, xx);<br>    read(y, yy);<br>    read(lengths, l);<br>    read(names, t);<br>    n = xx.size();<br>    vector &lt;pair &lt;pair &lt;int, int&gt;, pair &lt;int, string&gt; &gt; &gt; s(n);<br>    for (int i = 0; i &lt; n; ++i) {<br>      s[i].first.first = xx[i];<br>      s[i].first.second = yy[i];<br>      s[i].second.first = l[i];<br>      s[i].second.second = t[i];<br>    }<br>    sort(all(s), cmp);<br>    vi a(n);<br>    for (int i = n - 1; i &gt;= 0; --i) {<br>      a[i] = 1;<br>      for (int j = i + 1; j &lt; n; ++j) {<br>        if (s[i].first.first &lt;= s[j].first.first &amp;&amp; s[i].first.second &lt;= s[j].first.second &amp;&amp;<br>            s[i].first.first + s[i].second.first &gt;= s[j].first.first + s[j].second.first &amp;&amp;<br>            s[i].first.second + s[i].second.first &gt;= s[j].first.second + s[j].second.first) {<br>          a[i] = max(a[i], a[j] + 1);<br>        }<br>      }<br>    }<br>    vi cand;<br>    string bw;<br>    for (int i = 0; i &lt; n; ++i) {<br>      if (a[i] &gt;= k &amp;&amp; (bw == "" || bw &gt; s[i].second.second)) {<br>        cand = vi(1, i);<br>        bw = s[i].second.second;<br>      } else if (a[i] &gt;= k &amp;&amp; bw == s[i].second.second) {<br>        cand.push_back(i);<br>      }<br>    }<br>    if (cand.size() == 0) return res;<br>    res.push_back(bw);<br>    for (int i = 1; i &lt; k; ++i) {<br>      string bw;<br>      vi ncand;<br>      for (int j = 0; j &lt; n; ++j) {<br>        if (a[j] &lt; k - i || bw != "" &amp;&amp; s[j].second.second &gt; bw) continue;<br>        bool good = false;<br>        for (int t = 0; t &lt; cand.size(); ++t) {<br>          int b = cand[t];<br>          if (j &gt; b &amp;&amp; s[b].first.first &lt;= s[j].first.first &amp;&amp; s[b].first.second &lt;= s[j].first.second &amp;&amp;<br>              s[b].first.first + s[b].second.first &gt;= s[j].first.first + s[j].second.first &amp;&amp;<br>              s[b].first.second + s[b].second.first &gt;= s[j].first.second + s[j].second.first) {<br>            good = true;<br>            break;<br>          }<br>        }<br>        if (good) {<br>          if (s[j].second.second == bw) {<br>            ncand.push_back(j);<br>          } else {<br>            ncand = vi(1, j);<br>            bw = s[j].second.second;<br>          }<br>        }<br>      }<br>      res.push_back(bw);<br>      cand.swap(ncand);<br>    }<br>    return res;<br>  }<br>  <br><br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>