<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt; <br>#include &lt;list&gt; <br>#include &lt;map&gt; <br>#include &lt;set&gt; <br>#include &lt;deque&gt; <br>#include &lt;queue&gt; <br>#include &lt;stack&gt; <br>#include &lt;bitset&gt; <br>#include &lt;algorithm&gt; <br>#include &lt;functional&gt; <br>#include &lt;numeric&gt; <br>#include &lt;utility&gt; <br>#include &lt;complex&gt; <br>#include &lt;sstream&gt; <br>#include &lt;iostream&gt; <br>#include &lt;iomanip&gt; <br>#include &lt;cstdio&gt; <br>#include &lt;cmath&gt; <br>#include &lt;cstdlib&gt; <br>#include &lt;cstring&gt; <br>#include &lt;ctime&gt; <br>#include &lt;cassert&gt; <br>using namespace std;<br> <br>struct CandyGame{<br>  int maximumCandy(vector &lt;string&gt; graph, int target);<br>};<br>const long long maxv=2000000001;<br>vector&lt;string&gt; G;<br>bool vis[50];<br>int maxdep[50];<br>int n;<br>long long dfs(int p,int dep){<br>  vis[p]=true;<br>  maxdep[p]=dep;<br>  long long ret=0;<br>  for(int i=0;i&lt;n;i++)<br>    if(G[p][i]=='Y'&amp;&amp;!vis[i])<br>      ret+=dfs(i,dep+1),maxdep[p]&gt;?=maxdep[i];<br>  if(dep!=0)<br>    (ret+=1LL&lt;&lt;maxdep[p]-dep)&lt;?=maxv;<br>  return ret;<br>}<br>int CandyGame::maximumCandy(vector &lt;string&gt; graph, int target){<br>  n=graph.size(),G=graph;<br>  memset(vis,false,sizeof(vis));<br>  long long res=dfs(target,0);<br>  for(int i=0;i&lt;n;i++)<br>    if(!vis[i])<br>      return -1;<br>  return res==maxv?-1:res;<br>}<br> <br> <br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>