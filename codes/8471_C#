<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Text; <br><br>public class TurningMaze<br>{<br>    Queue&lt;int&gt; x, y, rot, d;<br>    int[, ,] cache;<br>    bool[, ,] seen;<br>    string[] maze;<br>    int n, m;<br>    void update(int x1, int y1, int r1, int d1)<br>    {<br>        if (!seen[r1, x1, y1])<br>        {<br>            seen[r1, x1, y1] = true;<br>            cache[r1, x1, y1] = d1;<br>            x.Enqueue(x1);<br>            y.Enqueue(y1);<br>            rot.Enqueue(r1);<br>            d.Enqueue(d1);<br>        }<br>    }<br>    public int minTime(string[] __maze)<br>    {<br>        maze = __maze;<br>        n = maze.Length;<br>        m = maze[0].Length;<br>        cache = new int[1 &lt;&lt; 15, 8, 8];<br>        seen = new bool[1 &lt;&lt; 15, 8, 8];<br>        x = new Queue&lt;int&gt;();<br>        y = new Queue&lt;int&gt;();<br>        rot = new Queue&lt;int&gt;();<br>        d = new Queue&lt;int&gt;();<br>        x.Enqueue(0);<br>        y.Enqueue(0);<br>        rot.Enqueue(0);<br>        d.Enqueue(0);<br>        while (x.Count &gt; 0)<br>        {<br>            int x1 = x.Dequeue();<br>            int y1 = y.Dequeue();<br>            int r1 = rot.Dequeue();<br>            int d1 = d.Dequeue();<br>            if (x1 == n - 1 &amp;&amp; y1 == m - 1) return d1;<br>            update(x1, y1, r1 ^ (1 &lt;&lt; x1) ^ (1 &lt;&lt; (7 + y1)), d1 + 1);<br>            if (canup(x1, y1, r1))<br>            {<br>                update(x1 - 1, y1, r1, d1 + 1);<br>            }<br>            if (candown(x1, y1, r1))<br>            {<br>                update(x1 + 1, y1, r1, d1 + 1);<br>            }<br>            if (canleft(x1, y1, r1))<br>            {<br>                update(x1, y1 - 1, r1, d1 + 1);<br>            }<br>            if (canright(x1, y1, r1))<br>            {<br>                update(x1, y1 + 1, r1, d1 + 1);<br>            }<br>        }<br>        return -1;<br>    }<br>    bool canup(int x1, int y1, int r1)<br>    {<br>        if (x1 == 0) return false;<br>        <br>        if (maze[x1][y1] == 'B') return false;<br>        int tot = (r1 &amp; (1&lt;&lt;x1)) &gt; 0 ? 1 : 0;<br>        tot += (r1 &amp; (1&lt;&lt;(7+y1))) &gt; 0 ? 1 : 0;<br>        if (maze[x1][y1] == 'C' &amp;&amp; (tot % 2 == 1)) return false;<br>        if (maze[x1][y1] == 'D' &amp;&amp; (tot % 2 == 0)) return false;<br><br>        if (maze[x1-1][y1] == 'B') return false;<br>        tot = (r1 &amp; (1 &lt;&lt; x1-1)) &gt; 0 ? 1 : 0;<br>        tot += (r1 &amp; (1 &lt;&lt; (7 + y1))) &gt; 0 ? 1 : 0;<br>        if (maze[x1-1][y1] == 'C' &amp;&amp; (tot % 2 == 1)) return false;<br>        if (maze[x1-1][y1] == 'D' &amp;&amp; (tot % 2 == 0)) return false;<br><br>        return true;<br>    }<br><br>    bool candown(int x1, int y1, int r1)<br>    {<br>        if (x1 == n - 1) return false;<br><br>        if (maze[x1][y1] == 'B') return false;<br>        int tot = (r1 &amp; (1 &lt;&lt; x1)) &gt; 0 ? 1 : 0;<br>        tot += (r1 &amp; (1 &lt;&lt; (7 + y1))) &gt; 0 ? 1 : 0;<br>        if (maze[x1][y1] == 'C' &amp;&amp; (tot % 2 == 1)) return false;<br>        if (maze[x1][y1] == 'D' &amp;&amp; (tot % 2 == 0)) return false;<br><br>        if (maze[x1 + 1][y1] == 'B') return false;<br>        tot = (r1 &amp; (1 &lt;&lt; x1 + 1)) &gt; 0 ? 1 : 0;<br>        tot += (r1 &amp; (1 &lt;&lt; (7 + y1))) &gt; 0 ? 1 : 0;<br>        if (maze[x1 + 1][y1] == 'C' &amp;&amp; (tot % 2 == 1)) return false;<br>        if (maze[x1 + 1][y1] == 'D' &amp;&amp; (tot % 2 == 0)) return false;<br><br>        return true;<br>    }<br><br>    bool canleft(int x1, int y1, int r1)<br>    {<br>        if (y1 == 0) return false;<br><br>        if (maze[x1][y1] == 'B') return false;<br>        int tot = (r1 &amp; (1 &lt;&lt; x1)) &gt; 0 ? 1 : 0;<br>        tot += (r1 &amp; (1 &lt;&lt; (7 + y1))) &gt; 0 ? 1 : 0;<br>        if (maze[x1][y1] == 'C' &amp;&amp; (tot % 2 == 0)) return false;<br>        if (maze[x1][y1] == 'D' &amp;&amp; (tot % 2 == 1)) return false;<br><br>        if (maze[x1][y1 - 1] == 'B') return false;<br>        tot = (r1 &amp; (1 &lt;&lt; x1)) &gt; 0 ? 1 : 0;<br>        tot += (r1 &amp; (1 &lt;&lt; (7 + y1 - 1))) &gt; 0 ? 1 : 0;<br>        if (maze[x1][y1 - 1] == 'C' &amp;&amp; (tot % 2 == 0)) return false;<br>        if (maze[x1][y1 - 1] == 'D' &amp;&amp; (tot % 2 == 1)) return false;<br><br>        return true;<br>    }<br><br>    bool canright(int x1, int y1, int r1)<br>    {<br>        if (y1 == m-1) return false;<br><br>        if (maze[x1][y1] == 'B') return false;<br>        int tot = (r1 &amp; (1 &lt;&lt; x1)) &gt; 0 ? 1 : 0;<br>        tot += (r1 &amp; (1 &lt;&lt; (7 + y1))) &gt; 0 ? 1 : 0;<br>        if (maze[x1][y1] == 'C' &amp;&amp; (tot % 2 == 0)) return false;<br>        if (maze[x1][y1] == 'D' &amp;&amp; (tot % 2 == 1)) return false;<br><br>        if (maze[x1][y1 + 1] == 'B') return false;<br>        tot = (r1 &amp; (1 &lt;&lt; x1)) &gt; 0 ? 1 : 0;<br>        tot += (r1 &amp; (1 &lt;&lt; (7 + y1 + 1))) &gt; 0 ? 1 : 0;<br>        if (maze[x1][y1 + 1] == 'C' &amp;&amp; (tot % 2 == 0)) return false;<br>        if (maze[x1][y1 + 1] == 'D' &amp;&amp; (tot % 2 == 1)) return false;<br><br>        return true;<br>    }<br><br>    // helper<br>    void cout(object o) { System.Console.WriteLine(o); } <br><br>};<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>