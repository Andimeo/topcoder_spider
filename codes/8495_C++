<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cmath&gt;<br>#include &lt;string&gt;<br>#define Eps 1E-10<br>#define sqrt(a) ((a) &lt; 0 ? 0 : sqrt(a))<br>using namespace std;<br>class AirlineInternet {<br>  public:<br>    int pos[25][2];<br>    int info[25][4];<br>    double delta[25][2];<br>    double start[25][2];<br>    int N, M;<br>    double alltime[8005];<br>    int s;<br>    double sqr(double x) {<br>      return x * x;<br>    }<br>    int OK(double x) {<br>      int i, j, k, l;<br>      int Graph[35][35];<br>      double cntpos[35][2];<br>      double a, b, c, d;<br>      s = 0;<br>      for (i = 0; i &lt; M; i ++)<br>        for (j = i + 1; j &lt; M; j ++) {<br>          a = sqr(delta[i][0] - delta[j][0]) + sqr(delta[i][1] - delta[j][1]);<br>          c = sqr(start[i][0] - delta[i][0] * info[i][2] - start[j][0] + delta[j][0] * info[j][2]) + sqr(start[i][1] - delta[i][1] * info[i][2] - start[j][1] + delta[j][1] * info[j][2]) - sqr(x);<br>          b = 2 * (delta[i][0] - delta[j][0]) * (start[i][0] - delta[i][0] * info[i][2] - start[j][0] + delta[j][0] * info[j][2]) + 2 * (delta[i][1] - delta[j][1]) * (start[i][1] - delta[i][1] * info[i][2] - start[j][1] + delta[j][1] * info[j][2]);<br>          d = sqr(b) - 4 * a * c;<br>          if (d &gt; -Eps &amp;&amp; a &gt; Eps) {<br>            alltime[s ++] = (-b + sqrt(d)) / 2 / a;<br>            if (alltime[s - 1] &lt;= info[i][2] || alltime[s - 1] &lt;= info[j][2] || alltime[s - 1] &gt;= info[i][3] || alltime[s - 1] &gt;= info[j][3])<br>              s --;<br>            alltime[s ++] = (-b - sqrt(d)) / 2 / a;<br>            if (alltime[s - 1] &lt;= info[i][2] || alltime[s - 1] &lt;= info[j][2] || alltime[s - 1] &gt;= info[i][3] || alltime[s - 1] &gt;= info[j][3])<br>              s --;            <br>          }<br>        }<br>      for (i = 0; i &lt; M; i ++)<br>        for (j = 0; j &lt; N; j ++) {<br>          a = sqr(delta[i][0]) + sqr(delta[i][1]);<br>          c = sqr(start[i][0] - delta[i][0] * info[i][2] - pos[j][0]) + sqr(start[i][1] - delta[i][1] * info[i][2] - pos[j][1]) - sqr(x);<br>          b = 2 * (delta[i][0]) * (start[i][0] - delta[i][0] * info[i][2] - pos[j][0]) + 2 * (delta[i][1]) * (start[i][1] - delta[i][1] * info[i][2] - pos[j][1]);<br>          d = sqr(b) - 4 * a * c;<br>          if (d &gt; -Eps &amp;&amp; a &gt; Eps) {<br>            alltime[s ++] = (-b + sqrt(d)) / 2 / a;<br>            if (alltime[s - 1] &lt;= info[i][2] || alltime[s - 1] &gt;= info[i][3])<br>              s --;<br>            alltime[s ++] = (-b - sqrt(d)) / 2 / a;<br>            if (alltime[s - 1] &lt;= info[i][2] || alltime[s - 1] &gt;= info[i][3])<br>              s --;            <br>          }<br>        }<br>      alltime[s ++] = 0;<br>      alltime[s ++] = 1000;<br>      sort(alltime, alltime + s);<br>      for (i = 0; i &lt; s - 1; i ++) {<br>        double cnttime = (alltime[i + 1] + alltime[i]) / 2;<br>        for (j = 0; j &lt; N; j ++) {<br>          cntpos[j][0] = pos[j][0];<br>          cntpos[j][1] = pos[j][1];<br>        }<br>        for (j = 0; j &lt; M; j ++)<br>          if (cnttime &lt;= info[j][2]) {<br>            cntpos[j + N][0] = start[j][0];<br>            cntpos[j + N][1] = start[j][1];<br>          }<br>          else<br>            if (cnttime &gt;= info[j][3]) {<br>              cntpos[j + N][0] = pos[info[j][1]][0];<br>              cntpos[j + N][1] = pos[info[j][1]][1];<br>            }<br>            else {<br>              cntpos[j + N][0] = start[j][0] + (cnttime - info[j][2]) * delta[j][0];<br>              cntpos[j + N][1] = start[j][1] + (cnttime - info[j][2]) * delta[j][1];<br>            }<br>        for (j = 0; j &lt; N + M; j ++)<br>          for (k = j; k &lt; N + M; k ++)<br>            if ((sqr(cntpos[j][0] - cntpos[k][0]) + sqr(cntpos[j][1] - cntpos[k][1])) &lt;= sqr(x + Eps))<br>              Graph[j][k] = Graph[k][j] = 1;<br>            else<br>              Graph[j][k] = Graph[k][j] = 0;<br>        for (l = 0; l &lt; N + M; l ++)<br>          for (j = 0; j &lt; N + M; j ++)<br>            for (k = 0; k &lt; N + M; k ++)<br>              Graph[j][k] = (Graph[j][k] || (Graph[j][l] &amp;&amp; Graph[l][k]));<br>        for (j = N; j &lt; N + M; j ++) {<br>          for (k = 0; k &lt; N; k ++)<br>            if (Graph[j][k])<br>              break;<br>          if (k &gt;= N)<br>            return 0;<br>        }<br>      }<br>      return 1;<br>    }<br>    double minimumRange(vector &lt;string&gt; airportLocations, vector &lt;string&gt; flights) {<br>      double f, r, m;<br>      int i;<br>      N = airportLocations.size();<br>      M = flights.size();<br>      for (i = 0; i &lt; N; i ++) {<br>        istringstream sin(airportLocations[i]);<br>        sin &gt;&gt; pos[i][0] &gt;&gt; pos[i][1];<br>      }<br>      for (i = 0; i &lt; M; i ++) {<br>        istringstream sin(flights[i]);<br>        sin &gt;&gt; info[i][0] &gt;&gt; info[i][1] &gt;&gt; info[i][2] &gt;&gt; info[i][3];<br>        delta[i][0] = (double)(pos[info[i][1]][0] - pos[info[i][0]][0]) / (double)(info[i][3] - info[i][2]);<br>        delta[i][1] = (double)(pos[info[i][1]][1] - pos[info[i][0]][1]) / (double)(info[i][3] - info[i][2]);;<br>        start[i][0] = pos[info[i][0]][0];<br>        start[i][1] = pos[info[i][0]][1];<br>      }<br>      f = 0;<br>      r = 2000;<br>      while (f + Eps &lt; r) {<br>        m = (f + r) / 2;<br>        if (OK(m))<br>          r = m;<br>        else<br>          f = m;<br>      }<br>      return (f + r) / 2;<br>    }<br>};<br> <br>//Powered by [KawigiEdit] 2.0!<br>;<br></td>