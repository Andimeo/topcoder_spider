<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Text;<br>using System.Collections.Generic;<br><br>public class IncreasingSequence {<br>    long MOD = 1000000003;<br><br>    public int getProduct(string[] digits)<br>    {<br>        StringBuilder b = new StringBuilder();<br>        foreach (string s in digits)<br>            b.Append(s);<br>        string input = b.ToString();<br>        int n = input.Length;<br>        int[,] numEq = new int[n + 2, n + 2];<br>        for (int i = n; i &gt;= 1; --i)<br>            for (int j = n; j &gt;= 1; --j)<br>            {<br>                if (input[i - 1] == input[j - 1])<br>                {<br>                    numEq[i, j] = 1 + numEq[i + 1, j + 1];<br>                }<br>            }<br>        int[] best = new int[n + 1];<br>        int[] firstNonzero = new int[n + 1];<br>        int at = n + 1;<br>        for (int i = n; i &gt;= 0; --i)<br>        {<br>            if (i &gt; 0 &amp;&amp; input[i - 1] != '0')<br>                at = i;<br>            firstNonzero[i] = at;<br>        }<br>        best[0] = 0;<br>        bool[] canLast = new bool[n + 1];<br>        canLast[n] = true;<br>        for (int i = 1; i &lt;= n; ++i)<br>        {<br>            best[i] = i;<br>            for (int j = i - 1; j &gt;= 1; --j)<br>            {<br>                int start = firstNonzero[i - j + 1];<br>                if (start &gt; i)<br>                    start = i + 1;<br>                int finish = i;<br>                int pstart = firstNonzero[i - j - best[i - j] + 1];<br>                int pfinish = i - j;<br>                if (pstart &gt; pfinish)<br>                    pstart = pfinish + 1;<br>                int len = finish - start + 1;<br>                int plen = pfinish - pstart + 1;<br>                bool ok = false;<br>                if (len &gt; plen)<br>                    ok = true;<br>                else if (len == plen)<br>                {<br>                    int ne = numEq[start, pstart];<br>                    if (ne &lt; len)<br>                    {<br>                        ok = input[start + ne - 1] &gt; input[pstart + ne - 1];<br>                    }<br>                }<br>                if (ok)<br>                {<br>                    best[i] = j;<br>                    if (i == n)<br>                        canLast[j] = true;<br>                }<br>            }<br>        }<br><br>        int[] maxCan = new int[n + 1];<br>        for (int i = 0; i &lt; n + 1; ++i)<br>            maxCan[i] = -1;<br>        int k = best[n];<br>        while (true)<br>        {<br>            if (canLast[k])<br>                maxCan[n - k + 1] = k;<br>            if (k == n)<br>                break;<br>            if (input[n - k - 1] != '0')<br>                break;<br>            ++k;<br>        }<br><br>        for (int i = n; i &gt;= 1; --i)<br>        {<br>            if (maxCan[i] &gt;= 0)<br>                continue;<br>            for (int j = 1; i + j - 1 &lt; n; ++j)<br>            {<br>                if (maxCan[i + j] &lt; 0)<br>                    continue;<br>                int start = firstNonzero[i];<br>                int finish = i + j - 1;<br>                if (start &gt; finish + 1)<br>                    start = finish + 1;<br>                int pstart = firstNonzero[i + j];<br>                int pfinish = i + j + maxCan[i + j] - 1;<br>                if (pstart &gt; pfinish + 1)<br>                    pstart = pfinish + 1;<br>                int len = finish - start + 1;<br>                int plen = pfinish - pstart + 1;<br>                bool ok = false;<br>                if (len &lt; plen)<br>                    ok = true;<br>                else if (len == plen)<br>                {<br>                    int ne = numEq[start, pstart];<br>                    if (ne &lt; len)<br>                    {<br>                        ok = input[start + ne - 1] &lt; input[pstart + ne - 1];<br>                    }<br>                }<br>                if (ok)<br>                {<br>                    maxCan[i] = j;<br>                }<br>            }<br>        }<br><br>        long res = 1;<br>        int atp = 1;<br>        while (atp &lt;= n)<br>        {<br>            int start = atp;<br>            int finish = atp + maxCan[atp] - 1;<br>            long by = 0;<br>            for (int i = start; i &lt;= finish; ++i)<br>                by = (by * 10 + input[i - 1] - '0') % MOD;<br>            //Console.WriteLine(input.Substring(start - 1, finish - start + 1));<br>            res = (res * by) % MOD;<br>            atp = finish + 1;<br>        }<br><br>        return (int)res;<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>