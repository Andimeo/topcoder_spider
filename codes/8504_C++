<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;ctime&gt;<br>using namespace std;<br><br>typedef long long int64;<br>typedef vector&lt;string&gt; vs;<br><br>#define For(i,a,b) for (int i(a),_b(b); i &lt;= _b; ++i)<br>#define Ford(i,a,b) for (int i(a),_b(b); i &gt;= _b; --i)<br>#define Rep(i,n) for (int i(0),_n(n); i &lt; _n; ++i)<br>#define Repd(i,n) for (int i((n)-1); i &gt;= 0; --i)<br>#define Fill(a,c) memset(&amp;a, c, sizeof(a))<br>#define MP(x, y) make_pair((x), (y))<br>#define All(v) (v).begin(), (v).end()<br><br>template&lt;typename T&gt; inline int Size(const T&amp; c) { return (int)c.size(); }<br>template&lt;typename T&gt; inline void checkMin(T&amp; a, T b) { if (b &lt; a) a = b; }<br>template&lt;typename T&gt; inline void checkMax(T&amp; a, T b) { if (b &gt; a) a = b; }<br><br>const int maxn = 2510;<br>const int mod = 1000000003;<br>int n;<br>string s;<br>int dp[maxn][maxn+1], dp2[maxn][maxn+1];<br>int zero[maxn+1];<br><br>int compare(int i1, int i2, int j1, int j2) {<br>  i1 += zero[i1];<br>  checkMin(i1, i2);<br>  j1 += zero[j1];<br>  checkMin(j1, j2);<br>  int res = (i2-i1)-(j2-j1);<br>  if (res != 0)<br>    return res;<br>  if (i1 == j1 &amp;&amp; i2 == j2)<br>    return 0;<br>  while (i1 &lt; i2) {<br>    res = s[i1]-s[j1];<br>    if (res != 0)<br>      return res;<br>    ++i1;<br>    ++j1;<br>  }<br>  return 0;<br>}<br><br>int64 getNumber(int i1, int i2) {<br>  int64 res = 0;<br>  while (i1 &lt; i2) {<br>    res = (res*10+s[i1]-'0')%mod;<br>    ++i1;<br>  }<br>  return res;<br>}<br><br>struct IncreasingSequence {<br>  int getProduct(vs digits) {<br>    Rep(i, Size(digits))<br>      s += digits[i];<br>    n = Size(s);<br>    zero[n] = 0;<br>    Repd(i, n)<br>      zero[i] = s[i] == '0' ? 1+zero[i+1] : 0;<br>    Repd(i, n) {<br>      int minK = -1;<br>      For(j, i+1, n) {<br>        if (j == n) {<br>          dp[i][j] = i;<br>        } else {<br>          dp[i][j] = -1;<br>          checkMax(minK, j+1);<br>          while (minK &lt; n &amp;&amp; compare(j, minK, i, j) &lt;= 0)<br>            ++minK;<br>          For(k, minK, minK) {<br>            if (dp2[j][k] != -1 &amp;&amp; compare(j, k, i, j) &gt; 0) {<br>              if (dp[i][j] == -1 || compare(dp2[j][k], n, dp[i][j], n) &lt; 0)<br>                dp[i][j] = dp2[j][k];<br>            }<br>          }<br>        }<br>      }<br>      dp2[i][n] = dp[i][n];<br>      Ford(j, n-1, i+1) {<br>        dp2[i][j] = dp2[i][j+1];<br>        if (dp[i][j] != -1 &amp;&amp; compare(dp[i][j], n, dp2[i][j], n) &lt; 0)<br>          dp2[i][j] = dp[i][j];<br>      }<br>    }<br>    printf("dp found\n");<br>    int best = 0;<br>    For(i, 1, n)<br>      if (dp[0][i] != -1 &amp;&amp; compare(dp[0][i], n, best, n) &lt; 0)<br>        best = dp[0][i];<br>    int i = 0;<br>    int64 res = 1;<br>    while (i &lt; n) {<br>      int j = -1;<br>      For(k, i+1, n) {<br>        if (compare(dp[i][k], n, best, n) == 0) {<br>          if (j == -1 || compare(i, k, i, j) &gt; 0)<br>            j = k;<br>        }<br>      }<br>      assert(j != -1);<br>      res = (res*getNumber(i, j))%mod;<br>      i = j;<br>    }<br>    return (int)res;<br>  }<br>};<br></td>