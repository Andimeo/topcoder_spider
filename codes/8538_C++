<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br> <br>using namespace std;<br> <br>class MarblesRegroupingHard {<br>public:<br>  int minMoves(vector &lt;string&gt;);<br>};<br> <br>#define MAXSIZE 100<br>#define INF 1000000000<br>int match[MAXSIZE];<br>bool dfs(int v, int n, int adj[MAXSIZE][MAXSIZE], int mark[], int s[], int t[])<br>{<br>  int i;<br>  s[v] = 1;<br>  mark[v] = 1;<br>  for (i = 0; i &lt; n; i++)<br>    if (adj[v][i])<br>      if (t[i] = 1, match[i] == -1 || (!mark[match[i]] &amp;&amp;<br>        dfs(match[i], n, adj, mark, s, t)))<br>        return match[i] = v, true;<br>  return false;<br>}<br>bool matching(int n, int adj[MAXSIZE][MAXSIZE], int s[], int t[], int sa[])<br>{<br>  int i;<br>  int max = 0;<br>  int mark[MAXSIZE];<br>  memset(mark, 0, sizeof(mark));<br>  for (i = 0; i &lt; n; i++)<br>    if (!sa[i] &amp;&amp; !mark[i] &amp;&amp; dfs(i, n, adj, mark, s, t))<br>    {<br>      memset(mark, 0, sizeof(mark));<br>      sa[i] = 1;<br>    }<br>    for (i = 0; i &lt; n; i++)<br>      if (!sa[i])<br>        return false;<br>    return true;<br>}<br>void weighted(int n, int m, int weight[MAXSIZE][MAXSIZE])<br>{<br>  int i, j;<br>  int size = 0;<br>  int sa[MAXSIZE], s[MAXSIZE], t[MAXSIZE];<br>  int cover[2][MAXSIZE];<br>  int adj[MAXSIZE][MAXSIZE];<br>  memset(match, -1, sizeof(match));<br>  memset(sa, 0, sizeof(sa));<br>  memset(adj, 0, sizeof(adj));<br>  if (m &gt; n)<br>    n = m;<br>  for (i = 0; i &lt; n; i++)<br>  {<br>    int index = 0;<br>    for (j = 1; j &lt; n; j++)<br>      if (weight[i][index] &lt; weight[i][j])<br>        index = j;<br>    cover[1][i] = 0;<br>    cover[0][i] = weight[i][index];<br>    adj[i][index] = 1;<br>  }<br>  while (!matching(n, adj, s, t, sa))<br>  {<br>    memset(s, 0, sizeof(s));<br>    memset(t, 0, sizeof(t));<br>    matching(n, adj, s, t, sa);<br>    int min = INF;<br>    for (i = 0; i &lt; n; i++)<br>      for (j = 0; j &lt; n; j++)<br>        if (s[i] &amp;&amp; !t[j] &amp;&amp; !adj[i][j])<br>          if (cover[0][i] + cover[1][j] - weight[i][j] &lt; min)<br>            min = cover[0][i] + cover[1][j] - weight[i][j];<br>    for (i = 0; i &lt; n; i++)<br>      if (s[i])<br>        cover[0][i] -= min;<br>    for (i = 0; i &lt; n; i++)<br>      if (t[i])<br>        cover[1][i] += min;<br>    for (i = 0; i &lt; n; i++)<br>      for (j = 0; j &lt; n; j++)<br>        if ((s[i] &amp;&amp; !t[j]) || (!s[i] &amp;&amp; t[j]))<br>          if ((cover[0][i] + cover[1][j]-weight[i][j])==0)<br>            adj[i][j] = 1;<br>          else<br>            adj[i][j] = 0;<br>  }<br>}<br>  <br>int arr[50][14] = {0};<br> <br>int MarblesRegroupingHard::minMoves(vector &lt;string&gt; b) {<br>  int i, j, tn;<br>  int n, m, sum, len = b.size();<br>  int weight[MAXSIZE][MAXSIZE];<br>  memset(weight, 0, sizeof weight);<br>  for( int i = 0; i &lt; b.size(); i++ ){<br>    istringstream sin( b[i] );<br>    int cnt = 0, tp;<br>    while( sin &gt;&gt; tp ){<br>      arr[i][cnt] = tp;<br>      cnt++;<br>    }<br>    m = cnt;<br>  }<br>  for( int i = 0;i &lt; len; i++ )<br>    for( int k = 0;k &lt; 14; k++ ){<br>      int sm = 0;<br>      for( int j = 0;j &lt; len; j++ )<br>        if( j != i )<br>          sm += arr[j][k];<br>      weight[i][k] = -sm;<br>    }<br>  n = b.size();<br>  weighted(n, m, weight);<br>  sum = 0;<br>  for (i = 0; i &lt; max(n, m); i++)<br>  {<br>    if (i &lt; m &amp;&amp; match[i] &lt; n)<br>    {<br>      sum += weight[match[i]][i];<br>    }<br>  }<br>  return -sum;<br>  <br>}<br> <br> <br>//Powered by [KawigiEdit] 2.0!<br></td>