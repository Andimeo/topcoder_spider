<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class SpecificPolyominoCovering {<br>  public string[] findCovering(string[] region) {<br>        int height = region.Length;<br>        int width = region[0].Length;<br>        char[,] res = new char[height, width];<br>        bool[,] curField = new bool[height, width];<br>        for (int row = 0; row &lt; height; ++row)<br>            for (int col = 0; col &lt; width; ++col)<br>            {<br>                if (region[row][col] == 'X')<br>                {<br>                    curField[row, col] = true;<br>                }<br>                res[row, col] = '.';<br>            }<br>        if (!valid(curField, height, width))<br>            return new string[0];<br>        for (int row = 0; row &lt; height; ++row)<br>            for (int col = 0; col &lt; width; ++col)<br>                if (curField[row, col])<br>                {<br>                    bool[,] newField = apply(curField, row, col, f1, 2, 4, height, width);<br>                    if (newField != null &amp;&amp; valid(newField, height, width))<br>                    {<br>                        curField = newField;<br>                        putRes(res, row, col, f1, 2, 4, 'A');<br>                    }<br>                    else<br>                    {<br>                        newField = apply(curField, row, col, f2, 1, 2, height, width);<br>                        if (newField != null &amp;&amp; valid(newField, height, width))<br>                        {<br>                            curField = newField;<br>                            putRes(res, row, col, f2, 1, 2, 'B');<br>                        }<br>                        else<br>                        {<br>                            throw new Exception();<br>                        }<br>                    }<br>                }<br>        string[] resS = new string[height];<br>        for (int row = 0; row &lt; height; ++row)<br>            for (int col = 0; col &lt; width; ++col)<br>                resS[row] += res[row, col];<br>        return resS;<br>  }<br><br>    private void putRes(char[,] res, int row, int col, bool[,] fig, int mr, int mc, char ch)<br>    {<br>        for (int dr = 0; dr &lt; mr; ++dr)<br>            for (int dc = 0; dc &lt; mc; ++dc)<br>                if (fig[dr, dc])<br>                    res[row + dr, col + dc] = ch;<br>    }<br><br>    private bool[,] apply(bool[,] curField, int row, int col, bool[,] fig, int mr, int mc, int height, int width)<br>    {<br>        if (row + mr &gt; height || col + mc &gt; width)<br>            return null;<br>        for (int dr = 0; dr &lt; mr; ++dr)<br>            for (int dc = 0; dc &lt; mc; ++dc)<br>                if (!curField[row + dr, col + dc] &amp;&amp; fig[dr, dc])<br>                    return null;<br>        bool[,] newField = (bool[,])curField.Clone();<br>        for (int dr = 0; dr &lt; mr; ++dr)<br>            for (int dc = 0; dc &lt; mc; ++dc)<br>                newField[row + dr, col + dc] &amp;= !fig[dr, dc];<br>        return newField;<br>    }<br><br>    bool[,] f1 = new bool[,] { { true, false, false, true }, { true, true, true, true } };<br>    bool[,] f2 = new bool[,] { { true, true } };<br><br>    bool valid(bool[,] _field, int height, int width)<br>    {<br>        bool[,] copy = (bool[,]) _field.Clone();<br>        for (int row = 0; row &lt; height; ++row)<br>        {<br>            int ngrp = 0;<br>            for (int col = 0; col &lt;= width; ++col)<br>            {<br>                if (col == width || !copy[row, col])<br>                {<br>                    if (ngrp % 2 != 0)<br>                    {<br>                        if (row == height - 1)<br>                            return false;<br>                        if (col + 2 &gt;= width)<br>                            return false;<br>                        for (int dr = 0; dr &lt; 2; ++dr)<br>                            for (int dc = 0; dc &lt; 4; ++dc)<br>                                if (copy[row + dr, col - 1 + dc] ^ f1[dr, dc])<br>                                    return false;<br>                                else<br>                                    copy[row + dr, col - 1 + dc] = false;<br>                    }<br>                    ngrp = 0;<br>                }<br>                else<br>                {<br>                    ++ngrp;<br>                }<br>            }<br>        }<br>        return true;<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>