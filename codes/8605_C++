<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;math.h&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;numeric&gt;<br>#include &lt;bitset&gt;<br>#include &lt;stack&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>using namespace std;<br> <br>int dr[]={0,1,0,-1,1,1,-1,-1};<br>int dc[]={1,0,-1,0,1,-1,1,-1};<br>#define zmax(a,b) (((a)&gt;(b))?(a):(b))<br>#define zmin(a,b) (((a)&gt;(b))?(b):(a))<br>#define zabs(a) (((a)&gt;=0)?(a):(-(a)))<br>#define iif(c,t,f) ((c)?(t):(f))<br>template&lt;class A, class B&gt; A cvt(B x) {stringstream s;s&lt;&lt;x;A r;s&gt;&gt;r;return r;}<br> <br>#define MAXVAR 100<br>#define MAXCONSTRAINT 100<br>#define lptype double<br>#define EPS 1e-7<br> <br>//Simplex input<br>//  Maximizes CX subject to AX &lt;= B with X &gt;= 0<br>lptype C[MAXVAR];<br>lptype A[MAXCONSTRAINT][MAXVAR];<br>lptype B[MAXCONSTRAINT];<br> <br>//simplex output<br>//  The X vector that maximizes CX subject to AX = B with x &gt;= 0<br>lptype X[MAXVAR];<br> <br>//simplex temporaries<br>lptype tableau[MAXCONSTRAINT + 1][MAXVAR + MAXCONSTRAINT + 2];<br> <br>//Returns CX<br>lptype simplex(int variables, int constraints)<br>{<br>  //Initialize tablueau<br>  int rows = constraints;      //Note rows and cols doesn't count the outermost row/col for convenience<br>  int cols = variables + constraints + 1;<br>  for(int i = 0; i &lt; constraints; i++)<br>  {<br>    for(int j = 0; j &lt; variables; j++) tableau[i][j] = A[i][j];<br>    for(int j = 0; j &lt; constraints; j++) tableau[i][j + variables] = i == j ? 1 : 0;<br>    tableau[i][variables + constraints] = 0;<br>    tableau[i][variables + constraints + 1] = B[i];<br>  }<br>  for(int j = 0; j &lt; variables; j++)<br>  {<br>    tableau[constraints][j] = C[j] == 0 ? 0 : -C[j];<br>    tableau[constraints][j + variables] = 0;<br>  }<br>  tableau[constraints][variables + constraints] = 1;<br>  tableau[constraints][variables + constraints + 1] = 0;<br> <br>  //Pivot until done<br>  while(true)<br>  {<br>    //Select pivot column<br>    int pivot_col = 0;<br>    for(int i = 1; i &lt; cols; i++)<br>      if(tableau[rows][i] &lt; tableau[rows][pivot_col])<br>        pivot_col = i;<br> <br>    //Check for finishing condition<br>    if(tableau[rows][pivot_col] &gt;= 0) break;<br> <br>    //Select pivot row<br>    int pivot_row = 0;<br>    for(int i = 1; i &lt; rows; i++)<br>      if(tableau[i][pivot_col] &gt;= EPS)<br>        if(tableau[pivot_row][pivot_col] &lt; EPS || tableau[i][cols] / tableau[i][pivot_col] &lt; tableau[pivot_row][cols] / tableau[pivot_row][pivot_col])<br>          pivot_row = i;<br> <br>    //Perform pivot<br>    for(int i = 0; i &lt;= rows; i++)<br>    {<br>      if(i == pivot_row) continue;<br>      lptype ratio = tableau[i][pivot_col] / tableau[pivot_row][pivot_col];<br>      for(int j = 0; j &lt;= cols; j++)<br>        tableau[i][j] -= ratio * tableau[pivot_row][j];<br>      tableau[i][pivot_col] = 0; //should already be zero, just to keep things precise<br>    }<br> <br>    //Normalize table<br>    for(int i = 0; i &lt;= rows; i++)<br>    {<br>      double max = 0;<br>      for(int j = 0; j &lt;= cols; j++)<br>        max &gt;?= zabs(tableau[i][j]);<br>      for(int j = 0; j &lt;= cols; j++)<br>        tableau[i][j] /= max;<br>    }<br> <br>  }<br> <br> <br>  //Extract X vector<br>  for(int i = 0; i &lt; variables; i++)<br>  {<br>    bool found = false;<br>    for(int j = 0; j &lt; constraints; j++)<br>    {<br>      if(tableau[j][i] != 0)<br>      {<br>        if(!found)<br>        {<br>          X[i] = tableau[j][cols] / tableau[j][i];<br>          found = true;<br>        }<br>        else<br>        {<br>          X[i] = 0;<br>          break;<br>        }<br>      }<br>    }<br>  }<br> <br>  return tableau[rows][cols] / tableau[rows][cols - 1];<br>}<br> <br> <br>class PreciousStones<br>{<br>public:<br>double PreciousStones::value(vector &lt;int&gt; silver, vector &lt;int&gt; gold)<br>{<br>  int n = silver.size();<br>  memset(&amp;C, 0, sizeof(C));<br>  memset(&amp;B, 0, sizeof(B));<br>  memset(&amp;A, 0, sizeof(A));<br>  for(int i = 0; i &lt; n; i++) C[i] = silver[i];<br>  for(int i = 0; i &lt; n; i++)<br>  {<br>    A[i][i] = 1;<br>    B[i] = 1;<br>  }<br>  for(int i = 0; i &lt; n; i++)<br>  {<br>    A[n][i] = silver[i] + gold[i];<br>  }<br>  B[n] = accumulate(gold.begin(), gold.end(), 0);<br>  double ret = simplex(n, n + 1);<br>  return ret;<br>}<br>};<br> <br> <br>//Powered by [KawigiEdit] 2.0<br></td>