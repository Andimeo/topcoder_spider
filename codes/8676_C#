<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br><br>public class MagicLabeling {<br>    const int MOD = 1000003;<br><br>  public int count(string[] graph, int M) {<br>        int n = graph.Length;<br>        bool[,] g = new bool[n, n];<br>        bool haveY = false;<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>            {<br>                g[i, j] = graph[i][j] == 'Y';<br>                if (g[i, j])<br>                    haveY = true;<br>            }<br>        int res = 0;<br>        int mul = 1;<br>        for (int sum = 1; sum &lt;= (haveY ? 2 * M : 1); ++sum)<br>        {<br>            int cur = 1;<br>            int[] mark = new int[n];<br>            for (int i = 0; i &lt; n; ++i)<br>                if (mark[i] == 0)<br>                {<br>                    int n1 = 0;<br>                    int n2 = 0;<br>                    bool odd = false;<br>                    dfs(i, ref n1, ref n2, ref odd, mark, 1, g, n);<br>                    if (n1 + n2 == 1)<br>                    {<br>                        if (sum == 1)<br>                        {<br>                            mul = (mul * M) % MOD;<br>                        }<br>                    } else if (odd)<br>                    {<br>                        if (sum % 2 != 0)<br>                            cur = 0;<br>                    }<br>                    else<br>                    {<br>                        int mn = Math.Max(1, sum - M);<br>                        int mx = Math.Min(M, sum - 1);<br>                        int am = mx - mn + 1;<br>                        if (am &lt; 0)<br>                            am = 0;<br>                        cur = (cur * am) % MOD;<br>                    }<br>                }<br>            res = (res + cur) % MOD;<br>        }<br>        return (int) ((((long) res) * mul) % MOD);<br>  }<br><br>    private void dfs(int i, ref int n1, ref int n2, ref bool odd, int[] mark, int p, bool[,] g, int n)<br>    {<br>        if (mark[i] != 0)<br>        {<br>            if (mark[i] != p)<br>                odd = true;<br>            return;<br>        }<br>        mark[i] = p;<br>        if (p == 1)<br>            ++n1;<br>        else<br>            ++n2;<br>        for (int j = 0; j &lt; n; ++j)<br>            if (g[i, j])<br>                dfs(j, ref n1, ref n2, ref odd, mark, 3 - p, g, n);<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>