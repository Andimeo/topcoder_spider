<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class CompanyRestructuring {<br>  public int fewestDivisions(string[] hasManaged) {<br>        int n = hasManaged.Length;<br>        bool[,] g = new bool[n, n];<br>        bool[,] c = new bool[n, n];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>            {<br>                bool cur = hasManaged[i][j] == 'Y';<br>                g[i, j] = cur;<br>                c[i, j] = cur;<br>            }<br>        for (int i = 0; i &lt; n; ++i)<br>            c[i, i] = true;<br>        for (int k = 0; k &lt; n; ++k)<br>            for (int i = 0; i &lt; n; ++i)<br>                for (int j = 0; j &lt; n; ++j)<br>                    c[i, j] |= c[i, k] &amp;&amp; c[k, j];<br>        int[] ncomp = new int[n];<br>        int lastcomp = 0;<br>        bool[] mark = new bool[n];<br>        for (int i = 0; i &lt; n; ++i)<br>            if (!mark[i])<br>            {<br>                for (int j = 0; j &lt; n; ++j)<br>                    if (c[i, j] &amp;&amp; c[j, i])<br>                    {<br>                        mark[j] = true;<br>                        ncomp[j] = lastcomp;<br>                    }<br>                ++lastcomp;<br>            }<br>        bool[,] ccomp = new bool[lastcomp, lastcomp];<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; n; ++j)<br>                ccomp[ncomp[i], ncomp[j]] |= c[i, j];<br>        List&lt;int&gt; topological = new List&lt;int&gt;();<br>        topologicalSort(lastcomp, ccomp, topological);<br>        int res = 0;<br>        List&lt;int&gt; got = new List&lt;int&gt;();<br>        foreach (int comp in topological) {<br>            List&lt;int&gt; cur = new List&lt;int&gt;();<br>            for (int i = 0; i &lt; n; ++i)<br>                if (ncomp[i] == comp)<br>                    cur.Add(i);<br>            int l = got.Count;<br>            int r = cur.Count;<br>            bool[,] v = new bool[l, r];<br>            for (int i = 0; i &lt; l; ++i)<br>                for (int j = 0; j &lt; r; ++j)<br>                    v[i, j] = g[got[i], cur[j]];<br>            int matchingSize = findMatching(l, r, v);<br>            res += r - matchingSize;<br>            got.AddRange(cur);<br>        }<br>        return res;<br>  }<br><br>    private int findMatching(int l, int r, bool[,] v)<br>    {<br>        int[] rm = new int[r];<br>        for (int i = 0; i &lt; r; ++i)<br>            rm[i] = -1;<br>        bool[] mark = new bool[l];<br>        int res = 0;<br>        for (int i = 0; i &lt; l; ++i)<br>        {<br>            if (dfs2(i, r, rm, mark, v))<br>            {<br>                ++res;<br>                mark = new bool[l];<br>            }<br>        }<br>        return res;<br>    }<br><br>    private bool dfs2(int i, int r, int[] rm, bool[] mark, bool[,] v)<br>    {<br>        if (mark[i])<br>            return false;<br>        mark[i] = true;<br>        for (int j = 0; j &lt; r; ++j)<br>            if (v[i, j] &amp;&amp; (rm[j] &lt; 0 || dfs2(rm[j], r, rm, mark, v)))<br>            {<br>                rm[j] = i;<br>                return true;<br>            }<br>        return false;<br>    }<br><br>    private void topologicalSort(int lastcomp, bool[,] ccomp, List&lt;int&gt; topological)<br>    {<br>        bool[] mark = new bool[lastcomp];<br>        for (int i = 0; i &lt; lastcomp; ++i)<br>            if (!mark[i])<br>            {<br>                dfs(i, mark, lastcomp, ccomp, topological);<br>            }<br>    }<br><br>    private void dfs(int i, bool[] mark, int lastcomp, bool[,] ccomp, List&lt;int&gt; topological)<br>    {<br>        mark[i] = true;<br>        for (int j = 0; j &lt; lastcomp; ++j)<br>            if (!mark[j] &amp;&amp; ccomp[i, j])<br>                dfs(j, mark, lastcomp, ccomp, topological);<br>        topological.Insert(0, i);<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>