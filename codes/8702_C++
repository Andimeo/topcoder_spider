<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>using namespace std;<br> <br>int N, man[50][50], sup[50][50];<br> <br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;VI&gt; VVI;<br> <br>VI BipartiteMatch(const VVI &amp;mat, VI *back_match = NULL) {<br>  // Returns -1 for unmatched items.<br>  // Complexity: O(V*E)<br>  int max_item = -1;<br>  VI fmat(mat.size(), -1), seen(mat.size(), -1), prev(mat.size());<br>  for (int i = 0; i &lt; mat.size(); i++) if (mat[i].size())<br>    max_item &gt;?= *max_element(mat[i].begin(), mat[i].end());<br>  VI bmat(max_item+1, -1);<br> <br>  for (int i = 0; i &lt; mat.size(); i++) {<br>    VI q(1, i);<br>    seen[i] = i; prev[i] = -1;<br>    int x, y;<br>    while (!q.empty()) {<br>      x = q.back(); q.pop_back();<br>      for (VI::const_iterator it = mat[x].begin(); it != mat[x].end(); ++it) {<br>        int bm = bmat[*it];<br>        if (bm == -1) {y = *it; goto found_match;}<br>        if (seen[bm] &lt; i) {<br>          seen[bm] = i; prev[bm] = x;<br>          q.push_back(bm);<br>        }<br>      }<br>    }<br>    continue;<br>found_match:<br>    while (x != -1) {<br>      bmat[y] = x;<br>      swap(y, fmat[x]);<br>      x = prev[x];<br>    }<br>  }<br> <br>  if (back_match) *back_match = bmat;<br>  return fmat;<br>}<br> <br>class CompanyRestructuring {<br>public:<br>int fewestDivisions(vector &lt;string&gt; hasManaged) {<br>  int i, j, k, x, y, z;<br> <br>  N = hasManaged.size();<br>  for (i = 0; i &lt; N; i++)<br>  for (j = 0; j &lt; N; j++)<br>    man[i][j] = (hasManaged[i][j] == 'Y');<br>  memcpy(sup, man, sizeof(sup));<br>  for (k = 0; k &lt; N; k++)<br>  for (i = 0; i &lt; N; i++)<br>  for (j = 0; j &lt; N; j++)<br>    sup[i][j] |= sup[i][k] &amp; sup[k][j];<br>  int ret = 0;<br>  VI u(N);<br>  for (i = 0; i &lt; N; i++) if (!u[i]) {<br>    VVI mat;<br>    for (j = 0; j &lt; N; j++) if (j == i || (sup[i][j] &amp;&amp; sup[j][i])) {<br>      u[j] = true;<br>      mat.push_back(VI());<br>      for (k = 0; k &lt; N; k++) if (man[k][j] &amp;&amp; !sup[j][k])<br>        mat.back().push_back(k);<br>    }<br>    VI bp = BipartiteMatch(mat);<br>    for (j = 0; j &lt; bp.size(); j++) if (bp[j] == -1) ret++;<br>  }<br>  return ret;<br>}<br> <br>};<br> <br> <br> <br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>