<td class="problemText" colspan="8" valign="middle" align="left">
            import javax.swing.*;<br>import java.math.BigInteger;<br>import java.util.*;<br><br>public class ModuleSequence {<br>    public long countElements(long K, long N, long A, long B, long lower, long upper) {<br>        K %= N;<br>        return doit(K, N, A, B, upper) - doit(K, N, A, B, lower - 1);<br>    }<br><br>    private long doit(long k, long n, long a, long b, long upper) {<br>        if (upper &lt; 0)<br>            return 0;<br>        if (upper &gt; n - 1)<br>            upper = n - 1;<br>        return doit2(k, n, b, upper) - doit2(k, n, a - 1, upper);<br>    }<br><br>    private long doit2(long k, long n, long maxFactor, long maxProduct) {<br>        if (maxFactor &lt; 0)<br>            return 0;<br>        long bigStep = Math.max(1, (long) Math.sqrt(maxFactor + 1));<br>        int numBigSteps = (int) (maxFactor / bigStep);<br>        long bigStepBy = multiply(k, bigStep, n);<br>        long[] bigs = new long[numBigSteps + 1];<br>        bigs[0] = 0;<br>        for (int i = 1; i &lt;= numBigSteps; ++i) {<br>            bigs[i] = bigs[i - 1] + bigStepBy;<br>            if (bigs[i] &gt;= n) {<br>                bigs[i] -= n;<br>            }<br>        }<br>        long lastBigStep = bigs[numBigSteps];<br>        Arrays.sort(bigs);<br>        long small = 0;<br>        long res = 0;<br>        for (int i = 0; i &lt; bigStep; ++i) {<br>            res += lowerBound(bigs, maxProduct + 1 - small) + lowerBound(bigs, n + maxProduct + 1 - small) - lowerBound(bigs, n - small);<br><br>            if (numBigSteps * bigStep + i &gt; maxFactor) {<br>                long missing = lastBigStep + small;<br>                if (missing &gt;= n) missing -= n;<br>                if (missing &lt;= maxProduct)<br>                    --res;<br>            }<br>            small += k;<br>            if (small &gt;= n) small -= n;<br>        }<br>        return res;<br>    }<br><br>    private int lowerBound(long[] where, long what) {<br>        int l = -1;<br>        int r = where.length;<br>        while (l + 1 &lt; r) {<br>            int middle = (l + r) / 2;<br>            if (what &lt;= where[middle]) {<br>                r = middle;<br>            } else {<br>                l = middle;<br>            }<br>        }<br>        return r;<br>    }<br><br>    private long multiply(long a, long b, long modulo) {<br>        return BigInteger.valueOf(a).multiply(BigInteger.valueOf(b)).mod(BigInteger.valueOf(modulo)).longValue();<br>    }<br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>