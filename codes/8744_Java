<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br> <br>public class KnightsOut {<br>    boolean[][] a;<br>    boolean[] b;<br>    public int count(int N, int M) {<br>        if (N &lt;= 2 || M &lt;= 2) {<br>            buildStupid(N, M);<br>        } else {<br>            buildClever(N, M);<br>        }<br>        return gauss();<br>    }<br> <br>    int MOD = 123456789;<br> <br>    private int gauss() {<br>        int n = a.length;<br>        boolean[] used = new boolean[n];<br>        int nused = 0;<br>        for (int j = 0; j &lt; n; ++j) {<br>            for (int i = 0; i &lt; n; ++i) {<br>                if (!used[i] &amp;&amp; a[i][j]) {<br>                    for (int ii = 0; ii &lt; n; ++ii)<br>                        if (ii != i &amp;&amp; a[ii][j]) {<br>                            for (int k = 0; k &lt; n; ++k)<br>                                a[ii][k] ^= a[i][k];<br>                            b[ii] ^= b[i];<br>                        }<br>                    used[i] = true;<br>                    ++nused;<br>                    break;<br>                }<br>            }<br>        }<br>        for (int i = 0; i &lt; n; ++i) if (!used[i] &amp;&amp; b[i])<br>            return 0;<br>        int res = 1;<br>        for (int i = nused; i &lt; n; ++i) {<br>            res += res;<br>            if (res &gt;= MOD) res -= MOD;<br>        }<br>        return res;<br>    }<br> <br>    private void buildClever(int n, int m) {<br>        int nv = 2 * m + (n - 2);<br>        a = new boolean[nv][nv];<br>        b = new boolean[nv];<br>        int p = 0;<br>        for (int si = 0; si &lt; n; ++si) {<br>            int maxj = si &lt; 2 ? m : 1;<br>            for (int sj = 0; sj &lt; maxj; ++sj) {<br>                boolean[][] field = new boolean[n][m];<br>                op(field, si, sj, n, m);<br>                resolve(field, n, m, false);<br>                int k = 0;<br>                for (int i = 0; i &lt; n; ++i) {<br>                    int minj = i + 2 &gt;= n ? 0 : m - 1;<br>                    for (int j = minj; j &lt; m; ++j) {<br>                        if (field[i][j]) {<br>                            a[k][p] ^= true;<br>                        }<br>                        ++k;<br>                    }<br>                }<br>                ++p;<br>            }<br>        }<br>        {<br>            boolean[][] field = new boolean[n][m];<br>            resolve(field, n, m, true);<br>            int k = 0;<br>            for (int i = 0; i &lt; n; ++i) {<br>                int minj = i + 2 &gt;= n ? 0 : m - 1;<br>                for (int j = minj; j &lt; m; ++j) {<br>                    if (!field[i][j]) {<br>                        b[k] ^= true;<br>                    }<br>                    ++k;<br>                }<br>            }<br>        }<br>    }<br> <br>    private void op(boolean[][] field, int i, int j, int n, int m) {<br>        for (int di = -2; di &lt;= 2; ++di)<br>            for (int dj = -2; dj &lt;= 2; ++dj)<br>                if (Math.abs(di * dj) == 2 || (di == 0 &amp;&amp; dj == 0)) {<br>                    int ni = i + di;<br>                    int nj = j + dj;<br>                    if (ni &lt; 0 || ni &gt;= n || nj &lt; 0 || nj &gt;= m) continue;<br>                    field[ni][nj] ^= true;<br>                }<br>    }<br> <br>    private void resolve(boolean[][] field, int n, int m, boolean whatNeeded) {<br>        for (int i = 2; i &lt; n; ++i)<br>            for (int j = 1; j &lt; m; ++j) {<br>                if (field[i - 2][j - 1] != whatNeeded) {<br>                    op(field, i, j, n, m);<br>                }<br>            }<br>    }<br> <br>    private void buildStupid(int n, int m) {<br>        int nv = n * m;<br>        a = new boolean[nv][nv];<br>        b = new boolean[nv];<br>        Arrays.fill(b, true);<br>        for (int i = 0; i &lt; n; ++i)<br>            for (int j = 0; j &lt; m; ++j) {<br>                for (int di = -2; di &lt;= 2; ++di)<br>                    for (int dj = -2; dj &lt;= 2; ++dj)<br>                        if (Math.abs(di * dj) == 2 || (di == 0 &amp;&amp; dj == 0)) {<br>                            int ni = i + di;<br>                            int nj = j + dj;<br>                            if (ni &lt; 0 || ni &gt;= n || nj &lt; 0 || nj &gt;= m) continue;<br>                            a[ni * m + nj][i * m + j] ^= true;<br>                        }<br>            }<br>    }<br> <br>}<br> <br> <br>// Powered by FileEdit<br>// Powered by RETester [based on ExampleBuilder]<br>// Powered by CodeProcessor<br></td>