<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt; <br>#include &lt;list&gt; <br>#include &lt;map&gt; <br>#include &lt;set&gt; <br>#include &lt;deque&gt; <br>#include &lt;queue&gt; <br>#include &lt;stack&gt; <br>#include &lt;bitset&gt; <br>#include &lt;algorithm&gt; <br>#include &lt;functional&gt; <br>#include &lt;numeric&gt; <br>#include &lt;utility&gt; <br>#include &lt;complex&gt; <br>#include &lt;sstream&gt; <br>#include &lt;iostream&gt; <br>#include &lt;iomanip&gt; <br>#include &lt;cstdio&gt; <br>#include &lt;cmath&gt; <br>#include &lt;cstdlib&gt; <br>#include &lt;cstring&gt; <br>#include &lt;ctime&gt; <br>#include &lt;cassert&gt; <br>using namespace std;<br> <br>struct DancingParty{<br>  int maxDances(vector &lt;string&gt; likes, int k);<br>};<br>class Graph{<br>private:<br>  struct edge{<br>    int to,cap,back;<br>  };<br>  vector&lt;vector&lt;edge&gt; &gt; adj;<br>  int n;<br>public:<br>  Graph(int n):n(n){<br>    adj.resize(n);<br>    for(int i=0;i&lt;n;i++)<br>      adj[i].clear();<br>  }<br>  ~Graph(){<br>    for(int i=0;i&lt;n;i++)<br>      adj[i].clear();<br>    adj.clear();<br>  }<br>  void insert(int i,int j,int c){<br>    adj[i].push_back((edge){j,c,adj[j].size()});<br>    adj[j].push_back((edge){i,0,adj[i].size()-1});<br>  }<br>  int dinic(int s,int t){<br>    int q[n],prev[n];<br>    int allflow=0;<br>    while(true){<br>      memset(prev,-1,sizeof(prev));<br>      int qf=0,qb=0;<br>      prev[q[qb++]=s]=-2;<br>      while(qb&gt;qf&amp;&amp;prev[t]==-1)<br>        for(int u=q[qf++],i=0,v;i&lt;adj[u].size();i++)<br>          if(prev[v=adj[u][i].to]==-1&amp;&amp;adj[u][i].cap&gt;0)<br>            prev[q[qb++]=v]=adj[u][i].back;<br>      if(prev[t]==-1)<br>        break;<br>      for(int i=0,z;i&lt;adj[t].size();i++)<br>        if(adj[z=adj[t][i].to][adj[t][i].back].cap&gt;0&amp;&amp;prev[z]!=-1){<br>          int flow=adj[z][adj[t][i].back].cap;<br>          for(int v=z,u=prev[v];u&gt;=0;v=adj[v][u].to,u=prev[v])<br>            flow&lt;?=adj[adj[v][u].to][adj[v][u].back].cap;<br>          if(!flow)<br>            continue;<br>          adj[z][adj[t][i].back].cap-=flow;<br>          adj[t][i].cap+=flow;<br>          for (int v=z,u=prev[v];u&gt;=0;v=adj[v][u].to,u=prev[v]){<br>            adj[adj[v][u].to][adj[v][u].back].cap-=flow;<br>            adj[v][u].cap+=flow;<br>          }<br>          allflow+=flow;<br>        }<br>    }<br>    return allflow;<br>  }<br>};<br>int DancingParty::maxDances(vector &lt;string&gt; G, int k){<br>  int n=G.size();<br>  int s=n*4,t=n*4+1;<br>  int lo=0,hi=n,mid;<br>  while(lo&lt;hi){<br>    mid=lo+hi&gt;&gt;1;<br>    Graph flow(n*4+2);<br>    for(int i=0;i&lt;n;i++){<br>      flow.insert(s,i,mid+1);<br>      flow.insert(i,i+n,k);<br>      flow.insert(i+n+n,i+n+n+n,k);<br>      flow.insert(i+n+n+n,t,mid+1);<br>    }<br>    for(int i=0;i&lt;n;i++)<br>      for(int j=0;j&lt;n;j++)<br>        if(G[i][j]=='Y')<br>          flow.insert(i,j+n+n+n,1);<br>        else<br>          flow.insert(i+n,j+n+n,1);<br>    if(flow.dinic(s,t)==(mid+1)*n)<br>      lo=mid+1;<br>    else<br>      hi=mid;<br>  }<br>  return lo;<br>}<br> <br> <br>//Powered by [KawigiEdit] 2.0 modified by pivanof!<br></td>