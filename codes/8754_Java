<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.math.*;<br>import java.io.*;<br>import java.text.*;<br>import java.util.regex.*;<br>import static java.util.Arrays.*;<br>import static java.lang.Math.*;<br>import static java.lang.Integer.parseInt;<br>class MaxFlow{<br>  <br>  /* Constructor for normal flow */<br>  MaxFlow(int[][] cost, int[][] cap){<br>    this.cost = cost;<br>    this.cap = cap;<br>    n = cost.length;<br>    f = new int[n][n];<br>    c = new int[n];<br>    d = new int[n];<br>  }<br>  int n, inf = Integer.MAX_VALUE/2;<br>  int[][] cost, cap, f;<br>  int totcost, totflow;<br>  void go(){<br>    while(findPath()) makePath();<br>  }<br>  void makePath(){<br> <br>    int flow = inf;<br>    int pos = n-1;<br>    while(d[pos] != -1){<br>      flow = min(flow, cap[d[pos]][pos]-f[d[pos]][pos]);<br>      pos = d[pos];<br>    }<br>    pos = n-1;<br>    totflow += flow;<br>    while(d[pos] != -1){<br>      f[d[pos]][pos] += flow;<br>      f[pos][d[pos]] -= flow;<br>      totcost += flow*cost[d[pos]][pos];<br>      pos = d[pos];<br>    }<br>  }<br>  /* Improved Bellman-Ford, homemade, will go into infinite loop<br>   * (instead of giving a useful error message) if a negative cycle is present */<br>  int[] c, d;<br>  boolean findPath(){<br>    fill(c, inf);<br>    fill(d, -1);<br>    c[0] = 0;<br>    boolean[] inq = new boolean[n]; // true for the nodes already enqueued<br>    LinkedList&lt;Integer&gt; que = new LinkedList&lt;Integer&gt;();<br>    que.add(0);<br>    while(que.size() &gt; 0){<br>      int at = que.removeFirst();<br>      inq[at] = false;<br>      for(int i = 0; i &lt; n; i++){<br>        if(cap[at][i]-f[at][i] &lt;= 0)continue;<br>        if(c[at]+cost[at][i] &lt; c[i]){<br>          c[i] = c[at]+cost[at][i];<br>          d[i] = at;<br>          if(!inq[i]){<br>            que.add(i);<br>            inq[i] = true;<br>          }<br>        }<br>      }<br>    }<br>    return c[n-1] != inf;<br>  }<br>}<br>public class DancingParty {<br>  int n;<br>  public int maxDances(String[] likes, int k) {<br>    int N = likes.length*4+2;<br>    n = likes.length;<br>    int[][] cost = new int[N][N];<br>    int[][] cap = new int[N][N];<br>    for(int i = 0; i &lt; likes.length; i++){<br>      cap[boy(i)][superboy(i)] = k;<br>      cap[supergirl(i)][girl(i)] = k;<br>    }<br>    for(int i = 0; i &lt; likes.length; i++){<br>      for(int j = 0; j &lt; likes[i].length(); j++){<br>        if(likes[i].charAt(j) == 'Y'){<br>          cap[boy(i)][girl(j)] = 1;<br>        }else{<br>          cap[superboy(i)][supergirl(j)] = 1;<br>        }<br>      }<br>    }<br>    MaxFlow mf = new MaxFlow(cost, cap);<br>    for(int test = 1;; test++){<br>      for(int i = 0; i &lt; likes.length; i++){<br>        cap[0][boy(i)] = test;<br>      }<br>      for(int i = 0; i &lt; likes[0].length(); i++){<br>        cap[girl(i)][N-1] = test;<br>      }<br>      mf.go();<br>      if(mf.totflow != test*likes.length){<br>        return min(likes.length, test-1);<br>      }<br>    }<br>  }<br>  int supergirl(int i){<br>    return 1+n+n+n+i;<br>  }<br>  int superboy(int i){<br>    return 1+n+n+i;<br>  }<br>  int boy(int i){<br>    return 1+i;<br>  }<br>  int girl(int i){<br>    return 1+n+i;<br>  }<br> <br> <br> <br>}<br> <br>// Powered by PopsEdit<br>// Powered by CodeProcessor<br></td>