<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class HouseProtection {<br><br>  private class Network // Prewritten<br>  {<br>    private List&lt;int&gt;[] _edges;<br>    private int _source, _sink, _cookie = 1, _totalFlow = 0;<br>    private int[,] _capacity, _flow;<br>    private int[] _tag;<br><br>    public Network(int maxNodes)<br>    {<br>      _source = maxNodes;<br>      _sink = maxNodes + 1;<br>      maxNodes += 2;<br>      _edges = new List&lt;int&gt;[maxNodes];<br>      for (int i = 0; i &lt; maxNodes; i++) _edges[i] = new List&lt;int&gt;();<br>      _capacity = new int[maxNodes, maxNodes];<br>      _flow = new int[maxNodes, maxNodes];<br>      _tag = new int[maxNodes];<br>    }<br><br>    public void AddSourceEdge(int dest, int capacity) { AddEdge(_source, dest, capacity); }<br>    public void AddSinkEdge(int src, int capacity) { AddEdge(src, _sink, capacity); }<br><br>    public void AddEdge(int src, int dest, int capacity)<br>    {<br>      if (_capacity[src, dest] == 0 &amp;&amp; _capacity[dest, src] == 0)<br>      {<br>        if (src != _sink) _edges[src].Add(dest);<br>        if (src != _source) _edges[dest].Add(src);<br>      }<br>      _capacity[src, dest] += capacity;<br>    }<br><br>    private int Go(int cur, int flow)<br>    {<br>      if (cur == _source) _cookie++;<br>      if (cur == _sink) return flow;<br>      if (_tag[cur] == _cookie || flow == 0) return 0;<br>      _tag[cur] = _cookie;<br>      foreach (int v in _edges[cur])<br>      {<br>        int f = Go(v, Math.Min(flow, _capacity[cur, v] - _flow[cur, v] + _flow[v, cur]));<br>        if (f &gt; 0) { _flow[cur, v] += f; return f; }<br>      }<br>      return 0;<br>    }<br><br>    public int Flow()<br>    {<br>      int f;<br>      while ((f = Go(_source, int.MaxValue)) &gt; 0) _totalFlow += f;<br>      return _totalFlow;<br>    }<br>  }<br><br>  private class Distance : IComparable&lt;Distance&gt;<br>  {<br>    public int SqDist;<br>    public int BNode, RNode;<br><br>    public Distance(int sqDist, int bNode, int rNode)<br>    {<br>      SqDist = sqDist;<br>      BNode = bNode;<br>      RNode = rNode;<br>    }<br><br>    public int CompareTo(Distance other)<br>    {<br>      return SqDist - other.SqDist;<br>    }<br>  }<br><br>  public double safetyFactor(int[] bx, int[] by, int[] rx, int[] ry, int R) {<br>    int bn = bx.Length, rn = rx.Length;<br>    List&lt;Distance&gt; distances = new List&lt;Distance&gt;();<br>    for (int i = 0; i &lt; bn; i++)<br>    {<br>      for (int j = 0; j &lt; rn; j++)<br>      {<br>        int dx = bx[i] - rx[j], dy = by[i] - ry[j];<br>        int sqDist = dx*dx + dy*dy;<br>        if (sqDist &lt;= 4*R*R)<br>          distances.Add(new Distance(sqDist, i, j));<br>      }<br>    }<br>    distances.Sort();<br><br>    double best = 0.0;<br><br>    Network nw = new Network(bx.Length + rx.Length);<br>    for (int i = 0; i &lt; bn; i++)<br>      nw.AddSourceEdge(i, 1);<br>    for (int i = 0; i &lt; rn; i++)<br>      nw.AddSinkEdge(bn + i, 1);<br><br>    for (int i = 0; i &lt; distances.Count; i++)<br>    {<br>      int d = distances[i].SqDist;<br>      int currentFlow = nw.Flow();<br>      int radarsUsed = rn + bn - currentFlow;<br>      double safety = radarsUsed*Math.PI*d/4;<br>//      Console.WriteLine("Radius: " + Math.Sqrt(d) + ", radars possible: " + radarsUsed + ", safety: " + safety);<br>      best = Math.Max(best, safety);<br>      <br>      nw.AddEdge(distances[i].BNode, bn + distances[i].RNode, 1);<br>    }<br><br>    int finalFlow = nw.Flow();<br>    int finalRadarsUsed = rn + bn - finalFlow;<br>    double finalSafety = finalRadarsUsed*Math.PI*R*R;<br>//    Console.WriteLine("Radius: " + R + ", radars possible: " + finalRadarsUsed + ", safety: " + finalSafety);<br>    best = Math.Max(best, finalSafety);<br><br>    return best;<br>  }<br><br>}<br><br><br><br><br>// Powered by FileEdit<br></td>