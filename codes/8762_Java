<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br>import java.util.regex.*;<br>import java.text.*;<br>import java.math.*;<br>import java.awt.geom.*;<br> <br>public class HouseProtection<br>{<br>  final double eps = 1e-9;<br>  <br>  double dist( double x0, double y0, double x1, double y1) {<br>    return Math.sqrt( (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0));<br>  }<br>  <br>  int m, n;<br>  double result;<br>  double[][] kc;<br>  boolean[][] ke;<br>  int[] x, y, by;<br>  int socap;<br>  <br>  void tang(int v) {<br>    int u, k;<br>    ++socap;<br>    while(v!=-1) {<br>      u = by[v];<br>      k = x[u];<br>      x[u] = v;<br>      y[v] = u;<br>      v = k;<br>    }<br>  }<br>  <br>  void tim(int i) {<br>    Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();<br>    q.add(i);<br>    Arrays.fill( by, -1);<br>    while(!q.isEmpty()) {<br>      int u = q.remove();<br>      for(int v=0;v&lt;n;++v) if(by[v]==-1 &amp;&amp; ke[u][v]) {<br>        by[v] = u;<br>        if(y[v]==-1) {<br>          tang(v);<br>          return;<br>        }<br>        q.add(y[v]);<br>      }<br>    }<br>  }<br>  <br>  public double safetyFactor(int[] bx, int[] by, int[] rx, int[] ry, int R)<br>  {<br>    ArrayList&lt;Double&gt; ar = new ArrayList&lt;Double&gt;();<br>    ar.add(2.0*R);<br>    <br>    m = bx.length;<br>    n =  rx.length;<br>    kc = new double[m][n];<br>    <br>    for(int i=0;i&lt;bx.length;++i) for(int j=0;j&lt;rx.length;++j) {<br>      double d = dist( bx[i], by[i], rx[j], ry[j]);<br>      kc[i][j] = d;<br>      if(d&lt;=2.0*R) ar.add(d);<br>    }<br> <br>    result = 0 ;<br>    ke = new boolean[m][n];<br>    x = new int[m];<br>    y = new int[n];<br>    this.by = new int[n];<br>        <br>    for(double r : ar) {<br>      for(boolean[] bb : ke) Arrays.fill( bb, false);<br>      for(int i=0;i&lt;m;++i) for(int j=0;j&lt;n;++j) {<br>        double d = kc[i][j];<br>        if(d + eps &lt; r) ke[i][j] = true;<br>        else ke[i][j] = false;<br>      }<br>      Arrays.fill( x, -1);Arrays.fill( y, -1);<br>      socap = 0;<br>      for(int i=0;i&lt;m;++i) tim(i);<br>      result = Math.max( result, (m+n-socap) * r * r * Math.PI / 4);<br>    }    <br>    <br>    return result;<br>  }<br>  <br>  <br>}<br>//Powered by [KawigiEdit] 2.0!<br></td>