<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class ShadowArea {<br>    class Segment<br>    {<br>        public double x1;<br>        public double y1;<br>        public double x2;<br>        public double y2;<br><br>        public Segment(double x1, double y1, double x2, double y2)<br>        {<br>            this.x1 = x1;<br>            this.y1 = y1;<br>            this.x2 = x2;<br>            this.y2 = y2;<br>        }<br>    }<br><br>  public double area(string[] room) {<br>        int height = room.Length;<br>        int width = room[0].Length;<br>        List&lt;Segment&gt; all = new List&lt;Segment&gt;();<br>        all.Add(new Segment(0, 0, width, 0));<br>        all.Add(new Segment(0, 0, 0, height));<br>        all.Add(new Segment(0, height, width, height));<br>        all.Add(new Segment(width, 0, width, height));<br>        double totalEmpty = 0;<br>        double lx = 0.5;<br>        double ly = 0.5;<br>        for (int x1 = 0; x1 &lt; width; ++x1)<br>            for (int y1 = 0; y1 &lt; height; ++y1)<br>            {<br>                if (x1 &lt; width - 1)<br>                {<br>                    if (room[y1][x1] == '#' ^ room[y1][x1 + 1] == '#')<br>                        all.Add(new Segment(x1 + 1, y1, x1 + 1, y1 + 1));<br>                }<br>                if (y1 &lt; height - 1)<br>                {<br>                    if (room[y1][x1] == '#' ^ room[y1 + 1][x1] == '#')<br>                        all.Add(new Segment(x1, y1 + 1, x1 + 1, y1 + 1));<br>                }<br>                if (room[y1][x1] != '#')<br>                    ++totalEmpty;<br>                if (room[y1][x1] == '*')<br>                {<br>                    lx = x1 + 0.5;<br>                    ly = y1 + 0.5;<br>                }<br>            }<br>        List&lt;double&gt; dirs = new List&lt;double&gt;();<br>        foreach (Segment x in all)<br>        {<br>            dirs.Add(Math.Atan2(x.y1 - ly, x.x1 - lx));<br>            dirs.Add(Math.Atan2(x.y2 - ly, x.x2 - lx));<br>        }<br>        dirs.Sort();<br>        for (int i = 0; i &lt; dirs.Count; ++i)<br>        {<br>            double la = dirs[i];<br>            double ra = i == dirs.Count - 1 ? dirs[0] + 2 * Math.PI : dirs[i + 1];<br>            double ma = (la + ra) / 2;<br>            if (ra - la &lt; 1e-9)<br>                continue;<br>            Segment closest = null;<br>            double closestT = double.MaxValue;<br>            foreach (Segment x in all)<br>            {<br>                double d1 = Math.Sqrt((x.x1 - lx) * (x.x1 - lx) + (x.y1 - ly) * (x.y1 - ly));<br>                double d2 = Math.Sqrt((x.x2 - lx) * (x.x2 - lx) + (x.y2 - ly) * (x.y2 - ly));<br>                if (Math.Abs(x.x1 - x.x2) + Math.Abs(x.y1 - x.y2) == 1 &amp;&amp; d1 &gt; closestT + 1 &amp;&amp; d2 &gt; closestT + 1)<br>                    continue;<br>                double p = (x.x2 - x.x1) * (ly - x.y1) - (x.y2 - x.y1) * (lx - x.x1);<br>                double q = Math.Cos(ma) * (x.y2 - x.y1) - Math.Sin(ma) * (x.x2 - x.x1);<br>                if (Math.Abs(q) &lt; 1e-9)<br>                    continue;<br>                double t = p / q;<br>                if (t &lt; 1e-9)<br>                    continue;<br>                double nx = lx + Math.Cos(ma) * t;<br>                double ny = ly + Math.Sin(ma) * t;<br>                double prod = (nx - x.x1) * (nx - x.x2) + (ny - x.y1) * (ny - x.y2);<br>                if (prod &gt; -1e-9)<br>                    continue;<br>                if (t &lt; closestT)<br>                {<br>                    closest = x;<br>                    closestT = t;<br>                }<br>            }<br>            if (closest == null)<br>                continue;<br>            {<br>                Segment x = closest;<br>                double p1 = (x.x2 - x.x1) * (ly - x.y1) - (x.y2 - x.y1) * (lx - x.x1);<br>                double q1 = Math.Cos(la) * (x.y2 - x.y1) - Math.Sin(la) * (x.x2 - x.x1);<br>                double p2 = (x.x2 - x.x1) * (ly - x.y1) - (x.y2 - x.y1) * (lx - x.x1);<br>                double q2 = Math.Cos(ra) * (x.y2 - x.y1) - Math.Sin(ra) * (x.x2 - x.x1);<br>                double t1 = p1 / q1;<br>                double t2 = p2 / q2;<br>                double nx1 = lx + Math.Cos(la) * t1;<br>                double ny1 = ly + Math.Sin(la) * t1;<br>                double nx2 = lx + Math.Cos(ra) * t2;<br>                double ny2 = ly + Math.Sin(ra) * t2;<br>                totalEmpty -= Math.Abs(lx * ny1 - ly * nx1 + nx1 * ny2 - ny1 * nx2 + nx2 * ly - ny2 * lx) / 2;<br>            }<br>        }<br>        return totalEmpty;<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>