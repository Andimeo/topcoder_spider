<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>#include &lt;vector&gt;<br>#include &lt;string&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;climits&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cassert&gt;<br>#include &lt;numeric&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;iostream&gt;<br>#include &lt;sstream&gt;<br>#include &lt;cctype&gt;<br>#include &lt;ctime&gt;<br>#include &lt;float.h&gt;<br>using namespace std;<br><br>#define For(i,a,b) for (int i(a),_b(b); i &lt;= _b; ++i)<br>#define Ford(i,a,b) for (int i(a),_b(b); i &gt;= _b; --i)<br>#define Rep(i,n) for (int i(0),_n(n); i &lt; _n; ++i)<br>#define Repd(i,n) for (int i((n)-1); i &gt;= 0; --i)<br>#define All(v) (v).begin(), (v).end()<br><br>template&lt;typename T&gt; inline T sqr(T a) { return a*a; }<br>template&lt;typename T&gt; inline int size(const T&amp; c) { return (int)c.size(); }<br>template&lt;typename T&gt; inline void remin(T&amp; a, T b) { if (b &lt; a) a = b; }<br>template&lt;typename T&gt; inline void remax(T&amp; a, T b) { if (b &gt; a) a = b; }<br><br>const double pi = 2*acos(0.0), eps = 1e-9;<br><br>int fcmp(double x, double y) {<br>  return fabs(x-y) &lt; eps ? 0 : x &lt; y ? -1 : 1;<br>}<br><br>double atan3(double dy, double dx) {<br>  double res = atan2(dy, dx);<br>  while (fcmp(res, 0.0) &lt; 0)<br>    res += 2*pi;<br>  while (fcmp(res, 2*pi) &gt;= 0)<br>    res -= 2*pi;<br>  return res;<br>}<br><br>double cx, cy;<br><br>struct Event {<br>  double alfa;<br>  double x1, y1, x2, y2, d;<br>  int add;<br>  Event() { }<br>  Event(double x1, double y1, double x2, double y2, double alfa, int add)<br>    : x1(x1), y1(y1), x2(x2), y2(y2), alfa(alfa), add(add) {<br>    d = sqrt(sqr(cx-0.5*(x1+x2))+sqr(cy-0.5*(y1+y2)));<br>  }<br>  bool operator&lt;(const Event&amp; e) const {<br>    return alfa &lt; e.alfa;<br>  }<br>};<br><br>vector&lt;Event&gt; events;<br><br>void addSegment(double x1, double y1, double x2, double y2) {<br>  double alfa, beta;<br>  alfa = atan3(y1-cy, x1-cx);<br>  beta = atan3(y2-cy, x2-cx);<br>  if (alfa &gt; beta) <br>    swap(alfa, beta);<br>  if (beta-alfa &lt; pi) {<br>    events.push_back(Event(x1, y1, x2, y2, alfa, +1));<br>    events.push_back(Event(x1, y1, x2, y2, beta, -1));<br>  } else {<br>    events.push_back(Event(x1, y1, x2, y2, 0, +1));<br>    events.push_back(Event(x1, y1, x2, y2, alfa, -1));<br>    events.push_back(Event(x1, y1, x2, y2, beta, +1));<br>    events.push_back(Event(x1, y1, x2, y2, 2*pi, -1));<br>  }<br>}<br><br>struct Segment {<br>  double d, x1, y1, x2, y2;<br>  Segment() { }<br>  Segment(double x1, double y1, double x2, double y2, double d) <br>    : d(d), x1(x1), y1(y1), x2(x2), y2(y2) {<br>  }<br>  bool operator&lt;(const Segment&amp; seg) const {<br>    return d &lt; seg.d;<br>  }<br>};<br><br>double getArea(double alfa, double beta, const Segment&amp; seg) {<br>  double a = seg.y2-seg.y1, b = seg.x1-seg.x2, c = a*seg.x1+b*seg.y1;<br>  // a*(cx+t*cos(alfa))+b*(cy+t*sin(alfa)) = c<br>  double t1 = (c-a*cx-b*cy)/(a*cos(alfa)+b*sin(alfa));<br>  double t2 = (c-a*cx-b*cy)/(a*cos(beta)+b*sin(beta));<br>  return fabs(0.5*t1*t2*sin(beta-alfa));<br>}<br><br>class ShadowArea {<br>  public:<br>  double area(vector &lt;string&gt; room) {<br>    int h = size(room), w = size(room[0]);<br>    Rep(i, h) Rep(j, w) {<br>      if (room[i][j] == '*') {<br>        cx = j+0.5;<br>        cy = i+0.5;<br>      }<br>    }<br>    events.clear();<br>    addSegment(0, 0, w, 0);<br>    addSegment(0, h, w, h);<br>    addSegment(0, 0, 0, h);<br>    addSegment(w, 0, w, h);<br>    Rep(i, h) Rep(j, w) {<br>      if (room[i][j] == '#') {<br>        addSegment(j, i, j+1, i);<br>        addSegment(j, i, j, i+1);<br>        addSegment(j+1, i+1, j+1, i);<br>        addSegment(j+1, i+1, j, i+1);<br>      }<br>    }<br>    sort(All(events));<br>    multiset&lt;Segment&gt; segments;<br>    double sum = 0;<br>    int i = 0;<br>    while (i &lt; size(events)) {<br>      int j = i;<br>      while (j &lt; size(events) &amp;&amp; fcmp(events[i].alfa, events[j].alfa) == 0) { <br>        if (events[j].add == 1)<br>          segments.insert(Segment(events[j].x1, events[j].y1, events[j].x2, events[j].y2, events[j].d));<br>        else {<br>          multiset&lt;Segment&gt;::iterator it = segments.find(Segment(events[j].x1, events[j].y1, events[j].x2, events[j].y2, events[j].d));<br>          assert(it != segments.end());<br>          segments.erase(it);<br>        }<br>        ++j;<br>      }<br>      double minArea = 1e32;<br>      for (multiset&lt;Segment&gt;::iterator it = segments.begin(); it != segments.end(); ++it)<br>        remin(minArea, getArea(events[i].alfa, events[j].alfa, *it));<br>      sum += minArea;<br>      if (j &lt; size(events) &amp;&amp; fcmp(events[j].alfa, 2*pi) == 0)<br>        break;<br>      i = j;      <br>    }<br>    sum = h*w-sum;<br>    Rep(i, h) Rep(j, w)<br>      if (room[i][j] == '#')<br>        sum -= 1.0;<br>    return sum;<br>  }<br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.12 [modified TZTester]<br>// Powered by CodeProcessor<br></td>