<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class IncompatibleMice {<br>  List&lt;List&lt;int&gt;&gt;[] m;<br>  int[] dist;<br>  int xsize,ysize;<br>  int[,] w1,w2;<br>  bool[,] wall;<br>  int[] dx = new int[4] {0,-1,0,1};<br>  int[] dy = new int[4] {-1,0,1,0};<br>  <br>  void bfs(int sx, int sy, int[,] w)<br>  {<br>    for(int y=0;y&lt;ysize;y++)<br>      for(int x=0;x&lt;xsize;x++)<br>        w[y,x]=-1;<br>    w[sy,sx]=0;<br>    Queue&lt;int&gt; q = new Queue&lt;int&gt;();<br>    q.Enqueue(sy*50+sx);<br>    while (q.Count &gt; 0)<br>    {<br>      int cur=q.Dequeue();<br>      sx=cur%50;<br>      sy=cur/50;<br>      for(int d=0;d&lt;4;d++) {<br>        int nx=sx+dx[d],ny=sy+dy[d];<br>        if (nx&lt;0 || ny&lt;0 || nx&gt;=xsize || ny&gt;=ysize) continue;<br>        if (wall[ny,nx] || w[ny,nx] &gt;= 0) continue;<br>        w[ny,nx]=w[sy,sx]+1;<br>        q.Enqueue(ny*50+nx);<br>      }  <br>    }<br>  }<br>  <br>  bool same(List&lt;int&gt; p1, List&lt;int&gt; p2)<br>  {    <br>    int x=0, y=0;<br>    while (x&lt;p1.Count &amp;&amp; y&lt;p2.Count) {<br>      if (p1[x]==p2[y]) return true;<br>      if (p1[x]&lt;p2[y]) x++; else y++;<br>    }<br>    return false;<br>  }<br>  <br>  int[,,] memo = new int[3,3,30000];<br>  <br>  bool collide(int m1, int m2, int offset)<br>  {<br>    if (memo[m1,m2,offset] &gt; 0)<br>      return memo[m1,m2,offset] == 2;<br>      <br>    for(int i=0;i&lt;m[m1].Count;i++) {<br>      List&lt;int&gt; p1 = m[m1][i];<br>      if (i-offset&gt;=0 &amp;&amp; i-offset&lt;m[m2].Count) {<br>        List&lt;int&gt; p2 = m[m2][i-offset];<br>        if (same(p1,p2)) {<br>          memo[m1,m2,offset] = 2;<br>          return true;<br>        }<br>      }<br>      <br>      if (i-offset-1&gt;=0 &amp;&amp; i-offset-1&lt;m[m2].Count) {<br>        List&lt;int&gt; p2 = m[m2][i-offset-1];<br>        if (same(p1,p2)) {<br>          memo[m1,m2,offset] = 2;<br>          return true;<br>        }<br>      }<br>      <br>    }<br>    memo[m1,m2,offset] = 1;<br>    return false;<br>  }<br>  <br>  public int totalTime(string[] maze) {<br>    int[] x1 = new int[3], y1 = new int[3], x2 = new int[3], y2 = new int[3];<br>    xsize=maze[0].Length;<br>    ysize=maze.Length;<br>    wall = new bool[ysize,xsize];<br>    for(int y=0;y&lt;ysize;y++)<br>      for(int x=0;x&lt;xsize;x++) {<br>        wall[y,x]=maze[y][x]=='#';<br>        if (maze[y][x]&gt;='a' &amp;&amp; maze[y][x]&lt;='c') {<br>          int t=maze[y][x]-'a';<br>          x1[t]=x;y1[t]=y;<br>        }<br>        if (maze[y][x]&gt;='A' &amp;&amp; maze[y][x]&lt;='C') {<br>          int t=maze[y][x]-'A';<br>          x2[t]=x;y2[t]=y;<br>        }<br>      }<br>    <br>    dist = new int[3];<br>    m = new List&lt;List&lt;int&gt;&gt;[3];<br>    for(int i=0;i&lt;3;i++) {<br>      w1=new int[ysize,xsize];<br>      w2=new int[ysize,xsize];<br>      bfs(x1[i],y1[i],w1);<br>      bfs(x2[i],y2[i],w2);<br>      dist[i]=w1[y2[i],x2[i]];<br>      if (dist[i]&lt;0)<br>        return -1;<br>      m[i]=new List&lt;List&lt;int&gt;&gt;();<br>      for(int j=0;j&lt;=dist[i];j++)<br>        m[i].Add(new List&lt;int&gt;());<br>      for(int y=0;y&lt;ysize;y++)<br>        for(int x=0;x&lt;xsize;x++)<br>          if (w1[y,x]+w2[y,x]==dist[i])<br>            m[i][w1[y,x]].Add(y*50+x);<br>      for(int j=0;j&lt;m[i].Count;j++)<br>        m[i][j].Sort();<br>        <br>      Console.WriteLine(dist[i]);<br>      <br>      /*<br>      Console.WriteLine("Mouse " + i);<br>      for(int j=0;j&lt;=dist[i];j++) {<br>        Console.Write("Step " + j + ": ");<br>        foreach(int pos in m[i][j]) {<br>          int y=pos/50,x=pos%50;<br>          Console.Write(x+","+y+"  ");<br>        }<br>        Console.WriteLine();<br>      }        <br>      Console.WriteLine();<br>      */<br>    }<br>    <br>    int best = 999999999;<br>    for(int first=0;first&lt;3;first++)<br>      for(int second=0;second&lt;3;second++)<br>        for(int third=0;third&lt;3;third++) {<br>          if (first==second || first==third || second==third) continue;<br>          for(int o1=0;o1&lt;dist[first]+2;o1++)<br>            for(int o2=0;o2&lt;Math.Max(dist[first],dist[second]+o1)+2;o2++) {              <br>              int tm=Math.Max(Math.Max(dist[first],dist[second]+o1),dist[third]+o1+o2);<br>              if (tm &gt;= best)<br>                continue;<br>              if (collide(first,second,o1)) continue;<br>              if (collide(first,third,o1+o2)) continue;<br>              if (collide(second,third,o2)) continue;<br>              best = tm;<br>            }  <br>        }<br>    <br>    return best;<br>  }<br>}<br><br><br>// Powered by FileEdit<br></td>