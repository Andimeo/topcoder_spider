<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class ColorfulBalls {<br>    static Dictionary&lt;State, State&gt; states = new Dictionary&lt;State, State&gt;();<br>    static int nextId = 0;<br>    static int size = 0;<br>    static List&lt;State&gt; allStates = new List&lt;State&gt;();<br>    static List&lt;State&gt;[] statesByAmount = new List&lt;State&gt;[100];<br><br>    class State {<br>        public int id;<br>        public int aid;<br>        public List&lt;int&gt; e = new List&lt;int&gt;();<br>        public List&lt;int&gt; jumps = new List&lt;int&gt;();<br>        public List&lt;double&gt; jp = new List&lt;double&gt;();<br>        int h;<br><br>        public State(List&lt;int&gt; old, int src, int dst) {<br>            for (int i = 0; i &lt; old.Count; ++i) {<br>                e.Add(old[i]);<br>            }<br>            --e[src];<br>            ++e[dst];<br>            if (e[src] == 0)<br>                e.RemoveAt(src);<br>            e.Sort();<br>            h = e.Count;<br>            for (int i = 0; i &lt; e.Count; ++i)<br>                h = h * 3137 + e[i];<br>        }<br><br>        public void BuildJumps() {<br>            for (int a = 0; a &lt; e.Count; ++a)<br>                for (int b = 0; b &lt; e.Count; ++b) {<br>                    int num;<br>                    if (a == b)<br>                        num = e[a] * (e[b] - 1);<br>                    else<br>                        num = e[a] * e[b];<br>                    State next = new State(e, a, b);<br>                    if (next.e.Count == 1) {<br>                        next = null;<br>                    } else if (states.ContainsKey(next))<br>                        next = states[next];<br>                    else {<br>                        states[next] = next;<br>                        allStates.Add(next);<br>                        statesByAmount[next.e.Count].Add(next);<br>                        next.id = nextId++;<br>                        next.BuildJumps();<br>                    }<br>                    if (next == null)<br>                        jumps.Add(-1);<br>                    else<br>                        jumps.Add(next.id);<br>                    jp.Add((double) num / ((size * (size - 1))));<br>                }<br>        }<br><br>        public override bool Equals(Object o) {<br>            State s = (State) o;<br>            if (h != s.h)<br>                return false;<br>            if (e.Count != s.e.Count)<br>                return false;<br>            for (int i = 0; i &lt; e.Count; ++i)<br>                if (e[i] != s.e[i])<br>                    return false;<br>            return true;<br>        }<br><br>        public override int GetHashCode() {<br>            return h;<br>        }<br>    }<br><br>    double[] Gauss(double[,] a, double[] b) {<br>        int n = b.Length;<br>        int[] u = new int[n];<br>        for (int i = 0; i &lt; n; ++i)<br>            u[i] = -1;<br>        for (int i = 0; i &lt; n; ++i) {<br>            double mx = 0;<br>            int mxid = -1;<br>            for (int j = 0; j &lt; n; ++j)<br>                if (u[j] &lt; 0 &amp;&amp; Math.Abs(a[j, i]) &gt; mx) {<br>                    mx = Math.Abs(a[j, i]);<br>                    mxid = j;<br>                }<br>            if (mxid &lt; 0)<br>                throw new Exception();<br>            mx = a[mxid, i];<br>            u[mxid] = i;<br>            for (int j = 0; j &lt; n; ++j)<br>                a[mxid, j] /= mx;<br>            b[mxid] /= mx;<br>            for (int k = 0; k &lt; n; ++k) {<br>                if (k == mxid)<br>                    continue;<br>                double by = -a[k, i];<br>                for (int j = 0; j &lt; n; ++j)<br>                    a[k, j] += by * a[mxid, j];<br>                b[k] += by * b[mxid];<br>            }<br>        }<br>        double[] res = new double[n];<br>        for (int i = 0; i &lt; n; ++i)<br>            res[u[i]] = b[i];<br>        return res;<br>    }<br><br>    public double expectedStepCount(string colors) {<br>        size = colors.Length;<br>        for (int i = 0; i &lt;= size; ++i)<br>            statesByAmount[i] = new List&lt;State&gt;();<br>        List&lt;int&gt; am = new List&lt;int&gt;();<br>        for (int i = 0; i &lt; 26; ++i)<br>            am.Add(0);<br>        foreach (char ch in colors)<br>            ++am[ch - 'A'];<br>        for (int i = 25; i &gt;= 0; --i)<br>            if (am[i] == 0)<br>                am.RemoveAt(i);<br>        am.Sort();<br>        if (am.Count == 1)<br>            return 0;<br>        State start = new State(am, 0, 0);<br>        start.id = nextId++;<br>        states[start] = start;<br>        allStates.Add(start);<br>        statesByAmount[start.e.Count].Add(start);<br>        start.BuildJumps();<br><br>        double[] res = new double[nextId];<br><br>        for (int amount = 2; amount &lt;= start.e.Count; ++amount) {<br>            int n = statesByAmount[amount].Count;<br>            double[,] a = new double[n, n];<br>            double[] b = new double[n];<br>            for (int i = 0; i &lt; n; ++i) {<br>                statesByAmount[amount][i].aid = i;<br>            }<br>            for (int i = 0; i &lt; n; ++i) {<br>                a[i, i] += 1;<br>                b[i] = 1;<br>                State s = statesByAmount[amount][i];<br>                for (int j = 0; j &lt; s.jumps.Count; ++j) {<br>                    int dst = s.jumps[j];<br>                    double pr = s.jp[j];<br>                    if (dst &gt;= 0) {<br>                        State nx = allStates[dst];<br>                        if (nx.e.Count &lt; amount) {<br>                            b[i] += res[dst] * pr;<br>                        } else {<br>                            a[i, nx.aid] -= pr;<br>                        }<br>                    }<br>                }<br>            }<br>/*            for (int i = 0; i &lt; n; ++i) {<br>                for (int j = 0; j &lt; n; ++j)<br>                    Console.Write(a[i, j] + " " );<br>                Console.WriteLine("= " + b[i]);<br>            }<br>            Console.WriteLine();*/<br>            double[] x = Gauss(a, b);<br>            for (int i = 0; i &lt; n; ++i) {<br>                res[statesByAmount[amount][i].id] = x[i];<br>            }<br>        }<br>/*        double[] p = new double[nextId];<br>        double[] np = new double[nextId];<br>        p[0] = 1;<br>        double pLeft = 1;<br>        double res = 0;<br>        int step = 0;<br>        while (pLeft &gt; 1e-10) {<br>            ++step;<br>            for (int i = 0; i &lt; nextId; ++i)<br>                np[i] = 0;<br>            for (int i = 0; i &lt; nextId; ++i) {<br>                State s = allStates[i];<br>                for (int j = 0; j &lt; s.jumps.Count; ++j) {<br>                    int dst = s.jumps[j];<br>                    double pr = p[i] * s.jp[j];<br>                    if (dst &lt; 0) {<br>                        res += pr * step;<br>                        pLeft -= pr;<br>                    } else {<br>                        //Console.WriteLine(dst + " " + nextId);<br>                        np[dst] += pr;<br>                    }<br>                }<br>            }<br>            double[] tmp = p;<br>            p = np;<br>            np = tmp;<br>            if (step % 1000 == 0) {<br>                Console.WriteLine(step + " " + pLeft);<br>            }<br>        }<br>        Console.WriteLine(step);*/<br>        return res[0];<br>    }<br>}<br><br><br>// Powered by FileEdit<br></td>