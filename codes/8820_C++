<td class="problemText" colspan="8" valign="middle" align="left">
            using namespace std;<br><br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;iostream&gt;<br>#include &lt;queue&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;set&gt;<br>#include &lt;map&gt;<br>#include &lt;algorithm&gt;<br><br>#define REP(var,hi) for (int var=0; var&lt;hi; var++)<br>#define REPD(var,hi) for (int var=(hi)-1; var&gt;=0; var--)<br>#define FOR(var,lo,hi) for (int var=lo; var&lt;hi; var++)<br>#define FORD(var,lo,hi) for (int var=(hi)-1; var&gt;=lo; var--)<br>#define FORALL(var,x) for (typeof(x.begin()) var=x.begin(); var!=x.end(); var++)<br><br>#define SORT(x) sort(x.begin(), x.end())<br>#define UNIQUE(x) x.erase(unique(x.begin(),x.end()),x.end())<br><br>#define SZ size()<br>#define PB push_back<br><br>typedef vector&lt;int&gt; VI;<br>typedef vector&lt;VI&gt; VVI;<br>typedef vector&lt;VVI&gt; VVVI;<br>typedef vector&lt;string&gt; VS;<br>typedef vector&lt;double&gt; VD;<br>typedef vector&lt;VD&gt; VVD;<br>typedef long long LL;<br>typedef vector&lt;LL&gt; VLL;<br>typedef vector&lt;VLL&gt; VVLL;<br><br>class OptimalPlay {<br>  public:<br>  double winnings(vector &lt;double&gt; bet, vector &lt;double&gt; call) {<br>    int N=bet.SZ;<br>    VD fold(N);<br>    REP(i,N) fold[i]=1-bet[i]-call[i];<br><br>    double res=0;<br><br>    // check<br>    VD p(N);<br>    double sum=0;<br>    REP(i,N) {<br>      p[i] = call[i] + fold[i];<br>      sum += p[i];<br>    }<br>    REP(i,N) p[i]/=sum;<br><br>    if (sum&gt;0) {<br>      REP(i,N) {<br>  double EVcheck = 0;<br>  REP(j,N) {<br>  if (j==i) EVcheck += p[j]*0.5;<br>  if (j&lt;i)  EVcheck += p[j]*1;<br>      }<br>      double EVbet = 0;<br>      REP(j,N) {<br>  EVbet += fold[j]/sum * 1;<br>  if (j&gt;i)  EVbet -= call[j]/sum * 1;<br>  if (j==i) EVbet += call[j]/sum * 0.5;<br>  if (j&lt;i)  EVbet += call[j]/sum * 2;<br>      }<br><br>      res += sum * 1/N * max(EVbet, EVcheck);<br>    }<br>    }<br>      <br>    // bet<br>    p=VD(N);<br>    sum=0;<br>    REP(i,N) {<br>      p[i] = bet[i];<br>      sum += p[i];<br>    }<br>    REP(i,N) p[i]/=sum;<br><br>    if (sum&gt;0) {<br>    REP(i,N) {<br>      double EVcall = 0;<br>      REP(j,N) {<br>  if (j&gt;i)  EVcall -= p[j]*1;<br>  if (j==i) EVcall += p[j]*0.5;<br>  if (j&lt;i)  EVcall += p[j]*2;<br>      }<br><br>      res += sum * 1/N * max(0.0, EVcall);<br>    }<br>    }<br><br>    return res/N;<br>  }<br>};<br><br><br>// Powered by FileEdit<br></td>