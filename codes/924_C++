<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cmath&gt;<br>#include &lt;queue&gt;<br>using namespace std;<br>typedef vector&lt;int&gt; VI;  typedef vector&lt;vector&lt;int&gt; &gt; VVI;<br>typedef vector&lt;string&gt; VS;  typedef vector&lt;vector&lt;string&gt; &gt; VVS;<br>typedef signed long long i64;  typedef unsigned long long u64;<br><br>vector&lt;string&gt; tokenize(string s, string ch) {<br>  vector&lt;string&gt; ret;<br>  for( int p = 0, p2; p &lt; s.size(); p = p2+1 ) {<br>    p2 = s.find_first_of(ch, p);<br>    if( p2 == -1 ) p2 = s.size();<br>    if( p2-p &gt; 0 ) ret.push_back( s.substr(p, p2-p) );<br>  }<br>  return ret;<br>}<br><br>struct Point {<br>  int x, y;<br>  bool operator&lt;(const Point &amp;p) const {<br>    if( x != p.x ) return (x&lt;p.x);<br>    return (y&lt;p.y);<br>  }<br>  bool operator==(const Point &amp;p) const {<br>    return (x==p.x) &amp;&amp; (y==p.y);<br>  }<br>};<br><br>vector&lt;Point&gt; b;<br><br>inline i64 lineDist(const Point &amp;pa, const Point &amp;pb, const Point &amp;p) {<br>  return (p.x-pa.x)*(i64)(pb.y-pa.y) - (pb.x-pa.x)*(i64)(p.y-pa.y);<br>}<br><br>int tryLine(Point pa, Point pb) {<br>  vector&lt;Point&gt; b2;<br><br>  Point p;<br>  double vl = (pb.x-pa.x)*(double)(pb.x-pa.x) +<br>        (pb.y-pa.y)*(double)(pb.y-pa.y);<br>//cout &lt;&lt; "(" &lt;&lt; pa.x &lt;&lt; "," &lt;&lt; pa.y &lt;&lt; ")-";<br>//cout &lt;&lt; "(" &lt;&lt; pb.x &lt;&lt; "," &lt;&lt; pb.y &lt;&lt; "):" &lt;&lt; endl;<br>  for( int i = 0; i &lt; b.size(); i++ ) {<br>    double d = 2*lineDist(pa, pb, b[i]) / vl;<br>    double x = b[i].x - d*(pb.y-pa.y);<br>    double y = b[i].y + d*(pb.x-pa.x);<br>    p.x = (int)(x+1000000.0000001)-1000000;<br>    p.y = (int)(y+1000000.0000001)-1000000;<br>//cout &lt;&lt; "  ";<br>//cout &lt;&lt; "(" &lt;&lt; b[i].x &lt;&lt; "," &lt;&lt; b[i].y &lt;&lt; ") -&gt; ";<br>//cout &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; "," &lt;&lt; p.y &lt;&lt; ")" &lt;&lt; ' ' &lt;&lt; d &lt;&lt; endl;<br>    if( ((int)(x+1000000.0-0.0000001))-1000000 == p.x ) return 0;<br>    if( ((int)(y+1000000.0-0.0000001))-1000000 == p.y ) return 0;<br>    b2.push_back(p);<br>  }<br>  sort(b2.begin(), b2.end());<br>  return( b == b2 );<br>}<br><br>class Symmetry {<br>public:<br>int countLines(vector &lt;string&gt; a) {<br>  int i, j, k, x, y, z, n;<br>  int ret = 0;<br>  Point p, p2;<br>  <br>  for( i = 0; i &lt; a.size(); i++ ) {<br>    VS t = tokenize(a[i], " ");<br>    for( j = 0; j &lt; t.size(); j += 2 ) {<br>      p.x = atoi(t[j].c_str())*2;<br>      p.y = atoi(t[j+1].c_str())*2;<br>      b.push_back(p);<br>    }<br>  }<br><br>  sort(b.begin(), b.end());<br>  for( i = 1; i &lt; b.size(); i++ ) {<br>    p.x = (b[0].x+b[i].x)/2;<br>    p.y = (b[0].y+b[i].y)/2;<br>    p2.x = p.x + (b[i].y - p.y);<br>    p2.y = p.y + (p.x - b[i].x);<br>    ret += tryLine(p, p2);<br>  }<br>  for( i = 2; i &lt; b.size(); i++ ) {<br>    p.x = (b[1].x+b[i].x)/2;<br>    p.y = (b[1].y+b[i].y)/2;<br>    p2.x = p.x + (b[i].y - p.y);<br>    p2.y = p.y + (p.x - b[i].x);<br>    if( lineDist(p, p2, b[0]) == 0 )<br>      ret += tryLine(p, p2);<br>  }<br>  ret += tryLine(b[0], b[1]);<br>  return ret;<br>}<br>};<br></td>