<td class="problemText" colspan="8" valign="middle" align="left">
            #include&lt;vector&gt;<br>#include&lt;string&gt;<br>#include&lt;set&gt;<br>#include&lt;map&gt;<br>#include&lt;list&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;iostream&gt;<br>#include&lt;math.h&gt;<br>#include&lt;stdio.h&gt;<br>#include&lt;queue&gt;<br>#include&lt;iterator&gt;<br> <br>#define q(x) #x<br>#define qq(x) #x[0]<br> <br>#define fori(st, end) for (int i = ((int)(st)); i &lt;= ((int)(end)); i++) <br>#define forj(st, end) for (int j = ((int)(st)); j &lt;= ((int)(end)); j++)<br>#define fork(st, end) for (int k = ((int)(st)); k &lt;= ((int)(end)); k++)<br>#define forl(st, end) for (int l = ((int)(st)); l &lt;= ((int)(end)); l++)<br>#define form(st, end) for (int m = ((int)(st)); m &lt;= ((int)(end)); m++)<br>#define fordi(st, end) for (int i = ((int)(st)); i &gt;= ((int)(end)); i--) <br>#define fordj(st, end) for (int j = ((int)(st)); j &gt;= ((int)(end)); j--)<br>#define fordk(st, end) for (int k = ((int)(st)); k &gt;= ((int)(end)); k--)<br>#define repi(end) for (int i=0; i&lt;((int)(end)); i++)<br>#define repj(end) for (int j=0; j&lt;((int)(end)); j++)<br>#define repk(end) for (int k=0; k&lt;((int)(end)); k++)<br>#define foreach(vec, it) for ( __typeof(vec.begin()) it = vec.begin(); it!=vec.end(); it++)<br> <br>#define ITADJ for(int adx=-1; adx&lt;=1; adx++) for(int ady=-1; ady&lt;=1; ady++)<br>#define chk_cell(i, j, n, m) ((i)&gt;=0&amp;&amp;(j)&gt;=0&amp;&amp;(i)&lt;n&amp;&amp;(j)&lt;m)<br> <br>#define VECI  vector&lt;int&gt;<br>#define LISTI list&lt;int&gt;<br> <br>#define VECS vector&lt;string&gt;<br>#define LISTS list&lt;string&gt;<br> <br>#define VECD vector&lt;double&gt;<br> <br>using namespace std;<br>typedef vector&lt;int&gt; veci;<br>typedef vector&lt;double&gt; vecd;<br>typedef vector&lt;string&gt; vecs;<br>typedef vector&lt;char&gt;   vecch;<br>typedef string str;<br> <br> <br>#define ITRI vector&lt;int&gt;::iterator<br>#define ITRS vector&lt;string&gt;::iterator<br> <br>#define vp(vec, val) vec.push_back(val)    <br>#define vf(vec, val) find(vec.begin(), vec.end(), val)<br>#define vs(vec) sort(vec.begin(), vec.end())<br>#define ve(vec, val) (vf(vec, val) != vec.end())<br>#define va(vec) vec.begin(), vec.end()<br>#define vind(vec, val) (ve(vec, val) ? vf(vec, val) - vec.begin() : -1)<br>#define vins(vec, val) do { if (!ve(vec, val)) vp(vec, val); } while(0)<br> <br>#define lint long long<br> <br>#define ABS(x) ((x) &gt; 0 ? (x) : -(x))<br>#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))<br>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))<br>#define DIST(x, y) ABS((x)-(y))<br> <br>typedef pair&lt;int, int&gt; PAIRI;<br>typedef pair&lt;double, double&gt; PAIRD;<br> <br>typedef PAIRI pairi;<br>typedef PAIRD paird;<br> <br>typedef pair&lt; PAIRD, int &gt; TRIPLEI;<br> <br>#define mp(x, y) make_pair(x, y)<br>#define mt(x,y,z) mp(mp(x,y),z)<br> <br>typedef pair&lt;pairi, int&gt; triplei;<br>typedef pair&lt; paird, double &gt; tripled;<br> <br>#define pq priority_queue<br> <br>#include &lt;sstream&gt;<br> <br>#define vall(v) v.begin(), v.end()<br> <br>#define   pint  parsestr&lt;int&gt;<br>#define   plint parsestr&lt;lint&gt;<br>#define   pstr  parsestr&lt;string&gt;<br>#define   pdouble parsestr&lt;double&gt;<br> <br>template&lt;class T&gt; <br>vector&lt;T&gt; parsestr(string s, string delims = " ") {<br>   string s1;<br>   vector&lt;T&gt; ret;<br>   while (s != "") {<br>      while(delims.find(s[0]) != string::npos) s = s.erase(0, 1);<br>      while(delims.find(s[s.length()-1]) != string::npos)  s = s.erase(s.length()-1, 1);   <br> <br>      int pos = s.find_first_of(delims);<br>      if (pos == string::npos) {<br>         s1 = s;<br>         s  = "";<br>      } else {<br>         s1 = s.substr(0, pos);<br>         s  = s.substr(pos+1, s.length());<br>      }<br> <br>      T val;<br>      istringstream st(s1);<br>      st &gt;&gt; val;<br>      vp(ret, val);<br>   }<br>   return ret;<br> <br>}<br> <br>string toupper(string s) {<br>   string s1 = "";<br>   fori(0, s.size()-1) s1 += toupper(s[i]);<br>   return s1;<br>}<br> <br>string tolower(string s) {<br>   string s1 = "";<br>   fori(0, s.size()-1) s1 += tolower(s[i]);<br>   return s1;<br>}<br> <br>lint gcd(lint a, lint b) {<br>  if (b &gt; a) swap(a, b);<br>  if (b==0) return a;<br>  if ((a%b)==0) return b;<br>  return gcd(b, a%b);<br>}<br> <br>int lcm(int a, int b) {<br>  return (a*b)/gcd(a, b);<br>}<br> <br>lint choose(int n, int k) {<br>  lint ret = 1;<br>  int x = n;<br>  int y = 1;<br>  while (x != n-k) {<br>    ret *= x;<br>    x--;<br>    while (y != k+1 &amp;&amp; (ret % y) == 0)  {  ret /= y; y++; }<br>  }<br>  return ret;<br>}<br> <br>inline double dist(const paird &amp;p1, const paird &amp;p2) {<br>  double ret=(p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second);<br>  return sqrt(ret);<br>}<br> <br>#define USE_EXTRA 0<br>#if USE_EXTRA<br>void bfForVECS(const VECS &amp;field, PAIRI st, const vector&lt; PAIRI &gt; &amp;adj, char wall, map&lt; PAIRI, int &gt; &amp;dists) {<br>   list&lt; PAIRI &gt;  t;<br>   t.push_back(st);<br>   while (!t.empty()) {<br>      PAIRI cur = t.front(); <br>      t.pop_front();<br>      fori(0, adj.size()-1) {<br>         int nx = cur.first + adj[i].first;<br>         int ny = cur.second + adj[i].second;<br>         if (nx &lt; 0 || ny &lt;0 || nx &gt;= field.size() || ny &gt;= field[0].size()) continue;<br>         if (field[nx][ny] == wall) continue;<br>         if (dists.find(mp(nx, ny)) == dists.end()) {<br>            dists[mp(nx, ny)] = dists[cur]+1;<br>            vp(t, mp(nx, ny));<br>         }<br>      }<br>   }<br>   return;<br>}<br> <br>template&lt;class T&gt;<br>double get_area(const pair&lt; T, T&gt; &amp;p1, const pair&lt; T, T&gt; &amp;p2, const pair&lt;T, T&gt; &amp;p3) {<br>  return ((double)0.5)*(p1.first*p2.second-p2.first*p1.second +<br>  p2.first*p3.second-p3.first*p2.second+p3.first*p1.second-p1.first*p3.second);<br>}<br>  <br>template &lt;class T&gt; <br>vector&lt;pair&lt; T, T&gt; &gt; get_chull(vector&lt;pair&lt; T, T &gt; &gt; &amp;v) {<br>  vector&lt;pair&lt;T, T&gt; &gt; ret;<br>    <br>  vs(v);<br>  vp(ret, v[0]);<br>    <br>  pair&lt; T, T&gt; cur=v[0];<br>  while(1) {<br>    pair&lt; T, T &gt; p;  <br>    fori(0, v.size()-1) if (v[i]!=cur) {<br>      bool f=true;<br>        <br>    forj(0, v.size()-1) if (j!=i&amp;&amp;v[j]!=cur)<br>      if (get_area(cur, v[i], v[j])&lt;0) { f=false; break; }<br>        <br>      if (f) {p=v[i]; break; }<br>    }<br>    if (p==v[0]) break;<br>    vp(ret, p);<br>    cur=p;<br>  }<br>  return ret;<br>}<br> <br>inline bool isect(const paird &amp;p1, const paird &amp;p2, const paird &amp;p3, const paird &amp;p4, paird &amp;ret) {<br>  <br>  paird v1(p2.first-p1.first, p2.second-p1.second);<br>  paird v2(p3.first-p4.first, p3.second-p4.second);<br>  <br>  paird b(p3.first-p1.first, p3.second-p1.second);<br>  <br>  double det=v1.first*v2.second-v1.second*v2.first;<br>  if (ABS(det)&lt;1e-9) return false;<br> <br>  double alpha=b.first*v2.second-b.second*v2.first;<br>  alpha /= det;<br>  <br>//  if (alpha&lt;0) return false;<br>  ret.first = p1.first + v1.first * alpha;<br>  ret.second = p1.second + v1.second * alpha;<br>  <br>  if (ret.first &lt; MIN(p3.first, p4.first)) return false;<br>  if (ret.second &lt; MIN(p3.second, p4.second)) return false;<br>  if (ret.first &gt; MAX(p3.first, p4.first)) return false;<br>  if (ret.second &gt; MAX(p3.second, p4.second)) return false;<br> <br>  if (ret.first &lt; MIN(p1.first, p2.first)) return false;<br>  if (ret.second &lt; MIN(p1.second, p2.second)) return false;<br>  if (ret.first &gt; MAX(p1.first, p2.first)) return false;<br>  if (ret.second &gt; MAX(p1.second, p2.second)) return false;<br> <br>  return true;<br>}<br> <br>#endif<br> <br>bool is_leap(int y) {<br>  if (y%4 != 0) return false;<br>  if (y%400 == 0) return true;<br>  <br>  return (y%100 != 0);<br>}<br> <br>int ndays(int y, int m) {<br>  <br>  if (m == -1) { if (is_leap(y)) return 366; else return 365; }<br>  switch(m) {<br>    case 1:<br>      if (is_leap(y)) return 29; else return 28;<br>    case 0: case 2: case 4:  case 6: case 7: case 9: case 11:<br>      return 31;<br>    default:<br>      return 30;<br>  }<br>}<br> <br>int get_days_between( int d1, int m1, int y1, int d, int m, int y) {<br>  int ret = 0;<br>  while(y != y1) {<br>    ret += ndays(y+1, -1);<br>    y++;<br>  }<br> <br>  while (m &lt; m1) {<br>    ret += ndays(y, m);<br>    m++;<br>  }  <br>  <br>  while (m1 &lt; m) {<br>    ret -= ndays(y, m1);<br>    m1++;<br>  }<br>  <br>  ret += (d1-d);<br>  return ret;<br>}<br> <br>inline void get_next_day(int &amp;d, int &amp;m, int &amp;y) {<br>  d++;<br>  if (d == ndays(y, m)+1) {<br>    d=1;<br>    m++;<br>    if (m==12) {<br>      m=0;<br>      y++;<br>    }<br>  }<br>}<br> <br>inline void get_prev_day(int &amp;d, int &amp;m, int &amp;y) {<br>  d--;<br>  if (d == 0) {<br>    m--;<br>    if (m &lt; 0) {<br>      y--;<br>      m = 11;<br>    }<br>    d = ndays(y, m);<br>  }<br>}<br> <br> <br> <br> <br>class BlueMoons {<br>  public:<br>  int count(string interval, string fullMoon) {<br>    <br>// BEGIN CUT HERE<br>    //static bool s_FirstTime = true; if (s_FirstTime) { s_FirstTime = false; run_test(-1); }<br>// END CUT HERE<br>    <br>    veci v = pint(fullMoon, "./");<br>    <br>    int fmday=v[0];<br>    int fmper = v[1];<br>    int fmmon = v[2]-1;<br>    int fmyear=v[3];<br>    <br>    veci iv = pint(interval, " /to");<br>    <br>    int m1, y1;<br>    int m2, y2;<br>    <br>    m1 = iv[0]-1;<br>    y1 = iv[1];<br>    <br>    m2 = iv[2]-1;<br>    y2 = iv[3];<br>    <br>    while (fmyear &gt; y1 || (fmyear == y1 &amp;&amp; fmmon &gt;= m1)) {<br>      fori(0, 28) get_prev_day(fmday, fmmon, fmyear);<br>      if (fmper &gt;= 53) { fmper -= 53; }<br>      else { get_prev_day(fmday, fmmon, fmyear); fmper += (100-53); }<br>    }<br>    <br>    int ret=0;<br>    int prevm=-1;<br>    <br>    while(fmyear &lt; y2 || (fmyear == y2 &amp;&amp; fmmon &lt;= m2)) {<br>      if (fmyear &gt; y1 || (fmyear == y1 &amp;&amp; fmmon &gt;= m1)) {<br>        if (fmmon == prevm) ret++;<br>        prevm=fmmon;<br>      }<br>      <br>      fori(0,28) get_next_day(fmday, fmmon, fmyear);<br>      if (fmper+53 &lt; 100) { fmper += 53; }<br>      else { get_next_day(fmday, fmmon, fmyear); fmper += (53-100); }  <br>    }<br>    <br>    return ret;<br>    <br>  }<br>  <br>// BEGIN CUT HERE<br>  public:<br>  void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); }<br>  private:<br>  template &lt;typename T&gt; string print_array(const vector&lt;T&gt; &amp;V) { ostringstream os; os &lt;&lt; "{ "; for (typename vector&lt;T&gt;::const_iterator iter = V.begin(); iter != V.end(); ++iter) os &lt;&lt; '\"' &lt;&lt; *iter &lt;&lt; "\","; os &lt;&lt; " }"; return os.str(); }<br>  void verify_case(int Case, const int &amp;Expected, const int &amp;Received) { cerr &lt;&lt; "Test Case #" &lt;&lt; Case &lt;&lt; "..."; if (Expected == Received) cerr &lt;&lt; "PASSED" &lt;&lt; endl; else { cerr &lt;&lt; "FAILED" &lt;&lt; endl; cerr &lt;&lt; "\tExpected: \"" &lt;&lt; Expected &lt;&lt; '\"' &lt;&lt; endl; cerr &lt;&lt; "\tReceived: \"" &lt;&lt; Received &lt;&lt; '\"' &lt;&lt; endl; } }<br>  void test_case_0() { string Arg0 = "01/2002 to 05/2002"; string Arg1 = "28.95/01/2002"; int Arg2 = 0; verify_case(0, Arg2, count(Arg0, Arg1)); }<br>  void test_case_1() { string Arg0 = "01/2002 to 05/2002"; string Arg1 = "01.00/01/2002"; int Arg2 = 2; verify_case(1, Arg2, count(Arg0, Arg1)); }<br>  void test_case_2() { string Arg0 = "01/2002 to 01/2002"; string Arg1 = "02.46/01/2002"; int Arg2 = 1; verify_case(2, Arg2, count(Arg0, Arg1)); }<br>  void test_case_3() { string Arg0 = "01/2002 to 01/2002"; string Arg1 = "01.00/02/2002"; int Arg2 = 0; verify_case(3, Arg2, count(Arg0, Arg1)); }<br> <br>// END CUT HERE<br> <br>};<br> <br>BlueMoons BlueMoons_obj;<br> <br>extern  "C" void i_know_it_would_fail_but_at_least_i_can_try() {<br>  BlueMoons_obj.run_test(-1);<br>}<br> <br> <br>// Powered by PopsEdit<br>// Powered by TZTester 1.01 [25-Feb-2003]<br>// Powered by CodeProcessor<br></td>