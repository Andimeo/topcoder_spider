<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class ContiguousCache {<br>    public long minimumReads(int n, int k, int[] addresses) {<br>        List&lt;long&gt; cool = new List&lt;long&gt;();<br>        cool.Add(-5 * (long) k);<br>        foreach (int x in addresses)<br>        {<br>            cool.Add(x);<br>            cool.Add(x - k + 1);<br>        }<br>        cool.Add(0);<br>        cool.Add(n - k);<br>        int m = cool.Count;<br>        int s = addresses.Length;<br>        long[,] best = new long[s + 1, m];<br>        for (int j = 0; j &lt;= s; ++j)<br>            for (int i = 0; i &lt; m; ++i)<br>                best[j, i] = long.MaxValue;<br>        best[0, 0] = 0;<br>        for (int i = 0; i &lt; s; ++i)<br>        {<br>            for (int j = 0; j &lt; m; ++j)<br>                if (best[i, j] &lt; long.MaxValue)<br>                {<br>                    for (int jj = 0; jj &lt; m; ++jj)<br>                        if (cool[jj] &lt;= addresses[i] &amp;&amp; cool[jj] + k &gt; addresses[i])<br>                            best[i + 1, jj] = Math.Min(best[i + 1, jj], best[i, j] + k - overlap(cool[j], cool[jj], k));<br>                }<br>        }<br>        long res = long.MaxValue;<br>        for (int j = 0; j &lt; m; ++j)<br>            res = Math.Min(res, best[s, j]);<br>        return res;<br>    }<br><br>    private long overlap(long p, long q, long k)<br>    {<br>        long d = Math.Abs(p - q);<br>        if (d &gt;= k)<br>            return 0;<br>        else<br>            return k - d;<br><br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>