<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections;<br>using System.Collections.Generic;<br>using System.Collections.Specialized;<br>using System.Text;<br>using System.Text.RegularExpressions;<br>public class WorkersOnPlane<br>{<br>    public int howMany(string[] field, int K)<br>    {<br>        int numG = 0, numS = 0, numW = 0;<br>        int[,] Gnum = new int[field.Length, field[0].Length];<br>        int[,] Snum = new int[field.Length, field[0].Length];<br>        Point[] ws = new Point[field.Length * field[0].Length];<br>        for (int i = 0; i &lt; field.Length; i++)<br>        {<br>            for (int j = 0; j &lt; field[i].Length; j++)<br>            {<br>                if (field[i][j] == 'G') Gnum[i, j] = numG++;<br>                if (field[i][j] == 'S') Snum[i, j] = numS++;<br>                if (field[i][j] == 'W') ws[numW++] = new Point(i, j);<br>            }<br>        }<br> <br>        int n = 2 + numG + numW + numW + numS;<br>        int[,] capacity = new int[n, n];<br>        for (int i = 0; i &lt; numG; i++)<br>            capacity[0, i + 1] = 1;<br>        for (int i = 0; i &lt; numS; i++)<br>            capacity[1 + numG + numW + numW + i, n - 1] = 1;<br>        for (int i = 0; i &lt; numW; i++)<br>            capacity[1 + numG + i, 1 + numG + numW + i] = 1;<br> <br>        int[] dx = new int[] { 0, -1, 0, 1 };<br>        int[] dy = new int[] { 1, 0, -1, 0 };<br>        for (int i = 0; i &lt; numW; i++)<br>        {<br>            int Win = 1 + numG + i;<br>            int Wout = 1 + numG + numW + i;<br>            bool[,] done = new bool[field.Length, field[0].Length];<br>            Queue&lt;Point&gt; Q = new Queue&lt;Point&gt;();<br>            for (int j = 0; j &lt; 4; j++)<br>                Q.Enqueue(new Point(ws[i].X + dx[j], ws[i].Y + dy[j], 1));<br>            while (Q.Count &gt; 0)<br>            {<br>                Point top = Q.Dequeue();<br>                if (top.X &lt; 0 || top.X &gt;= field.Length || top.Y &lt; 0 || top.Y &gt;= field[0].Length)<br>                    continue;<br>                if (done[top.X, top.Y]) continue;<br>                done[top.X, top.Y] = true;<br>                if (top.dist &gt; K) continue;<br>                if (field[top.X][top.Y] == 'G')<br>                    capacity[1 + Gnum[top.X, top.Y], Win] = 1;<br>                else if (field[top.X][top.Y] == 'S')<br>                    capacity[Wout, 1 + numG + numW + numW + Snum[top.X, top.Y]] = 1;<br>                else if (field[top.X][top.Y] == '.')<br>                    for (int j = 0; j &lt; 4; j++)<br>                        Q.Enqueue(new Point(top.X + dx[j], top.Y + dy[j], top.dist + 1));<br>            }<br>        }<br> <br>        return max_flow(n, capacity, 0, n - 1);<br>    }<br> <br>    private class Point<br>    {<br>        public int X, Y, dist = 0;<br> <br>        public Point(int x, int y)<br>        {<br>            X = x;<br>            Y = y;<br>        }<br> <br>        public Point(int x, int y, int dist)<br>        {<br>            X = x;<br>            Y = y;<br>            this.dist = dist;<br>        }<br>    }<br> <br>    #region "Maximum Flow"<br>    public static int max_flow(int n, int[,] capacity, int source, int dest)<br>    {<br>        int[,] used = new int[n, n];<br>        int this_cap = 0;<br>        int total_cap = 0;<br>        while (true)<br>        {<br>            int[] from = new int[n];<br>            bool[] done = new bool[n];<br>            for (int i = 0; i &lt; n; i++) from[i] = -1;<br>            PriorityQueue&lt;Node&gt; Q = new PriorityQueue&lt;Node&gt;();<br>            Q.Push(new Node(source, -1, 0));<br>            while (Q.Count &gt; 0)<br>            {<br>                Node actn = Q.Pop();<br>                if (done[actn.act]) continue;<br>                done[actn.act] = true;<br>                from[actn.act] = actn.from;<br>                if (actn.act == dest) break;<br>                for (int i = 0; i &lt; n; i++)<br>                {<br>                    if (capacity[actn.act, i] - used[actn.act, i] &gt; 0 || used[i, actn.act] &gt; 0)<br>                    {<br>                        Q.Push(new Node(i, actn.act, Math.Max(capacity[actn.act, i]<br>                           - used[actn.act, i], used[i, actn.act])));<br>                    }<br>                }<br>            }<br>            if (from[dest] == -1) break;<br>            this_cap = int.MaxValue;<br>            int act = dest;<br>            while (from[act] &gt; -1)<br>            {<br>                this_cap = Math.Min(this_cap, Math.Max(capacity[from[act], act]<br>                   - used[from[act], act], used[act, from[act]]));<br>                act = from[act];<br>            }<br>            act = dest;<br>            while (from[act] &gt; -1)<br>            {<br>                if (used[act, from[act]] &gt; 0)<br>                {<br>                    if (used[act, from[act]] &gt;= this_cap)<br>                        used[act, from[act]] -= this_cap;<br>                    else<br>                    {<br>                        used[from[act], act] += this_cap - used[act, from[act]];<br>                        used[act, from[act]] = 0;<br>                    }<br>                }<br>                else<br>                    used[from[act], act] += this_cap;<br>                act = from[act];<br>            }<br>            total_cap += this_cap;<br>        }<br>        return total_cap;<br>    }<br> <br>    class Node : IComparable&lt;Node&gt;<br>    {<br>        public int act;<br>        public int from;<br>        public int cap;<br> <br>        public Node(int a, int f, int c)<br>        {<br>            act = a;<br>            from = f;<br>            cap = c;<br>        }<br> <br>        public int CompareTo(Node other)<br>        {<br>            return other.cap - cap;<br>        }<br>    }<br>    #endregion<br>    <br>    <br>public class PriorityQueue&lt;T&gt;<br>{<br>    private T[] list;<br>    public int Count;<br>    public System.Collections.Generic.Comparer&lt;T&gt; Comparer;<br> <br>    public PriorityQueue()<br>    {<br>        list = new T[16];<br>        Count = 0;<br>        Comparer = System.Collections.Generic.Comparer&lt;T&gt;.Default;<br>    }<br> <br>    public void Push(T value)<br>    {<br>        if (Count == list.Length)<br>        {<br>            T[] tmp = new T[list.Length * 2];<br>            System.Array.Copy(list, tmp, list.Length);<br>            list = tmp;<br>        }<br>        list[Count++] = value;<br>        int i = Count - 1;<br>        while (i &gt; 0 &amp;&amp; Comparer.Compare(list[i], list[parent(i)]) &lt; 0)<br>        {<br>            T tmp = list[i];<br>            list[i] = list[parent(i)];<br>            list[parent(i)] = tmp;<br>            i = parent(i);<br>        }<br>    }<br> <br>    public T Pop()<br>    {<br>        T ret = list[0];<br>        list[0] = list[--Count];<br>        int i = 0;<br>        while (true)<br>        {<br>            int left = (i * 2) + 1;<br>            if (left &gt;= Count) break;<br>            int right = left + 1;<br>            int ind = left;<br>            if (right &lt; Count &amp;&amp; Comparer.Compare(list[left], list[right]) &gt; 0)<br>                ind = right;<br>            if (Comparer.Compare(list[i], list[ind]) &gt;= 0)<br>            {<br>                T tmp = list[i];<br>                list[i] = list[ind];<br>                list[ind] = tmp;<br>                i = ind;<br>            }<br>            else break;<br>        }<br>        return ret;<br>    }<br> <br>    private int parent(int i)<br>    {<br>        return (i - 1) / 2;<br>    }<br>}<br> <br> <br>}<br>//Powered by [KawigiEdit] 2.0!<br></td>