<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;stdio.h&gt;<br>#include &lt;math.h&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;vector&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;string&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;memory.h&gt;<br>#include &lt;sstream&gt;<br>using namespace std;<br><br>inline long min(long a,long b){return a&lt;b?a:b;}<br>inline long max(long a,long b){return a&gt;b?a:b;}<br>inline void swap(long &amp;a,long &amp;b){long tmp=a;a=b,b=tmp;}<br><br>struct point {long x1,x2,y,s;};<br>bool cmp(const point  &amp;a,const point &amp;b)<br>{if(a.y==b.y)return a.x1&lt;b.x1;return a.y&lt;b.y;}<br>class GetToTheTop{<br>public:<br>    point p[100];<br>    int dp[100],w[100];<br>    long fa[100];<br>    double tk;<br>    char cal(char s1,char s2)<br>    {<br>        long l1=s1-'0';<br>        long l2=s2-'0';<br><br>        for(int i=0;i&lt;=9;i++)<br>            if((l1+i)%10==l2)return char(i+'0');<br>    }<br><br>    double dist(long x1,long y1,long x2,long y2)<br>    {<br>        return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));<br>    }<br>    int findset(long v)<br>    {<br>        long u=v,t;<br>        while(v!=fa[v])v=fa[v];<br>        while(u!=v){t=fa[u];fa[u]=v;u=t;}<br>        return v;<br>    }<br>    void unionset(long a,long b)<br>    {<br>        long aa=findset(a);<br>        long bb=findset(b);<br>        fa[aa]=bb;<br>    }<br><br>    bool isok(long a,long b)<br>    {<br>        if(p[b].x1&lt;=p[a].x2&amp;&amp;p[b].x1&gt;=p[a].x1||<br>           p[b].x2&lt;=p[a].x2&amp;&amp;p[b].x2&gt;=p[a].x1||<br>           p[b].x2&gt;=p[a].x2&amp;&amp;p[b].x1&lt;=p[a].x1)<br>        {<br>            if(p[b].y-p[a].y&lt;=tk)return 1;<br>        }<br>        if(dist(p[b].x1,p[b].y,p[a].x1,p[a].y)&lt;=tk)return 1;<br>        if(dist(p[b].x2,p[b].y,p[a].x1,p[a].y)&lt;=tk)return 1;<br>        if(dist(p[b].x1,p[b].y,p[a].x2,p[a].y)&lt;=tk)return 1;<br>        if(dist(p[b].x2,p[b].y,p[a].x2,p[a].y)&lt;=tk)return 1;<br>        return 0;<br>    }<br>    int collectSweets(int K, vector &lt;int&gt; s, vector &lt;int&gt; x, vector &lt;int&gt; y, vector &lt;int&gt; L)<br>    {<br>        int ans = 0;<br>        tk=K;<br>        int i,j,k,n;<br>        s.push_back(0);<br>        x.push_back(0);<br>        y.push_back(0);<br>        L.push_back(20000);<br>        for(i=0;i&lt;s.size();i++)fa[i]=i,dp[i]=-1,w[i]=0;<br>        for(i=0;i&lt;s.size();i++)<br>        {<br>            p[i].s=s[i];<br>            p[i].x1=x[i];<br>            p[i].x2=x[i]+L[i];<br>            p[i].y=y[i];<br>        }<br>        sort(p,p+s.size(),cmp);<br>        for(i=0;i&lt;s.size();i++)<br>        {<br>            for(j=i+1;j&lt;s.size();j++)<br>            {<br>                if(p[i].y==p[j].y)<br>                {<br>                    if((p[j].x1-p[i].x2)&lt;=K)unionset(i,j);<br>                }<br>            }<br>        }<br>        for(i=0;i&lt;s.size();i++)<br>        {<br>            j=findset(i);<br>            w[j]+=p[i].s;<br>        }<br>        long aa,bb;<br>        dp[findset(0)]=0;<br>        for(i=0;i&lt;s.size();i++)<br>        {<br>            aa=findset(i);<br>            if(dp[aa]==-1)continue;<br>            for(j=i+1;j&lt;s.size();j++)<br>            {<br>                bb=findset(j);<br>                if(aa==bb)continue;<br>                if(isok(i,j))<br>                {<br>                    dp[bb]=max(dp[bb],dp[aa]+w[bb]);<br>                    ans = max(ans,dp[bb]);<br>                }<br>            }<br>        }<br>        return ans;<br><br>    }<br><br>};<br></td>