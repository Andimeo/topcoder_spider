<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br>using System.Text;<br><br>class AllCycleLengths<br>{<br>    class State : IEquatable&lt;State&gt;<br>    {<br>        public State(int startersCount)<br>        {<br>            _states = new int[startersCount];<br>        }<br><br>        private readonly int [] _states;<br>        public int Number<br>        {<br>            get <br>            { <br>                for(int i=0;i&lt;_states.Length;i++)<br>                    if ((_states[i] &amp; (1&lt;&lt;i)) &gt; 0)<br>                        return 1;<br>                return 0;<br>            }<br>        }<br><br>        public bool this[int starter, int bit]<br>        {<br>            get { return (_states[starter] &amp; (1 &lt;&lt; bit)) &gt; 0; }<br>            set<br>            {<br>                if (value)<br>                    _states[starter] |= (1 &lt;&lt; bit);<br>                else<br>                    _states[starter] &amp;= ~(1 &lt;&lt; bit);<br>            }<br>        }<br>        public override int GetHashCode()<br>        {<br>            int result = 0;<br>            for (int i = 0; i &lt; _states.Length; i++)<br>            {<br>                result *= 7;<br>                result ^= _states[i];<br>            }<br>            return result;<br>        }<br><br>        public bool Equals(State other)<br>        {<br>            if(other._states.Length!=_states.Length)<br>                throw new Exception("Impossible!!");<br>            for (int i = 0; i &lt; _states.Length; i++)<br>                if (_states[i] != other._states[i])<br>                    return false;<br>            return true;<br>        }<br>    }<br><br>    readonly Dictionary&lt;State, int&gt; met_states = new Dictionary&lt;State, int&gt;();<br><br>    private string[] _arcs;<br><br>    public string findAll(string[] arcs)<br>    {<br>        List&lt;int&gt; resultList = new List&lt;int&gt;();<br>        _arcs = arcs;<br>        int N = arcs.Length;<br><br>        State state = new State(N);<br>        for (int starter = 0; starter &lt; N; starter++)<br>            state[starter, starter] = true;<br><br>        while(!met_states.ContainsKey(state))<br>        {<br>            met_states.Add(state, resultList.Count);<br>            resultList.Add(state.Number);<br><br>            State new_state = new State(N);<br>            for (int starter = 0; starter &lt; N; starter++)<br>                for (int i = 0; i &lt; N; i++)<br>                    for(int j=0;j&lt;N;j++)<br>                        if (have_edge(j, i) &amp;&amp; state[starter, j])<br>                            new_state[starter, i] = true;<br><br>            state = new_state;<br>        }<br><br>        int bigCycleLength = resultList.Count - met_states[state];<br><br>        if (resultList.Count == bigCycleLength)<br>            resultList.Add(resultList[0]);<br><br>        int [] result = new int[resultList.Count - 1];<br>        resultList.CopyTo(1, result, 0, result.Length);<br><br>        for (int cycleLenght = 1; cycleLenght &lt;= bigCycleLength; cycleLenght++ )<br>        {<br>            if(bigCycleLength % cycleLenght != 0)<br>                continue;<br>            int i;<br>            for(i=result.Length-cycleLenght-1;i&gt;=0;i--)<br>                if(result[i] != result[i+cycleLenght])<br>                    break;<br>            if(i&gt;=result.Length-bigCycleLength)<br>                continue;<br>            <br>            StringBuilder res = new StringBuilder();<br>            i++;<br>            for (int j = 0; j &lt; i; j++)<br>                res.Append(result[j]);<br>            res.Append('(');<br>            for (int j = 0; j &lt; cycleLenght; j++)<br>                res.Append(result[i+j]);<br>            res.Append(')');<br>            return res.ToString();<br>        }<br>        throw new Exception("Cannot happen!");<br>    }<br><br>    private bool have_edge(int j, int i)<br>    {<br>        return _arcs[j][i] == 'Y';<br>    }<br>}<br></td>