<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class TransformMatrix {<br>    const int INF = 12;<br>    const int INF_D = 1000000;<br><br>    public int transform(string[] A, string[] B, string[] count) {<br>        List&lt;int&gt; Xs = new List&lt;int&gt;();<br>        List&lt;int&gt; Ys = new List&lt;int&gt;();<br>        List&lt;int&gt; Xt = new List&lt;int&gt;();<br>        List&lt;int&gt; Yt = new List&lt;int&gt;();<br>        int h = A.Length;<br>        int w = A[0].Length;<br>        for (int i = 0; i &lt; h; ++i)<br>            for (int j = 0; j &lt; w; ++j)<br>                if (A[i][j] != B[i][j]) {<br>                    if (A[i][j] == '1') {<br>                        Xs.Add(i);<br>                        Ys.Add(j);<br>                    } else {<br>                        Xt.Add(i);<br>                        Yt.Add(j);<br>                    }<br>                }<br>        if (Xs.Count != Xt.Count)<br>            return -1;<br>        int n = h * w * 2 + 2;<br>        int[,] cap = new int[n, n];<br>        int[,] cost = new int[n, n];<br>        for (int i = 0; i &lt; h; ++i)<br>            for (int j = 0; j &lt; w; ++j)<br>            {<br>                cap[(i * w + j) * 2 + 1, (i * w + j) * 2] = count[i][j] - '0';<br>                if (A[i][j] != B[i][j])<br>                    --cap[(i * w + j) * 2 + 1, (i * w + j) * 2];<br>                if (cap[(i * w + j) * 2 + 1, (i * w + j) * 2] &lt; 0)<br>                    return -1;<br>                cap[(i * w + j) * 2 + 1, (i * w + j) * 2] /= 2;<br>                cost[(i * w + j) * 2 + 1, (i * w + j) * 2] = 1;<br>                cost[(i * w + j) * 2, (i * w + j) * 2 + 1] = -1;<br>                for (int ii = 0; ii &lt; h; ++ii)<br>                    for (int jj = 0; jj &lt; w; ++jj)<br>                        if (Math.Abs(i - ii) &lt;= 1 &amp;&amp; Math.Abs(j - jj) &lt;= 1)<br>                            cap[(i * w + j) * 2, (ii * w + jj) * 2 + 1] = INF;<br>            }<br>        for (int k = 0; k &lt; Xs.Count; ++k)<br>        {<br>            cap[n - 2, (Xs[k] * w + Ys[k]) * 2] = 1;<br>            cap[(Xt[k] * w + Yt[k]) * 2 + 1, n - 1] = 1;<br>        }<br>        int flow;<br>        int flowCost;<br>        minCostFlow(n, n - 2, n - 1, cap, cost, out flow, out flowCost);<br>        if (flow == Xs.Count)<br>            return flowCost + Xs.Count;<br>        else<br>            return -1;<br>    }<br><br>    private void minCostFlow(int n, int s, int t, int[,] cap, int[,] cost, out int flow, out int flowCost)<br>    {<br>        flow = 0;<br>        flowCost = 0;<br>        int[] mu = new int[n];<br>        while (true)<br>        {<br>            int[] d = new int[n];<br>            for (int i = 0; i &lt; n; ++i)<br>                d[i] = INF_D;<br>            bool[] got = new bool[n];<br>            d[s] = 0;<br>            int[] p = new int[n];<br>            int last = 0;<br>            while (true)<br>            {<br>                int bi = -1;<br>                int best = INF_D;<br>                for (int i = 0; i &lt; n; ++i)<br>                    if (!got[i] &amp;&amp; d[i] &lt; best)<br>                    {<br>                        best = d[i];<br>                        bi = i;<br>                    }<br>                if (bi &lt; 0)<br>                    break;<br>                last = best;<br>                got[bi] = true;<br>                for (int i = 0; i &lt; n; ++i)<br>                    if (cap[bi, i] &gt; 0)<br>                    {<br>                        int nd = d[bi] + cost[bi, i] + mu[bi] - mu[i];<br>                        if (nd &lt; d[i])<br>                        {<br>                            d[i] = nd;<br>                            p[i] = bi;<br>                        }<br>                    }<br>            }<br>            if (d[t] &gt;= INF_D)<br>                break;<br>            ++flow;<br>            flowCost += d[t] - mu[s] + mu[t];<br>            int a = t;<br>            while (a != s)<br>            {<br>                --cap[p[a], a];<br>                ++cap[a, p[a]];<br>                a = p[a];<br>            }<br>            for (int i = 0; i &lt; n; ++i)<br>                if (d[i] &lt; INF_D)<br>                    mu[i] += d[i];<br>                else<br>                    mu[i] += last;<br>        }<br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>