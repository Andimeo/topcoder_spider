<td class="problemText" colspan="8" valign="middle" align="left">
            #include "assert.h"<br>#include "ctype.h"<br>#include "float.h"<br>#include "math.h"<br>#include "stdio.h"<br>#include "string.h"<br>#include "stdlib.h"<br>#include "stdarg.h"<br>#include "time.h"<br>#include "algorithm"<br>#include "numeric"<br>#include "functional"<br>#include "utility"<br>#include "bitset"<br>#include "vector"<br>#include "list"<br>#include "set"<br>#include "map"<br>#include "queue"<br>#include "stack"<br>#include "string"<br>#include "sstream"<br>#include "iostream"<br>using namespace std;<br><br>#define all(v) (v).begin(), (v).end()<br>typedef long long i64;<br>template &lt;class T&gt; void make_unique(T&amp; v) {sort(all(v)); v.resize(unique(all(v)) - v.begin());}<br><br>const int INFINITE = 100000;<br>struct edge_t {<br>  edge_t(int src_, int dest_, int rev_, int capacity_, int cost_) :<br>    src(src_), dest(dest_), rev(rev_), capacity(capacity_), cost(cost_), flow(0) {}<br>  int src, dest, rev, capacity, cost, flow;<br>};<br>typedef vector&lt;edge_t&gt; node_t;<br>struct graph_t {<br>  static const int MAX_N = 1300;<br>  node_t V[MAX_N]; int N;<br>};<br>struct path_t {<br>  vector&lt;edge_t*&gt; edges;<br>  int flow, cost;<br>};<br><br>void AddDirectedEdge(graph_t&amp; graph, int src, int dest, int capacity, int cost) {<br>  const edge_t edge1(src, dest, (int)graph.V[dest].size(), capacity, cost);<br>  const edge_t edge2(dest, src, (int)graph.V[src].size(), 0, -cost);<br>  graph.V[src].push_back(edge1); graph.V[dest].push_back(edge2);<br>}<br><br>void BellmannFord(graph_t&amp; graph, vector&lt;edge_t*&gt;&amp; tree, vector&lt;int&gt;&amp; distance, int src) {<br>  queue&lt;int&gt; active; active.push(src); active.push(graph.N);<br>  vector&lt;bool&gt; mark(graph.N, false); mark[src] = true;<br>  tree[src] = NULL; distance[src] = 0;<br>  for (int pass = 0; pass &lt; graph.N &amp;&amp; !active.empty();) {<br>    const int node = active.front(); active.pop();<br>    if (node == graph.N &amp;&amp; ++pass &lt; graph.N) {<br>      active.push(graph.N);<br>    } else if (node &lt; graph.N) {<br>      mark[node] = false;<br>      for (int j = 0, N = (int)graph.V[node].size(); j &lt; N; ++j) {<br>        edge_t* const edge = &amp;graph.V[node][j]; if (edge-&gt;capacity &lt;= 0) continue;<br>        const int newDistance = distance[node] + edge-&gt;cost;<br>        if (newDistance &lt; distance[edge-&gt;dest]) {<br>          tree[edge-&gt;dest] = edge, distance[edge-&gt;dest] = newDistance;<br>          if (!mark[edge-&gt;dest]) active.push(edge-&gt;dest), mark[edge-&gt;dest] = true;<br>        }<br>      }<br>    }<br>  }<br>}<br><br>void Disjktra(graph_t&amp; graph, vector&lt;edge_t*&gt;&amp; tree, vector&lt;int&gt;&amp; distance,<br>              const vector&lt;int&gt;&amp; potential, int src) {<br>  typedef pair&lt;int, pair&lt;int, edge_t*&gt; &gt; state_t;  // (distance, (node, parent))<br>  priority_queue&lt;state_t, vector&lt;state_t&gt;, greater&lt;state_t&gt; &gt; pqueue;<br>  pqueue.push(state_t(0, make_pair(src, (edge_t*)NULL)));<br>  while (!pqueue.empty()) {<br>    const int nextDistance = pqueue.top().first, node = pqueue.top().second.first;<br>    edge_t* const pred = pqueue.top().second.second; pqueue.pop();<br>    if (nextDistance &gt;= distance[node]) continue;<br>    distance[node] = nextDistance, tree[node] = pred;<br>    for (int k = 0, N = (int)graph.V[node].size(); k &lt; N; ++k) {<br>      edge_t* const edge = &amp;graph.V[node][k]; if (edge-&gt;capacity &lt;= 0) continue;<br>      const int newDistance = nextDistance + edge-&gt;cost + potential[edge-&gt;dest] - potential[node];<br>      if (newDistance &lt; distance[edge-&gt;dest])<br>        pqueue.push(state_t(newDistance, make_pair(edge-&gt;dest, edge)));<br>    }<br>  }<br>}<br><br>bool GetPath(const vector&lt;edge_t*&gt;&amp; parent, path_t&amp; path, int src, int dest) {<br>  path.edges.clear(); path.flow = INFINITE, path.cost = 0;<br>  while (src != dest) {<br>    if (parent[dest] == NULL) return false;<br>    path.edges.push_back(parent[dest]);<br>    path.flow = min(path.flow, parent[dest]-&gt;capacity);<br>    path.cost += parent[dest]-&gt;cost;<br>    dest = parent[dest]-&gt;src;<br>  }<br>  return true;<br>}<br><br>void AddFlow(edge_t&amp; edge, int flow) {<br>  edge.capacity -= flow;<br>  edge.flow += flow;<br>}<br><br>void Augment(graph_t&amp; graph, path_t&amp; path) {<br>  for (int k = 0, N = (int)path.edges.size(); k &lt; N; k++) {<br>    edge_t&amp; edge = *path.edges[k]; AddFlow(edge, +path.flow);<br>    AddFlow(graph.V[edge.dest][edge.rev], -path.flow);<br>  }<br>}<br><br>pair&lt;int, int&gt; MinCostMaxFlow(graph_t&amp; graph, int src, int dest) {<br>  vector&lt;edge_t*&gt; tree(graph.N, (edge_t*)NULL);<br>  vector&lt;int&gt; potential(graph.N, 0), distance(graph.N, INFINITE);<br>  BellmannFord(graph, tree, distance, src);<br>  for (int k = 0; k &lt; graph.N; ++k) potential[k] = -distance[k];<br>  int networkFlow = 0, flowCost = 0;<br>  for (path_t path; GetPath(tree, path, src, dest);) {<br>    networkFlow += path.flow, flowCost += path.cost * path.flow; Augment(graph, path);<br>    for (int k = 0; k &lt; graph.N; ++k) tree[k] = NULL, distance[k] = INFINITE;<br>    Disjktra(graph, tree, distance, potential, src);<br>    for (int k = 0; k &lt; graph.N; ++k) potential[k] -= distance[k];<br>  }<br>  return make_pair(networkFlow, flowCost);<br>}<br><br>struct TransformMatrix {<br>  enum {IN = 0, MID = 1, OUT = 2};<br>  int m, n;<br><br>  int node(int i, int j, int type) {<br>    return (i * n + j) * 3 + type;<br>  }<br><br>  int ones(const vector&lt;string&gt;&amp; A) {<br>    int cnt = 0;<br>    for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j)<br>      if (A[i][j] == '1') ++cnt;<br>    return cnt;<br>  }<br><br>  int transform(vector&lt;string&gt; A, vector&lt;string&gt; B, vector&lt;string&gt; count) {<br>    m = (int)A.size(), n = (int)A[0].size();<br>    const int o1 = ones(A), o2 = ones(B);<br>    if (o1 != o2) return -1;<br>    graph_t graph; graph.N = m * n * 3 + 2;<br>    const int src = m * n * 3, sink = src + 1;<br>    for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j) {<br>      const int cnt = count[i][j] - '0';<br>      const int outRem = A[i][j] == '1' ? cnt % 2 : 0;<br>      const int inRem = outRem == 0 &amp;&amp; B[i][j] == '1' ? cnt % 2 : 0;<br>      AddDirectedEdge(graph, node(i, j, IN), node(i, j, MID), cnt / 2 + inRem, 1);<br>      AddDirectedEdge(graph, node(i, j, MID), node(i, j, OUT), cnt / 2 + outRem, 1);<br>      const int di[] = {-1, -1, -1, 0, 0, +1, +1, +1};<br>      const int dj[] = {-1, 0, +1, -1, +1, -1, 0, +1};<br>      for (int k = 0; k &lt; 8; ++k) {<br>        const int ni = i + di[k], nj = j + dj[k];<br>        if (ni &gt;= 0 &amp;&amp; ni &lt; m &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; n)<br>          AddDirectedEdge(graph, node(i, j, OUT), node(ni, nj, IN), INFINITE, 0);<br>      }<br>      if (A[i][j] == '1') AddDirectedEdge(graph, src, node(i, j, MID), 1, 0);<br>      if (B[i][j] == '1') AddDirectedEdge(graph, node(i, j, MID), sink, 1, 0);<br>    }<br>    const pair&lt;int, int&gt; flow = MinCostMaxFlow(graph, src, sink);<br>    if (flow.first != o1) return -1;<br>    return flow.second / 2;<br>  }<br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.11 [modified TZTester]<br>// Powered by CodeProcessor<br></td>