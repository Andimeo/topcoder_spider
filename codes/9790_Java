<td class="problemText" colspan="8" valign="middle" align="left">
            import java.util.*;<br><br>public class TransformMatrix {<br>  final int INF = Integer.MAX_VALUE &gt;&gt; 1;<br>  class Edge {<br>    int u, v, f, c, cost;<br>    Edge sm;<br>    public Edge(int u, int v, int c, int cost) {<br>      super();<br>      this.u = u;<br>      this.v = v;<br>      this.c = c;<br>      this.cost = cost;<br>      f = 0;<br>    }<br>  }<br>  <br>  void addEdge(int u, int v, int cap, int cost) {<br>    Edge forw = new Edge(u, v, cap, cost);<br>    Edge backw = new Edge(v, u, 0, -cost);<br>    forw.sm = backw;<br>    backw.sm = forw;<br>    g[u].add(forw);<br>    g[v].add(backw);<br>  }<br>  <br>  int[][] a, b, cnt;<br>  int n, m;<br>  <br>  int[] d;<br>  Edge[] pr;<br>  List&lt;Edge&gt;[] g;<br>  <br>  boolean inMap(int y, int x) {<br>    return 0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n;<br>  }<br>  <br>  public int transform(String[] A, String[] B, String[] count) {<br>    n = A.length;<br>    m = A[0].length();<br>    a = trans(A);<br>    b = trans(B);<br>    cnt = trans(count);<br>    if (getCountZero(a) != getCountZero(b)) return -1;<br>    g = new List[n * m * 2 + 2];<br>    for(int i = 0; i &lt; g.length; ++i)<br>      g[i] = new ArrayList&lt;Edge&gt;();<br>    int need = 0;<br>    for(int i = 0; i &lt; n; ++i)<br>      for(int j = 0; j &lt; m; ++j) {<br>        if (a[i][j] != b[i][j]) {<br>          if (cnt[i][j] == 0) return -1;<br>          ++need;<br>          --cnt[i][j];<br>          if (a[i][j] == 0) addEdge(0, out(i, j), 1, 0);<br>          else addEdge(in(i, j), n * m * 2 + 1, 1, 0);<br>        }<br>        addEdge(in(i, j), out(i, j), cnt[i][j] &gt;&gt; 1, 1);<br>        for(int dx = -1; dx &lt;= 1; ++dx)<br>          for(int dy = -1; dy &lt;= 1; ++dy)<br>            if (dx != 0 || dy != 0)<br>              if (inMap(i + dy, j + dx))<br>                addEdge(out(i, j), in(i + dy, j + dx), INF, 0);<br>      }<br>    need &gt;&gt;= 1;<br>    int ans = need;<br>    d = new int[2 * n * m + 2];<br>    pr = new Edge[2 * n * m + 2];<br>    for(int i = 0; i &lt; need; ++i) {<br>      int t = FB();<br>      if (t == INF) return -1;<br>      ans += t;<br>    }<br>    return ans;<br>  }<br>  private int in(int i, int j) {<br>    return 2 * (i * m + j + 1) - 1;<br>  }<br><br>  private int out(int i, int j) {<br>    return 2 * (i * m + j + 1);<br>  }<br><br>  private int FB() {<br>    Arrays.fill(d, INF);<br>    d[0] = 0;<br>    boolean was = true;<br>    while (was) {<br>      was = false;<br>      for(int i = 0; i &lt; 2 * n * m + 2; ++i)<br>        if (d[i] &lt; INF)<br>          for(Edge e: g[i])<br>            if (e.f &lt; e.c &amp;&amp; d[e.v] &gt; d[i] + e.cost) {<br>              pr[e.v] = e;<br>              d[e.v] = d[i] + e.cost;<br>              was = true;<br>            }<br>    }<br>    int v = 2 * n * m + 1;<br>    if (d[v] == INF) return INF;<br>    while (v != 0) {<br>      ++pr[v].f;<br>      --pr[v].sm.f;<br>      v = pr[v].u;<br>    }<br>    return d[2 * n * m + 1];<br>  }<br><br>  private int getCountZero(int[][] a) {<br>    int ans = 0;<br>    for(int i = 0; i &lt; n; ++i)<br>      for(int j = 0; j &lt; m; ++j)<br>        if (a[i][j] == 0) ++ans;<br>    return ans;<br>  }<br>  private int[][] trans(String[] sa) {<br>    int[][] res = new int[n][m];<br>    for(int i = 0; i &lt; n; ++i)<br>      for(int j = 0; j &lt; m; ++j)<br>        res[i][j] = sa[i].charAt(j) - '0';<br>    return res;<br>  }<br>}<br></td>