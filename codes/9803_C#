<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br>using System.Text;<br><br>public class LockedDoors {<br>  private struct Pos {<br>    public int x, y, k, dist;<br>    public Pos(int x, int y, int k, int d) {<br>      this.x = x;<br>      this.y = y;<br>      this.k = k;<br>      dist = d;<br>    }<br>    public bool HasKey(int n) {<br>      return (k &amp; (1 &lt;&lt; n)) &gt; 0;<br>    }<br>    public void SetKey(int n) {<br>      k |= (1 &lt;&lt; n);<br>    }<br>    /*public override int GetHashCode() {<br>      return x ^ y ^ k;<br>    }<br>    public override bool Equals(object o) {<br>      Pos p = o as Pos;<br>      if (p != null) {<br>        return x == p.x &amp;&amp; y == p.y &amp;&amp; k == p.k;<br>      } else<br>        return false;<br>    }*/<br>  }<br>  int h;<br>  int w;<br>  bool[,] passable;<br>  byte[,] keyGet;<br>  byte[,] keyNeeded;<br>  bool[,] isExit;<br>  const int Inf = int.MaxValue / 2;<br>  int bestDist = Inf;<br>  bool[, ,] enqd;<br>  Queue&lt;Pos&gt; queue = new Queue&lt;Pos&gt;();<br>  public int pathOutside(string[] maze) {<br>    h = maze.Length;<br>    w = maze[0].Length;<br>    passable = new bool[w, h];<br>    keyGet = new byte[w, h];<br>    keyNeeded = new byte[w, h];<br>    isExit = new bool[w, h];<br>    enqd = new bool[w, h, 64];<br>    int startX = -1, startY = -1;<br>    for (int y = 0; y &lt; h; y++) {<br>      for (int x = 0; x &lt; w; x++) {<br>        char c = maze[y][x];<br>        if (c == '.') {<br>          passable[x, y] = true;<br>          keyGet[x, y] = 100;<br>          keyNeeded[x, y] = 100;<br>          isExit[x, y] = false;<br>        } else if (c == '#') {<br>          passable[x, y] = false;<br>          keyGet[x, y] = 100;<br>          keyNeeded[x, y] = 100;<br>          isExit[x, y] = false;<br>        } else if (c == '0') {<br>          startX = x;<br>          startY = y;<br>          passable[x, y] = true;<br>          keyGet[x, y] = 100;<br>          keyNeeded[x, y] = 100;<br>          isExit[x, y] = false;<br>        } else if (c == '1') {<br>          passable[x, y] = true;<br>          keyGet[x, y] = 100;<br>          keyNeeded[x, y] = 100;<br>          isExit[x, y] = true;<br>        } else if ('a' &lt;= c &amp;&amp; c &lt;= 'f') {<br>          passable[x, y] = true;<br>          keyGet[x, y] = ( byte )(c - 'a');<br>          keyNeeded[x, y] = 100;<br>          isExit[x, y] = false;<br>        } else if ('A' &lt;= c &amp;&amp; c &lt;= 'F') {<br>          passable[x, y] = true;<br>          keyGet[x, y] = 100;<br>          keyNeeded[x, y] = ( byte )(c - 'A');<br>          isExit[x, y] = false;<br>        }<br>      }<br>    }<br>    queue.Enqueue(new Pos(startX, startY, 0, 0));<br>    while (queue.Count &gt; 0) {<br>      Pos p = queue.Dequeue();<br>      TryEnqueue(new Pos(p.x, p.y + 1, p.k, p.dist+1));<br>      TryEnqueue(new Pos(p.x, p.y - 1, p.k, p.dist+1));<br>      TryEnqueue(new Pos(p.x + 1, p.y, p.k, p.dist+1));<br>      TryEnqueue(new Pos(p.x - 1, p.y, p.k, p.dist+1));<br>    }<br>    return bestDist == Inf ? -1 : bestDist;<br>  }<br>  private void TryEnqueue(Pos p) {<br>    if (0 &lt;= p.x &amp;&amp; p.x &lt; w &amp;&amp; 0 &lt;= p.y &amp;&amp; p.y &lt; h &amp;&amp; passable[p.x, p.y]) {<br>      byte key = keyGet[p.x, p.y];<br>      if (key != 100) {<br>        p.SetKey(key);<br>      }<br>      if (!enqd[p.x, p.y, p.k]) {<br>        byte nKey = keyNeeded[p.x, p.y];<br>        if (nKey == 100 || p.HasKey(nKey)) {<br>          if (isExit[p.x, p.y]) {<br>            bestDist = Math.Min(bestDist, p.dist);<br>          }<br>          queue.Enqueue(p);<br>          enqd[p.x, p.y, p.k] = true;<br>        }<br>      }<br>    }<br>  }<br>}<br></td>