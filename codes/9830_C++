<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br> <br>using namespace std;<br> <br>typedef long long int64;<br>typedef long double ldb;<br>typedef pair&lt;int, int&gt; pii;<br>typedef vector&lt;string&gt; vecst;<br>typedef vector&lt;int&gt; vecint;<br> <br>#define sz(C) (int((C).size()))<br>#define sh(C) cerr &lt;&lt; #C &lt;&lt; ": " &lt;&lt; (C) &lt;&lt; endl<br> <br>class TeleportsNetwork {<br>public:<br>  int distribute(int, vector &lt;int&gt;, vector &lt;int&gt;);<br>};<br> <br>int incov();<br> <br>const int maxN = 55;<br>const int maxTC = 10;<br>const double inf = 1e9;<br>const double eps = 1e-7;<br>vector&lt;int&gt; G[maxN];<br> <br>int used[maxTC];<br>int dist[maxN][maxN];<br>int n, tc, bestIncov = 1000000000;<br> <br>void compDist() {<br>  for (int i = 0; i &lt; n; ++i) { <br>    for (int j = 0; j &lt; n; ++j)<br>      dist[i][j] = 1000000000;<br>    dist[i][i] = 0;<br>    for (int j = 0; j &lt; sz(G[i]); ++j)<br>      dist[i][G[i][j]] = 1;<br>  }<br>  for (int k = 0; k &lt; n; ++k)<br>    for (int i = 0; i &lt; n; ++i)<br>      for (int j = 0; j &lt; n; ++j)<br>        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);<br>}<br> <br>void bt(int pos, int from) {<br>  if (pos == tc) {<br>    int inc = incov();<br>    if (inc &lt; bestIncov) {<br>//      cerr &lt;&lt; "used: ";<br>//      for (int i = 0; i &lt; tc; ++i)<br>//        cerr &lt;&lt; used[i] &lt;&lt; ' ';<br>//      cerr &lt;&lt; endl;<br>      bestIncov = inc;<br>    }<br>    return;<br>  }<br>  for (int i = from; i &lt; n; ++i) {<br>    used[pos] = i;<br>    bt(pos+1,i+1);<br>  }<br>}<br> <br>int incov() {<br>  int ret = 0;<br>  for (int i = 0; i &lt; n; ++i) {<br>    int thinc = dist[i][0];<br>    for (int j = 0; j &lt; tc; ++j) {<br>      assert(used[j] &gt;= 0 &amp;&amp; used[j] &lt; n);<br>      if (dist[i][used[j]] &lt; thinc)<br>        thinc = dist[i][used[j]];<br>    }<br>//    cerr &lt;&lt; "ret(" &lt;&lt; i &lt;&lt; "): " &lt;&lt; thinc &lt;&lt; endl;<br>    ret = max(ret, thinc);<br>  }<br>  return ret;<br>}<br> <br>vector&lt;int&gt; cx, cy;<br> <br>double eucdist(int i, int j) {<br>  double dx = cx[j]-cx[i], dy = cy[j]-cy[i];<br>  return sqrt(dx*dx+dy*dy);<br>}<br> <br>int TeleportsNetwork::distribute(int telCount, vector &lt;int&gt; citx, vector &lt;int&gt; city) {<br>  bestIncov = 100000000;<br>  cx = citx;<br>  cy = city;<br>  tc = telCount;<br>  n = cx.size();<br>  for (int i = 0; i &lt; n; ++i)<br>    G[i].clear();<br>  for (int i = 1; i &lt; n; ++i) {<br>    double bestDist = inf;<br>    int best;<br>    for (int j = 0; j &lt; n; ++j) {<br>      if (eucdist(j,0)+eps&gt;eucdist(i,0))<br>        continue;<br>      double d = eucdist(i,j);<br>      if (abs(bestDist-d) &lt; eps) {<br>        if (cx[j] &lt; cx[best] || (cx[j]==cx[best] &amp;&amp; cy[j] &lt; cy[best]))<br>          best = j;<br>      } else if (d &lt; bestDist) {<br>        bestDist = d;<br>        best = j;<br>      }<br>    }<br>    G[i].push_back(best);<br>    G[best].push_back(i);<br>//    cerr &lt;&lt; "edge: " &lt;&lt; i &lt;&lt; ' ' &lt;&lt; best &lt;&lt; endl;<br>  }<br>  <br>  compDist();<br>//  for (int i = 0; i &lt; n; ++i)<br>//    for (int j = 0; j &lt; n; ++j) {<br>//      cerr &lt;&lt; "dist(" &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; ": " &lt;&lt; dist[i][j] &lt;&lt; endl;<br>//    }<br>  <br>  bt(0,1);<br>  return bestIncov;<br>}<br> <br> <br>//Powered by [KawigiEdit] 2.0!<br> <br>//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!<br></td>