<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class RoadsOfKingdom {<br>    public double getProbability(string[] roads)<br>    {<br>        int n = roads.Length;<br>        int[] comp = new int[n];<br>        int ncomp = 0;<br>        for (int i = 0; i &lt; n; ++i)<br>        {<br>            if (comp[i] == 0)<br>            {<br>                ++ncomp;<br>                if (dfs(roads, n, i, -1, ncomp, comp))<br>                {<br>                    return 0.0;<br>                }<br>            }<br>        }<br>        double res = 1.0;<br>        double[,] pe = new double[ncomp, ncomp];<br>        double[,] pne = new double[ncomp, ncomp];<br>        for (int ca = 0; ca &lt; ncomp; ++ca)<br>            for (int cb = 0; cb &lt; ncomp; ++cb)<br>                if (ca != cb)<br>                {<br>                    List&lt;double&gt; w = new List&lt;double&gt;();<br>                    for (int a = 0; a &lt; n; ++a)<br>                        if (comp[a] == ca + 1)<br>                            for (int b = 0; b &lt; n; ++b)<br>                                if (comp[b] == cb + 1)<br>                                {<br>                                    w.Add((roads[a][b] - '0') / 8.0);<br>                                }<br>                    double pnw = 1.0;<br>                    foreach (double x in w)<br>                        pnw = pnw * (1 - x);<br>                    pne[ca, cb] = pnw;<br>                    foreach (double x in w)<br>                    {<br>                        pe[ca, cb] += x / (1 - x) * pnw;<br>                    }<br>                    if (ca &lt; cb)<br>                        res *= pnw;<br>                }<br>                else<br>                {<br>                    for (int a = 0; a &lt; n; ++a)<br>                        if (comp[a] == ca + 1)<br>                            for (int b = a + 1; b &lt; n; ++b)<br>                                if (comp[b] == cb + 1)<br>                                    if (roads[a][b] != '8')<br>                                        res *= (1.0 - (roads[a][b] - '0') / 8.0);<br>                }<br>        double[,] m = new double[ncomp, ncomp];<br>        for (int i = 0; i &lt; ncomp; ++i)<br>            for (int j = 0; j &lt; ncomp; ++j)<br>                if (i != j)<br>                {<br>                    m[i, j] = -pe[i, j] / pne[i, j];<br>                    m[i, i] -= m[i, j];<br>                }<br>        return res * det(m, ncomp - 1);<br>  }<br><br>    private double det(double[,] m, int n)<br>    {<br>        double res = 1.0;<br>        bool[] u = new bool[n];<br>        for (int i = 0; i &lt; n; ++i) {<br>            int j;<br>            for (j = 0; j &lt; n; ++j)<br>                if (!u[j] &amp;&amp; Math.Abs(m[j, i]) &gt; 1e-10)<br>                    break;<br>            if (j &gt;= n)<br>                return 0.0;<br>            res *= m[j, i];<br>            u[j] = true;<br>            double z = 1 / m[j, i];<br>            for (int k = 0; k &lt; n; ++k)<br>                m[j, k] *= z;<br>            for (int l = 0; l &lt; n; ++l) if (l != j)<br>                {<br>                    z = -m[l, i];<br>                    for (int k = 0; k &lt; n; ++k)<br>                        m[l, k] = m[l, k] + z * m[j, k];<br>                }<br>        }<br>        return res;<br>    }<br><br>    private bool dfs(string[] roads, int n, int a, int b, int ncomp, int[] comp)<br>    {<br>        if (comp[a] != 0)<br>            return true;<br>        comp[a] = ncomp;<br>        for (int i = 0; i &lt; n; ++i)<br>            if (i != b &amp;&amp; roads[a][i] == '8')<br>            {<br>                if (dfs(roads, n, i, a, ncomp, comp))<br>                    return true;<br>            }<br>        return false;<br>    }<br><br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>