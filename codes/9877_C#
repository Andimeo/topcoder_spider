<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class AlienDictionary {<br>    class Trie<br>    {<br>        public Trie[] children = new Trie[2];<br>        public Trie[] jump = new Trie[2];<br>        public Trie parent;<br>        public Trie sufLink;<br>        public int id;<br>        public int level = 0;<br>    }<br><br>    List&lt;Trie&gt;[] byLevel;<br><br>    public string[] getWords(int wordLength, string[] forbiddenSubstrings, int[] wordNumbers) {<br>        int len = 0;<br>        if (forbiddenSubstrings.Length &gt; 0)<br>            len = forbiddenSubstrings[0].Length;<br>        byLevel = new List&lt;Trie&gt;[len + 1];<br>        for (int i = 0; i &lt;= len; ++i)<br>            byLevel[i] = new List&lt;Trie&gt;();<br>        Trie root = new Trie();<br>        int total = 0;<br>        root.id = total++;<br>        byLevel[0].Add(root);<br>        bool[] bad = new bool[1 &lt;&lt; len];<br>        foreach (string x in forbiddenSubstrings)<br>        {<br>            int mask = 0;<br>            int cur = 0;<br>            for (int i = 0; i &lt; x.Length; ++i)<br>            {<br>                switch (x[i])<br>                {<br>                    case 'A':<br>                        break;<br>                    case 'B':<br>                        cur |= (1 &lt;&lt; i);<br>                        break;<br>                    case '?':<br>                        mask |= (1 &lt;&lt; i);<br>                        break;<br>                    default:<br>                        throw new Exception();<br>                }<br>            }<br>            for (int z = mask; true; z = (z - 1) &amp; mask)<br>            {<br>                bad[z | cur] = true;<br>                if (z == 0)<br>                    break;<br>            }<br>        }<br>        Trie evil = new Trie();<br>        evil.id = total++;<br>        for (int i = 0; i &lt; bad.Length; ++i)<br>        {<br>            if (bad[i])<br>            {<br>                Trie cur = root;<br>                for (int j = 0; j &lt; len - 1; ++j)<br>                {<br>                    int ch = (i &gt;&gt; j) &amp; 1;<br>                    if (cur.children[ch] == null)<br>                    {<br>                        cur.children[ch] = new Trie();<br>                        cur.children[ch].level = j + 1;<br>                        cur.children[ch].parent = cur;<br>                        cur.children[ch].id = total++;<br>                        byLevel[j + 1].Add(cur.children[ch]);<br>                    }<br>                    cur = cur.children[ch];<br>                }<br>                cur.children[(i &gt;&gt; (len - 1)) &amp; 1] = evil;<br>            }<br>        }<br>        for (int level = 1; level &lt; Math.Max(len, 1); ++level)<br>        {<br>            foreach (Trie x in byLevel[level])<br>            {<br>                Trie y = x.parent;<br>                int ch = y.children[0] == x ? 0 : 1;<br>                if (y.sufLink == null)<br>                    x.sufLink = y;<br>                else<br>                {<br>                    y = y.sufLink;<br>                    while (true)<br>                    {<br>                        if (y.children[ch] != null)<br>                        {<br>                            x.sufLink = y.children[ch];<br>                            break;<br>                        }<br>                        if (y.sufLink == null)<br>                        {<br>                            x.sufLink = y;<br>                            break;<br>                        }<br>                        y = y.sufLink;<br>                    }<br>                }<br>            }<br>        }<br>        int[,] am = new int[wordLength + 1, total];<br>        for (int level = 0; level &lt; Math.Max(len, 1); ++level)<br>        {<br>            foreach (Trie x in byLevel[level])<br>            {<br>                am[0, x.id] = 1;<br>                for (int ch = 0; ch &lt; 2; ++ch)<br>                {<br>                    Trie y = x;<br>                    while (true)<br>                    {<br>                        if (y.children[ch] != null)<br>                        {<br>                            x.jump[ch] = y.children[ch];<br>                            break;<br>                        }<br>                        if (y.sufLink == null)<br>                        {<br>                            x.jump[ch] = y;<br>                            break;<br>                        }<br>                        y = y.sufLink;<br>                    }<br>                }<br>            }<br>        }<br>        for (int k = 1; k &lt;= wordLength; ++k)<br>        {<br>            for (int level = 0; level &lt; Math.Max(1, len); ++level)<br>            {<br>                foreach (Trie x in byLevel[level])<br>                {<br>                    am[k, x.id] = am[k - 1, x.jump[0].id] + am[k - 1, x.jump[1].id];<br>                    if (am[k, x.id] &gt; 1000000001)<br>                        am[k, x.id] = 1000000001;<br>                }<br>            }<br>        }<br>        Console.WriteLine(total);<br>        string[] res = new string[wordNumbers.Length];<br>        for (int z = 0; z &lt; wordNumbers.Length; ++z)<br>        {<br>            int left = wordNumbers[z];<br>            if (left &gt;= am[wordLength, root.id])<br>                res[z] = "NO PAGE";<br>            else<br>            {<br>                res[z] = "";<br>                Trie cur = root;<br>                for (int i = 0; i &lt; wordLength; ++i)<br>                {<br>                    if (am[wordLength - i - 1, cur.jump[0].id] &lt;= left)<br>                    {<br>                        left -= am[wordLength - 1 - i, cur.jump[0].id];<br>                        cur = cur.jump[1];<br>                        res[z] += "B";<br>                    }<br>                    else<br>                    {<br>                        res[z] += "A";<br>                        cur = cur.jump[0];<br>                    }<br>                }<br>            }<br>        }<br>        return res;<br>    }<br><br>   <br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>