<td class="problemText" colspan="8" valign="middle" align="left">
            using System;<br>using System.Collections.Generic;<br><br>public class StampsCollection {<br>  public int sell(int n, string[] demand, int[] price) {<br>        int[,] e = new int[demand.Length, 2];<br>        int[] cover = new int[n];<br>        for (int i = 0; i &lt; demand.Length; ++i)<br>        {<br>            string[] p = demand[i].Split(' ');<br>            e[i, 0] = int.Parse(p[0]);<br>            ++cover[e[i, 0]];<br>            if (p.Length &gt; 1)<br>            {<br>                e[i, 1] = int.Parse(p[1]);<br>                ++cover[e[i, 1]];<br>            } <br>            else<br>                e[i, 1] = -1;<br>        }<br>        bool[] used = new bool[demand.Length];<br>        int res = 0;<br><br>        for (int i = 0; i &lt; n; ++i)<br>            if (cover[i] == 1)<br>            {<br>                process(used, e, cover, price, i, ref res);<br>            }<br><br>        for (int i = 0; i &lt; demand.Length; ++i)<br>            if (e[i, 1] == -1 &amp;&amp; !used[i])<br>                process(used, e, cover, price, e[i, 0], ref res);<br><br>        for (int i = 0; i &lt; n; ++i)<br>            if (cover[i] &gt; 0)<br>            {<br>                if (cover[i] != 2)<br>                    throw new Exception();<br>                process(used, e, cover, price, i, ref res);<br>            }<br><br>        return res;<br>  }<br><br>    private void process(bool[] used, int[,] e, int[] cover, int[] price, int start, ref int res)<br>    {<br>        List&lt;int&gt; seq = new List&lt;int&gt;();<br>        int last = -1;<br>        int cur = start;<br>        for (int i = 0; i &lt; used.Length; ++i)<br>            if (!used[i] &amp;&amp; (e[i, 0] == cur &amp;&amp; e[i, 1] == -1))<br>            {<br>                used[i] = true;<br>                --cover[e[i, 0]];<br>                if (e[i, 1] &gt;= 0)<br>                    --cover[e[i, 1]];<br>                seq.Add(price[i]);<br>                last = i;<br>                break;<br>            }<br>        while (cur &gt;= 0)<br>        {<br>            bool found = false;<br>            if (found)<br>                continue;<br>            for (int i = 0; i &lt; used.Length; ++i)<br>                if (!used[i] &amp;&amp; (e[i, 0] == cur || e[i, 1] == cur))<br>                {<br>                    if (i == last)<br>                        continue;<br>                    used[i] = true;<br>                    --cover[e[i, 0]];<br>                    if (e[i, 1] &gt;= 0)<br>                        --cover[e[i, 1]];<br>                    seq.Add(price[i]);<br>                    cur = e[i, 0] + e[i, 1] - cur;<br>                    last = i;<br>                    found = true;<br>                    break;<br>                }<br>            if (!found)<br>                break;<br>        }<br>        if (cur == start &amp;&amp; seq.Count &gt; 1)<br>        {<br>            // cycle<br>            int max = 0;<br>            for (int i = 0; i &lt; seq.Count; ++i)<br>            {<br>                List&lt;int&gt; nseq = new List&lt;int&gt;();<br>                for (int j = i + 1; j &lt; seq.Count; ++j)<br>                    nseq.Add(seq[j]);<br>                for (int j = 0; j &lt; i; ++j)<br>                    nseq.Add(seq[j]);<br>                max = Math.Max(max, doit(nseq));<br>            }<br>            res += max;<br>        }<br>        else<br>        {<br>            res += doit(seq);<br>        }<br>    }<br><br>    private int doit(List&lt;int&gt; seq)<br>    {<br>        int[] best = new int[seq.Count + 1];<br>        best[0] = 0;<br>        int res = 0;<br>        for (int i = 1; i &lt;= seq.Count; ++i)<br>        {<br>            best[i] = Math.Max(best[i - 1], seq[i - 1] + (i &gt; 1 ? best[i - 2] : 0));<br>            res = Math.Max(res, best[i]);<br>        }<br>        return res;<br>    }<br><br><br>}<br><br><br>// Powered by FileEdit<br>// Powered by TZTester 1.01 [25-Feb-2003] [modified for C# by Petr]<br>// Powered by CodeProcessor<br></td>