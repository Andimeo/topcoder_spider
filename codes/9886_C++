<td class="problemText" colspan="8" valign="middle" align="left">
            #include &lt;vector&gt;<br>#include &lt;list&gt;<br>#include &lt;map&gt;<br>#include &lt;set&gt;<br>#include &lt;deque&gt;<br>#include &lt;queue&gt;<br>#include &lt;stack&gt;<br>#include &lt;bitset&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;functional&gt;<br>#include &lt;numeric&gt;<br>#include &lt;utility&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cctype&gt;<br>#include &lt;string&gt;<br>#include &lt;cstring&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;ctime&gt;<br> <br>using namespace std;<br> <br>#define SIZE(X) ((int)(X.size()))<br>template&lt;class T&gt; inline void checkmax(T &amp;a,T b){if(b&gt;a) a=b;}<br> <br>class StampsCollection<br>{<br>public:<br>  int n,C[60];<br>  vector&lt;int&gt; G[60];<br>  bool visited[60];<br>  int size,Q[60],A[60],F[60];<br>  void DFS(int v)<br>  {<br>    visited[v]=true;<br>    Q[++size]=v;<br>    for (int i=0;i&lt;SIZE(G[v]);i++) if (!visited[G[v][i]]) DFS(G[v][i]);<br>  }<br>  int sell(int m, vector &lt;string&gt; demand, vector &lt;int&gt; price)<br>  {<br>    n=SIZE(demand);<br>    for (int i=0;i&lt;n;i++) G[i].clear();<br>    for (int i=0;i&lt;n;i++) for (int j=i+1;j&lt;n;j++)<br>    {<br>      istringstream sin1(demand[i]);<br>      istringstream sin2(demand[j]);<br>      vector&lt;int&gt; D1,D2;<br>      for (int v1;sin1&gt;&gt;v1;D1.push_back(v1));<br>      for (int v2;sin2&gt;&gt;v2;D2.push_back(v2));<br>      bool fd=false;<br>      for (int u=0;u&lt;SIZE(D1);u++) for (int v=0;v&lt;SIZE(D2);v++) if (D1[u]==D2[v]) fd=true;<br>      if (fd) G[i].push_back(j),G[j].push_back(i);<br>    }<br>    for (int i=0;i&lt;n;i++) C[i]=price[i];<br>    for (int i=0;i&lt;n;i++) visited[i]=false;<br>    int result=0;<br>    for (int step=0;step&lt;2;step++)<br>      for (int i=0;i&lt;n;i++) if(!visited[i])<br>      {<br>        if (SIZE(G[i])==2 &amp;&amp; step==0) continue;<br>        size=0;<br>        DFS(i);<br>        int nedge=0;<br>        for (int k=1;k&lt;=size;k++) nedge+=SIZE(G[Q[k]]);<br>        nedge/=2;<br>        if (nedge==size)<br>        {<br>          int maxc=0;<br>          for (int d=0;d&lt;size;d++)<br>          {<br>            for (int i=1;i&lt;=size-1;i++) A[i]=C[Q[i]];<br>            for (int i=1;i&lt;=size-1;i++)<br>            {<br>              int c1=((i-2&gt;0)?F[i-2]:0)+A[i];<br>              int c2=(i-1&gt;0)?F[i-1]:0;<br>              F[i]=max(c1,c2);<br>            }<br>            checkmax(maxc,F[size-1]);<br>            int tmp=Q[1];<br>            for (int i=1;i&lt;=size-1;i++) Q[i]=Q[i+1];<br>            Q[size]=tmp;<br>          }<br>          result+=maxc;<br>        }<br>        else<br>        {<br>          for (int i=1;i&lt;=size;i++) A[i]=C[Q[i]];<br>          for (int i=1;i&lt;=size;i++)<br>          {<br>            int c1=((i-2&gt;0)?F[i-2]:0)+A[i];<br>            int c2=(i-1&gt;0)?F[i-1]:0;<br>            F[i]=max(c1,c2);<br>          }<br>          result+=F[size];<br>        }<br>      }<br>    return result;<br>  }<br>};<br></td>