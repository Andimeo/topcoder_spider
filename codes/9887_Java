<td class="problemText" colspan="8" valign="middle" align="left">
            import static java.lang.Math.*;<br>import static java.math.BigInteger.*;<br>import static java.util.Arrays.*;<br>import static java.util.Collections.*;<br>import java.math.*;<br>import java.util.*;<br><br>public class PickingUp {<br>  public int[] fairPickingUp(long[] score1, long[] score2) {<br>    int n = score1.length, m = n / 2;<br>    TreeSet&lt;Entry&gt;[] set1 = new TreeSet[m + 1];<br>    TreeSet&lt;Entry&gt;[] set2 = new TreeSet[m + 1];<br>    for (int i = 0; i &lt;= m; i++) {<br>      set1[i] = new TreeSet&lt;Entry&gt;();<br>      set2[i] = new TreeSet&lt;Entry&gt;();<br>    }<br>    for (int i = 0; i &lt; 1 &lt;&lt; m; i++) {<br>      int k = 0;<br>      long v = 0;<br>      for (int j = 0; j &lt; m; j++) {<br>        if ((i &amp; 1 &lt;&lt; j) == 0) {<br>          k++;<br>          v += score1[m - j - 1];<br>        } else {<br>          v -= score2[m - j - 1];<br>        }<br>      }<br>      set1[k].add(new Entry(v, i));<br>    }<br>    for (int i = 0; i &lt; 1 &lt;&lt; m; i++) {<br>      int k = 0;<br>      long v = 0;<br>      for (int j = 0; j &lt; m; j++) {<br>        if ((i &amp; 1 &lt;&lt; j) == 0) {<br>          k++;<br>          v += score1[n - j - 1];<br>        } else {<br>          v -= score2[n - j - 1];<br>        }<br>      }<br>      set2[k].add(new Entry(v, i));<br>    }<br>    long min = Long.MAX_VALUE;<br>    int r1 = 0, r2 = 0;<br>    Entry[][] ess = new Entry[m + 1][];<br>    for (int i = 0; i &lt;= m; i++) ess[i] = set2[i].toArray(new Entry[0]);<br>    for (int i = 0; i &lt;= m; i++) {<br>      for (Entry e : set1[i]) {<br>        long v = e.v;<br>        int p = binarySearch(ess[m - i], new Entry(-v, 0));<br>        if (p &gt;= 0) {<br>          Entry f = ess[m - i][p];<br>          if (min &gt; 0 || (min == 0 &amp;&amp; (r1 &gt; e.j || (r1 == e.j &amp;&amp; r2 &gt; f.j)))) {<br>            min = 0;<br>            r1 = e.j;<br>            r2 = f.j;<br>          }<br>        } else {<br>          p = -p - 2;<br>          if (p &gt;= 0) {<br>            Entry f = ess[m - i][p];<br>            long u = abs(v + f.v);<br>            if (min &gt; u || (min == u &amp;&amp; (r1 &gt; e.j || (r1 == e.j &amp;&amp; r2 &gt; f.j)))) {<br>              min = u;<br>              r1 = e.j;<br>              r2 = f.j;<br>            }<br>          }<br>          p++;<br>          if (p &lt; ess[m - i].length) {<br>            Entry f = ess[m - i][p];<br>            long u = abs(v + f.v);<br>            if (min &gt; u || (min == u &amp;&amp; (r1 &gt; e.j || (r1 == e.j &amp;&amp; r2 &gt; f.j)))) {<br>              min = u;<br>              r1 = e.j;<br>              r2 = f.j;<br>            }<br>          }<br>        }<br>      }<br>    }<br>    debug(min);<br>    int[] res = new int[n];<br>    for (int i = 0; i &lt; m; i++) {<br>      if ((r1 &amp; 1 &lt;&lt; i) == 0) res[m - i - 1] = 1;<br>      else res[m - i - 1] = 2;<br>      if ((r2 &amp; 1 &lt;&lt; i) == 0) res[n - i - 1] = 1;<br>      else res[n - i - 1] = 2;<br>    }<br>    debug(res);<br>    return res;<br>  }<br>  class Entry implements Comparable&lt;Entry&gt; {<br>    long v;<br>    int j;<br>    Entry(long v, int j) {<br>      this.v = v;<br>      this.j = j;<br>    }<br>    public int compareTo(Entry o) {<br>      if (v &lt; o.v) return -1;<br>      if (v &gt; o.v) return 1;<br>      return 0;<br>    }<br>  }<br>  void debug(Object...os) {<br>    System.err.println(Arrays.deepToString(os));<br>  }<br>}<br></td>