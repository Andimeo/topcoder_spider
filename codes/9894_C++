<td class="problemText" colspan="8" valign="middle" align="left">
            #line 89 "LongStraightRoad.cpp"<br>#include &lt;vector&gt;                                                <br>#include &lt;map&gt;                                                   <br>#include &lt;set&gt;<br>#include &lt;algorithm&gt;<br>#include &lt;sstream&gt;<br>#include &lt;iostream&gt;<br>#include &lt;cmath&gt;<br>#include &lt;string&gt;<br>#include &lt;complex&gt;<br>using namespace std;<br> <br>class LongStraightRoad {<br>   public:<br>      map &lt;string, int&gt; name;<br>      int info[55][105];<br>      int s, N;<br>      int father[105];<br>      int S[55], P[105];<br>      int colour[105];<br>      int mark[105];<br>      long long mat[55][55];<br>      int num, pos[105];<br>      int process(int c, string x) {<br>   int i, last, j;<br>   x += ";";<br>   last = -1;<br>   for (i = 0; i &lt; x.length(); i ++)<br>      if (x[i] == ';') {<br>         char tmp[55];<br>         sscanf(x.c_str() + last + 1, "%s", tmp);<br>         if (name.find(string(tmp)) == name.end()) {<br>      name[string(tmp)] = s ++;<br>         }<br>         for (j = last + 1; x[j] != ' '; j ++);<br>         sscanf(x.c_str() + j + 1, "%d", &amp;info[c][name[string(tmp)]]);<br>         last = i;<br>      }<br>   return 0;<br>      }<br>      int getRoot(int x) {<br>   return (father[x] == -1 ? x : (father[x] = getRoot(father[x])));<br>      }<br>      int merge(int x, int y) {<br>   x = getRoot(x);<br>   y = getRoot(y);<br>   if (x != y)<br>      father[x] = y;<br>   return 0;<br>      }<br>      int solve(int x, int d) {<br>   int i, j;<br>   if (!mark[x])<br>      mark[x] = 1;<br>   else<br>      return (S[x] == d);<br>   S[x] = d;<br>   for (i = 0; i &lt; s; i ++)<br>      for (j = 0; j &lt; N; j ++)<br>         if (info[x][i] != -1 &amp;&amp; info[j][i] != -1)<br>      if (!solve(j, d + info[x][i] - info[j][i]))<br>         return 0;<br>   return 1;<br>      }<br>      int distanceToDestination(vector &lt;string&gt; signs, string destination) {<br>         int i, j, k;<br>   N = signs.size();<br>   name.clear();<br>   s = 0;<br>   memset(info, -1, sizeof(info));<br>   for (i = 0; i &lt; N; i ++)<br>      process(i, signs[i]);<br>   int dest;<br>   if (name.find(destination) == name.end())<br>      return -1;<br>   dest = name[destination];<br>   memset(father, -1, sizeof(father));<br>   for (i = 0; i &lt; N; i ++)<br>      for (j = i + 1; j &lt; N; j ++)<br>         for (k = 0; k &lt; s; k ++)<br>      if (info[i][k] != -1 &amp;&amp; info[j][k] != -1)<br>         merge(i, j);<br>   for (i = 0; i &lt; N; i ++)<br>      for (j = 0; j &lt; s; j ++)<br>         if (info[i][j] != -1)<br>      colour[j] = getRoot(i);<br>   memset(mark, 0, sizeof(mark));<br>   for (i = 0; i &lt; N; i ++)<br>      if (!mark[getRoot(i)]) {<br>         j = getRoot(i);<br>         if (!solve(j, 0))<br>      return -1;<br>      }<br>   for (i = 0; i &lt; N; i ++)<br>      for (j = 0; j &lt; s; j ++)<br>         if (info[i][j] != -1)<br>      P[j] = S[i] + info[i][j];<br>   for (i = 0; i &lt; N; i ++)<br>      for (j = 0; j &lt; s; j ++)<br>         if (info[i][j] != -1)<br>      if (P[j] != S[i] + info[i][j])<br>         return -1;<br>   for (i = 0; i &lt; N; i ++)<br>      for (j = i + 1; j &lt; N; j ++)<br>         if (getRoot(i) == getRoot(j) &amp;&amp; S[i] &gt;= S[j])<br>      return -1;<br>   num = 0;<br>   for (i = 0; i &lt; N; i ++)<br>      if (getRoot(i) == i)<br>         pos[i] = num ++;<br>   for (i = 0; i &lt; num; i ++)<br>      for (j = 0; j &lt; num; j ++)<br>         mat[i][j] = 1000000000;<br>   for (i = 0; i &lt; N; i ++)<br>      for (j = i + 1; j &lt; N; j ++)<br>         if (getRoot(i) != getRoot(j))<br>      mat[pos[getRoot(i)]][pos[getRoot(j)]] = min(mat[pos[getRoot(i)]][pos[getRoot(j)]], (long long)S[j] - S[i]);<br>   for (i = 0; i &lt; num; i ++)<br>      for (j = 0; j &lt; num; j ++)<br>         mat[i][j] = mat[i][j] * 10000LL - 1;<br>   long long d[55];<br>   for (i = 0; i &lt; num; i ++)<br>      d[i] = 0;<br>   for (i = 0; i &lt; num + 1; i ++)<br>      for (j = 0; j &lt; num; j ++)<br>         for (k = 0; k &lt; num; k ++)<br>      d[j] = min(d[j], d[k] + mat[j][k]);<br>   for (i = 0; i &lt; num; i ++)<br>      for (j = 0; j &lt; num; j ++)<br>         if (d[i] &gt; d[j] + mat[i][j])<br>      return -1;<br>   if (colour[dest] == getRoot(N - 1) &amp;&amp; P[dest] - S[N - 1] &gt;= 0)<br>      return P[dest] - S[N - 1];<br>   return -1;<br>      }<br>};<br> <br> <br> <br>// Powered by FileEdit<br></td>