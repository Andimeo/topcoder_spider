<td class="problemText" colspan="8" valign="middle" align="left">
            #include "assert.h"<br>#include "ctype.h"<br>#include "float.h"<br>#include "math.h"<br>#include "stdio.h"<br>#include "string.h"<br>#include "stdlib.h"<br>#include "stdarg.h"<br>#include "time.h"<br>#include "algorithm"<br>#include "numeric"<br>#include "functional"<br>#include "utility"<br>#include "bitset"<br>#include "vector"<br>#include "list"<br>#include "set"<br>#include "map"<br>#include "queue"<br>#include "stack"<br>#include "string"<br>#include "sstream"<br>#include "iostream"<br>using namespace std;<br><br>typedef long long i64;<br><br>const int MOVES_COUNT = 4;<br>struct Move {<br>  int i, j;<br>  void (*move)();<br>  void (*back)();<br>};<br>Move move[MOVES_COUNT];<br><br>enum Face {TOP = 0, NORTH, WEST, EAST, SOUTH, BOTTOM};<br>bool cube[6];<br>int paper[6][6];<br><br>void MoveNorth() {<br>  bool top = cube[TOP];<br>  cube[TOP] = cube[SOUTH];<br>  cube[SOUTH] = cube[BOTTOM];<br>  cube[BOTTOM] = cube[NORTH];<br>  cube[NORTH] = top;<br>}<br>void MoveEast() {<br>  bool top = cube[TOP];<br>  cube[TOP] = cube[WEST];<br>  cube[WEST] = cube[BOTTOM];<br>  cube[BOTTOM] = cube[EAST];<br>  cube[EAST] = top;<br>}<br>void MoveSouth() {<br>  bool top = cube[TOP];<br>  cube[TOP] = cube[NORTH];<br>  cube[NORTH] = cube[BOTTOM];<br>  cube[BOTTOM] = cube[SOUTH];<br>  cube[SOUTH] = top;<br>}<br>void MoveWest() {<br>  bool top = cube[TOP];<br>  cube[TOP] = cube[EAST];<br>  cube[EAST] = cube[BOTTOM];<br>  cube[BOTTOM] = cube[WEST];<br>  cube[WEST] = top;<br>}<br>void InitMoves() {<br>  move[0].i = -1;<br>  move[0].j = 0;<br>  move[0].move = MoveNorth;<br>  move[0].back = MoveSouth;<br>  move[1].i = 0;<br>  move[1].j = -1;<br>  move[1].move = MoveWest;<br>  move[1].back = MoveEast;<br>  move[2].i = 1;<br>  move[2].j = 0;<br>  move[2].move = MoveSouth;<br>  move[2].back = MoveNorth;<br>  move[3].i = 0;<br>  move[3].j = 1;<br>  move[3].move = MoveEast;<br>  move[3].back = MoveWest;<br>}<br><br>void SearchStart(int&amp; i, int&amp; j) {<br>  for (i = 0; i &lt; 6; i++) for (j = 0; j &lt; 6; j++)<br>    if (paper[i][j] == 1) return;<br>}<br>bool IsInside(int i, int j) {<br>  return (i &gt;= 0 &amp;&amp; i &lt; 6) &amp;&amp; (j &gt;= 0 &amp;&amp; j &lt; 6);<br>}<br>void Flood(int i, int j) {<br>  cube[BOTTOM] = true;<br>  paper[i][j] = 0;<br>  for (int k = 0; k &lt; MOVES_COUNT; k++) {<br>    int dest_i = i + move[k].i;<br>    int dest_j = j + move[k].j;<br>    if (!IsInside(dest_i, dest_j) || paper[dest_i][dest_j] == 0) continue;<br>    move[k].move();<br>    Flood(dest_i, dest_j);<br>    move[k].back();<br>  }<br>}<br>bool IsArmable() {<br>  memset(cube, 0, sizeof(cube));<br>  int i = 0, j = 0;<br>  SearchStart(i, j);<br>  Flood(i, j);<br>  for (int k = 0; k &lt; 6; k++)<br>    if (!cube[k]) return false;<br>  return true;<br>}<br><br>struct CubeNets {<br>  string isCubeNet(vector&lt;string&gt; figure) {<br>    const int m = (int)figure.size(), n = (int)figure[0].size();<br>    memset(paper, 0, sizeof(paper));<br>    for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; n; ++j)<br>      if (figure[i][j] == '#') paper[i][j] = 1;<br>    InitMoves();<br>    return IsArmable() ? "YES" : "NO";<br>  }<br>};<br><br><br><br>// Powered by FileEdit<br>// Powered by moj 4.11 [modified TZTester]<br>// Powered by CodeProcessor<br></td>