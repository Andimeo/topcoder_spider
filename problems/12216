<td class="problemText" valign="middle" align="left">
                      
              		<table><tr><td colspan="2" class="statText"><h3>Problem Statement</h3></td></tr><tr><td class="statText">    </td><td class="statText"><i>This problem statement contains images that may not display properly outside the applet.</i>
<br><br>
There are <b>N</b> characters in the Ninja language. As the number of different characters can be very large, we will use numbers from 1 to <b>N</b> to represent the individual characters in Ninja language.
The characters are numbered in alphabetical order. That is, whenever i &lt; j, character i is earlier in the alphabet than character j. Each string in Ninja language can now be seen as a sequence of integers. When comparing two different strings of the same length, the lexicographically smaller one is the one with a smaller integer on the first place where they differ.
<br><br>
Ninja Ren has a string R of length <b>N</b> that contains each character exactly once. Then she converted the string R to the string S using the following method:
<br><br>
First, Ren takes her string R and writes it onto a circular piece of paper. The paper can now be cut at one of <b>N</b> possible positions, each time producing a different string of length <b>N</b>. Ren takes those <b>N</b> different strings and sorts them into lexicographical order (starting with the lexicographically smallest one). The string S is obtained by taking the <i>last</i> characters of the <b>N</b> sorted strings, in order. In other words, Ren takes the <b>N</b> cyclic rotations of R, sorts them, and then only looks at their last letters.
<br><br>
For example, when R is "2 4 5 1 3", S will be "5 3 1 2 4". The following picture shows how the conversion works.
<br><br><img src="http://www.topcoder.com/contest/problem/StRings/string.png"><br><br>
You are given the int <b>N</b> and a int[] <b>first</b>. containing a prefix of the string S. More precisely, for each valid index i, element i of <b>first</b> is the i-th character of S. (Both indices are 0-based.)
<br><br>
Find the lexicographically smallest possible string S. If <b>N</b> is less than or equal to 50, return the entire string S. If <b>N</b> is greater than 50, return just the last 50 characters of S. If there is no such S, return an empty int[] instead.</td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Definition</h3></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText">Class:</td><td class="statText">StRings</td></tr><tr><td class="statText">Method:</td><td class="statText">getSmallest</td></tr><tr><td class="statText">Parameters:</td><td class="statText">int, int[]</td></tr><tr><td class="statText">Returns:</td><td class="statText">int[]</td></tr><tr><td class="statText">Method signature:</td><td class="statText">int[] getSmallest(int N, int[] first)</td></tr><tr><td colspan="2" class="statText">(be sure your method is public)</td></tr></table></td></tr><tr><td class="statText">    </td></tr><tr><td class="statText"></td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText"><b>N</b> will be between 1 and 100,000 inclusive.</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText"><b>first</b> will contain between 1 and 50 elements, inclusive.</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText">Each element of <b>first</b> will be between 1 and <b>N</b>, inclusive.</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText">Elements of <b>first</b> will be pairwise distinct.</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText">The constraints above guarantee that the number of elements of <b>first</b> will be less than or equal to <b>N</b>.</td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Examples</h3></td></tr><tr><td align="center" nowrap class="statText">0)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>5</pre></td></tr><tr><td class="statText"><pre>{2, 4}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: {2, 4, 1, 5, 3 }</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">{2, 4, 1, 5, 3} is the lexicographically smallest possible string S.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">1)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>5</pre></td></tr><tr><td class="statText"><pre>{1}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: { }</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">There is no S that starts with 1.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">2)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>10</pre></td></tr><tr><td class="statText"><pre>{3, 8, 6}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: {3, 8, 6, 1, 2, 5, 4, 9, 10, 7 }</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">3)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>100</pre></td></tr><tr><td class="statText"><pre>{34, 68, 97, 87, 47, 39, 50, 59, 4, 7, 29, 91, 1, 80, 90, 95,
 60, 40, 43, 73, 54, 69, 32, 31, 53, 11, 84, 3, 28, 77, 44, 86,
 2, 75, 85, 52, 93, 81, 70, 89, 19, 67, 98, 100, 41, 65, 57, 27, 33, 49}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: 
{5, 6, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 30, 35, 36, 37, 38, 42, 45, 46, 48, 51, 55, 56, 58, 61, 62, 63, 64, 71, 66, 72, 74, 76, 78, 79, 82, 88, 83, 94, 96, 92, 99 }</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">If <b>N</b> is greater than 50, return just the last 50 characters of S.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">4)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>1</pre></td></tr><tr><td class="statText"><pre>{1}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: {1 }</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText"></td></tr></table></td></tr></table></td></tr></table><hr><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2010, TopCoder, Inc.  All rights reserved.  </p>
                      
                   </td>