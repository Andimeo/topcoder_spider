<td class="problemText" valign="middle" align="left">
                      
              		<table><tr><td colspan="2" class="statText"><h3>Problem Statement</h3></td></tr><tr><td class="statText">    </td><td class="statText"><p>
Given an expression, we must determine its type. Expressions are formatted as follows:
</p>
<ul><li><tt>&lt;expression&gt; ::= &lt;constant&gt; | &lt;function&gt;(&lt;args&gt;)</tt></li>
<li><tt>&lt;args&gt; ::= &lt;expression&gt; | &lt;expression&gt;,&lt;args&gt;</tt></li>
<li><tt>&lt;constant&gt; ::= &lt;identifier&gt;</tt></li>
<li><tt>&lt;function&gt; ::= &lt;identifier&gt;</tt></li>
<li><tt>&lt;identifier&gt; ::= </tt>between 1 and 10 letters (<tt>'a'-'z'</tt>, <tt>'A'-'Z'</tt>), inclusive</li>
</ul><p>
Some examples of valid expressions are <tt>"x"</tt>, <tt>"upper(x)"</tt>, <tt>"ord(upper(x))"</tt>, <tt>"succ(succ)"</tt>, <tt>"fst(x,x)"</tt>.
</p>
<p>
To aid us in determining the type of an expression, we are given a list of type definitions.  Each element of the String[] <b>definitions</b> is formatted as follows:
</p><ul><li><tt>&lt;definition&gt; ::= &lt;type_expression&gt;:&lt;type_name&gt;</tt></li>
<li><tt>&lt;type_expression&gt; ::= &lt;constant&gt; | &lt;function&gt;(&lt;type_args&gt;)</tt></li>
<li><tt>&lt;type_args&gt; ::= &lt;type_name&gt; | &lt;type_name&gt;,&lt;type_args&gt;</tt></li>
<li><tt>&lt;type_name&gt; ::= &lt;identifier&gt;</tt></li>
</ul><p>
For example:
</p><ul><li><tt>"x:Char"</tt> means that the constant <tt>"x"</tt> has type <tt>"Char"</tt>.</li>
<li><tt>"succ(Int):Int"</tt> means that the function named <tt>"succ"</tt> that takes a parameter of type <tt>"Int"</tt> has type <tt>"Int"</tt>.</li>
<li><tt>"upper(Char):Char"</tt> means that the function named <tt>"upper"</tt> that takes a parameter of type <tt>"Char"</tt> has type <tt>"Char"</tt>.</li>
<li><tt>"ord(Char):Int"</tt> means that the function named <tt>"ord"</tt> that takes a parameter of type <tt>"Char"</tt> has type <tt>"Int"</tt>.</li>
<li><tt>"fst(Int,Int):Int"</tt> means that the function named <tt>"fst"</tt> that takes two parameters, both of type <tt>"Int"</tt>, has type <tt>"Int"</tt>.</li>
</ul><p>
In general, <tt>"&lt;constant&gt;:&lt;type_name&gt;"</tt> means that the constant named <tt>&lt;constant&gt;</tt> will have type <tt>&lt;type_name&gt;</tt>, and <tt>"&lt;function&gt;(&lt;type_args&gt;):&lt;type_name&gt;"</tt> means that the function named <tt>&lt;function&gt;</tt> will have type <tt>&lt;type_name&gt;</tt> if and only if its argument types match <tt>&lt;type_args&gt;</tt> exactly (the same number of arguments, with the types in the exact order given).
</p>
<p>
Using these example definitions, we can determine the types of three of the example expressions given above.  <tt>"x"</tt> has type <tt>"Char"</tt>, <tt>"upper(x)"</tt> has type <tt>"Char"</tt>, and <tt>"ord(upper(x))"</tt> has type <tt>"Int"</tt>.  We cannot determine the type of <tt>"succ(succ)"</tt> because all we know is that a function named <tt>"succ"</tt> has type <tt>"Int"</tt> if its argument is of type <tt>"Int"</tt>.  In this case, we cannot determine the type of its argument.  We cannot determine the type of <tt>"fst(x,x)"</tt> because all we know is that <tt>"fst"</tt> is of type <tt>"Int"</tt> if its two arguments are of type <tt>"Int"</tt>.  In this case, both arguments are of type <tt>"Char"</tt>.
</p>
<p>
Given a String <b>expression</b> and a String[] <b>definitions</b>, return the type of <b>expression</b>.  If the type cannot be determined using the given definitions, return an empty String ("").
</p></td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Definition</h3></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText">Class:</td><td class="statText">MonomorphicTyper</td></tr><tr><td class="statText">Method:</td><td class="statText">infer</td></tr><tr><td class="statText">Parameters:</td><td class="statText">String, String[]</td></tr><tr><td class="statText">Returns:</td><td class="statText">String</td></tr><tr><td class="statText">Method signature:</td><td class="statText">String infer(String expression, String[] definitions)</td></tr><tr><td colspan="2" class="statText">(be sure your method is public)</td></tr></table></td></tr><tr><td class="statText">    </td></tr><tr><td class="statText"></td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Notes</h3></td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText">All identifiers used are case-sensitive, i.e., "a" is not the same identifier as "A".</td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText"><b>expression</b> will be a valid expression (as described in the problem statement).</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText"><b>expression</b> will contain between 1 and 50 characters, inclusive.</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText"><b>definitions</b> will contain between 0 and 20 elements, inclusive.</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText">Each element of <b>definitions</b> will contain between 3 and 50 characters, inclusive.</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText">Each element of <b>definitions</b> will be a valid definition (as described in the problem statement); they will contain no spaces.</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText"><b>definitions</b> will contain no duplicate <tt>&lt;function&gt;</tt>s and no duplicate <tt>&lt;constant&gt;</tt>s.</td></tr><tr><td align="center" valign="top" class="statText">-</td><td class="statText">No <tt>&lt;function&gt;</tt> in <b>definitions</b> will have the same name as a <tt>&lt;constant&gt;</tt> in <b>definitions</b>.</td></tr><tr><td colspan="2" class="statText"> </td></tr><tr><td colspan="2" class="statText"><h3>Examples</h3></td></tr><tr><td align="center" nowrap class="statText">0)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>"x"</pre></td></tr><tr><td class="statText"><pre>{"x:Char"}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: "Char"</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText"><b>definitions</b> tells us that a constant with the name <tt>"x"</tt> has type <tt>"Char"</tt>.  <b>expression</b> is a constant named <tt>"x"</tt>, so we know that its type is <tt>"Char"</tt>.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">1)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>"upper(x)"</pre></td></tr><tr><td class="statText"><pre>{"x:Char","upper(Char):Char"}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: "Char"</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText"><b>expression</b> is a function named <tt>"upper"</tt> that takes a constant named <tt>"x"</tt> as an argument.  According to the <b>definitions</b>, a constant named <tt>"x"</tt> has type <tt>"Char"</tt>, and a function named <tt>"upper"</tt> that takes an argument of type <tt>"Char"</tt> has type <tt>"Char"</tt>.  Therefore, we know that the type of <tt>"upper(x)"</tt> is <tt>"Char"</tt>.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">2)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>"ord(upper(letter))"</pre></td></tr><tr><td class="statText"><pre>{"ord(Char):Int","upper(Char):Char","letter:Char","Letter:String"}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: "Int"</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">Here, the argument to the outer function <tt>"ord"</tt> is a function named "upper", which takes a constant named <tt>"letter"</tt> as its argument.  Using the logic from the previous example, we can determine that <tt>"upper(letter)"</tt> has type <tt>"Char"</tt>.  This means that the function <tt>"ord"</tt> in our expression is given an argument of type <tt>"Char"</tt>.  We can therefore conclude that the expression has type <tt>"Int"</tt>.
Note also that <tt>"letter"</tt> and <tt>"Letter"</tt> are different constants (with different types).</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">3)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>"id(id)"</pre></td></tr><tr><td class="statText"><pre>{"id(Int):Int"}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: ""</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText"><b>expression</b> is a function named <tt>"id"</tt> that takes a constant named <tt>"id"</tt> as an argument.  <b>definitions</b> contains no type definition for a constant named <tt>"id"</tt>, so we cannot determine the type of the expression.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">4)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>"f(unknown)"</pre></td></tr><tr><td class="statText"><pre>{"f(A):B"}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: ""</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">The constant passed as a parameter has no declared type.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">5)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>"fst(zero)"</pre></td></tr><tr><td class="statText"><pre>{"fst(Int,Int):Int","zero:Int"}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: ""</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">The definition of <tt>"fst"</tt> takes two <tt>"Int"</tt> parameters, but only one is provided in the expression.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap class="statText">6)</td><td class="statText"></td></tr><tr><td class="statText">    </td><td class="statText"><table><tr><td class="statText"><table><tr><td class="statText"><pre>"Func(Int,Char,a)"</pre></td></tr><tr><td class="statText"><pre>{"Int:Char", "Func(Char,Char,Int):Int", "Char:Char", "a:Int"}</pre></td></tr></table></td></tr><tr><td class="statText"><pre>Returns: "Int"</pre></td></tr><tr><td class="statText"><table><tr><td colspan="2" class="statText">Function and constant names are not the same as type names. The expression is well-typed and has type <tt>"Int"</tt>.</td></tr></table></td></tr></table></td></tr></table><hr><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2010, TopCoder, Inc.  All rights reserved.  </p>
                      
                   </td>